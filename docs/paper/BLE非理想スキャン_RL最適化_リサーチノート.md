以下は、**非理想的なスマホスキャン環境下でのBLEアドバタイズ最適化**に関するリサーチノートです。  
理論的な一般論ではなく、**スマホOSの挙動・数理モデル・MAB/RLアルゴリズム・シミュレータ・実装戦略**といった深い部分だけを抜き出して整理します。

---

# 1. 非理想スキャン環境の具体像

## 1.1 BLE近隣発見の基本モデル（再掲）

- アドバタイザ側:
  - アドバタイズ間隔 `T_adv` ごとに、3チャネル（37/38/39）へ送信。
  - BLE仕様上、各イベントに 0〜10 ms 程度の疑似ランダム遅延が混入。
- スキャナ側:
  - スキャン間隔 `T_scan` ごとに、スキャンウィンドウ `d_scan` だけ受信。
  - デューティ比 `δ = d_scan / T_scan`。
- 発見遅延 L:
  - アドバタイズイベントとスキャンウィンドウの **オーバーラップまでの時間**。
  - スロットレスだが、ランダム遅延と `T_adv`, `T_scan` の相互作用から分布が決まる。

---

## 1.2 決定論的ブラインドスポット（Valley Area）

- **高調波関係問題**
  - `T_adv` と `T_scan` が整数比（高調波）に近い場合、
    - アドバタイズが系統的にスキャナのスリープ区間に入り続け、
    - 半ば決定論的に「ほぼ見つからない」組み合わせが生じる。
- **ランダム遅延の限界**
  - 仕様上のランダム遅延は偶然の位相ずれを生むが、
    - エネルギー制約のある端末ではイベント数自体が少なく、
    - 最悪ケース遅延や Valley Area を確率論的に打ち消すには不十分な場合がある。
- **高密度環境**
  - 多数のアドバタイザが同時に送信する場合、
    - スキャナ側の受信スロットが飽和 → 衝突・競合でパケットロス。
  - 理想モデル（ランダム一様・単一ペア）から大きく逸脱する。

---

## 1.3 Android の非理想スキャン挙動（2023–2025）

- **スキャンモードと実際のデューティ**
  - `SCAN_MODE_LOW_LATENCY`
    - フロント（画面ON・アプリフォアグラウンド）時のみ **ほぼ連続スキャン**に近い動作。
  - `SCAN_MODE_BALANCED` / `LOW_POWER`
    - バックグラウンドでは、例として「500 ms スキャン / 5000 ms スリープ」など、
      - デューティ `δ < 10%` 程度に強制的に落とされるケースが多い。
  - 実際のウィンドウ/間隔は端末・OSバージョン依存であり、**アプリ側からは取得できない**。

- **Doze / App Standby / Android 15 の変更**
  - Dozeモード:
    - 端末がアイドル（画面OFF・充電無し）に入ると、
      - スキャンは OS により間欠的にしか実行されない。
  - Android 15:
    - `BLUETOOTH_SCAN` 権限導入でプライバシー分離を行いつつ、
      - バックグラウンドスキャンのスロットリングが強化。
    - 「オポチュニスティック・スキャン」:
      - 他アプリのスキャンに便乗して結果を共有する形になり、
      - **自アプリが明示的に連続スキャンしているわけではない**。
    - 実務報告レベルでは、「バックグラウンド連続スキャンが 30 分程度で OS によって止まる」という事象が観測されている。

---

## 1.4 iOS の非理想スキャン挙動（iOS 18 まで）

- **バックグラウンド制約**
  - アプリがバックグラウンドに落ちると、
    - BLEスキャンの **頻度・長さはOS内部ロジックにより大幅に縮退**。
    - 実測では「数秒〜数分に一度、数 ms のウィンドウ」というレベルになる事例も報告。
  - **Duplicate Filtering 強制**
    - バックグラウンドでは、**同じ周辺機器からのアドバタイザは最初の1回しか通知されない**。
    - 継続的な RSSI 監視や連続データを受け取るには、接続モードに移行するか、アドバタイザ側が UUID/アドレスを変える等トリッキーな手が必要。

- **iOS 18 / AccessorySetupKit**
  - アクセサリセットアップを簡略化するフレームワーク。
  - ただし、「ユーザ主導のペアリング」を前提とした API であり、
    - 不特定多数のビーコンをバックグラウンドで検出し続ける用途の制限は緩和されていない。

---

## 1.5 オポチュニスティック・スキャンと合成ウィンドウ

- 複数アプリが異なるパラメータでスキャンする場合、
  - 実際のRFレベルでは「スキャンウィンドウの和集合」がハードウェアで実行される。
  - これを **Opportunistic Scan** と呼ぶ。
- アドバタイザからは、
  - 合成されたスキャンパターンは完全に未知であり、時間とともに変化。
  - この「未知で非定常なスキャナ」を前提にした制御問題として扱うのが妥当。

擬似コード例（概念レベル）:

```python
# 各アプリ i が個別の (T_scan_i, d_scan_i) でスキャンしていると仮定
windows = []
for app in apps:
    for k in range(num_slots):
        start = k * app.T_scan + app.phase
        end   = start + app.d_scan
        windows.append((start, end))

# Opportunistic Scan: ハードウェア上は和集合として動作
synthetic_windows = merge_overlaps(sorted(windows))
```

アドバタイズ最適化側は、この `synthetic_windows` を**明示的には知らない**まま、  
観測された成功フラグだけをもとに interval/mask を学習する必要がある。

---

# 2. MAB / RL によるアドバタイズ最適化

## 2.1 Hasegawa/Kitagawa 系列の MAB アプローチ

- **問題設定**
  - アーム `a`：アドバタイズ間隔 × チャンネルマスク（37/38/39 の組み合わせ）。
    - 例：interval ∈ {100, 500, 1000 ms} × mask ∈ {3ch, 2ch, 1ch}。
  - 時刻 t ごとにアームを選び、その設定で広告 → 成功/失敗とエネルギーを観測。

- **報酬設計（例）**

  ```text
  R_t = α · 1{Success_t} − β · E_t
  ```

  - `Success_t`:
    - Scan Request / Connect Request を受信できたかどうか。
  - `E_t`:
    - その送信条件で消費したエネルギー（電流積分や、SF/TxPower/回数の近似式）。
  - α, β で「発見率 vs 省電力」のトレードオフを調整。

- **重要なポイント**
  - スキャナの `T_scan, d_scan, δ` を一切明示的に知らなくても、
    - 成功フラグだけを見て「スキャナと噛み合いやすい interval/mask」を暗黙に学習。
  - 混雑度や OS スケジューラの変化は「報酬分布の変動」として現れ、
    - アルゴリズムが自動的に再適応する。

---

## 2.2 UCB1‑tuned と Tug‑of‑War (TOW)

- **UCB1‑tuned**
  - 通常の UCB は「平均報酬 + √(ln t / n_k)」のみを見るが、
    - 無線環境では報酬分散が大きい（混雑・フェージングなど）。
  - UCB1‑tuned は分散推定 `σ_hat_k^2` を入れて上界を調整：

    ```text
    UCB_k = μ_hat_k + sqrt{ (ln t / n_k) * min(1/4, σ_hat_k^2 + sqrt(2 ln t / n_k)) }
    ```

  - 分散が大きいアームは探索項が増える一方、
    - 極端に不安定なアームは早めに見切りをつけやすく、収束が安定。

- **Tug‑of‑War (TOW) ダイナミクス**
  - よりシンプルで演算も軽い更新則を持つ意思決定アルゴリズム。
  - 利点:
    - 非定常環境（スキャナ挙動が頻繁に変わる）で、
      - 重い UCB 系よりも素早く「当たりのアーム」に切り替えられるケースがある。
  - BLE環境では、短時間接触（すれ違い）や瞬間的な負荷変動に対する追従性が評価されている。

---

## 2.3 Q-Learning / Deep RL による長期的最適化

- **状態と行動の例**
  - 状態 S:
    - バッテリ残量（離散化）、直近の成功率（窓平均）、推定混雑度（loss率）。
  - 行動 A:
    - アドバタイズ間隔の増減（100→500→1000msなど）。
    - 送信電力の調整（TxPower ステップアップ/ダウン）。

- **効果**
  - シミュレーションでは、
    - ランダム/固定方式に比べてネットワーク寿命を大幅に延長しつつ、
    - 最大遅延制約（例: TL p95 ≤ τ）を満たす方策を獲得。

- **課題**
  - Q-Learning は**収束までの試行数が多い**（Warm‑up が長い）。
  - スマホとの接触時間が短いシナリオ（すれ違い広告など）では、
    - 学習が終わる前に通信機会が終わる危険。
  - これに対し、**事前にオフライン学習した DQN ポリシーを MCUに焼き込む**形で、
    - 初期からそこそこ良い行動をとれるようにする研究もある。

---

## 2.4 コンテキストMAB：Wi‑Fi/外部情報の利用

- **アイデア**
  - BLE だけでなく、スマホが頻繁に行っている Wi‑Fi スキャン結果などを「コンテキスト」として利用。
  - 例:
    - 周辺 Wi‑Fi AP の RSSI 分布や BSSID 数から「端末がアクティブに通信している状況か」を推定。
    - このとき BLE スキャンも動いている可能性が高いと仮定し、広告間隔を一時的に短縮。

- **類似事例**
  - mmWave 近隣発見の研究では、
    - Wi‑Fi の情報からビーム方向や探索優先度を学習するコンテキストバンディットが提案されており、
    - BLEのチャンネル／interval 選択にもコンセプトが応用可能。

---

# 3. シミュレーションフレームワークと決定論的検証

## 3.1 Blender フレームワーク（トレース駆動）

- **従来シミュレータの問題**
  - スキャナを「一定の確率で On/Off するランダムプロセス」としてモデル化。
  - 実際の OS スケジューラは決定論的であり、
    - 例: 「1.5s スキャン、3.5s スリープ」を正確に繰り返す端末など。
  - この場合、理論上「見つかるはず」のパラメータが**永遠に見つからない**ことがありうる。

- **Blender の特徴**
  - **トレース駆動（trace‑driven）**
    - 実機 Android/iOS から収集したスキャンログを入力。
  - **全位相探索**
    - `T_adv, T_scan, d_scan, loss_rate` を与えると、
      - 可能な全ての位相差に対する遅延分布を決定論的に計算。
    - パラメタ例:
      - `adv_interval`: 20〜10240 ms
      - `scan_interval`, `scan_window`: 20〜10240 ms
      - `loss_rate`: 0〜99%
  - 結果:
    - **最悪ケース遅延** や Valley Area を明示的に把握できる。
    - MAB/RLで学んだポリシーが、特定のOSや端末で「穴」にはまらないか検証可能。

---

## 3.2 ElastiCast：インターバル多重化戦略

- **発想**
  - 単一の固定 `T_adv` では、全てのスキャナに対して良い性能を出すことは困難。
  - そこで、**複数の `T_adv` を時間的に多重化**する。
    - 例: 素数関係にある複数の interval を組み合わせる。

- **効果**
  - 高調波関係による Valley Area を避け、
    - どのような `T_scan, d_scan` を持つ端末でも、
    - ある程度の時間内には必ずオーバーラップするように設計する。
  - 「学習で環境に合わせる」アプローチに対し、
    - ElastiCast は「**決定論的設計で最悪ケースを潰す**」方向の戦略。

---

## 3.3 ReND：推論ベース近隣発見（Reasoning-based ND）

- **三段論法によるトリガー**
  - 大前提: クラウドDBに「BLEビーコンXはWi‑Fi AP Yの近くにある」という知識を保存。
  - 小前提: スマホが Wi‑Fi スキャンで AP Y を発見。
  - 結論: 「ビーコンXが近くにいる可能性が高い」と推論。
- **実装**
  - 推論成立時に、アプリが OS に対して「高頻度BLEスキャン」を一時的に要求。
  - 通常は数％の duty に抑えつつ、
    - **必要な瞬間だけ 100% に近いスキャン**を実行し、一発で発見する。

- **強化学習との関係**
  - MAB/RL が「アドバタイザがスキャナに合わせに行く」アプローチだとすると、
    - ReND は「スキャナの duty をアプリ側から引き上げる」アプローチ。
  - 両者は補完的:
    - ReNDでチャンスを作り、
    - その中で MAB/RL で最適 interval/mask を当てる、という組み合わせも考えられる。

---

# 4. 実装上の示唆（ReFormHAR‑Tiny への応用視点）

- **アドバタイザ側（ESP32/TX）**
  - 低コストな MAB（UCB1‑tuned or TOW）をファームウェア内に実装し、
    - 報酬を「ScanReq/ConnectReq 成功 − λ·消費エネルギー」で設計。
  - 将来的に LinUCB などコンテキストバンディットを使う場合は、
    - 受信側ログや外部メタデータを簡約した「コンテキスト特徴」をどう埋め込むかを設計する余地あり。

- **スキャナ側（スマホアプリ）**
  - Android:
    - `SCAN_MODE_LOW_LATENCY` を必要時だけ On にする **オンデマンドスキャン**。
    - 他アプリのトレースを収集し、Blender 系のフレームワークで Valley Area を事前解析。
  - iOS:
    - Background Duplicate Filtering を前提に、
      - 「単発検出」用途に割り切るか、
      - 接続モードへの移行や ReND 的トリガーを利用するかを設計段階で決める必要あり。

- **評価**
  - 単に平均 PDR/TL でなく、
    - Blender 等で **最悪ケースTL** と Valley Area の有無を指標化することが重要。
  - 実験時は、ターゲット端末（Pixel系, Galaxy系, iPhone世代別）ごとにトレースを収集しておくとよい。

このノートは、BLE広告最適化を「非理想スキャナ前提」で考えるための材料として、OS挙動・MAB/RL・シミュレータ・実システムの接続方法をまとめたものである。  
フェーズ2以降の MAB/Safe‑MAB や ReND的なトリガー設計を検討する際に、必要な要素だけを抜き出して使えるようにしている。 
