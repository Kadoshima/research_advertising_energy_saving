This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
BLE非理想スキャン_RL最適化_リサーチノート.md
literature_review_ble_dynamic_adv.md
TinyML制約付き学習_リサーチノート.md
不確実性駆動送信制御_リサーチノート.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="BLE非理想スキャン_RL最適化_リサーチノート.md">
以下は、**非理想的なスマホスキャン環境下でのBLEアドバタイズ最適化**に関するリサーチノートです。  
理論的な一般論ではなく、**スマホOSの挙動・数理モデル・MAB/RLアルゴリズム・シミュレータ・実装戦略**といった深い部分だけを抜き出して整理します。

---

# 1. 非理想スキャン環境の具体像

## 1.1 BLE近隣発見の基本モデル（再掲）

- アドバタイザ側:
  - アドバタイズ間隔 `T_adv` ごとに、3チャネル（37/38/39）へ送信。
  - BLE仕様上、各イベントに 0〜10 ms 程度の疑似ランダム遅延が混入。
- スキャナ側:
  - スキャン間隔 `T_scan` ごとに、スキャンウィンドウ `d_scan` だけ受信。
  - デューティ比 `δ = d_scan / T_scan`。
- 発見遅延 L:
  - アドバタイズイベントとスキャンウィンドウの **オーバーラップまでの時間**。
  - スロットレスだが、ランダム遅延と `T_adv`, `T_scan` の相互作用から分布が決まる。

---

## 1.2 決定論的ブラインドスポット（Valley Area）

- **高調波関係問題**
  - `T_adv` と `T_scan` が整数比（高調波）に近い場合、
    - アドバタイズが系統的にスキャナのスリープ区間に入り続け、
    - 半ば決定論的に「ほぼ見つからない」組み合わせが生じる。
- **ランダム遅延の限界**
  - 仕様上のランダム遅延は偶然の位相ずれを生むが、
    - エネルギー制約のある端末ではイベント数自体が少なく、
    - 最悪ケース遅延や Valley Area を確率論的に打ち消すには不十分な場合がある。
- **高密度環境**
  - 多数のアドバタイザが同時に送信する場合、
    - スキャナ側の受信スロットが飽和 → 衝突・競合でパケットロス。
  - 理想モデル（ランダム一様・単一ペア）から大きく逸脱する。

---

## 1.3 Android の非理想スキャン挙動（2023–2025）

- **スキャンモードと実際のデューティ**
  - `SCAN_MODE_LOW_LATENCY`
    - フロント（画面ON・アプリフォアグラウンド）時のみ **ほぼ連続スキャン**に近い動作。
  - `SCAN_MODE_BALANCED` / `LOW_POWER`
    - バックグラウンドでは、例として「500 ms スキャン / 5000 ms スリープ」など、
      - デューティ `δ < 10%` 程度に強制的に落とされるケースが多い。
  - 実際のウィンドウ/間隔は端末・OSバージョン依存であり、**アプリ側からは取得できない**。

- **Doze / App Standby / Android 15 の変更**
  - Dozeモード:
    - 端末がアイドル（画面OFF・充電無し）に入ると、
      - スキャンは OS により間欠的にしか実行されない。
  - Android 15:
    - `BLUETOOTH_SCAN` 権限導入でプライバシー分離を行いつつ、
      - バックグラウンドスキャンのスロットリングが強化。
    - 「オポチュニスティック・スキャン」:
      - 他アプリのスキャンに便乗して結果を共有する形になり、
      - **自アプリが明示的に連続スキャンしているわけではない**。
    - 実務報告レベルでは、「バックグラウンド連続スキャンが 30 分程度で OS によって止まる」という事象が観測されている。

---

## 1.4 iOS の非理想スキャン挙動（iOS 18 まで）

- **バックグラウンド制約**
  - アプリがバックグラウンドに落ちると、
    - BLEスキャンの **頻度・長さはOS内部ロジックにより大幅に縮退**。
    - 実測では「数秒〜数分に一度、数 ms のウィンドウ」というレベルになる事例も報告。
  - **Duplicate Filtering 強制**
    - バックグラウンドでは、**同じ周辺機器からのアドバタイザは最初の1回しか通知されない**。
    - 継続的な RSSI 監視や連続データを受け取るには、接続モードに移行するか、アドバタイザ側が UUID/アドレスを変える等トリッキーな手が必要。

- **iOS 18 / AccessorySetupKit**
  - アクセサリセットアップを簡略化するフレームワーク。
  - ただし、「ユーザ主導のペアリング」を前提とした API であり、
    - 不特定多数のビーコンをバックグラウンドで検出し続ける用途の制限は緩和されていない。

---

## 1.5 オポチュニスティック・スキャンと合成ウィンドウ

- 複数アプリが異なるパラメータでスキャンする場合、
  - 実際のRFレベルでは「スキャンウィンドウの和集合」がハードウェアで実行される。
  - これを **Opportunistic Scan** と呼ぶ。
- アドバタイザからは、
  - 合成されたスキャンパターンは完全に未知であり、時間とともに変化。
  - この「未知で非定常なスキャナ」を前提にした制御問題として扱うのが妥当。

---

# 2. MAB / RL によるアドバタイズ最適化

## 2.1 Hasegawa/Kitagawa 系列の MAB アプローチ

- **問題設定**
  - アーム `a`：アドバタイズ間隔 × チャンネルマスク（37/38/39 の組み合わせ）。
    - 例：interval ∈ {100, 500, 1000 ms} × mask ∈ {3ch, 2ch, 1ch}。
  - 時刻 t ごとにアームを選び、その設定で広告 → 成功/失敗とエネルギーを観測。

- **報酬設計（例）**

  ```text
  R_t = α · 1{Success_t} − β · E_t
  ```

  - `Success_t`:
    - Scan Request / Connect Request を受信できたかどうか。
  - `E_t`:
    - その送信条件で消費したエネルギー（電流積分や、SF/TxPower/回数の近似式）。
  - α, β で「発見率 vs 省電力」のトレードオフを調整。

- **重要なポイント**
  - スキャナの `T_scan, d_scan, δ` を一切明示的に知らなくても、
    - 成功フラグだけを見て「スキャナと噛み合いやすい interval/mask」を暗黙に学習。
  - 混雑度や OS スケジューラの変化は「報酬分布の変動」として現れ、
    - アルゴリズムが自動的に再適応する。

---

## 2.2 UCB1‑tuned と Tug‑of‑War (TOW)

- **UCB1‑tuned**
  - 通常の UCB は「平均報酬 + √(ln t / n_k)」のみを見るが、
    - 無線環境では報酬分散が大きい（混雑・フェージングなど）。
  - UCB1‑tuned は分散推定 `σ_hat_k^2` を入れて上界を調整：

    ```text
    UCB_k = μ_hat_k + sqrt{ (ln t / n_k) * min(1/4, σ_hat_k^2 + sqrt(2 ln t / n_k)) }
    ```

  - 分散が大きいアームは探索項が増える一方、
    - 極端に不安定なアームは早めに見切りをつけやすく、収束が安定。

- **Tug‑of‑War (TOW) ダイナミクス**
  - よりシンプルで演算も軽い更新則を持つ意思決定アルゴリズム。
  - 利点:
    - 非定常環境（スキャナ挙動が頻繁に変わる）で、
      - 重い UCB 系よりも素早く「当たりのアーム」に切り替えられるケースがある。
  - BLE環境では、短時間接触（すれ違い）や瞬間的な負荷変動に対する追従性が評価されている。

---

## 2.3 Q-Learning / Deep RL による長期的最適化

- **状態と行動の例**
  - 状態 S:
    - バッテリ残量（離散化）、直近の成功率（窓平均）、推定混雑度（loss率）。
  - 行動 A:
    - アドバタイズ間隔の増減（100→500→1000msなど）。
    - 送信電力の調整（TxPower ステップアップ/ダウン）。

- **効果**
  - シミュレーションでは、
    - ランダム/固定方式に比べてネットワーク寿命を大幅に延長しつつ、
    - 最大遅延制約（例: TL p95 ≤ τ）を満たす方策を獲得。

- **課題**
  - Q-Learning は**収束までの試行数が多い**（Warm‑up が長い）。
  - スマホとの接触時間が短いシナリオ（すれ違い広告など）では、
    - 学習が終わる前に通信機会が終わる危険。
  - これに対し、**事前にオフライン学習した DQN ポリシーを MCUに焼き込む**形で、
    - 初期からそこそこ良い行動をとれるようにする研究もある。

---

## 2.4 コンテキストMAB：Wi‑Fi/外部情報の利用

- **アイデア**
  - BLE だけでなく、スマホが頻繁に行っている Wi‑Fi スキャン結果などを「コンテキスト」として利用。
  - 例:
    - 周辺 Wi‑Fi AP の RSSI 分布や BSSID 数から「端末がアクティブに通信している状況か」を推定。
    - このとき BLE スキャンも動いている可能性が高いと仮定し、広告間隔を一時的に短縮。

- **類似事例**
  - mmWave 近隣発見の研究では、
    - Wi‑Fi の情報からビーム方向や探索優先度を学習するコンテキストバンディットが提案されており、
    - BLEのチャンネル／interval 選択にもコンセプトが応用可能。

---

# 3. シミュレーションフレームワークと決定論的検証

## 3.1 Blender フレームワーク（トレース駆動）

- **従来シミュレータの問題**
  - スキャナを「一定の確率で On/Off するランダムプロセス」としてモデル化。
  - 実際の OS スケジューラは決定論的であり、
    - 例: 「1.5s スキャン、3.5s スリープ」を正確に繰り返す端末など。
  - この場合、理論上「見つかるはず」のパラメータが**永遠に見つからない**ことがありうる。

- **Blender の特徴**
  - **トレース駆動（trace‑driven）**
    - 実機 Android/iOS から収集したスキャンログを入力。
  - **全位相探索**
    - `T_adv, T_scan, d_scan, loss_rate` を与えると、
      - 可能な全ての位相差に対する遅延分布を決定論的に計算。
    - パラメタ例:
      - `adv_interval`: 20〜10240 ms
      - `scan_interval`, `scan_window`: 20〜10240 ms
      - `loss_rate`: 0〜99%
  - 結果:
    - **最悪ケース遅延** や Valley Area を明示的に把握できる。
    - MAB/RLで学んだポリシーが、特定のOSや端末で「穴」にはまらないか検証可能。

---

## 3.2 ElastiCast：インターバル多重化戦略

- **発想**
  - 単一の固定 `T_adv` では、全てのスキャナに対して良い性能を出すことは困難。
  - そこで、**複数の `T_adv` を時間的に多重化**する。
    - 例: 素数関係にある複数の interval を組み合わせる。

- **効果**
  - 高調波関係による Valley Area を避け、
    - どのような `T_scan, d_scan` を持つ端末でも、
    - ある程度の時間内には必ずオーバーラップするように設計する。
  - 「学習で環境に合わせる」アプローチに対し、
    - ElastiCast は「**決定論的設計で最悪ケースを潰す**」方向の戦略。

---

## 3.3 ReND：推論ベース近隣発見（Reasoning-based ND）

- **三段論法によるトリガー**
  - 大前提: クラウドDBに「BLEビーコンXはWi‑Fi AP Yの近くにある」という知識を保存。
  - 小前提: スマホが Wi‑Fi スキャンで AP Y を発見。
  - 結論: 「ビーコンXが近くにいる可能性が高い」と推論。
- **実装**
  - 推論成立時に、アプリが OS に対して「高頻度BLEスキャン」を一時的に要求。
  - 通常は数％の duty に抑えつつ、
    - **必要な瞬間だけ 100% に近いスキャン**を実行し、一発で発見する。

- **強化学習との関係**
  - MAB/RL が「アドバタイザがスキャナに合わせに行く」アプローチだとすると、
    - ReND は「スキャナの duty をアプリ側から引き上げる」アプローチ。
  - 両者は補完的:
    - ReNDでチャンスを作り、
    - その中で MAB/RL で最適 interval/mask を当てる、という組み合わせも考えられる。

---

# 4. 実装上の示唆（ReFormHAR‑Tiny への応用視点）

- **アドバタイザ側（ESP32/TX）**
  - 低コストな MAB（UCB1‑tuned or TOW）をファームウェア内に実装し、
    - 報酬を「ScanReq/ConnectReq 成功 − λ·消費エネルギー」で設計。
  - 将来的に LinUCB などコンテキストバンディットを使う場合は、
    - 受信側ログや外部メタデータを簡約した「コンテキスト特徴」をどう埋め込むかを設計する余地あり。

- **スキャナ側（スマホアプリ）**
  - Android:
    - `SCAN_MODE_LOW_LATENCY` を必要時だけ On にする **オンデマンドスキャン**。
    - 他アプリのトレースを収集し、Blender 系のフレームワークで Valley Area を事前解析。
  - iOS:
    - Backgroud Duplicate Filtering を前提に、
      - 「単発検出」用途に割り切るか、
      - 接続モードへの移行や ReND 的トリガーを利用するかを設計段階で決める必要あり。

- **評価**
  - 単に平均 PDR/TL でなく、
    - Blender 等で **最悪ケースTL** と Valley Area の有無を指標化することが重要。
  - 実験時は、ターゲット端末（Pixel系, Galaxy系, iPhone世代別）ごとにトレースを収集しておくとよい。

このノートは、BLE広告最適化を「非理想スキャナ前提」で考えるための材料として、OS挙動・MAB/RL・シミュレータ・実システムの接続方法をまとめたものである。  
フェーズ2以降の MAB/Safe‑MAB や ReND的なトリガー設計を検討する際に、必要な要素だけを抜き出して使えるようにしている。
</file>

<file path="literature_review_ble_dynamic_adv.md">
以下は、BLEアドバタイズ間隔制御と省電力・到達性評価・バンディット学習適用に関する先行研究の整理ノートです。  
ReFormHAR‑Tiny プロジェクトのペーパー用バックグラウンドとして位置づけ、要件定義や設計書からは独立に管理します。

---

# 1. 調査の目的と観点

本調査では、次の 3 点を同時に満たす先行研究が存在するかを確認した。

1. **BLEアドバタイズ間隔を動的に調整して省電力化すること**  
2. **実機で電力と通信到達性（PDR, TL, Pout など）を同時に測定して評価していること**  
3. **マルチアーム・バンディット（MAB）等のオンライン学習で環境適応を行っていること**  

これらを満たす研究が既にあるか、もしくは部分的に満たす研究の組み合わせがどの程度存在するかを確認した。

---

# 2. 動的アドバタイズ間隔制御に関する先行研究

## 2.1 ヒューリスティック／ルールベースな制御

- 無線チャネルの混雑度やビーコン受信状況に応じて、**広告間隔を伸縮させるヒューリスティックな手法**はいくつか報告されている。
  - 例: 周囲のトラフィック密度（近接ビーコン数やスキャン成功率）に応じて、`adv_interval` を段階的に増減させる方式。
  - 例: 電子棚札やデジタルサイネージにおいて、**人気度・アクセス頻度**に応じて広告頻度を下げることで電力を節約する方式。
- 多くの場合、
  - 制御則は「if 混雑度>閾値 then intervalを伸ばす」といった**固定ロジック**であり、
  - オフラインで決めたパラメタに従って挙動するに留まる。

## 2.2 最適化問題としての扱い

- 一部の研究では、「発見遅延」と「消費電力」のトレードオフを解析的にモデル化し、**最適な広告間隔を数値的に求める**手法が提案されている。
  - 例: ビーコン発見までの期待遅延を解析し、許容遅延の範囲内で電力を最小化する `adv_interval` を導出する研究。
- これらは主に
  - 理論解析やシミュレーションに基づき、
  - 実システムへの実装は「固定値（最適値）」として適用する形が多い。
- 一方で、
  - **環境が時間とともに変動すること**を前提にした「オンライン最適化」としての扱いは少なく、
  - 「混雑度に応じてローカルルールで伸縮する」レベルで止まっているものが多い。

## 2.3 調査からの示唆

- 「動的に広告間隔を変える」というアイデア自体は先行研究にも見られるが、
  - その多くは **ヒューリスティック／ルールベース**であり、
  - **オンライン学習で逐次的に最適化する枠組み**までは踏み込んでいない。

---

# 3. 電力・到達性の実機評価に関する先行研究

## 3.1 BLE性能の一般的なレビュー

- BLEのスループット・到達距離・省電力性に関するレビュー論文では、
  - 理論スループット（≈230 kbps）に対して実効スループットは ≈100 kbps 程度、
  - 送信電力に依存しつつも、屋内で数十メートル程度の到達距離、
  - 接続型 vs 非接続型の損得（スキャン負荷など）
  といった整理が行われている。
- しかし、
  - **アドバタイズ間隔を複数条件で振りつつ**、
  - **実機で電力と到達性（PDR, TL, Pout）を同時に詳細測定**した研究は限定的である。

## 3.2 実機を用いた計測事例

- いくつかの論文では、BLEビーコンやウェアラブル機器の**電流波形をオシロスコープや専用電力計で測定**し、
  - 省電力モードの比較、
  - 通信パターン（接続間隔や広告間隔）の比較
  を行っている。
- ただし多くは、
  - 評価対象が「平均電流」や「バッテリ寿命推定」に留まり、
  - **受信側ログ（PDR/TL）と統合した評価**までは行っていない。

## 3.3 本調査から見えたギャップ

- 「アドバタイズ間隔を変えながら、**同時に**電力と通信到達性を実機で測る」という観点は、
  - レビュー論文でも「十分に行われていない」と指摘されている。
- 特に以下の点は、ほとんどカバーされていない。
  - **固定でない adv_interval（動的制御）**
  - **ΔE/adv のようなイベント単位のエネルギー指標**
  - **PDR/TL/Pout を同じ実験系で併記した評価**

---

# 4. バンディット学習・機械学習の適用状況

## 4.1 バンディット学習を用いたBLE制御

- 近年（2024年頃）の研究において、BLEの
  - **広告チャネル数**、
  - **広告間隔の粗い離散集合**
  をアームとみなし、**マルチアーム・バンディット（MAB）** で省電力化を図る例がある。
  - 例: チャネル数や広告頻度を調整し、最大約40%の省電力効果を報告した研究。
- ただし多くの場合、
  - 状態空間は比較的粗く、
  - 目的関数も「平均エネルギー」や「成功率」のような単一指標に近い。
- また、
  - 学習の一部または大半が **シミュレーション環境** で実施され、
  - 実機での**逐次学習（online learning）**は限定的であることが多い。

## 4.2 その他の機械学習的アプローチ

- BLEビーコン配置やチャンネル割り当てに対して、教師あり学習や強化学習を用いる研究も存在する。
  - 例: 人の流れ・滞在時間を予測し、それに合わせてビーコン出力を調整するモデル。
  - 例: シミュレーション上で強化学習によりデューティ比を最適化する研究。
- しかし、
  - 多くは**離線のログ**を使ったモデル学習や、
  - シミュレーション上での評価に留まっており、
  - 実機で広告間隔をオンライン最適化しながら電力と到達性を観測する事例はほぼ見当たらない。

---

# 5. 総合的な位置づけと新規性

## 5.1 調査のまとめ

- 先行研究には、以下のような部分的な要素は存在する。
  - BLE広告間隔をヒューリスティックに動的制御する手法。
  - 電力あるいは到達性のどちらかを中心にした実機評価。
  - BLE関連設定（チャネル数や間隔）に対する MAB や機械学習の適用。
- しかし、本プロジェクトが掲げる次の 3 点を **同時に**満たす研究は確認できなかった。

1. **広告間隔を動的に調整することによる省電力効果の検証**  
2. **実機で「電力＋通信到達性（PDR/TL/Pout）」を同時に計測する評価系**  
3. **マルチアーム・バンディット等によるオンライン環境適応（実環境での逐次学習）**  

## 5.2 本プロジェクトの位置づけ

- ReFormHAR‑Tiny / Phase‑0/1 の計画（擬似U/S → CCS → adv_interval制御、ΔE/adv＋PDR/TL/Pout評価、Phase‑2/3でのMAB/Safe‑MAB化）は、
  - 既存研究に散在する「動的間隔」「実測電力」「到達性」「バンディット学習」の要素を **1つの実験系に統合** するものと位置づけられる。
- 特に以下の点は、先行研究と比較して特徴的である。
  - **ΔE/adv（イベントあたりのエネルギー増分）**を軸とした電力評価。
  - **PDR/TL/Pout** を同時に取る実機実験系（TX/TXSD/RXの三ノード構成）。
  - 将来フェーズでの **Safe‑MAB によるオンライン制御** を見据えた設計。

## 5.3 要件・設計への示唆（メモ）

- 要件定義・設計定義に反映する場合の候補（反映はオーナー承認後）：
  - フェーズ1のKPI項目における **ΔE/adv の位置づけ**（すでにフェーズ0-0で採用済みの考え方を、Phase‑1/2にも明示するかどうか）。
  - 「既存研究との違い」を整理した **非機能要件（再現性・外的妥当性・学習安定性）** の補足。
  - MAB/Safe‑MABフェーズに向けた「オンライン学習実験」の要件定義（評価指標や安全側フォールバック条件など）。

（現時点では要件定義・設計書への直接の修正は行わず、本ファイルはペーパー準備用のリサーチノートとして扱う。）
</file>

<file path="TinyML制約付き学習_リサーチノート.md">
以下は、**TinyML環境（MCU）における制約付き強化学習／Multi‑armed Bandit実装**に関するリサーチノートです。  
イントロ的な一般論は省き、**MCU上で実際にどう実装するか／どこまでできているか**に関する深い部分だけを整理します。

---

# 1. TinyML向け学習の制約構造

- **二つの強い制約**
  - **ハードウェア制約**
    - RAM は数 KB〜数百 KB（例：STM32F103 20 KB, Nano 33 BLE 256 KB, Teensy 4.1 1 MB）。
    - Flash は 64 KB〜数 MB。コードと定数は置けるが、頻繁な書き換えには不向き。
    - 動的メモリ（`malloc/new`）は断片化リスクから避けるのが前提 → **静的配列／スタック確保が基本**。
    - FPU/DSP命令有無で実現可能なアルゴリズムが変わる（Cortex‑M3 と M4F/M7 の差は大きい）。
  - **安全・QoS制約**
    - LoRaWAN デューティサイクル、規制上限（1%）などを**絶対に越えられない**。
    - 医療系やインフラ監視では「試行錯誤の失敗」が人命・法令違反に直結 → 無制限探索不可。
- **結論として必要なアーキテクチャ**
  - 学習アルゴリズムそのものは「通常の」報酬最適化に徹し、
  - その外側に **軽量な Safety Filter（Action Masking / CBF など）** を置いてハード制約を担保する構造が現実解として採用されている。

---

# 2. MCU上の Multi‑armed Bandit / LinUCB 実装

## 2.1 単純 MAB（ε‑Greedy, UCB1）

- **特徴**
  - 必要状態は「各アームの平均報酬」「訪問回数」だけ → メモリ O(K)。
  - 8‑bit MCU でも実装可能（tabular Q‑learning と同程度）。
- **限界**
  - コンテキスト（SNR, バッテリ, 位置など）を考慮できないため、通信制御などの実用シナリオでは表現力不足。

---

## 2.2 線形コンテキストバンディット（LinUCB）

- **モデル**
  - 各アーム a の期待報酬：`E[r | x_a] = x_a^T θ*`（x_a∈ℝ^d）。
  - 推定量：`θ_hat = A^-1 b`  
    - `A = Σ x x^T + λI`、`b = Σ r x`。
  - UCB スコア：`score(a) = x_a^T θ_hat + α sqrt(x_a^T A^-1 x_a)`。

- **MCU上の最大のボトルネック**
  - d×d 行列 A とその逆行列 A^-1 を保持・更新する必要がある。
  - 朴素な逆行列計算は O(d^3) → 数十 MHz クラスMCUには重い。

---

## 2.3 Sherman–Morrison 公式による高速化

- **ランク1更新**
  - 新サンプル (x_t, r_t) に対し、`A_{t+1} = A_t + x_t x_t^T`。
  - Sherman‑Morrison により、

    ```text
    A_{t+1}^{-1}
      = A_t^{-1} - (A_t^{-1} x_t x_t^T A_t^{-1}) / (1 + x_t^T A_t^{-1} x_t)
    ```

  - 必要な計算は
    - ベクトル v = A_t^-1 x_t（O(d^2)）
    - スカラー s = 1 + x_t^T v（O(d)）
    - A^-1 のランク1更新（O(d^2)）
  - → **1ステップあたり O(d^2)** に削減（O(d^3)→O(d^2)）。

- **実装上の工夫（C/C++）**
  - 行列は `float A_inv[d*d]` の 1次元配列に格納（SIMD／キャッシュ友好）。
  - 中間ベクトル `v[d]` などはクラスメンバとして **静的確保**（ヒープ不使用）。
  - 対称性（A^-1 は対称）を活かした上三角のみの格納も理論上は可能だが、
    - index計算が複雑化し、SIMD化が難しくなるため、
    - 多くの実装では「フル行列＋SIMD」の方を採用。

- **報告されている性能**
  - Cortex‑M4（STM32 Nucleo）上の最適化版 LinUCB:
    - d=16 の場合、朴素版 ≈ 5 ms/step → Woodbury＋SIMD で ≈ 0.3 ms/step に短縮（約1/15）。
  - RAM 使用量は d=16, K≲30 の設定で **1 KBオーダー** に収まる。

---

## 2.4 プラットフォーム適合性（抜粋）

- **20 KB RAM級（STM32F103など）**
  - 可能：Tabular Q‑learning, ε‑Greedy/UCB1, **ごく小さい d（≤4）** の LinUCB。
  - 限界：d が少し増えると A/A^-1 で RAM を使い切る。
- **256 KB RAM級（Arduino Nano 33 BLE, Cortex‑M4F）**
  - 可能：d≲16 の LinUCB、軽量 DNN を用いた Deep RL（小規模）。
  - FPU + DSP 命令あり → CMSIS‑DSP で行列演算高速化。
- **1 MB RAM級（Teensy 4.1, Cortex‑M7）**
  - 可能：d≳32 の LinUCB、PPO/SAC 等の Deep RL 学習も（RLtools 利用前提）。
- **ESP32**
  - RAM ≈ 520 KB、Flash ≈ 4 MB。
  - Wi‑Fi/BLE 内蔵のため、**Federated Learning や Multi‑agent Bandit** の通信基盤として有利。

---

# 3. 安全性制約の実装メカニズム

## 3.1 アクションマスキング（Validity Masking）

- **考え方**
  - 状態 s_t で「絶対に取ってはいけない行動 a」を、
    - 学習アルゴリズムの**外側で**除外し、
    - バンディット／RL側には「選べるアーム集合 A_valid」だけを渡す。
  - → 学習中も**ハード制約を破らない**。

- **LoRaWAN デューティサイクル例**
  - 制約：サブギガ帯で **Duty ≤ 1%**。
  - 各アーム a = (SF, TxPower) について、Time‑on‑Air `T_air(a)` を LoRaWAN 仕様から算出。
  - 直近履歴から「累積 ToA」と「回復までの残り」を計算し、
    - `current_ToA + T_air(a) > budget` なら a を INVALID に設定。
  - LinUCB/UCB1/Thompson 等は、A_valid からのみアクションを選ぶ。
  - 数理的には「Volatile Bandit（可用アーム集合が時間変動）」として扱われる。

---

## 3.2 Control Barrier Functions（CBF）の簡略フィルタ

- **用途**
  - 慣性のある系（ロボット・ドローン等）で、**「その行動を選んだ瞬間はOKだが、その後のダイナミクスで衝突する」**ケースを防ぐ。
- **理論（概念レベル）**
  - 安全集合 h(x)≥0 に対し、

    ```text
    d/dt h(x) + α h(x) ≥ 0 を満たす u のみ許容
    ```

- **MCU向け簡略実装**
  - バリア条件をそのままQPで解くのではなく、
    - 状態 x と提案行動 u_nominal に対して「危険かどうか」を安価に判定し、
    - 危険なら `u_safe` に置き換える**関数として実装**する。
  - C++イメージ:

    ```cpp
    float safety_filter(float u_nominal, const State& x) {
        if (is_violation_likely(x, u_nominal)) {
            return calculate_safe_u(x); // 速度/位置制限など
        }
        return u_nominal;
    }
    ```

  - 学習アルゴリズムは、この `u_safe` とその結果の報酬を観測するため、
    - 結果的に「安全領域内での最適方策」を学ぶことになる。

---

# 4. ケーススタディ：LoRaWAN ADR用 LinUCB（制約付き）

## 4.1 問題設定

- **目的**
  - LoRaWAN エンドデバイスで、
    - PDR を維持しつつ、
    - 消費エネルギー（送信電力＋ToA）を最小化。
- **変数**
  - コンテキスト x_t（例）:
    - 直近 N 回の SNR の平均／分散。
    - 直近の成功/失敗フラグ。
    - バッテリ残量。
  - アーム a:
    - SF ∈ {7,…,12} × TxPower ∈ {2,…,14 dBm} → K≈30。
  - 報酬 r_t（例）:

    ```text
    r_t = α * (PDR_t / PDR_target) - (1-α) * (Energy_t / Energy_max)
    ```

- **制約**
  - 法定 Duty ≤ 1% → **Action Masking** で保証。

---

## 4.2 MCU実装

- **ターゲット**
  - STM32L0 クラス（RAM ≈ 20 KB, 超低消費電力）。
- **状態保持**
  - d=4 とすると、
    - A_inv: 4×4 float = 64 bytes。
    - θ: 4 float = 16 bytes。
    - 各アームの平均報酬・選択回数：数百バイト。
  - 全体で **1 KB 未満** に収まる構成が可能。

- **動作イメージ**
  - 各送信結果ごとに LinUCB 更新（Sherman‑Morrison）。
  - 次の送信タイミングで、Action Masking されたアーム集合から UCB 最大のアームを選択。

- **報告されている効果**
  - シミュレーション／実機評価では、
    - 標準 ADR と比較して、**エネルギー効率 15–30% 改善**。
    - PDR は同等か、それ以上を維持。
  - 混雑環境でも「SF 上げすぎによるネットワーク崩壊」を避けられるケースが報告されている。

---

# 5. ケーススタディ：ECG サンプリングレート制御（TinyRL）

## 5.1 問題設定

- **用途**
  - 不整脈検知用 ECG ウェアラブル。
  - 常時 500 Hz サンプリングはバッテリ的に非現実的。
- **目的**
  - 不整脈検知精度 ≈99% を維持しつつ、
  - 平均消費電力をできるだけ下げる。

---

## 5.2 RLtools を用いた DQN Lite

- **構成**
  - MCU: Arduino Nano 33 BLE (Cortex‑M4F, 256 KB RAM)。
  - 特徴量: R‑R 間隔、QRS 幅などの軽量特徴から状態ベクトル s_t（4次元程度）を作成。
  - アクション:
    - {低レート, 中レート, 高レート} = {125 Hz, 250 Hz, 500 Hz}。
  - Policy/Qネットワーク（RLtools）:
    - 4 → 16 → 3 の全結合ネットワーク（ReLU）。
    - パラメータ数 = (4×16+16) + (16×3+3) = 131。
    - 単精度 float でも重みだけで ≈524 バイト + 中間バッファ含めても数 KB 程度。

- **学習の運用パターン**
  - 日中: 推論のみ（学習オフ）、報酬候補となるイベントをログに蓄積。
  - 夜間充電中 or 定期タイミング: ログを用いてバッチ学習（オンデバイス）／または Replay Buffer を用いたオンライン学習。
  - RLtools により、同じ C++ コードを PC シミュレータ＋MCU の両方で実行できるため、
    - まず PC 上でハイパラを詰めてから MCU に移植、というワークフローが取られている。

- **報告されている効果**
  - 常時 500 Hz サンプリングと比較して、
    - 不整脈検知精度 ≈99% を維持しつつ、
    - **平均消費電力 ≈1/7** まで削減。
  - 直前数十秒の HRV や `S_conf` の揺らぎが大きくなると高レートを選び、
    - 安定期は低レートに落とすポリシーを自律的に獲得。

---

# 6. 実装ベストプラクティス（TinyML学習用）

- **静的割り当ての徹底**
  - `std::vector`, `std::map` は基本的に使わない。
  - RLtools / ETL などの静的コンテナ、もしくは生配列を用いてヒープをゼロにする。
  - リンカの `.map` を確認し、`.bss/.data` サイズとスタックマージンを常に把握する。

- **PCシミュレーション→MCU移植**
  - 同じ C++ コードを
    - PC（Linux/macOS）でシミュレーション（OpenAI Gym 等）、
    - その後クロスコンパイルして MCU 上で動かす、
  - という 2段階開発が、TinyRL では実用的に採用されている。

- **数値精度と FPU の扱い**
  - FPUなし（Cortex‑M3 等）では float はソフトウェア実装 → 可能なら M4F 以上を使う。
  - LinUCB の A^-1 更新など、数値安定性が重要な部分は float（単精度）が最低ライン。
  - 固定小数点化は可能だが、実装・検証コストが高いため、まずは FPU 付きMCU＋float が現実解。

---

本ノートは、TinyML 環境において **「どの程度までバンディット/RLが現実的か」** を判断するための材料として、実装レベルの情報と具体的な削減効果のみを抜き出している。  
フェーズ2以降の MAB/Safe‑MAB 設計時には、ここに挙げた LinUCB 最適化・Action Masking・簡易CBF・RLtools のパターンを必要に応じて流用する。
</file>

<file path="不確実性駆動送信制御_リサーチノート.md">
以下は、**エッジデバイスにおける不確実性認識型・信頼度駆動型データ送信制御**に関する2021–2025年の主要研究を、**具体的なメカニズム・メトリクス・プロトコル実装・実験結果**に絞って整理したリサーチノートです。  
一般的なサマリーやパラダイム転換の議論は省き、実装上有用な「深い部分」のみを記録します。

---

# 1. 不確実性指標とオンデバイス実装

## 1.1 信頼度スコア（Softmax最大値）とキャリブレーション

- **定義**
  - `S_conf = max(softmax(z))`（z はロジットベクトル）。
  - エッジでは追加計算コストがゼロに近く、**最安の不確実性代理指標**として広く利用。

- **エッジでの具体的利用パターン**
  - **適応的認識 / サンプリング制御**
    - ウェアラブルの行動認識や端末内HARで、連続フレームの `S_conf` を監視。
    - 例: `S_conf > 0.85` が一定時間続く場合 → 推論が安定したとみなし、
      - センササンプリングレート↓（例: 50 Hz → 10–20 Hz）
      - 通信周期↑（例: 100 ms → 500–2000 ms）
    - `S_conf` が揺らぐ区間（過渡期）は、逆にサンプリング・通信頻度を一時的に増やす。
  - **早期終了（Early Exit）**
    - BranchyNet系の多出口CNNや Cloud-Edge協調LLMでは、中間層ごとの `S_conf` を監視。
    - `S_conf ≥ τ_exit`（例: 0.9）なら中間出口で推論を打ち切って結果を採用。
    - `S_conf < τ_exit` の場合のみ、より深い層 or クラウドにフォワード。
    - これにより、**平均演算量と送信頻度を同時に削減**。

- **問題点と対策**
  - Softmax は**過信（overconfidence）しやすい**ため、そのまま通信制御の閾値に使うと危険。
  - エッジ向け研究では、以下のような軽量キャリブレーションが実装されている。
    - **温度スケーリング（Temperature Scaling）**
      - 追加パラメータ T（スカラー）を導入し、`softmax(z/T)` で後処理。
      - バリデーション上の NLL/ECE を最小にする T を1次元探索で決定。
    - **Platt Scaling / 平滑化**
      - 出力の上側（0.5–1.0）に集中する確率を圧縮し、実際の正解率との整合を向上。
  - これらの処理により、**「S_conf > 0.9」なら実際の精度も ≈90%** 程度になるよう整えてから、送信制御に用いる。

---

## 1.2 情報エントロピーと優先度スケジューリング

- **定義**
  - `H = - Σ p_i log p_i`（p_i はクラス確率）。
  - 分布が平坦（迷っている）ほど H が高く、**モデルの迷いを直接表現**。

- **通信制御への具体的利用**
  - **トラフィック異常検知系**
    - IoTゲートウェイが、センサの通信パターン（ポート/パケットサイズ/周期）の分布から H を算出。
    - 通常時: H が低く安定 → ログ送信を抑制（定期サマリのみ）。
    - 異常時: H が急上昇（予測不能な通信パターン） → 詳細ログやパケットダンプを集中送信。
  - **UAV支援データ収集**
    - 多数の地上センサに対し、「AoI（Age of Information）」と「エントロピー」を組み合わせて優先度を算出。
    - `priority ∝ H × f(AoI)` とし、
      - H が低く変化の少ないノードは巡回頻度↓、
      - H が高く、かつ AoI が大きいノードを優先的に訪問・データ回収。
    - 結果として、限られた飛行時間の中で **「情報価値の高いノード」からの取得率を最大化**。

- **特徴**
  - Softmax最大値と異なり、**「どの程度迷っているか」** を多クラスで扱えるため、
    - 未知クラス検知、緩やかな変化検知、優先度制御に向いている。

---

## 1.3 ワンパス不確実性推定（Single-Pass Uncertainty）

- **従来手法の問題**
  - MC-Dropout やベイジアンNNによる不確実性推定は、
    - 同じ入力に対して **数十回の推論** を実行して分散を推定。
    - レイテンシ・消費電力ともに **O(N_samples)** で増大 → バッテリ駆動エッジには不適。

- **ワンパス系の解法（代表例）**
  - モデル側の正則化・構造変更により、
    - **1回のフォワードパスだけで「予測値＋不確実性」の両方を出力**する。
  - 典型的な構成要素:
    - **スペクトル正規化（Spectral Normalization）** による重みの制御。
    - **層ごとの分布近似**（例えば、最終層でガウス分布の平均・分散を直接出力）。
    - 損失関数に、**不確実性に基づくペナルティ項**を組み込む。

- **実験結果（Jetson Nano / TX2 等）**
  - 推論ごとに「予測＋分散」を得て、その分散を基準に
    - 送信/破棄/クラウドオフロードを判定。
  - ベースライン（MC-Dropout等）と比較して:
    - **エネルギー消費が最大 ≈28倍削減**。
    - レイテンシは、通常の推論＋行列演算数回増の範囲に収まる（実時間制御可能）。

---

## 1.4 偶然的不確実性（Aleatoric）と認識的不確実性（Epistemic）の分離

- **目的**
  - 「不確実だから送信する」のではなく、
    - **ノイズ起因の不確実性（Aleatoric）**：再サンプリングやローカル処理で対処すべき。
    - **知識不足起因の不確実性（Epistemic）**：クラウドや人間による再評価が必要。
  - この区別により、**不要なクラウド送信を抑えつつ、本当に重要なケースだけオフロード**できる。

- **オンデバイスでの扱い**
  - モデル側で「予測の分散」を
    - 観測ノイズに対応する成分（出力ヘッド側の分散）、
    - モデル不確実性に対応する成分（パラメタ分布由来）、
    に分解する設計が提案されている。
  - 制御ロジック例:
    - Aleatoric が支配的 → **同じセンサからの追加サンプル収集**を優先（送信は控える）。
    - Epistemic が支配的 → **生データ送信 or 高精度モデルへのオフロード**を優先。

---

# 2. 動的送信制御メカニズム

## 2.1 ファジィ論理制御（Fuzzy Logic Controller, FLC）によるBLEパラメータ制御

- **入力・出力変数**
  - 入力（例）:
    - 不確実性: {Low, Medium, High}（Softmax/Entropy由来）。
    - バッテリ残量: {Critical, Normal, Full}。
    - RSSI（リンク品質）: {Weak, Strong}。
  - 出力:
    - BLE接続間隔: {Short (≈7.5 ms), Medium, Long (≈4 s)}。
    - 送信電力: {Min（-20 dBm）, …, Max（+20 dBm）}。

- **ルール例**
  - `IF Uncertainty is High AND Battery is Normal THEN Interval is Short AND TxPower is Max`
    - 高不確実＋バッテリ余裕 → 確度を優先して高頻度・高出力で送信。
  - `IF Uncertainty is Low AND Battery is Low THEN Interval is Long AND TxPower is Min`
    - 推論は安定＋バッテリ低 → ハートビートのみ、電力極小で維持。

- **パラメタ最適化（PSO利用）**
  - メンバーシップ関数の形状（どこから High とみなすか等）を
    - 粒子群最適化（PSO）で自動調整。
  - 目的関数例:
    - **バッテリ寿命最大化**（平均電流 or mWh/日）。
    - かつ **QoS指標（到達率/正解率）≥95%** を制約として課す。

- **報告されている効果（ウェアラブルBLEデバイスなど）**
  - 静的設定と比較して、
    - 消費電力 **25–45%削減**。
    - 到達率（QoS）は **95%以上** を維持。
    - 「正常・高信頼」期間は実質的な Radio-on duty を **1%未満** に抑制。

---

## 2.2 Restless Multi-Armed Bandit（RMAB）とゲイン・インデックス

- **問題設定**
  - 多数のセンサノードが 1 つのゲートウェイ/UAV を共有する状況。
  - 各ノードは時間とともに
    - **情報の古さ（AoI）**、
    - **不確実性（Entropy など）**
    が変化し続ける。
  - 同時に通信できるノード数には上限がある（帯域制約）。

- **RMAB定式化とポリシー**
  - 各ノード n に対し、状態 s_n（AoI, 不確実性など）から「ゲイン・インデックス g_n」を計算。
  - スケジューラは、各ラウンドで **g_n が大きい順に上位 M ノードを選択**して送信権を与える。
  - g_n は「そのノードからデータを受け取ることで削減できるシステム損失（不確実性＋情報陳腐化）」を表す。

- **特徴と結果**
  - 単純な AoI ベース（古いデータ優先）に比べて、
    - **変化が激しく（高エントロピー）かつ情報が古いノード**を優先するため、
    - 閾値ベースでは難しい「監視すべき対象」に自動的にリソースを集中できる。
  - 代表的な研究では、
    - AoI単独最小化よりも **平均システム損失（L-条件付き交差エントロピーベース）を有意に低減**。

---

## 2.3 早期終了と適応的オフローディング

- **多出口DNN / BranchyNet系**
  - 中間層出口での `S_conf` または `H` を用いて、
    - 高信頼なら**浅い層で打ち切り**（計算＋通信コストを削減）。
    - 低信頼なら深層まで計算 or クラウドオフロード。

- **Cloud-Edge協調LLM（例: 小型SLM + クラウドLLM）**
  - エッジ側の小型モデルがトークンを生成し、各トークンの信頼度を監視。
  - `S_conf ≥ τ` ならそのまま採用（クラウド送信なし）。
  - `S_conf < τ` が続く場合、**コンテキスト（隠れ状態）をクラウドにアップロード**し、大モデルに引き継ぎ。
  - 閾値 τ は、チャネル帯域やRTTに応じて動的調整される例もあり、
    - 通信が高コストな場合は τ を下げてエッジ完結を優先。
    - 通信が安価な場合は τ を上げてクラウド精度を優先。

---

# 3. BLEプロトコル上での実装詳細

## 3.1 Connection Parameter Update Request による接続間隔制御

- **標準メカニズム**
  - BLE接続中、Peripheral（エッジデバイス）は L2CAP の **Connection Parameter Update Request** を通じて、
    - `conn_interval_min/max`（例: 6=7.5 ms〜3200=4 s）、`slave_latency` 等の変更を要求可能。
  - 不確実性に応じた典型的な制御:
    - 高不確実 / 異常兆候 → `conn_interval ≈ 7.5–30 ms`、`slave_latency ≈ 0`。
    - 安定 / 低不確実 → `conn_interval ≈ 数百〜4000 ms`、`slave_latency` を増やし実質的なスリープを延長。

- **OSスタックの制約と回避策**
  - Android / iOS の BLE スタックは、
    - Peripheral からの更新要求を無視・制限する場合がある。
  - 代表的な回避策:
    - **Smart Duty Cycling**
      - 接続間隔自体は比較的短め（例: 30 ms）に固定。
      - 不確実性が低く送信不要なときは **Empty PDU** のみ送信（実データを抑制）。
    - **Slave Latency の活用**
      - 複数回のポーリングをスキップしても接続維持が許されるよう設定し、**平均Radio-on時間を削減**。

---

## 3.2 パケット単位の送信電力制御

- **メカニズム**
  - Nordic nRF52、ST BlueNRG 等のBLE SoC は、
    - API 経由で**パケット単位の TxPower 切替**をサポート。
  - 制御例:
    - 通常テレメトリ: `TxPower = -20 dBm`（低電力で到達性はそこそこ）。
    - 高リスク・高不確実なアラート: `TxPower = +4〜+20 dBm`（最大の到達率を確保）。

- **不確実性との連携**
  - 条件例:
    - `U高` かつ リスククラス=「転倒/心不全疑い」 → TxPower 最大。
    - `U低` かつ 状態=「安定/低リスク」 → TxPower 最小 or 送信スキップ。
  - 実験では、
    - 重要度クラスごとに TxPower と接続間隔を組み合わせることで、
    - **平均消費電力を削減しつつ、重大イベントの到達率はほぼ100%を維持**した報告がある。

---

# 4. リスク指標とセマンティック通信的アプローチ

## 4.1 L-条件付き交差エントロピーと「沈黙のコスト」

- **課題**
  - 単純な AoI（最後の更新からの経過時間）は、「何を見逃しているか」の重みを考慮しない。
  - エッジでは、「送信しないことによるリスク」を定量化する必要がある。

- **L-条件付き交差エントロピー H_L のアイデア**
  - 古い情報 `X_{t-δ}` に基づく推定 `Ŷ_t` が、真の状態 `Y_t` からどれだけズレているかを、
    - 損失関数 `L(Y_t, Ŷ_t)` で重み付けした期待値として定義。
  - 特徴:
    - **リスク非対称性**を表現できる。
      - 異常を見逃す False Negative は非常に大きな損失。
      - 誤警報 False Positive は相対的に小さな損失。

- **通信制御への利用**
  - ノードごとに H_L を評価し、
    - H_L が閾値を超えたときのみ送信（＝沈黙のコストが大きくなったタイミングで通信）。
  - RMABの **ゲイン・インデックス g_n** は、送信による H_L の減少量として定義される例もあり、
    - 「どのノードの沈黙を破るべきか」を理論的に決定できる。

---

## 4.2 セマンティック通信とエッジAI

- **セマンティックシンボル送信**
  - 生データではなく、エンコーダDNNが抽出した特徴ベクトル（意味的シンボル）を送信。
  - デコーダ側は多少のビット誤りがあっても文脈から復元できるため、
    - 再送を減らしつつ、**意味情報の正確性**を維持。

- **不確実性との連携**
  - 受信側デコーダの不確実性が高い場合のみ、
    - **追加のパリティ / 再送要求 / コンテキスト追加送信**を行うハイブリッドARQが提案されている。
  - これにより、
    - 「意味が曖昧になった場合だけ追加コストを払う」形の通信が実現可能。

---

# 5. 代表的ケーススタディ（結果のみ）

以下は、不確実性駆動制御がどの程度の効果を示したかを具体的に報告している代表的事例の要約である。

- **Case 1: モバイルエッジ学習（MEL）におけるタスク割当**
  - プラットフォーム: Jetson Nano 等のエッジGPUクラスタ。
  - 手法: デバイス能力の不確実性を考慮した MED (Minimum Expected Delay) スキーム。
  - 結果:
    - 学習完了時間を **最大 ≈11%短縮**。
    - データドロップ率（送信失敗・間に合わない通信）を **最大 ≈42%削減**。

- **Case 2: ウェアラブルデバイスのBLE電力最適化（FLC + PSO）**
  - プラットフォーム: 心拍モニタ等のBLEウェアラブル。
  - 手法:
    - 不確実性・バッテリ・RSSI を入力とするファジィ論理制御。
    - メンバーシップ関数を PSO で最適化。
  - 結果:
    - 静的なBLE設定と比較して、消費電力 **25–45%削減**。
    - QoS（到達率/有効サンプル率）を **95%以上** で維持。
    - 重要でない期間の **Radio-on duty を ≈1%未満** に抑制。

- **Case 3: 視覚オドメトリにおけるワンパス不確実性＋決定保留**
  - プラットフォーム: 自律移動ロボットのオンボードGPU。
  - 手法:
    - ワンパス不確実性推定により、位置推定が不確実なフレームのみクラウド or 人手へエスカレーション。
  - 結果:
    - ベースライン比で **エネルギー消費最大 ≈28倍削減**。
    - 位置推定精度は、クラウド協調運用により目標値を維持。

- **Case 4: LLMオフローディングにおける信頼度駆動コンテキストアップロード**
  - プラットフォーム: エッジ上の小型LLM + クラウドLLM。
  - 手法:
    - トークンごとの信頼度スコアが閾値を下回り始めた段階で、
      - **バックグラウンドで隠れ状態（コンテキスト）をクラウドに送信**。
      - 実際のオフロード時には既にコンテキストが同期済み → ユーザ体験の「寸断」を回避。
  - 結果:
    - オフロードのレイテンシをユーザが知覚しにくいレベルまで低減。
    - 通信量は、常時クラウド推論に対して大幅に削減（定量値は研究ごとに異なるが、おおむね数十%〜オーダー削減）。

---

本ノートは、ReFormHAR‑Tiny における **U/S/CCS→adv_interval 制御**や将来の **MAB/Safe‑MAB設計**に流用可能な要素（指標設計、制御ロジック、BLE実装、リスク指標）だけを抽出したものである。  
要件定義・設計書へ反映する場合は、ここから該当部分のみを引用し、フェーズごとの役割に応じて簡略化して用いる。
</file>

</files>
