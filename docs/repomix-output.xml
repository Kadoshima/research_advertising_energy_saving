This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.obsidian/
  app.json
  appearance.json
  core-plugins.json
  workspace.json
paper/
  BLE非理想スキャン_RL最適化_リサーチノート.md
  index.md
  literature_review_ble_dynamic_adv.md
  repomix-output.xml
  TinyML制約付き学習_リサーチノート.md
  不確実性駆動送信制御_リサーチノート.md
トラブルシューティング/
  BLE省電力計測健全化_統合タイムライン.md
  OFF高消費電力_トラブルシューティング.md
  計測系_todo.md
  計測系作業ログ_2025-11-20.md
フェーズ0-0/
  decision_log_2025-11-29.md
  フェーズ0-0_サマリ.md
  技術トピック_電力計測健全化.md
  実験ログ_E2_1m_2025-11-09.md
  実験装置最終仕様書.md
  実験装置仕様書_v2.md
  要件定義.md
フェーズ0-1/
  phase0-1_to_phase1_handover.md
  splits_subject90.yaml
  splits.yaml
  要件定義.md
フェーズ0-2/
  要件定義.md
フェーズ1/
  results/
    delta_energy_row1120_row1123_off.md
    pdr_row1120_txsd_rx.md
    phase1_summary.md
  実験設計書.md
  要件定義.md
フェーズ2/
  実験設計書.md
  要件定義.md
TODO.md
全体像.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".obsidian/app.json">
{}
</file>

<file path=".obsidian/appearance.json">
{}
</file>

<file path=".obsidian/core-plugins.json">
{
  "file-explorer": true,
  "global-search": true,
  "switcher": true,
  "graph": true,
  "backlink": true,
  "canvas": true,
  "outgoing-link": true,
  "tag-pane": true,
  "footnotes": false,
  "properties": false,
  "page-preview": true,
  "daily-notes": true,
  "templates": true,
  "note-composer": true,
  "command-palette": true,
  "slash-command": false,
  "editor-status": true,
  "bookmarks": true,
  "markdown-importer": false,
  "zk-prefixer": false,
  "random-note": false,
  "outline": true,
  "word-count": true,
  "slides": false,
  "audio-recorder": false,
  "workspaces": false,
  "file-recovery": true,
  "publish": false,
  "sync": true,
  "bases": true,
  "webviewer": false
}
</file>

<file path=".obsidian/workspace.json">
{
  "main": {
    "id": "e34f05f72a0026ab",
    "type": "split",
    "children": [
      {
        "id": "766df89df37addb6",
        "type": "tabs",
        "children": [
          {
            "id": "ce2e5c235d3db0bc",
            "type": "leaf",
            "state": {
              "type": "markdown",
              "state": {
                "file": "paper/不確実性駆動送信制御_リサーチノート.md",
                "mode": "source",
                "source": false
              },
              "icon": "lucide-file",
              "title": "不確実性駆動送信制御_リサーチノート"
            }
          }
        ]
      }
    ],
    "direction": "vertical"
  },
  "left": {
    "id": "f115f74a67ced9b6",
    "type": "split",
    "children": [
      {
        "id": "64cbbb82342fa1ab",
        "type": "tabs",
        "children": [
          {
            "id": "9d2a1d4898dceacb",
            "type": "leaf",
            "state": {
              "type": "file-explorer",
              "state": {
                "sortOrder": "alphabetical",
                "autoReveal": false
              },
              "icon": "lucide-folder-closed",
              "title": "ファイルエクスプローラ"
            }
          },
          {
            "id": "a12366f22a6989f5",
            "type": "leaf",
            "state": {
              "type": "search",
              "state": {
                "query": "",
                "matchingCase": false,
                "explainSearch": false,
                "collapseAll": false,
                "extraContext": false,
                "sortOrder": "alphabetical"
              },
              "icon": "lucide-search",
              "title": "検索"
            }
          },
          {
            "id": "fa31cdedfd666456",
            "type": "leaf",
            "state": {
              "type": "bookmarks",
              "state": {},
              "icon": "lucide-bookmark",
              "title": "ブックマーク"
            }
          }
        ]
      }
    ],
    "direction": "horizontal",
    "width": 300
  },
  "right": {
    "id": "f340c6adcb6274c7",
    "type": "split",
    "children": [
      {
        "id": "0206ba7a953049d7",
        "type": "tabs",
        "children": [
          {
            "id": "cbc9f5c4fb889eed",
            "type": "leaf",
            "state": {
              "type": "backlink",
              "state": {
                "file": "paper/不確実性駆動送信制御_リサーチノート.md",
                "collapseAll": false,
                "extraContext": false,
                "sortOrder": "alphabetical",
                "showSearch": false,
                "searchQuery": "",
                "backlinkCollapsed": false,
                "unlinkedCollapsed": true
              },
              "icon": "links-coming-in",
              "title": "不確実性駆動送信制御_リサーチノートへのバックリンク"
            }
          },
          {
            "id": "f927578b5314fb6c",
            "type": "leaf",
            "state": {
              "type": "outgoing-link",
              "state": {
                "file": "paper/不確実性駆動送信制御_リサーチノート.md",
                "linksCollapsed": false,
                "unlinkedCollapsed": true
              },
              "icon": "links-going-out",
              "title": "不確実性駆動送信制御_リサーチノートからのアウトゴーイングリンク"
            }
          },
          {
            "id": "0cfa520619b6188d",
            "type": "leaf",
            "state": {
              "type": "tag",
              "state": {
                "sortOrder": "frequency",
                "useHierarchy": true,
                "showSearch": false,
                "searchQuery": ""
              },
              "icon": "lucide-tags",
              "title": "タグ"
            }
          },
          {
            "id": "e9f9f7b795895ffe",
            "type": "leaf",
            "state": {
              "type": "outline",
              "state": {
                "file": "paper/不確実性駆動送信制御_リサーチノート.md",
                "followCursor": false,
                "showSearch": false,
                "searchQuery": ""
              },
              "icon": "lucide-list",
              "title": "不確実性駆動送信制御_リサーチノートのアウトライン"
            }
          }
        ]
      }
    ],
    "direction": "horizontal",
    "width": 300,
    "collapsed": true
  },
  "left-ribbon": {
    "hiddenItems": {
      "switcher:クイックスイッチャーを開く": false,
      "graph:グラフビューを開く": false,
      "canvas:新規キャンバスを作成": false,
      "daily-notes:今日のデイリーノートを開く": false,
      "templates:テンプレートを挿入": false,
      "command-palette:コマンドパレットを開く": false,
      "bases:Create new base": false
    }
  },
  "active": "ce2e5c235d3db0bc",
  "lastOpenFiles": [
    "paper/TinyML制約付き学習_リサーチノート.md",
    "paper/literature_review_ble_dynamic_adv.md",
    "paper/BLE非理想スキャン_RL最適化_リサーチノート.md",
    "全体像.md",
    "トラブルシューティング/計測系作業ログ_2025-11-20.md",
    "トラブルシューティング/計測系_todo.md",
    "repomix-output.xml",
    "paper/repomix-output.xml",
    "paper/不確実性駆動送信制御_リサーチノート.md",
    "paper",
    "トラブルシューティング/BLE省電力計測健全化_統合タイムライン.md",
    "フェーズ0-0/技術トピック_電力計測健全化.md",
    "フェーズ0-0/実験装置最終仕様書.md"
  ]
}
</file>

<file path="paper/BLE非理想スキャン_RL最適化_リサーチノート.md">
以下は、**非理想的なスマホスキャン環境下でのBLEアドバタイズ最適化**に関するリサーチノートです。  
理論的な一般論ではなく、**スマホOSの挙動・数理モデル・MAB/RLアルゴリズム・シミュレータ・実装戦略**といった深い部分だけを抜き出して整理します。

---

# 1. 非理想スキャン環境の具体像

## 1.1 BLE近隣発見の基本モデル（再掲）

- アドバタイザ側:
  - アドバタイズ間隔 `T_adv` ごとに、3チャネル（37/38/39）へ送信。
  - BLE仕様上、各イベントに 0〜10 ms 程度の疑似ランダム遅延が混入。
- スキャナ側:
  - スキャン間隔 `T_scan` ごとに、スキャンウィンドウ `d_scan` だけ受信。
  - デューティ比 `δ = d_scan / T_scan`。
- 発見遅延 L:
  - アドバタイズイベントとスキャンウィンドウの **オーバーラップまでの時間**。
  - スロットレスだが、ランダム遅延と `T_adv`, `T_scan` の相互作用から分布が決まる。

---

## 1.2 決定論的ブラインドスポット（Valley Area）

- **高調波関係問題**
  - `T_adv` と `T_scan` が整数比（高調波）に近い場合、
    - アドバタイズが系統的にスキャナのスリープ区間に入り続け、
    - 半ば決定論的に「ほぼ見つからない」組み合わせが生じる。
- **ランダム遅延の限界**
  - 仕様上のランダム遅延は偶然の位相ずれを生むが、
    - エネルギー制約のある端末ではイベント数自体が少なく、
    - 最悪ケース遅延や Valley Area を確率論的に打ち消すには不十分な場合がある。
- **高密度環境**
  - 多数のアドバタイザが同時に送信する場合、
    - スキャナ側の受信スロットが飽和 → 衝突・競合でパケットロス。
  - 理想モデル（ランダム一様・単一ペア）から大きく逸脱する。

---

## 1.3 Android の非理想スキャン挙動（2023–2025）

- **スキャンモードと実際のデューティ**
  - `SCAN_MODE_LOW_LATENCY`
    - フロント（画面ON・アプリフォアグラウンド）時のみ **ほぼ連続スキャン**に近い動作。
  - `SCAN_MODE_BALANCED` / `LOW_POWER`
    - バックグラウンドでは、例として「500 ms スキャン / 5000 ms スリープ」など、
      - デューティ `δ < 10%` 程度に強制的に落とされるケースが多い。
  - 実際のウィンドウ/間隔は端末・OSバージョン依存であり、**アプリ側からは取得できない**。

- **Doze / App Standby / Android 15 の変更**
  - Dozeモード:
    - 端末がアイドル（画面OFF・充電無し）に入ると、
      - スキャンは OS により間欠的にしか実行されない。
  - Android 15:
    - `BLUETOOTH_SCAN` 権限導入でプライバシー分離を行いつつ、
      - バックグラウンドスキャンのスロットリングが強化。
    - 「オポチュニスティック・スキャン」:
      - 他アプリのスキャンに便乗して結果を共有する形になり、
      - **自アプリが明示的に連続スキャンしているわけではない**。
    - 実務報告レベルでは、「バックグラウンド連続スキャンが 30 分程度で OS によって止まる」という事象が観測されている。

---

## 1.4 iOS の非理想スキャン挙動（iOS 18 まで）

- **バックグラウンド制約**
  - アプリがバックグラウンドに落ちると、
    - BLEスキャンの **頻度・長さはOS内部ロジックにより大幅に縮退**。
    - 実測では「数秒〜数分に一度、数 ms のウィンドウ」というレベルになる事例も報告。
  - **Duplicate Filtering 強制**
    - バックグラウンドでは、**同じ周辺機器からのアドバタイザは最初の1回しか通知されない**。
    - 継続的な RSSI 監視や連続データを受け取るには、接続モードに移行するか、アドバタイザ側が UUID/アドレスを変える等トリッキーな手が必要。

- **iOS 18 / AccessorySetupKit**
  - アクセサリセットアップを簡略化するフレームワーク。
  - ただし、「ユーザ主導のペアリング」を前提とした API であり、
    - 不特定多数のビーコンをバックグラウンドで検出し続ける用途の制限は緩和されていない。

---

## 1.5 オポチュニスティック・スキャンと合成ウィンドウ

- 複数アプリが異なるパラメータでスキャンする場合、
  - 実際のRFレベルでは「スキャンウィンドウの和集合」がハードウェアで実行される。
  - これを **Opportunistic Scan** と呼ぶ。
- アドバタイザからは、
  - 合成されたスキャンパターンは完全に未知であり、時間とともに変化。
  - この「未知で非定常なスキャナ」を前提にした制御問題として扱うのが妥当。

擬似コード例（概念レベル）:

```python
# 各アプリ i が個別の (T_scan_i, d_scan_i) でスキャンしていると仮定
windows = []
for app in apps:
    for k in range(num_slots):
        start = k * app.T_scan + app.phase
        end   = start + app.d_scan
        windows.append((start, end))

# Opportunistic Scan: ハードウェア上は和集合として動作
synthetic_windows = merge_overlaps(sorted(windows))
```

アドバタイズ最適化側は、この `synthetic_windows` を**明示的には知らない**まま、  
観測された成功フラグだけをもとに interval/mask を学習する必要がある。

---

# 2. MAB / RL によるアドバタイズ最適化

## 2.1 Hasegawa/Kitagawa 系列の MAB アプローチ

- **問題設定**
  - アーム `a`：アドバタイズ間隔 × チャンネルマスク（37/38/39 の組み合わせ）。
    - 例：interval ∈ {100, 500, 1000 ms} × mask ∈ {3ch, 2ch, 1ch}。
  - 時刻 t ごとにアームを選び、その設定で広告 → 成功/失敗とエネルギーを観測。

- **報酬設計（例）**

  ```text
  R_t = α · 1{Success_t} − β · E_t
  ```

  - `Success_t`:
    - Scan Request / Connect Request を受信できたかどうか。
  - `E_t`:
    - その送信条件で消費したエネルギー（電流積分や、SF/TxPower/回数の近似式）。
  - α, β で「発見率 vs 省電力」のトレードオフを調整。

- **重要なポイント**
  - スキャナの `T_scan, d_scan, δ` を一切明示的に知らなくても、
    - 成功フラグだけを見て「スキャナと噛み合いやすい interval/mask」を暗黙に学習。
  - 混雑度や OS スケジューラの変化は「報酬分布の変動」として現れ、
    - アルゴリズムが自動的に再適応する。

---

## 2.2 UCB1‑tuned と Tug‑of‑War (TOW)

- **UCB1‑tuned**
  - 通常の UCB は「平均報酬 + √(ln t / n_k)」のみを見るが、
    - 無線環境では報酬分散が大きい（混雑・フェージングなど）。
  - UCB1‑tuned は分散推定 `σ_hat_k^2` を入れて上界を調整：

    ```text
    UCB_k = μ_hat_k + sqrt{ (ln t / n_k) * min(1/4, σ_hat_k^2 + sqrt(2 ln t / n_k)) }
    ```

  - 分散が大きいアームは探索項が増える一方、
    - 極端に不安定なアームは早めに見切りをつけやすく、収束が安定。

- **Tug‑of‑War (TOW) ダイナミクス**
  - よりシンプルで演算も軽い更新則を持つ意思決定アルゴリズム。
  - 利点:
    - 非定常環境（スキャナ挙動が頻繁に変わる）で、
      - 重い UCB 系よりも素早く「当たりのアーム」に切り替えられるケースがある。
  - BLE環境では、短時間接触（すれ違い）や瞬間的な負荷変動に対する追従性が評価されている。

---

## 2.3 Q-Learning / Deep RL による長期的最適化

- **状態と行動の例**
  - 状態 S:
    - バッテリ残量（離散化）、直近の成功率（窓平均）、推定混雑度（loss率）。
  - 行動 A:
    - アドバタイズ間隔の増減（100→500→1000msなど）。
    - 送信電力の調整（TxPower ステップアップ/ダウン）。

- **効果**
  - シミュレーションでは、
    - ランダム/固定方式に比べてネットワーク寿命を大幅に延長しつつ、
    - 最大遅延制約（例: TL p95 ≤ τ）を満たす方策を獲得。

- **課題**
  - Q-Learning は**収束までの試行数が多い**（Warm‑up が長い）。
  - スマホとの接触時間が短いシナリオ（すれ違い広告など）では、
    - 学習が終わる前に通信機会が終わる危険。
  - これに対し、**事前にオフライン学習した DQN ポリシーを MCUに焼き込む**形で、
    - 初期からそこそこ良い行動をとれるようにする研究もある。

---

## 2.4 コンテキストMAB：Wi‑Fi/外部情報の利用

- **アイデア**
  - BLE だけでなく、スマホが頻繁に行っている Wi‑Fi スキャン結果などを「コンテキスト」として利用。
  - 例:
    - 周辺 Wi‑Fi AP の RSSI 分布や BSSID 数から「端末がアクティブに通信している状況か」を推定。
    - このとき BLE スキャンも動いている可能性が高いと仮定し、広告間隔を一時的に短縮。

- **類似事例**
  - mmWave 近隣発見の研究では、
    - Wi‑Fi の情報からビーム方向や探索優先度を学習するコンテキストバンディットが提案されており、
    - BLEのチャンネル／interval 選択にもコンセプトが応用可能。

---

# 3. シミュレーションフレームワークと決定論的検証

## 3.1 Blender フレームワーク（トレース駆動）

- **従来シミュレータの問題**
  - スキャナを「一定の確率で On/Off するランダムプロセス」としてモデル化。
  - 実際の OS スケジューラは決定論的であり、
    - 例: 「1.5s スキャン、3.5s スリープ」を正確に繰り返す端末など。
  - この場合、理論上「見つかるはず」のパラメータが**永遠に見つからない**ことがありうる。

- **Blender の特徴**
  - **トレース駆動（trace‑driven）**
    - 実機 Android/iOS から収集したスキャンログを入力。
  - **全位相探索**
    - `T_adv, T_scan, d_scan, loss_rate` を与えると、
      - 可能な全ての位相差に対する遅延分布を決定論的に計算。
    - パラメタ例:
      - `adv_interval`: 20〜10240 ms
      - `scan_interval`, `scan_window`: 20〜10240 ms
      - `loss_rate`: 0〜99%
  - 結果:
    - **最悪ケース遅延** や Valley Area を明示的に把握できる。
    - MAB/RLで学んだポリシーが、特定のOSや端末で「穴」にはまらないか検証可能。

---

## 3.2 ElastiCast：インターバル多重化戦略

- **発想**
  - 単一の固定 `T_adv` では、全てのスキャナに対して良い性能を出すことは困難。
  - そこで、**複数の `T_adv` を時間的に多重化**する。
    - 例: 素数関係にある複数の interval を組み合わせる。

- **効果**
  - 高調波関係による Valley Area を避け、
    - どのような `T_scan, d_scan` を持つ端末でも、
    - ある程度の時間内には必ずオーバーラップするように設計する。
  - 「学習で環境に合わせる」アプローチに対し、
    - ElastiCast は「**決定論的設計で最悪ケースを潰す**」方向の戦略。

---

## 3.3 ReND：推論ベース近隣発見（Reasoning-based ND）

- **三段論法によるトリガー**
  - 大前提: クラウドDBに「BLEビーコンXはWi‑Fi AP Yの近くにある」という知識を保存。
  - 小前提: スマホが Wi‑Fi スキャンで AP Y を発見。
  - 結論: 「ビーコンXが近くにいる可能性が高い」と推論。
- **実装**
  - 推論成立時に、アプリが OS に対して「高頻度BLEスキャン」を一時的に要求。
  - 通常は数％の duty に抑えつつ、
    - **必要な瞬間だけ 100% に近いスキャン**を実行し、一発で発見する。

- **強化学習との関係**
  - MAB/RL が「アドバタイザがスキャナに合わせに行く」アプローチだとすると、
    - ReND は「スキャナの duty をアプリ側から引き上げる」アプローチ。
  - 両者は補完的:
    - ReNDでチャンスを作り、
    - その中で MAB/RL で最適 interval/mask を当てる、という組み合わせも考えられる。

---

# 4. 実装上の示唆（ReFormHAR‑Tiny への応用視点）

- **アドバタイザ側（ESP32/TX）**
  - 低コストな MAB（UCB1‑tuned or TOW）をファームウェア内に実装し、
    - 報酬を「ScanReq/ConnectReq 成功 − λ·消費エネルギー」で設計。
  - 将来的に LinUCB などコンテキストバンディットを使う場合は、
    - 受信側ログや外部メタデータを簡約した「コンテキスト特徴」をどう埋め込むかを設計する余地あり。

- **スキャナ側（スマホアプリ）**
  - Android:
    - `SCAN_MODE_LOW_LATENCY` を必要時だけ On にする **オンデマンドスキャン**。
    - 他アプリのトレースを収集し、Blender 系のフレームワークで Valley Area を事前解析。
  - iOS:
    - Background Duplicate Filtering を前提に、
      - 「単発検出」用途に割り切るか、
      - 接続モードへの移行や ReND 的トリガーを利用するかを設計段階で決める必要あり。

- **評価**
  - 単に平均 PDR/TL でなく、
    - Blender 等で **最悪ケースTL** と Valley Area の有無を指標化することが重要。
  - 実験時は、ターゲット端末（Pixel系, Galaxy系, iPhone世代別）ごとにトレースを収集しておくとよい。

このノートは、BLE広告最適化を「非理想スキャナ前提」で考えるための材料として、OS挙動・MAB/RL・シミュレータ・実システムの接続方法をまとめたものである。  
フェーズ2以降の MAB/Safe‑MAB や ReND的なトリガー設計を検討する際に、必要な要素だけを抜き出して使えるようにしている。
</file>

<file path="paper/index.md">
# レター論文用インデックス（Phase0-1/A_tiny + 既存BLEリサーチノート）
更新日: 2025-11-26  
注意: BLEのKPIや非理想スキャンに関する記述は `docs/paper` 配下のリサーチノートに集約。`har/` 配下には置かない。

## 新規（A_tiny / Phase0-1）
- 論文仕様書（ACM/IEEE対応）: `har/001/docs/A_tiny_paper_spec_acm_ieee.md`
- Tiny学習スクリプト: `har/004/tools/train_phase0-1_tiny.py`
- Tiny設定: `har/004/configs/phase0-1.acc.v2_tiny.yaml`
- Tiny学習結果: `har/004/runs/phase0-1-acc-tiny/fold90/metrics.json`, `har/004/runs/phase0-1-acc-tiny/fold90/best_model.pth`
- A0サマリ: `har/001/docs/A0_acc_v1_baseline_summary.md`
- A0 TFLite/ckpt/manifest: `har/004/export/acc_v1_keras/phase0-1-acc.v1.int8.tflite`, `har/004/runs/phase0-1-acc/fold90/best_model.pth`, `har/004/export/acc_v1_keras/manifest.json`
- split定義: `docs/フェーズ0-1/splits_subject90.yaml`
- データ前処理済: `har/001/data_processed/subject{XX}.npz`

## 既存BLE関連ドキュメント（docs/paper 配下）
- `docs/paper/literature_review_ble_dynamic_adv.md` … 動的adv制御の先行研究サーベイ。実機で電力×到達性同時計測の希少性を指摘
- `docs/paper/repomix-output.xml` … 証拠集メタ（本文引用は不要）

## リサーチノート（調査・考察）
- `docs/paper/BLE非理想スキャン_RL最適化_リサーチノート.md` … 非理想スキャン挙動、Valley Area、高調波、Opportunistic scan、MAB/RL報酬設計例
- `docs/paper/TinyML制約付き学習_リサーチノート.md` … MCU上のMAB/LinUCB制約と高速化、RAMクラス別指針
- `docs/paper/不確実性駆動送信制御_リサーチノート.md` … 不確実性指標/温度スケーリング/Early Exit/ファジィ制御など実装例

## Phase0-1 関連（参照のみ）
- 引き継ぎ: `har/001/docs/Phase0-1_引き継ぎ資料_2025-11-26.md`
- 再評価/作業ログ: `har/001/docs/Phase0-1再評価報告書_2025-11-25.md`, `har/001/docs/Phase0-1_作業ログ_2025-11-25.md`
- 評価表: `har/001/docs/HAR_model_evaluation_phase0-1.md`
- A/B比較・TinyML v1: `har/004/docs/HAR_model_evaluation_phase0-1_v1.md`, `har/004/docs/decision_log_2025-11-26.md`

## BLE要件・共通ルール
- フェーズ1要件: `docs/フェーズ1/要件定義.md`
- リポジトリルール: `AGENTS.md`, `CLAUDE.md`

## 備考
- A_tinyのTFLiteサイズ、FLOPs、Reliability図、4クラス混同行列（方向別誤り率）は要計測・要生成。論文化時に追記すること。
- BLE KPIに関する設計・考察は docs/paper 配下のリサーチノートを優先的に参照。`har/` 配下には書かない。
- リサーチノート類は調査・考察枠。実測データやモデル結果は har/ 配下および仕様書で取得・記載。

---

## IEEE論文化向け 参照ガイド & 必須記載ポイント

### どのデータをどこで見るか
- **モデル仕様・実装**: `har/001/src/model.py`（DSCNN定義）  
  - A_tiny/A0のレイヤ構成・パラメータ算出の根拠。
- **設定/分割**: `har/004/configs/phase0-1.acc.v2_tiny.yaml`（Tiny）、`har/004/configs/phase0-1.acc.v1.yaml`（A0）、`docs/フェーズ0-1/splits_subject90.yaml`（fold90）。
- **学習結果**: `har/004/runs/phase0-1-acc-tiny/fold90/metrics.json`、`har/004/runs/phase0-1-acc/fold90/metrics.json`。  
  - 12c/4cのBAcc/F1、calibration/T/τはここを引用。
- **導出メタ**: A0 manifest/meta (`har/004/export/acc_v1_keras/manifest.json`, `har/004/export/acc_v1/meta.json`) → sha256, rep_data, PT↔TFLite誤差。
- **データセット**: 前処理済 `har/001/data_processed/subject{XX}.npz`（胸Acc）。元データは mHealth（公開データセット）であることを明記。
- **BLE要件・KPI**: `docs/フェーズ1/要件定義.md`（KPI/閾値の根拠）、docs/paper 配下のリサーチノート（非理想スキャン/動的adv/TinyML制約/不確実性制御）。

### IEEE論文で必ず書くべき項目（抜け防止）
1. **タスク・設定**: 3軸胸Acc, 1.0s/0.5s窓, 12→4クラス集約（表で定義）。
2. **データ分割**: fold90（subject10 test）、train/val/test人数と窓数。
3. **モデル**: A0/A_tinyの全レイヤ表（出力形状・パラメータ数・FLOPs）、int8サイズ。
4. **学習条件**: CE, Adam, lr/batch/epoch/early-stop、augment（5種の範囲を明記）。
5. **指標（12c/4c）**: Acc/BAcc/Macro-F1/Weighted-F1、4c混同行列と Stationary↔Loc 誤り率（方向別）。
6. **較正/U/S/CCS**: T最適化法、T値、ECE(4c)、τ (Unknown 5–15%)、CCS式と θ_low/high、Reliability図。
7. **TinyML**: PT↔TFLite誤差（argmax一致/MAE）、int8サイズ、ESP32-S3の t_inf(p95/avg)、Arena最小/推奨。
8. **BLE制御**: ポリシー仕様（ACTIVE/UNCERTAIN/QUIET, θ, ヒステリシス, min_stay, max_rate, fallback）、状態遷移図。
9. **BLE実験設計**: 環境E1/E2、条件（固定{100,500,1000,2000}+不確実度）、反復回数、ログ項目（CCS/U/S/adv_interval, ΔE/adv, avg current, Pout, TL）。
10. **KPI判定**: 省電力（平均電流5–10%改善）、品質（Pout+1pt, TL p95 +10%）、再現性（±5%）。
11. **再現性**: コード/設定パス一覧、SHA256（TFLite, rep_data）、データライセンス（mHealth公開、プライバシー懸念なし）。
12. **Threats/Limitations/Future**: 3軸のみ、fold90依存、S3のみ評価、将来は多センサ/ポリシ適応/PHY拡張。

### よく参照する図・表
- 4クラス混同行列（row=true, col=pred）A0/A_tiny
- Reliability図（4クラス）
- モデルレイヤ表（A0/A_tiny）
- BLE状態遷移図
- 総合サマリ表（HAR性能/Calibration/TinyML/BLE KPI）

### メモ
- A_tiny: TFLiteサイズ、FLOPs、Reliability図、4c混同行列（方向別）は要生成・要記載。
- BLE KPIに関する設計・考察は docs/paper 配下のリサーチノートを優先的に参照。`har/` 配下には書かない。
</file>

<file path="paper/literature_review_ble_dynamic_adv.md">
以下は、BLEアドバタイズ間隔制御と省電力・到達性評価・バンディット学習適用に関する先行研究の整理ノートです。  
ReFormHAR‑Tiny プロジェクトのペーパー用バックグラウンドとして位置づけ、要件定義や設計書からは独立に管理します。

---

# 1. 調査の目的と観点

本調査では、次の 3 点を同時に満たす先行研究が存在するかを確認した。

1. **BLEアドバタイズ間隔を動的に調整して省電力化すること**  
2. **実機で電力と通信到達性（PDR, TL, Pout など）を同時に測定して評価していること**  
3. **マルチアーム・バンディット（MAB）等のオンライン学習で環境適応を行っていること**  

これらを満たす研究が既にあるか、もしくは部分的に満たす研究の組み合わせがどの程度存在するかを確認した。

---

# 2. 動的アドバタイズ間隔制御に関する先行研究

## 2.1 ヒューリスティック／ルールベースな制御

- 無線チャネルの混雑度やビーコン受信状況に応じて、**広告間隔を伸縮させるヒューリスティックな手法**はいくつか報告されている。
  - 例: 周囲のトラフィック密度（近接ビーコン数やスキャン成功率）に応じて、`adv_interval` を段階的に増減させる方式。
  - 例: 電子棚札やデジタルサイネージにおいて、**人気度・アクセス頻度**に応じて広告頻度を下げることで電力を節約する方式。
- 多くの場合、
  - 制御則は「if 混雑度>閾値 then intervalを伸ばす」といった**固定ロジック**であり、
  - オフラインで決めたパラメタに従って挙動するに留まる。

## 2.2 最適化問題としての扱い

- 一部の研究では、「発見遅延」と「消費電力」のトレードオフを解析的にモデル化し、**最適な広告間隔を数値的に求める**手法が提案されている。
  - 例: ビーコン発見までの期待遅延を解析し、許容遅延の範囲内で電力を最小化する `adv_interval` を導出する研究。
- これらは主に
  - 理論解析やシミュレーションに基づき、
  - 実システムへの実装は「固定値（最適値）」として適用する形が多い。
- 一方で、
  - **環境が時間とともに変動すること**を前提にした「オンライン最適化」としての扱いは少なく、
  - 「混雑度に応じてローカルルールで伸縮する」レベルで止まっているものが多い。

## 2.3 調査からの示唆

- 「動的に広告間隔を変える」というアイデア自体は先行研究にも見られるが、
  - その多くは **ヒューリスティック／ルールベース**であり、
  - **オンライン学習で逐次的に最適化する枠組み**までは踏み込んでいない。

---

# 3. 電力・到達性の実機評価に関する先行研究

## 3.1 BLE性能の一般的なレビュー

- BLEのスループット・到達距離・省電力性に関するレビュー論文では、
  - 理論スループット（≈230 kbps）に対して実効スループットは ≈100 kbps 程度、
  - 送信電力に依存しつつも、屋内で数十メートル程度の到達距離、
  - 接続型 vs 非接続型の損得（スキャン負荷など）
  といった整理が行われている。
- しかし、
  - **アドバタイズ間隔を複数条件で振りつつ**、
  - **実機で電力と到達性（PDR, TL, Pout）を同時に詳細測定**した研究は限定的である。

## 3.2 実機を用いた計測事例

- いくつかの論文では、BLEビーコンやウェアラブル機器の**電流波形をオシロスコープや専用電力計で測定**し、
  - 省電力モードの比較、
  - 通信パターン（接続間隔や広告間隔）の比較
  を行っている。
- ただし多くは、
  - 評価対象が「平均電流」や「バッテリ寿命推定」に留まり、
  - **受信側ログ（PDR/TL）と統合した評価**までは行っていない。

## 3.3 本調査から見えたギャップ

- 「アドバタイズ間隔を変えながら、**同時に**電力と通信到達性を実機で測る」という観点は、
  - レビュー論文でも「十分に行われていない」と指摘されている。
- 特に以下の点は、ほとんどカバーされていない。
  - **固定でない adv_interval（動的制御）**
  - **ΔE/adv のようなイベント単位のエネルギー指標**
  - **PDR/TL/Pout を同じ実験系で併記した評価**

---

# 4. バンディット学習・機械学習の適用状況

## 4.1 バンディット学習を用いたBLE制御

- 近年（2024年頃）の研究において、BLEの
  - **広告チャネル数**、
  - **広告間隔の粗い離散集合**
  をアームとみなし、**マルチアーム・バンディット（MAB）** で省電力化を図る例がある。
  - 例: チャネル数や広告頻度を調整し、最大約40%の省電力効果を報告した研究。
- ただし多くの場合、
  - 状態空間は比較的粗く、
  - 目的関数も「平均エネルギー」や「成功率」のような単一指標に近い。
- また、
  - 学習の一部または大半が **シミュレーション環境** で実施され、
  - 実機での**逐次学習（online learning）**は限定的であることが多い。

## 4.2 その他の機械学習的アプローチ

- BLEビーコン配置やチャンネル割り当てに対して、教師あり学習や強化学習を用いる研究も存在する。
  - 例: 人の流れ・滞在時間を予測し、それに合わせてビーコン出力を調整するモデル。
  - 例: シミュレーション上で強化学習によりデューティ比を最適化する研究。
- しかし、
  - 多くは**離線のログ**を使ったモデル学習や、
  - シミュレーション上での評価に留まっており、
  - 実機で広告間隔をオンライン最適化しながら電力と到達性を観測する事例はほぼ見当たらない。

---

# 5. 総合的な位置づけと新規性

## 5.1 調査のまとめ

- 先行研究には、以下のような部分的な要素は存在する。
  - BLE広告間隔をヒューリスティックに動的制御する手法。
  - 電力あるいは到達性のどちらかを中心にした実機評価。
  - BLE関連設定（チャネル数や間隔）に対する MAB や機械学習の適用。
- しかし、本プロジェクトが掲げる次の 3 点を **同時に**満たす研究は確認できなかった。

1. **広告間隔を動的に調整することによる省電力効果の検証**  
2. **実機で「電力＋通信到達性（PDR/TL/Pout）」を同時に計測する評価系**  
3. **マルチアーム・バンディット等によるオンライン環境適応（実環境での逐次学習）**  

## 5.2 本プロジェクトの位置づけ

- ReFormHAR‑Tiny / Phase‑0/1 の計画（擬似U/S → CCS → adv_interval制御、ΔE/adv＋PDR/TL/Pout評価、Phase‑2/3でのMAB/Safe‑MAB化）は、
  - 既存研究に散在する「動的間隔」「実測電力」「到達性」「バンディット学習」の要素を **1つの実験系に統合** するものと位置づけられる。
- 特に以下の点は、先行研究と比較して特徴的である。
  - **ΔE/adv（イベントあたりのエネルギー増分）**を軸とした電力評価。
  - **PDR/TL/Pout** を同時に取る実機実験系（TX/TXSD/RXの三ノード構成）。
  - 将来フェーズでの **Safe‑MAB によるオンライン制御** を見据えた設計。

## 5.3 要件・設計への示唆（メモ）

- 要件定義・設計定義に反映する場合の候補（反映はオーナー承認後）：
  - フェーズ1のKPI項目における **ΔE/adv の位置づけ**（すでにフェーズ0-0で採用済みの考え方を、Phase‑1/2にも明示するかどうか）。
  - 「既存研究との違い」を整理した **非機能要件（再現性・外的妥当性・学習安定性）** の補足。
  - MAB/Safe‑MABフェーズに向けた「オンライン学習実験」の要件定義（評価指標や安全側フォールバック条件など）。

（現時点では要件定義・設計書への直接の修正は行わず、本ファイルはペーパー準備用のリサーチノートとして扱う。）
</file>

<file path="paper/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
BLE非理想スキャン_RL最適化_リサーチノート.md
literature_review_ble_dynamic_adv.md
TinyML制約付き学習_リサーチノート.md
不確実性駆動送信制御_リサーチノート.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="BLE非理想スキャン_RL最適化_リサーチノート.md">
以下は、**非理想的なスマホスキャン環境下でのBLEアドバタイズ最適化**に関するリサーチノートです。  
理論的な一般論ではなく、**スマホOSの挙動・数理モデル・MAB/RLアルゴリズム・シミュレータ・実装戦略**といった深い部分だけを抜き出して整理します。

---

# 1. 非理想スキャン環境の具体像

## 1.1 BLE近隣発見の基本モデル（再掲）

- アドバタイザ側:
  - アドバタイズ間隔 `T_adv` ごとに、3チャネル（37/38/39）へ送信。
  - BLE仕様上、各イベントに 0〜10 ms 程度の疑似ランダム遅延が混入。
- スキャナ側:
  - スキャン間隔 `T_scan` ごとに、スキャンウィンドウ `d_scan` だけ受信。
  - デューティ比 `δ = d_scan / T_scan`。
- 発見遅延 L:
  - アドバタイズイベントとスキャンウィンドウの **オーバーラップまでの時間**。
  - スロットレスだが、ランダム遅延と `T_adv`, `T_scan` の相互作用から分布が決まる。

---

## 1.2 決定論的ブラインドスポット（Valley Area）

- **高調波関係問題**
  - `T_adv` と `T_scan` が整数比（高調波）に近い場合、
    - アドバタイズが系統的にスキャナのスリープ区間に入り続け、
    - 半ば決定論的に「ほぼ見つからない」組み合わせが生じる。
- **ランダム遅延の限界**
  - 仕様上のランダム遅延は偶然の位相ずれを生むが、
    - エネルギー制約のある端末ではイベント数自体が少なく、
    - 最悪ケース遅延や Valley Area を確率論的に打ち消すには不十分な場合がある。
- **高密度環境**
  - 多数のアドバタイザが同時に送信する場合、
    - スキャナ側の受信スロットが飽和 → 衝突・競合でパケットロス。
  - 理想モデル（ランダム一様・単一ペア）から大きく逸脱する。

---

## 1.3 Android の非理想スキャン挙動（2023–2025）

- **スキャンモードと実際のデューティ**
  - `SCAN_MODE_LOW_LATENCY`
    - フロント（画面ON・アプリフォアグラウンド）時のみ **ほぼ連続スキャン**に近い動作。
  - `SCAN_MODE_BALANCED` / `LOW_POWER`
    - バックグラウンドでは、例として「500 ms スキャン / 5000 ms スリープ」など、
      - デューティ `δ < 10%` 程度に強制的に落とされるケースが多い。
  - 実際のウィンドウ/間隔は端末・OSバージョン依存であり、**アプリ側からは取得できない**。

- **Doze / App Standby / Android 15 の変更**
  - Dozeモード:
    - 端末がアイドル（画面OFF・充電無し）に入ると、
      - スキャンは OS により間欠的にしか実行されない。
  - Android 15:
    - `BLUETOOTH_SCAN` 権限導入でプライバシー分離を行いつつ、
      - バックグラウンドスキャンのスロットリングが強化。
    - 「オポチュニスティック・スキャン」:
      - 他アプリのスキャンに便乗して結果を共有する形になり、
      - **自アプリが明示的に連続スキャンしているわけではない**。
    - 実務報告レベルでは、「バックグラウンド連続スキャンが 30 分程度で OS によって止まる」という事象が観測されている。

---

## 1.4 iOS の非理想スキャン挙動（iOS 18 まで）

- **バックグラウンド制約**
  - アプリがバックグラウンドに落ちると、
    - BLEスキャンの **頻度・長さはOS内部ロジックにより大幅に縮退**。
    - 実測では「数秒〜数分に一度、数 ms のウィンドウ」というレベルになる事例も報告。
  - **Duplicate Filtering 強制**
    - バックグラウンドでは、**同じ周辺機器からのアドバタイザは最初の1回しか通知されない**。
    - 継続的な RSSI 監視や連続データを受け取るには、接続モードに移行するか、アドバタイザ側が UUID/アドレスを変える等トリッキーな手が必要。

- **iOS 18 / AccessorySetupKit**
  - アクセサリセットアップを簡略化するフレームワーク。
  - ただし、「ユーザ主導のペアリング」を前提とした API であり、
    - 不特定多数のビーコンをバックグラウンドで検出し続ける用途の制限は緩和されていない。

---

## 1.5 オポチュニスティック・スキャンと合成ウィンドウ

- 複数アプリが異なるパラメータでスキャンする場合、
  - 実際のRFレベルでは「スキャンウィンドウの和集合」がハードウェアで実行される。
  - これを **Opportunistic Scan** と呼ぶ。
- アドバタイザからは、
  - 合成されたスキャンパターンは完全に未知であり、時間とともに変化。
  - この「未知で非定常なスキャナ」を前提にした制御問題として扱うのが妥当。

---

# 2. MAB / RL によるアドバタイズ最適化

## 2.1 Hasegawa/Kitagawa 系列の MAB アプローチ

- **問題設定**
  - アーム `a`：アドバタイズ間隔 × チャンネルマスク（37/38/39 の組み合わせ）。
    - 例：interval ∈ {100, 500, 1000 ms} × mask ∈ {3ch, 2ch, 1ch}。
  - 時刻 t ごとにアームを選び、その設定で広告 → 成功/失敗とエネルギーを観測。

- **報酬設計（例）**

  ```text
  R_t = α · 1{Success_t} − β · E_t
  ```

  - `Success_t`:
    - Scan Request / Connect Request を受信できたかどうか。
  - `E_t`:
    - その送信条件で消費したエネルギー（電流積分や、SF/TxPower/回数の近似式）。
  - α, β で「発見率 vs 省電力」のトレードオフを調整。

- **重要なポイント**
  - スキャナの `T_scan, d_scan, δ` を一切明示的に知らなくても、
    - 成功フラグだけを見て「スキャナと噛み合いやすい interval/mask」を暗黙に学習。
  - 混雑度や OS スケジューラの変化は「報酬分布の変動」として現れ、
    - アルゴリズムが自動的に再適応する。

---

## 2.2 UCB1‑tuned と Tug‑of‑War (TOW)

- **UCB1‑tuned**
  - 通常の UCB は「平均報酬 + √(ln t / n_k)」のみを見るが、
    - 無線環境では報酬分散が大きい（混雑・フェージングなど）。
  - UCB1‑tuned は分散推定 `σ_hat_k^2` を入れて上界を調整：

    ```text
    UCB_k = μ_hat_k + sqrt{ (ln t / n_k) * min(1/4, σ_hat_k^2 + sqrt(2 ln t / n_k)) }
    ```

  - 分散が大きいアームは探索項が増える一方、
    - 極端に不安定なアームは早めに見切りをつけやすく、収束が安定。

- **Tug‑of‑War (TOW) ダイナミクス**
  - よりシンプルで演算も軽い更新則を持つ意思決定アルゴリズム。
  - 利点:
    - 非定常環境（スキャナ挙動が頻繁に変わる）で、
      - 重い UCB 系よりも素早く「当たりのアーム」に切り替えられるケースがある。
  - BLE環境では、短時間接触（すれ違い）や瞬間的な負荷変動に対する追従性が評価されている。

---

## 2.3 Q-Learning / Deep RL による長期的最適化

- **状態と行動の例**
  - 状態 S:
    - バッテリ残量（離散化）、直近の成功率（窓平均）、推定混雑度（loss率）。
  - 行動 A:
    - アドバタイズ間隔の増減（100→500→1000msなど）。
    - 送信電力の調整（TxPower ステップアップ/ダウン）。

- **効果**
  - シミュレーションでは、
    - ランダム/固定方式に比べてネットワーク寿命を大幅に延長しつつ、
    - 最大遅延制約（例: TL p95 ≤ τ）を満たす方策を獲得。

- **課題**
  - Q-Learning は**収束までの試行数が多い**（Warm‑up が長い）。
  - スマホとの接触時間が短いシナリオ（すれ違い広告など）では、
    - 学習が終わる前に通信機会が終わる危険。
  - これに対し、**事前にオフライン学習した DQN ポリシーを MCUに焼き込む**形で、
    - 初期からそこそこ良い行動をとれるようにする研究もある。

---

## 2.4 コンテキストMAB：Wi‑Fi/外部情報の利用

- **アイデア**
  - BLE だけでなく、スマホが頻繁に行っている Wi‑Fi スキャン結果などを「コンテキスト」として利用。
  - 例:
    - 周辺 Wi‑Fi AP の RSSI 分布や BSSID 数から「端末がアクティブに通信している状況か」を推定。
    - このとき BLE スキャンも動いている可能性が高いと仮定し、広告間隔を一時的に短縮。

- **類似事例**
  - mmWave 近隣発見の研究では、
    - Wi‑Fi の情報からビーム方向や探索優先度を学習するコンテキストバンディットが提案されており、
    - BLEのチャンネル／interval 選択にもコンセプトが応用可能。

---

# 3. シミュレーションフレームワークと決定論的検証

## 3.1 Blender フレームワーク（トレース駆動）

- **従来シミュレータの問題**
  - スキャナを「一定の確率で On/Off するランダムプロセス」としてモデル化。
  - 実際の OS スケジューラは決定論的であり、
    - 例: 「1.5s スキャン、3.5s スリープ」を正確に繰り返す端末など。
  - この場合、理論上「見つかるはず」のパラメータが**永遠に見つからない**ことがありうる。

- **Blender の特徴**
  - **トレース駆動（trace‑driven）**
    - 実機 Android/iOS から収集したスキャンログを入力。
  - **全位相探索**
    - `T_adv, T_scan, d_scan, loss_rate` を与えると、
      - 可能な全ての位相差に対する遅延分布を決定論的に計算。
    - パラメタ例:
      - `adv_interval`: 20〜10240 ms
      - `scan_interval`, `scan_window`: 20〜10240 ms
      - `loss_rate`: 0〜99%
  - 結果:
    - **最悪ケース遅延** や Valley Area を明示的に把握できる。
    - MAB/RLで学んだポリシーが、特定のOSや端末で「穴」にはまらないか検証可能。

---

## 3.2 ElastiCast：インターバル多重化戦略

- **発想**
  - 単一の固定 `T_adv` では、全てのスキャナに対して良い性能を出すことは困難。
  - そこで、**複数の `T_adv` を時間的に多重化**する。
    - 例: 素数関係にある複数の interval を組み合わせる。

- **効果**
  - 高調波関係による Valley Area を避け、
    - どのような `T_scan, d_scan` を持つ端末でも、
    - ある程度の時間内には必ずオーバーラップするように設計する。
  - 「学習で環境に合わせる」アプローチに対し、
    - ElastiCast は「**決定論的設計で最悪ケースを潰す**」方向の戦略。

---

## 3.3 ReND：推論ベース近隣発見（Reasoning-based ND）

- **三段論法によるトリガー**
  - 大前提: クラウドDBに「BLEビーコンXはWi‑Fi AP Yの近くにある」という知識を保存。
  - 小前提: スマホが Wi‑Fi スキャンで AP Y を発見。
  - 結論: 「ビーコンXが近くにいる可能性が高い」と推論。
- **実装**
  - 推論成立時に、アプリが OS に対して「高頻度BLEスキャン」を一時的に要求。
  - 通常は数％の duty に抑えつつ、
    - **必要な瞬間だけ 100% に近いスキャン**を実行し、一発で発見する。

- **強化学習との関係**
  - MAB/RL が「アドバタイザがスキャナに合わせに行く」アプローチだとすると、
    - ReND は「スキャナの duty をアプリ側から引き上げる」アプローチ。
  - 両者は補完的:
    - ReNDでチャンスを作り、
    - その中で MAB/RL で最適 interval/mask を当てる、という組み合わせも考えられる。

---

# 4. 実装上の示唆（ReFormHAR‑Tiny への応用視点）

- **アドバタイザ側（ESP32/TX）**
  - 低コストな MAB（UCB1‑tuned or TOW）をファームウェア内に実装し、
    - 報酬を「ScanReq/ConnectReq 成功 − λ·消費エネルギー」で設計。
  - 将来的に LinUCB などコンテキストバンディットを使う場合は、
    - 受信側ログや外部メタデータを簡約した「コンテキスト特徴」をどう埋め込むかを設計する余地あり。

- **スキャナ側（スマホアプリ）**
  - Android:
    - `SCAN_MODE_LOW_LATENCY` を必要時だけ On にする **オンデマンドスキャン**。
    - 他アプリのトレースを収集し、Blender 系のフレームワークで Valley Area を事前解析。
  - iOS:
    - Backgroud Duplicate Filtering を前提に、
      - 「単発検出」用途に割り切るか、
      - 接続モードへの移行や ReND 的トリガーを利用するかを設計段階で決める必要あり。

- **評価**
  - 単に平均 PDR/TL でなく、
    - Blender 等で **最悪ケースTL** と Valley Area の有無を指標化することが重要。
  - 実験時は、ターゲット端末（Pixel系, Galaxy系, iPhone世代別）ごとにトレースを収集しておくとよい。

このノートは、BLE広告最適化を「非理想スキャナ前提」で考えるための材料として、OS挙動・MAB/RL・シミュレータ・実システムの接続方法をまとめたものである。  
フェーズ2以降の MAB/Safe‑MAB や ReND的なトリガー設計を検討する際に、必要な要素だけを抜き出して使えるようにしている。
</file>

<file path="literature_review_ble_dynamic_adv.md">
以下は、BLEアドバタイズ間隔制御と省電力・到達性評価・バンディット学習適用に関する先行研究の整理ノートです。  
ReFormHAR‑Tiny プロジェクトのペーパー用バックグラウンドとして位置づけ、要件定義や設計書からは独立に管理します。

---

# 1. 調査の目的と観点

本調査では、次の 3 点を同時に満たす先行研究が存在するかを確認した。

1. **BLEアドバタイズ間隔を動的に調整して省電力化すること**  
2. **実機で電力と通信到達性（PDR, TL, Pout など）を同時に測定して評価していること**  
3. **マルチアーム・バンディット（MAB）等のオンライン学習で環境適応を行っていること**  

これらを満たす研究が既にあるか、もしくは部分的に満たす研究の組み合わせがどの程度存在するかを確認した。

---

# 2. 動的アドバタイズ間隔制御に関する先行研究

## 2.1 ヒューリスティック／ルールベースな制御

- 無線チャネルの混雑度やビーコン受信状況に応じて、**広告間隔を伸縮させるヒューリスティックな手法**はいくつか報告されている。
  - 例: 周囲のトラフィック密度（近接ビーコン数やスキャン成功率）に応じて、`adv_interval` を段階的に増減させる方式。
  - 例: 電子棚札やデジタルサイネージにおいて、**人気度・アクセス頻度**に応じて広告頻度を下げることで電力を節約する方式。
- 多くの場合、
  - 制御則は「if 混雑度>閾値 then intervalを伸ばす」といった**固定ロジック**であり、
  - オフラインで決めたパラメタに従って挙動するに留まる。

## 2.2 最適化問題としての扱い

- 一部の研究では、「発見遅延」と「消費電力」のトレードオフを解析的にモデル化し、**最適な広告間隔を数値的に求める**手法が提案されている。
  - 例: ビーコン発見までの期待遅延を解析し、許容遅延の範囲内で電力を最小化する `adv_interval` を導出する研究。
- これらは主に
  - 理論解析やシミュレーションに基づき、
  - 実システムへの実装は「固定値（最適値）」として適用する形が多い。
- 一方で、
  - **環境が時間とともに変動すること**を前提にした「オンライン最適化」としての扱いは少なく、
  - 「混雑度に応じてローカルルールで伸縮する」レベルで止まっているものが多い。

## 2.3 調査からの示唆

- 「動的に広告間隔を変える」というアイデア自体は先行研究にも見られるが、
  - その多くは **ヒューリスティック／ルールベース**であり、
  - **オンライン学習で逐次的に最適化する枠組み**までは踏み込んでいない。

---

# 3. 電力・到達性の実機評価に関する先行研究

## 3.1 BLE性能の一般的なレビュー

- BLEのスループット・到達距離・省電力性に関するレビュー論文では、
  - 理論スループット（≈230 kbps）に対して実効スループットは ≈100 kbps 程度、
  - 送信電力に依存しつつも、屋内で数十メートル程度の到達距離、
  - 接続型 vs 非接続型の損得（スキャン負荷など）
  といった整理が行われている。
- しかし、
  - **アドバタイズ間隔を複数条件で振りつつ**、
  - **実機で電力と到達性（PDR, TL, Pout）を同時に詳細測定**した研究は限定的である。

## 3.2 実機を用いた計測事例

- いくつかの論文では、BLEビーコンやウェアラブル機器の**電流波形をオシロスコープや専用電力計で測定**し、
  - 省電力モードの比較、
  - 通信パターン（接続間隔や広告間隔）の比較
  を行っている。
- ただし多くは、
  - 評価対象が「平均電流」や「バッテリ寿命推定」に留まり、
  - **受信側ログ（PDR/TL）と統合した評価**までは行っていない。

## 3.3 本調査から見えたギャップ

- 「アドバタイズ間隔を変えながら、**同時に**電力と通信到達性を実機で測る」という観点は、
  - レビュー論文でも「十分に行われていない」と指摘されている。
- 特に以下の点は、ほとんどカバーされていない。
  - **固定でない adv_interval（動的制御）**
  - **ΔE/adv のようなイベント単位のエネルギー指標**
  - **PDR/TL/Pout を同じ実験系で併記した評価**

---

# 4. バンディット学習・機械学習の適用状況

## 4.1 バンディット学習を用いたBLE制御

- 近年（2024年頃）の研究において、BLEの
  - **広告チャネル数**、
  - **広告間隔の粗い離散集合**
  をアームとみなし、**マルチアーム・バンディット（MAB）** で省電力化を図る例がある。
  - 例: チャネル数や広告頻度を調整し、最大約40%の省電力効果を報告した研究。
- ただし多くの場合、
  - 状態空間は比較的粗く、
  - 目的関数も「平均エネルギー」や「成功率」のような単一指標に近い。
- また、
  - 学習の一部または大半が **シミュレーション環境** で実施され、
  - 実機での**逐次学習（online learning）**は限定的であることが多い。

## 4.2 その他の機械学習的アプローチ

- BLEビーコン配置やチャンネル割り当てに対して、教師あり学習や強化学習を用いる研究も存在する。
  - 例: 人の流れ・滞在時間を予測し、それに合わせてビーコン出力を調整するモデル。
  - 例: シミュレーション上で強化学習によりデューティ比を最適化する研究。
- しかし、
  - 多くは**離線のログ**を使ったモデル学習や、
  - シミュレーション上での評価に留まっており、
  - 実機で広告間隔をオンライン最適化しながら電力と到達性を観測する事例はほぼ見当たらない。

---

# 5. 総合的な位置づけと新規性

## 5.1 調査のまとめ

- 先行研究には、以下のような部分的な要素は存在する。
  - BLE広告間隔をヒューリスティックに動的制御する手法。
  - 電力あるいは到達性のどちらかを中心にした実機評価。
  - BLE関連設定（チャネル数や間隔）に対する MAB や機械学習の適用。
- しかし、本プロジェクトが掲げる次の 3 点を **同時に**満たす研究は確認できなかった。

1. **広告間隔を動的に調整することによる省電力効果の検証**  
2. **実機で「電力＋通信到達性（PDR/TL/Pout）」を同時に計測する評価系**  
3. **マルチアーム・バンディット等によるオンライン環境適応（実環境での逐次学習）**  

## 5.2 本プロジェクトの位置づけ

- ReFormHAR‑Tiny / Phase‑0/1 の計画（擬似U/S → CCS → adv_interval制御、ΔE/adv＋PDR/TL/Pout評価、Phase‑2/3でのMAB/Safe‑MAB化）は、
  - 既存研究に散在する「動的間隔」「実測電力」「到達性」「バンディット学習」の要素を **1つの実験系に統合** するものと位置づけられる。
- 特に以下の点は、先行研究と比較して特徴的である。
  - **ΔE/adv（イベントあたりのエネルギー増分）**を軸とした電力評価。
  - **PDR/TL/Pout** を同時に取る実機実験系（TX/TXSD/RXの三ノード構成）。
  - 将来フェーズでの **Safe‑MAB によるオンライン制御** を見据えた設計。

## 5.3 要件・設計への示唆（メモ）

- 要件定義・設計定義に反映する場合の候補（反映はオーナー承認後）：
  - フェーズ1のKPI項目における **ΔE/adv の位置づけ**（すでにフェーズ0-0で採用済みの考え方を、Phase‑1/2にも明示するかどうか）。
  - 「既存研究との違い」を整理した **非機能要件（再現性・外的妥当性・学習安定性）** の補足。
  - MAB/Safe‑MABフェーズに向けた「オンライン学習実験」の要件定義（評価指標や安全側フォールバック条件など）。

（現時点では要件定義・設計書への直接の修正は行わず、本ファイルはペーパー準備用のリサーチノートとして扱う。）
</file>

<file path="TinyML制約付き学習_リサーチノート.md">
以下は、**TinyML環境（MCU）における制約付き強化学習／Multi‑armed Bandit実装**に関するリサーチノートです。  
イントロ的な一般論は省き、**MCU上で実際にどう実装するか／どこまでできているか**に関する深い部分だけを整理します。

---

# 1. TinyML向け学習の制約構造

- **二つの強い制約**
  - **ハードウェア制約**
    - RAM は数 KB〜数百 KB（例：STM32F103 20 KB, Nano 33 BLE 256 KB, Teensy 4.1 1 MB）。
    - Flash は 64 KB〜数 MB。コードと定数は置けるが、頻繁な書き換えには不向き。
    - 動的メモリ（`malloc/new`）は断片化リスクから避けるのが前提 → **静的配列／スタック確保が基本**。
    - FPU/DSP命令有無で実現可能なアルゴリズムが変わる（Cortex‑M3 と M4F/M7 の差は大きい）。
  - **安全・QoS制約**
    - LoRaWAN デューティサイクル、規制上限（1%）などを**絶対に越えられない**。
    - 医療系やインフラ監視では「試行錯誤の失敗」が人命・法令違反に直結 → 無制限探索不可。
- **結論として必要なアーキテクチャ**
  - 学習アルゴリズムそのものは「通常の」報酬最適化に徹し、
  - その外側に **軽量な Safety Filter（Action Masking / CBF など）** を置いてハード制約を担保する構造が現実解として採用されている。

---

# 2. MCU上の Multi‑armed Bandit / LinUCB 実装

## 2.1 単純 MAB（ε‑Greedy, UCB1）

- **特徴**
  - 必要状態は「各アームの平均報酬」「訪問回数」だけ → メモリ O(K)。
  - 8‑bit MCU でも実装可能（tabular Q‑learning と同程度）。
- **限界**
  - コンテキスト（SNR, バッテリ, 位置など）を考慮できないため、通信制御などの実用シナリオでは表現力不足。

---

## 2.2 線形コンテキストバンディット（LinUCB）

- **モデル**
  - 各アーム a の期待報酬：`E[r | x_a] = x_a^T θ*`（x_a∈ℝ^d）。
  - 推定量：`θ_hat = A^-1 b`  
    - `A = Σ x x^T + λI`、`b = Σ r x`。
  - UCB スコア：`score(a) = x_a^T θ_hat + α sqrt(x_a^T A^-1 x_a)`。

- **MCU上の最大のボトルネック**
  - d×d 行列 A とその逆行列 A^-1 を保持・更新する必要がある。
  - 朴素な逆行列計算は O(d^3) → 数十 MHz クラスMCUには重い。

---

## 2.3 Sherman–Morrison 公式による高速化

- **ランク1更新**
  - 新サンプル (x_t, r_t) に対し、`A_{t+1} = A_t + x_t x_t^T`。
  - Sherman‑Morrison により、

    ```text
    A_{t+1}^{-1}
      = A_t^{-1} - (A_t^{-1} x_t x_t^T A_t^{-1}) / (1 + x_t^T A_t^{-1} x_t)
    ```

  - 必要な計算は
    - ベクトル v = A_t^-1 x_t（O(d^2)）
    - スカラー s = 1 + x_t^T v（O(d)）
    - A^-1 のランク1更新（O(d^2)）
  - → **1ステップあたり O(d^2)** に削減（O(d^3)→O(d^2)）。

- **実装上の工夫（C/C++）**
  - 行列は `float A_inv[d*d]` の 1次元配列に格納（SIMD／キャッシュ友好）。
  - 中間ベクトル `v[d]` などはクラスメンバとして **静的確保**（ヒープ不使用）。
  - 対称性（A^-1 は対称）を活かした上三角のみの格納も理論上は可能だが、
    - index計算が複雑化し、SIMD化が難しくなるため、
    - 多くの実装では「フル行列＋SIMD」の方を採用。

- **報告されている性能**
  - Cortex‑M4（STM32 Nucleo）上の最適化版 LinUCB:
    - d=16 の場合、朴素版 ≈ 5 ms/step → Woodbury＋SIMD で ≈ 0.3 ms/step に短縮（約1/15）。
  - RAM 使用量は d=16, K≲30 の設定で **1 KBオーダー** に収まる。

---

## 2.4 プラットフォーム適合性（抜粋）

- **20 KB RAM級（STM32F103など）**
  - 可能：Tabular Q‑learning, ε‑Greedy/UCB1, **ごく小さい d（≤4）** の LinUCB。
  - 限界：d が少し増えると A/A^-1 で RAM を使い切る。
- **256 KB RAM級（Arduino Nano 33 BLE, Cortex‑M4F）**
  - 可能：d≲16 の LinUCB、軽量 DNN を用いた Deep RL（小規模）。
  - FPU + DSP 命令あり → CMSIS‑DSP で行列演算高速化。
- **1 MB RAM級（Teensy 4.1, Cortex‑M7）**
  - 可能：d≳32 の LinUCB、PPO/SAC 等の Deep RL 学習も（RLtools 利用前提）。
- **ESP32**
  - RAM ≈ 520 KB、Flash ≈ 4 MB。
  - Wi‑Fi/BLE 内蔵のため、**Federated Learning や Multi‑agent Bandit** の通信基盤として有利。

---

# 3. 安全性制約の実装メカニズム

## 3.1 アクションマスキング（Validity Masking）

- **考え方**
  - 状態 s_t で「絶対に取ってはいけない行動 a」を、
    - 学習アルゴリズムの**外側で**除外し、
    - バンディット／RL側には「選べるアーム集合 A_valid」だけを渡す。
  - → 学習中も**ハード制約を破らない**。

- **LoRaWAN デューティサイクル例**
  - 制約：サブギガ帯で **Duty ≤ 1%**。
  - 各アーム a = (SF, TxPower) について、Time‑on‑Air `T_air(a)` を LoRaWAN 仕様から算出。
  - 直近履歴から「累積 ToA」と「回復までの残り」を計算し、
    - `current_ToA + T_air(a) > budget` なら a を INVALID に設定。
  - LinUCB/UCB1/Thompson 等は、A_valid からのみアクションを選ぶ。
  - 数理的には「Volatile Bandit（可用アーム集合が時間変動）」として扱われる。

---

## 3.2 Control Barrier Functions（CBF）の簡略フィルタ

- **用途**
  - 慣性のある系（ロボット・ドローン等）で、**「その行動を選んだ瞬間はOKだが、その後のダイナミクスで衝突する」**ケースを防ぐ。
- **理論（概念レベル）**
  - 安全集合 h(x)≥0 に対し、

    ```text
    d/dt h(x) + α h(x) ≥ 0 を満たす u のみ許容
    ```

- **MCU向け簡略実装**
  - バリア条件をそのままQPで解くのではなく、
    - 状態 x と提案行動 u_nominal に対して「危険かどうか」を安価に判定し、
    - 危険なら `u_safe` に置き換える**関数として実装**する。
  - C++イメージ:

    ```cpp
    float safety_filter(float u_nominal, const State& x) {
        if (is_violation_likely(x, u_nominal)) {
            return calculate_safe_u(x); // 速度/位置制限など
        }
        return u_nominal;
    }
    ```

  - 学習アルゴリズムは、この `u_safe` とその結果の報酬を観測するため、
    - 結果的に「安全領域内での最適方策」を学ぶことになる。

---

# 4. ケーススタディ：LoRaWAN ADR用 LinUCB（制約付き）

## 4.1 問題設定

- **目的**
  - LoRaWAN エンドデバイスで、
    - PDR を維持しつつ、
    - 消費エネルギー（送信電力＋ToA）を最小化。
- **変数**
  - コンテキスト x_t（例）:
    - 直近 N 回の SNR の平均／分散。
    - 直近の成功/失敗フラグ。
    - バッテリ残量。
  - アーム a:
    - SF ∈ {7,…,12} × TxPower ∈ {2,…,14 dBm} → K≈30。
  - 報酬 r_t（例）:

    ```text
    r_t = α * (PDR_t / PDR_target) - (1-α) * (Energy_t / Energy_max)
    ```

- **制約**
  - 法定 Duty ≤ 1% → **Action Masking** で保証。

---

## 4.2 MCU実装

- **ターゲット**
  - STM32L0 クラス（RAM ≈ 20 KB, 超低消費電力）。
- **状態保持**
  - d=4 とすると、
    - A_inv: 4×4 float = 64 bytes。
    - θ: 4 float = 16 bytes。
    - 各アームの平均報酬・選択回数：数百バイト。
  - 全体で **1 KB 未満** に収まる構成が可能。

- **動作イメージ**
  - 各送信結果ごとに LinUCB 更新（Sherman‑Morrison）。
  - 次の送信タイミングで、Action Masking されたアーム集合から UCB 最大のアームを選択。

- **報告されている効果**
  - シミュレーション／実機評価では、
    - 標準 ADR と比較して、**エネルギー効率 15–30% 改善**。
    - PDR は同等か、それ以上を維持。
  - 混雑環境でも「SF 上げすぎによるネットワーク崩壊」を避けられるケースが報告されている。

---

# 5. ケーススタディ：ECG サンプリングレート制御（TinyRL）

## 5.1 問題設定

- **用途**
  - 不整脈検知用 ECG ウェアラブル。
  - 常時 500 Hz サンプリングはバッテリ的に非現実的。
- **目的**
  - 不整脈検知精度 ≈99% を維持しつつ、
  - 平均消費電力をできるだけ下げる。

---

## 5.2 RLtools を用いた DQN Lite

- **構成**
  - MCU: Arduino Nano 33 BLE (Cortex‑M4F, 256 KB RAM)。
  - 特徴量: R‑R 間隔、QRS 幅などの軽量特徴から状態ベクトル s_t（4次元程度）を作成。
  - アクション:
    - {低レート, 中レート, 高レート} = {125 Hz, 250 Hz, 500 Hz}。
  - Policy/Qネットワーク（RLtools）:
    - 4 → 16 → 3 の全結合ネットワーク（ReLU）。
    - パラメータ数 = (4×16+16) + (16×3+3) = 131。
    - 単精度 float でも重みだけで ≈524 バイト + 中間バッファ含めても数 KB 程度。

- **学習の運用パターン**
  - 日中: 推論のみ（学習オフ）、報酬候補となるイベントをログに蓄積。
  - 夜間充電中 or 定期タイミング: ログを用いてバッチ学習（オンデバイス）／または Replay Buffer を用いたオンライン学習。
  - RLtools により、同じ C++ コードを PC シミュレータ＋MCU の両方で実行できるため、
    - まず PC 上でハイパラを詰めてから MCU に移植、というワークフローが取られている。

- **報告されている効果**
  - 常時 500 Hz サンプリングと比較して、
    - 不整脈検知精度 ≈99% を維持しつつ、
    - **平均消費電力 ≈1/7** まで削減。
  - 直前数十秒の HRV や `S_conf` の揺らぎが大きくなると高レートを選び、
    - 安定期は低レートに落とすポリシーを自律的に獲得。

---

# 6. 実装ベストプラクティス（TinyML学習用）

- **静的割り当ての徹底**
  - `std::vector`, `std::map` は基本的に使わない。
  - RLtools / ETL などの静的コンテナ、もしくは生配列を用いてヒープをゼロにする。
  - リンカの `.map` を確認し、`.bss/.data` サイズとスタックマージンを常に把握する。

- **PCシミュレーション→MCU移植**
  - 同じ C++ コードを
    - PC（Linux/macOS）でシミュレーション（OpenAI Gym 等）、
    - その後クロスコンパイルして MCU 上で動かす、
  - という 2段階開発が、TinyRL では実用的に採用されている。

- **数値精度と FPU の扱い**
  - FPUなし（Cortex‑M3 等）では float はソフトウェア実装 → 可能なら M4F 以上を使う。
  - LinUCB の A^-1 更新など、数値安定性が重要な部分は float（単精度）が最低ライン。
  - 固定小数点化は可能だが、実装・検証コストが高いため、まずは FPU 付きMCU＋float が現実解。

---

本ノートは、TinyML 環境において **「どの程度までバンディット/RLが現実的か」** を判断するための材料として、実装レベルの情報と具体的な削減効果のみを抜き出している。  
フェーズ2以降の MAB/Safe‑MAB 設計時には、ここに挙げた LinUCB 最適化・Action Masking・簡易CBF・RLtools のパターンを必要に応じて流用する。
</file>

<file path="不確実性駆動送信制御_リサーチノート.md">
以下は、**エッジデバイスにおける不確実性認識型・信頼度駆動型データ送信制御**に関する2021–2025年の主要研究を、**具体的なメカニズム・メトリクス・プロトコル実装・実験結果**に絞って整理したリサーチノートです。  
一般的なサマリーやパラダイム転換の議論は省き、実装上有用な「深い部分」のみを記録します。

---

# 1. 不確実性指標とオンデバイス実装

## 1.1 信頼度スコア（Softmax最大値）とキャリブレーション

- **定義**
  - `S_conf = max(softmax(z))`（z はロジットベクトル）。
  - エッジでは追加計算コストがゼロに近く、**最安の不確実性代理指標**として広く利用。

- **エッジでの具体的利用パターン**
  - **適応的認識 / サンプリング制御**
    - ウェアラブルの行動認識や端末内HARで、連続フレームの `S_conf` を監視。
    - 例: `S_conf > 0.85` が一定時間続く場合 → 推論が安定したとみなし、
      - センササンプリングレート↓（例: 50 Hz → 10–20 Hz）
      - 通信周期↑（例: 100 ms → 500–2000 ms）
    - `S_conf` が揺らぐ区間（過渡期）は、逆にサンプリング・通信頻度を一時的に増やす。
  - **早期終了（Early Exit）**
    - BranchyNet系の多出口CNNや Cloud-Edge協調LLMでは、中間層ごとの `S_conf` を監視。
    - `S_conf ≥ τ_exit`（例: 0.9）なら中間出口で推論を打ち切って結果を採用。
    - `S_conf < τ_exit` の場合のみ、より深い層 or クラウドにフォワード。
    - これにより、**平均演算量と送信頻度を同時に削減**。

- **問題点と対策**
  - Softmax は**過信（overconfidence）しやすい**ため、そのまま通信制御の閾値に使うと危険。
  - エッジ向け研究では、以下のような軽量キャリブレーションが実装されている。
    - **温度スケーリング（Temperature Scaling）**
      - 追加パラメータ T（スカラー）を導入し、`softmax(z/T)` で後処理。
      - バリデーション上の NLL/ECE を最小にする T を1次元探索で決定。
    - **Platt Scaling / 平滑化**
      - 出力の上側（0.5–1.0）に集中する確率を圧縮し、実際の正解率との整合を向上。
  - これらの処理により、**「S_conf > 0.9」なら実際の精度も ≈90%** 程度になるよう整えてから、送信制御に用いる。

---

## 1.2 情報エントロピーと優先度スケジューリング

- **定義**
  - `H = - Σ p_i log p_i`（p_i はクラス確率）。
  - 分布が平坦（迷っている）ほど H が高く、**モデルの迷いを直接表現**。

- **通信制御への具体的利用**
  - **トラフィック異常検知系**
    - IoTゲートウェイが、センサの通信パターン（ポート/パケットサイズ/周期）の分布から H を算出。
    - 通常時: H が低く安定 → ログ送信を抑制（定期サマリのみ）。
    - 異常時: H が急上昇（予測不能な通信パターン） → 詳細ログやパケットダンプを集中送信。
  - **UAV支援データ収集**
    - 多数の地上センサに対し、「AoI（Age of Information）」と「エントロピー」を組み合わせて優先度を算出。
    - `priority ∝ H × f(AoI)` とし、
      - H が低く変化の少ないノードは巡回頻度↓、
      - H が高く、かつ AoI が大きいノードを優先的に訪問・データ回収。
    - 結果として、限られた飛行時間の中で **「情報価値の高いノード」からの取得率を最大化**。

- **特徴**
  - Softmax最大値と異なり、**「どの程度迷っているか」** を多クラスで扱えるため、
    - 未知クラス検知、緩やかな変化検知、優先度制御に向いている。

---

## 1.3 ワンパス不確実性推定（Single-Pass Uncertainty）

- **従来手法の問題**
  - MC-Dropout やベイジアンNNによる不確実性推定は、
    - 同じ入力に対して **数十回の推論** を実行して分散を推定。
    - レイテンシ・消費電力ともに **O(N_samples)** で増大 → バッテリ駆動エッジには不適。

- **ワンパス系の解法（代表例）**
  - モデル側の正則化・構造変更により、
    - **1回のフォワードパスだけで「予測値＋不確実性」の両方を出力**する。
  - 典型的な構成要素:
    - **スペクトル正規化（Spectral Normalization）** による重みの制御。
    - **層ごとの分布近似**（例えば、最終層でガウス分布の平均・分散を直接出力）。
    - 損失関数に、**不確実性に基づくペナルティ項**を組み込む。

- **実験結果（Jetson Nano / TX2 等）**
  - 推論ごとに「予測＋分散」を得て、その分散を基準に
    - 送信/破棄/クラウドオフロードを判定。
  - ベースライン（MC-Dropout等）と比較して:
    - **エネルギー消費が最大 ≈28倍削減**。
    - レイテンシは、通常の推論＋行列演算数回増の範囲に収まる（実時間制御可能）。

---

## 1.4 偶然的不確実性（Aleatoric）と認識的不確実性（Epistemic）の分離

- **目的**
  - 「不確実だから送信する」のではなく、
    - **ノイズ起因の不確実性（Aleatoric）**：再サンプリングやローカル処理で対処すべき。
    - **知識不足起因の不確実性（Epistemic）**：クラウドや人間による再評価が必要。
  - この区別により、**不要なクラウド送信を抑えつつ、本当に重要なケースだけオフロード**できる。

- **オンデバイスでの扱い**
  - モデル側で「予測の分散」を
    - 観測ノイズに対応する成分（出力ヘッド側の分散）、
    - モデル不確実性に対応する成分（パラメタ分布由来）、
    に分解する設計が提案されている。
  - 制御ロジック例:
    - Aleatoric が支配的 → **同じセンサからの追加サンプル収集**を優先（送信は控える）。
    - Epistemic が支配的 → **生データ送信 or 高精度モデルへのオフロード**を優先。

---

# 2. 動的送信制御メカニズム

## 2.1 ファジィ論理制御（Fuzzy Logic Controller, FLC）によるBLEパラメータ制御

- **入力・出力変数**
  - 入力（例）:
    - 不確実性: {Low, Medium, High}（Softmax/Entropy由来）。
    - バッテリ残量: {Critical, Normal, Full}。
    - RSSI（リンク品質）: {Weak, Strong}。
  - 出力:
    - BLE接続間隔: {Short (≈7.5 ms), Medium, Long (≈4 s)}。
    - 送信電力: {Min（-20 dBm）, …, Max（+20 dBm）}。

- **ルール例**
  - `IF Uncertainty is High AND Battery is Normal THEN Interval is Short AND TxPower is Max`
    - 高不確実＋バッテリ余裕 → 確度を優先して高頻度・高出力で送信。
  - `IF Uncertainty is Low AND Battery is Low THEN Interval is Long AND TxPower is Min`
    - 推論は安定＋バッテリ低 → ハートビートのみ、電力極小で維持。

- **パラメタ最適化（PSO利用）**
  - メンバーシップ関数の形状（どこから High とみなすか等）を
    - 粒子群最適化（PSO）で自動調整。
  - 目的関数例:
    - **バッテリ寿命最大化**（平均電流 or mWh/日）。
    - かつ **QoS指標（到達率/正解率）≥95%** を制約として課す。

- **報告されている効果（ウェアラブルBLEデバイスなど）**
  - 静的設定と比較して、
    - 消費電力 **25–45%削減**。
    - 到達率（QoS）は **95%以上** を維持。
    - 「正常・高信頼」期間は実質的な Radio-on duty を **1%未満** に抑制。

---

## 2.2 Restless Multi-Armed Bandit（RMAB）とゲイン・インデックス

- **問題設定**
  - 多数のセンサノードが 1 つのゲートウェイ/UAV を共有する状況。
  - 各ノードは時間とともに
    - **情報の古さ（AoI）**、
    - **不確実性（Entropy など）**
    が変化し続ける。
  - 同時に通信できるノード数には上限がある（帯域制約）。

- **RMAB定式化とポリシー**
  - 各ノード n に対し、状態 s_n（AoI, 不確実性など）から「ゲイン・インデックス g_n」を計算。
  - スケジューラは、各ラウンドで **g_n が大きい順に上位 M ノードを選択**して送信権を与える。
  - g_n は「そのノードからデータを受け取ることで削減できるシステム損失（不確実性＋情報陳腐化）」を表す。

- **特徴と結果**
  - 単純な AoI ベース（古いデータ優先）に比べて、
    - **変化が激しく（高エントロピー）かつ情報が古いノード**を優先するため、
    - 閾値ベースでは難しい「監視すべき対象」に自動的にリソースを集中できる。
  - 代表的な研究では、
    - AoI単独最小化よりも **平均システム損失（L-条件付き交差エントロピーベース）を有意に低減**。

---

## 2.3 早期終了と適応的オフローディング

- **多出口DNN / BranchyNet系**
  - 中間層出口での `S_conf` または `H` を用いて、
    - 高信頼なら**浅い層で打ち切り**（計算＋通信コストを削減）。
    - 低信頼なら深層まで計算 or クラウドオフロード。

- **Cloud-Edge協調LLM（例: 小型SLM + クラウドLLM）**
  - エッジ側の小型モデルがトークンを生成し、各トークンの信頼度を監視。
  - `S_conf ≥ τ` ならそのまま採用（クラウド送信なし）。
  - `S_conf < τ` が続く場合、**コンテキスト（隠れ状態）をクラウドにアップロード**し、大モデルに引き継ぎ。
  - 閾値 τ は、チャネル帯域やRTTに応じて動的調整される例もあり、
    - 通信が高コストな場合は τ を下げてエッジ完結を優先。
    - 通信が安価な場合は τ を上げてクラウド精度を優先。

---

# 3. BLEプロトコル上での実装詳細

## 3.1 Connection Parameter Update Request による接続間隔制御

- **標準メカニズム**
  - BLE接続中、Peripheral（エッジデバイス）は L2CAP の **Connection Parameter Update Request** を通じて、
    - `conn_interval_min/max`（例: 6=7.5 ms〜3200=4 s）、`slave_latency` 等の変更を要求可能。
  - 不確実性に応じた典型的な制御:
    - 高不確実 / 異常兆候 → `conn_interval ≈ 7.5–30 ms`、`slave_latency ≈ 0`。
    - 安定 / 低不確実 → `conn_interval ≈ 数百〜4000 ms`、`slave_latency` を増やし実質的なスリープを延長。

- **OSスタックの制約と回避策**
  - Android / iOS の BLE スタックは、
    - Peripheral からの更新要求を無視・制限する場合がある。
  - 代表的な回避策:
    - **Smart Duty Cycling**
      - 接続間隔自体は比較的短め（例: 30 ms）に固定。
      - 不確実性が低く送信不要なときは **Empty PDU** のみ送信（実データを抑制）。
    - **Slave Latency の活用**
      - 複数回のポーリングをスキップしても接続維持が許されるよう設定し、**平均Radio-on時間を削減**。

---

## 3.2 パケット単位の送信電力制御

- **メカニズム**
  - Nordic nRF52、ST BlueNRG 等のBLE SoC は、
    - API 経由で**パケット単位の TxPower 切替**をサポート。
  - 制御例:
    - 通常テレメトリ: `TxPower = -20 dBm`（低電力で到達性はそこそこ）。
    - 高リスク・高不確実なアラート: `TxPower = +4〜+20 dBm`（最大の到達率を確保）。

- **不確実性との連携**
  - 条件例:
    - `U高` かつ リスククラス=「転倒/心不全疑い」 → TxPower 最大。
    - `U低` かつ 状態=「安定/低リスク」 → TxPower 最小 or 送信スキップ。
  - 実験では、
    - 重要度クラスごとに TxPower と接続間隔を組み合わせることで、
    - **平均消費電力を削減しつつ、重大イベントの到達率はほぼ100%を維持**した報告がある。

---

# 4. リスク指標とセマンティック通信的アプローチ

## 4.1 L-条件付き交差エントロピーと「沈黙のコスト」

- **課題**
  - 単純な AoI（最後の更新からの経過時間）は、「何を見逃しているか」の重みを考慮しない。
  - エッジでは、「送信しないことによるリスク」を定量化する必要がある。

- **L-条件付き交差エントロピー H_L のアイデア**
  - 古い情報 `X_{t-δ}` に基づく推定 `Ŷ_t` が、真の状態 `Y_t` からどれだけズレているかを、
    - 損失関数 `L(Y_t, Ŷ_t)` で重み付けした期待値として定義。
  - 特徴:
    - **リスク非対称性**を表現できる。
      - 異常を見逃す False Negative は非常に大きな損失。
      - 誤警報 False Positive は相対的に小さな損失。

- **通信制御への利用**
  - ノードごとに H_L を評価し、
    - H_L が閾値を超えたときのみ送信（＝沈黙のコストが大きくなったタイミングで通信）。
  - RMABの **ゲイン・インデックス g_n** は、送信による H_L の減少量として定義される例もあり、
    - 「どのノードの沈黙を破るべきか」を理論的に決定できる。

---

## 4.2 セマンティック通信とエッジAI

- **セマンティックシンボル送信**
  - 生データではなく、エンコーダDNNが抽出した特徴ベクトル（意味的シンボル）を送信。
  - デコーダ側は多少のビット誤りがあっても文脈から復元できるため、
    - 再送を減らしつつ、**意味情報の正確性**を維持。

- **不確実性との連携**
  - 受信側デコーダの不確実性が高い場合のみ、
    - **追加のパリティ / 再送要求 / コンテキスト追加送信**を行うハイブリッドARQが提案されている。
  - これにより、
    - 「意味が曖昧になった場合だけ追加コストを払う」形の通信が実現可能。

---

# 5. 代表的ケーススタディ（結果のみ）

以下は、不確実性駆動制御がどの程度の効果を示したかを具体的に報告している代表的事例の要約である。

- **Case 1: モバイルエッジ学習（MEL）におけるタスク割当**
  - プラットフォーム: Jetson Nano 等のエッジGPUクラスタ。
  - 手法: デバイス能力の不確実性を考慮した MED (Minimum Expected Delay) スキーム。
  - 結果:
    - 学習完了時間を **最大 ≈11%短縮**。
    - データドロップ率（送信失敗・間に合わない通信）を **最大 ≈42%削減**。

- **Case 2: ウェアラブルデバイスのBLE電力最適化（FLC + PSO）**
  - プラットフォーム: 心拍モニタ等のBLEウェアラブル。
  - 手法:
    - 不確実性・バッテリ・RSSI を入力とするファジィ論理制御。
    - メンバーシップ関数を PSO で最適化。
  - 結果:
    - 静的なBLE設定と比較して、消費電力 **25–45%削減**。
    - QoS（到達率/有効サンプル率）を **95%以上** で維持。
    - 重要でない期間の **Radio-on duty を ≈1%未満** に抑制。

- **Case 3: 視覚オドメトリにおけるワンパス不確実性＋決定保留**
  - プラットフォーム: 自律移動ロボットのオンボードGPU。
  - 手法:
    - ワンパス不確実性推定により、位置推定が不確実なフレームのみクラウド or 人手へエスカレーション。
  - 結果:
    - ベースライン比で **エネルギー消費最大 ≈28倍削減**。
    - 位置推定精度は、クラウド協調運用により目標値を維持。

- **Case 4: LLMオフローディングにおける信頼度駆動コンテキストアップロード**
  - プラットフォーム: エッジ上の小型LLM + クラウドLLM。
  - 手法:
    - トークンごとの信頼度スコアが閾値を下回り始めた段階で、
      - **バックグラウンドで隠れ状態（コンテキスト）をクラウドに送信**。
      - 実際のオフロード時には既にコンテキストが同期済み → ユーザ体験の「寸断」を回避。
  - 結果:
    - オフロードのレイテンシをユーザが知覚しにくいレベルまで低減。
    - 通信量は、常時クラウド推論に対して大幅に削減（定量値は研究ごとに異なるが、おおむね数十%〜オーダー削減）。

---

本ノートは、ReFormHAR‑Tiny における **U/S/CCS→adv_interval 制御**や将来の **MAB/Safe‑MAB設計**に流用可能な要素（指標設計、制御ロジック、BLE実装、リスク指標）だけを抽出したものである。  
要件定義・設計書へ反映する場合は、ここから該当部分のみを引用し、フェーズごとの役割に応じて簡略化して用いる。
</file>

</files>
</file>

<file path="paper/TinyML制約付き学習_リサーチノート.md">
以下は、**TinyML環境（MCU）における制約付き強化学習／Multi‑armed Bandit実装**に関するリサーチノートです。  
イントロ的な一般論は省き、**MCU上で実際にどう実装するか／どこまでできているか**に関する深い部分だけを整理します。

---

# 1. TinyML向け学習の制約構造

- **二つの強い制約**
  - **ハードウェア制約**
    - RAM は数 KB〜数百 KB（例：STM32F103 20 KB, Nano 33 BLE 256 KB, Teensy 4.1 1 MB）。
    - Flash は 64 KB〜数 MB。コードと定数は置けるが、頻繁な書き換えには不向き。
    - 動的メモリ（`malloc/new`）は断片化リスクから避けるのが前提 → **静的配列／スタック確保が基本**。
    - FPU/DSP命令有無で実現可能なアルゴリズムが変わる（Cortex‑M3 と M4F/M7 の差は大きい）。
  - **安全・QoS制約**
    - LoRaWAN デューティサイクル、規制上限（1%）などを**絶対に越えられない**。
    - 医療系やインフラ監視では「試行錯誤の失敗」が人命・法令違反に直結 → 無制限探索不可。
- **結論として必要なアーキテクチャ**
  - 学習アルゴリズムそのものは「通常の」報酬最適化に徹し、
  - その外側に **軽量な Safety Filter（Action Masking / CBF など）** を置いてハード制約を担保する構造が現実解として採用されている。

---

# 2. MCU上の Multi‑armed Bandit / LinUCB 実装

## 2.1 単純 MAB（ε‑Greedy, UCB1）

- **特徴**
  - 必要状態は「各アームの平均報酬」「訪問回数」だけ → メモリ O(K)。
  - 8‑bit MCU でも実装可能（tabular Q‑learning と同程度）。
- **限界**
  - コンテキスト（SNR, バッテリ, 位置など）を考慮できないため、通信制御などの実用シナリオでは表現力不足。

---

## 2.2 線形コンテキストバンディット（LinUCB）

- **モデル**
  - 各アーム a の期待報酬：`E[r | x_a] = x_a^T θ*`（x_a∈ℝ^d）。
  - 推定量：`θ_hat = A^-1 b`  
    - `A = Σ x x^T + λI`、`b = Σ r x`。
  - UCB スコア：`score(a) = x_a^T θ_hat + α sqrt(x_a^T A^-1 x_a)`。

- **MCU上の最大のボトルネック**
  - d×d 行列 A とその逆行列 A^-1 を保持・更新する必要がある。
  - 朴素な逆行列計算は O(d^3) → 数十 MHz クラスMCUには重い。

---

## 2.3 Sherman–Morrison 公式による高速化

- **ランク1更新**
  - 新サンプル (x_t, r_t) に対し、`A_{t+1} = A_t + x_t x_t^T`。
  - Sherman‑Morrison により、

    ```text
    A_{t+1}^{-1}
      = A_t^{-1} - (A_t^{-1} x_t x_t^T A_t^{-1}) / (1 + x_t^T A_t^{-1} x_t)
    ```

  - 必要な計算は
    - ベクトル v = A_t^-1 x_t（O(d^2)）
    - スカラー s = 1 + x_t^T v（O(d)）
    - A^-1 のランク1更新（O(d^2)）
  - → **1ステップあたり O(d^2)** に削減（O(d^3)→O(d^2)）。

- **実装上の工夫（C/C++）**
  - 行列は `float A_inv[d*d]` の 1次元配列に格納（SIMD／キャッシュ友好）。
  - 中間ベクトル `v[d]` などはクラスメンバとして **静的確保**（ヒープ不使用）。
  - 対称性（A^-1 は対称）を活かした上三角のみの格納も理論上は可能だが、
    - index計算が複雑化し、SIMD化が難しくなるため、
    - 多くの実装では「フル行列＋SIMD」の方を採用。

- **報告されている性能**
  - Cortex‑M4（STM32 Nucleo）上の最適化版 LinUCB:
    - d=16 の場合、朴素版 ≈ 5 ms/step → Woodbury＋SIMD で ≈ 0.3 ms/step に短縮（約1/15）。
  - RAM 使用量は d=16, K≲30 の設定で **1 KBオーダー** に収まる。

---

## 2.4 プラットフォーム適合性（抜粋）

- **20 KB RAM級（STM32F103など）**
  - 可能：Tabular Q‑learning, ε‑Greedy/UCB1, **ごく小さい d（≤4）** の LinUCB。
  - 限界：d が少し増えると A/A^-1 で RAM を使い切る。
- **256 KB RAM級（Arduino Nano 33 BLE, Cortex‑M4F）**
  - 可能：d≲16 の LinUCB、軽量 DNN を用いた Deep RL（小規模）。
  - FPU + DSP 命令あり → CMSIS‑DSP で行列演算高速化。
- **1 MB RAM級（Teensy 4.1, Cortex‑M7）**
  - 可能：d≳32 の LinUCB、PPO/SAC 等の Deep RL 学習も（RLtools 利用前提）。
- **ESP32**
  - RAM ≈ 520 KB、Flash ≈ 4 MB。
  - Wi‑Fi/BLE 内蔵のため、**Federated Learning や Multi‑agent Bandit** の通信基盤として有利。

---

# 3. 安全性制約の実装メカニズム

## 3.1 アクションマスキング（Validity Masking）

- **考え方**
  - 状態 s_t で「絶対に取ってはいけない行動 a」を、
    - 学習アルゴリズムの**外側で**除外し、
    - バンディット／RL側には「選べるアーム集合 A_valid」だけを渡す。
  - → 学習中も**ハード制約を破らない**。

- **LoRaWAN デューティサイクル例**
  - 制約：サブギガ帯で **Duty ≤ 1%**。
  - 各アーム a = (SF, TxPower) について、Time‑on‑Air `T_air(a)` を LoRaWAN 仕様から算出。
  - 直近履歴から「累積 ToA」と「回復までの残り」を計算し、
    - `current_ToA + T_air(a) > budget` なら a を INVALID に設定。
  - LinUCB/UCB1/Thompson 等は、A_valid からのみアクションを選ぶ。
  - 数理的には「Volatile Bandit（可用アーム集合が時間変動）」として扱われる。

---

## 3.2 Control Barrier Functions（CBF）の簡略フィルタ

- **用途**
  - 慣性のある系（ロボット・ドローン等）で、**「その行動を選んだ瞬間はOKだが、その後のダイナミクスで衝突する」**ケースを防ぐ。
- **理論（概念レベル）**
  - 安全集合 h(x)≥0 に対し、

    ```text
    d/dt h(x) + α h(x) ≥ 0 を満たす u のみ許容
    ```

- **MCU向け簡略実装**
  - バリア条件をそのままQPで解くのではなく、
    - 状態 x と提案行動 u_nominal に対して「危険かどうか」を安価に判定し、
    - 危険なら `u_safe` に置き換える**関数として実装**する。
  - C++イメージ:

    ```cpp
    float safety_filter(float u_nominal, const State& x) {
        if (is_violation_likely(x, u_nominal)) {
            return calculate_safe_u(x); // 速度/位置制限など
        }
        return u_nominal;
    }
    ```

  - 学習アルゴリズムは、この `u_safe` とその結果の報酬を観測するため、
    - 結果的に「安全領域内での最適方策」を学ぶことになる。

---

# 4. ケーススタディ：LoRaWAN ADR用 LinUCB（制約付き）

## 4.1 問題設定

- **目的**
  - LoRaWAN エンドデバイスで、
    - PDR を維持しつつ、
    - 消費エネルギー（送信電力＋ToA）を最小化。
- **変数**
  - コンテキスト x_t（例）:
    - 直近 N 回の SNR の平均／分散。
    - 直近の成功/失敗フラグ。
    - バッテリ残量。
  - アーム a:
    - SF ∈ {7,…,12} × TxPower ∈ {2,…,14 dBm} → K≈30。
  - 報酬 r_t（例）:

    ```text
    r_t = α * (PDR_t / PDR_target) - (1-α) * (Energy_t / Energy_max)
    ```

- **制約**
  - 法定 Duty ≤ 1% → **Action Masking** で保証。

---

## 4.2 MCU実装

- **ターゲット**
  - STM32L0 クラス（RAM ≈ 20 KB, 超低消費電力）。
- **状態保持**
  - d=4 とすると、
    - A_inv: 4×4 float = 64 bytes。
    - θ: 4 float = 16 bytes。
    - 各アームの平均報酬・選択回数：数百バイト。
  - 全体で **1 KB 未満** に収まる構成が可能。

- **動作イメージ**
  - 各送信結果ごとに LinUCB 更新（Sherman‑Morrison）。
  - 次の送信タイミングで、Action Masking されたアーム集合から UCB 最大のアームを選択。

- **報告されている効果**
  - シミュレーション／実機評価では、
    - 標準 ADR と比較して、**エネルギー効率 15–30% 改善**。
    - PDR は同等か、それ以上を維持。
  - 混雑環境でも「SF 上げすぎによるネットワーク崩壊」を避けられるケースが報告されている。

---

# 5. ケーススタディ：ECG サンプリングレート制御（TinyRL）

## 5.1 問題設定

- **用途**
  - 不整脈検知用 ECG ウェアラブル。
  - 常時 500 Hz サンプリングはバッテリ的に非現実的。
- **目的**
  - 不整脈検知精度 ≈99% を維持しつつ、
  - 平均消費電力をできるだけ下げる。

---

## 5.2 RLtools を用いた DQN Lite

- **構成**
  - MCU: Arduino Nano 33 BLE (Cortex‑M4F, 256 KB RAM)。
  - 特徴量: R‑R 間隔、QRS 幅などの軽量特徴から状態ベクトル s_t（4次元程度）を作成。
  - アクション:
    - {低レート, 中レート, 高レート} = {125 Hz, 250 Hz, 500 Hz}。
  - Policy/Qネットワーク（RLtools）:
    - 4 → 16 → 3 の全結合ネットワーク（ReLU）。
    - パラメータ数 = (4×16+16) + (16×3+3) = 131。
    - 単精度 float でも重みだけで ≈524 バイト + 中間バッファ含めても数 KB 程度。

- **学習の運用パターン**
  - 日中: 推論のみ（学習オフ）、報酬候補となるイベントをログに蓄積。
  - 夜間充電中 or 定期タイミング: ログを用いてバッチ学習（オンデバイス）／または Replay Buffer を用いたオンライン学習。
  - RLtools により、同じ C++ コードを PC シミュレータ＋MCU の両方で実行できるため、
    - まず PC 上でハイパラを詰めてから MCU に移植、というワークフローが取られている。

- **報告されている効果**
  - 常時 500 Hz サンプリングと比較して、
    - 不整脈検知精度 ≈99% を維持しつつ、
    - **平均消費電力 ≈1/7** まで削減。
  - 直前数十秒の HRV や `S_conf` の揺らぎが大きくなると高レートを選び、
    - 安定期は低レートに落とすポリシーを自律的に獲得。

---

# 6. 実装ベストプラクティス（TinyML学習用）

- **静的割り当ての徹底**
  - `std::vector`, `std::map` は基本的に使わない。
  - RLtools / ETL などの静的コンテナ、もしくは生配列を用いてヒープをゼロにする。
  - リンカの `.map` を確認し、`.bss/.data` サイズとスタックマージンを常に把握する。

- **PCシミュレーション→MCU移植**
  - 同じ C++ コードを
    - PC（Linux/macOS）でシミュレーション（OpenAI Gym 等）、
    - その後クロスコンパイルして MCU 上で動かす、
  - という 2段階開発が、TinyRL では実用的に採用されている。

- **数値精度と FPU の扱い**
  - FPUなし（Cortex‑M3 等）では float はソフトウェア実装 → 可能なら M4F 以上を使う。
  - LinUCB の A^-1 更新など、数値安定性が重要な部分は float（単精度）が最低ライン。
  - 固定小数点化は可能だが、実装・検証コストが高いため、まずは FPU 付きMCU＋float が現実解。

---

本ノートは、TinyML 環境において **「どの程度までバンディット/RLが現実的か」** を判断するための材料として、実装レベルの情報と具体的な削減効果のみを抜き出している。  
フェーズ2以降の MAB/Safe‑MAB 設計時には、ここに挙げた LinUCB 最適化・Action Masking・簡易CBF・RLtools のパターンを必要に応じて流用する。
</file>

<file path="paper/不確実性駆動送信制御_リサーチノート.md">
以下は、**エッジデバイスにおける不確実性認識型・信頼度駆動型データ送信制御**に関する2021–2025年の主要研究を、**具体的なメカニズム・メトリクス・プロトコル実装・実験結果**に絞って整理したリサーチノートです。  
一般的なサマリーやパラダイム転換の議論は省き、実装上有用な「深い部分」のみを記録します。

---

# 1. 不確実性指標とオンデバイス実装

## 1.1 信頼度スコア（Softmax最大値）とキャリブレーション

- **定義**
  - `S_conf = max(softmax(z))`（z はロジットベクトル）。
  - エッジでは追加計算コストがゼロに近く、**最安の不確実性代理指標**として広く利用。

- **エッジでの具体的利用パターン**
  - **適応的認識 / サンプリング制御**
    - ウェアラブルの行動認識や端末内HARで、連続フレームの `S_conf` を監視。
    - 例: `S_conf > 0.85` が一定時間続く場合 → 推論が安定したとみなし、
      - センササンプリングレート↓（例: 50 Hz → 10–20 Hz）
      - 通信周期↑（例: 100 ms → 500–2000 ms）
    - `S_conf` が揺らぐ区間（過渡期）は、逆にサンプリング・通信頻度を一時的に増やす。
  - **早期終了（Early Exit）**
    - BranchyNet系の多出口CNNや Cloud-Edge協調LLMでは、中間層ごとの `S_conf` を監視。
    - `S_conf ≥ τ_exit`（例: 0.9）なら中間出口で推論を打ち切って結果を採用。
    - `S_conf < τ_exit` の場合のみ、より深い層 or クラウドにフォワード。
    - これにより、**平均演算量と送信頻度を同時に削減**。

- **問題点と対策**
  - Softmax は**過信（overconfidence）しやすい**ため、そのまま通信制御の閾値に使うと危険。
  - エッジ向け研究では、以下のような軽量キャリブレーションが実装されている。
    - **温度スケーリング（Temperature Scaling）**
      - 追加パラメータ T（スカラー）を導入し、`softmax(z/T)` で後処理。
      - バリデーション上の NLL/ECE を最小にする T を1次元探索で決定。
    - **Platt Scaling / 平滑化**
      - 出力の上側（0.5–1.0）に集中する確率を圧縮し、実際の正解率との整合を向上。
  - これらの処理により、**「S_conf > 0.9」なら実際の精度も ≈90%** 程度になるよう整えてから、送信制御に用いる。

---

## 1.2 情報エントロピーと優先度スケジューリング

- **定義**
  - `H = - Σ p_i log p_i`（p_i はクラス確率）。
  - 分布が平坦（迷っている）ほど H が高く、**モデルの迷いを直接表現**。

- **通信制御への具体的利用**
  - **トラフィック異常検知系**
    - IoTゲートウェイが、センサの通信パターン（ポート/パケットサイズ/周期）の分布から H を算出。
    - 通常時: H が低く安定 → ログ送信を抑制（定期サマリのみ）。
    - 異常時: H が急上昇（予測不能な通信パターン） → 詳細ログやパケットダンプを集中送信。
  - **UAV支援データ収集**
    - 多数の地上センサに対し、「AoI（Age of Information）」と「エントロピー」を組み合わせて優先度を算出。
    - `priority ∝ H × f(AoI)` とし、
      - H が低く変化の少ないノードは巡回頻度↓、
      - H が高く、かつ AoI が大きいノードを優先的に訪問・データ回収。
    - 結果として、限られた飛行時間の中で **「情報価値の高いノード」からの取得率を最大化**。

- **特徴**
  - Softmax最大値と異なり、**「どの程度迷っているか」** を多クラスで扱えるため、
    - 未知クラス検知、緩やかな変化検知、優先度制御に向いている。

---

## 1.3 ワンパス不確実性推定（Single-Pass Uncertainty）

- **従来手法の問題**
  - MC-Dropout やベイジアンNNによる不確実性推定は、
    - 同じ入力に対して **数十回の推論** を実行して分散を推定。
    - レイテンシ・消費電力ともに **O(N_samples)** で増大 → バッテリ駆動エッジには不適。

- **ワンパス系の解法（代表例）**
  - モデル側の正則化・構造変更により、
    - **1回のフォワードパスだけで「予測値＋不確実性」の両方を出力**する。
  - 典型的な構成要素:
    - **スペクトル正規化（Spectral Normalization）** による重みの制御。
    - **層ごとの分布近似**（例えば、最終層でガウス分布の平均・分散を直接出力）。
    - 損失関数に、**不確実性に基づくペナルティ項**を組み込む。

- **実験結果（Jetson Nano / TX2 等）**
  - 推論ごとに「予測＋分散」を得て、その分散を基準に
    - 送信/破棄/クラウドオフロードを判定。
  - ベースライン（MC-Dropout等）と比較して:
    - **エネルギー消費が最大 ≈28倍削減**。
    - レイテンシは、通常の推論＋行列演算数回増の範囲に収まる（実時間制御可能）。

---

## 1.4 偶然的不確実性（Aleatoric）と認識的不確実性（Epistemic）の分離

- **目的**
  - 「不確実だから送信する」のではなく、
    - **ノイズ起因の不確実性（Aleatoric）**：再サンプリングやローカル処理で対処すべき。
    - **知識不足起因の不確実性（Epistemic）**：クラウドや人間による再評価が必要。
  - この区別により、**不要なクラウド送信を抑えつつ、本当に重要なケースだけオフロード**できる。

- **オンデバイスでの扱い**
  - モデル側で「予測の分散」を
    - 観測ノイズに対応する成分（出力ヘッド側の分散）、
    - モデル不確実性に対応する成分（パラメタ分布由来）、
    に分解する設計が提案されている。
  - 制御ロジック例:
    - Aleatoric が支配的 → **同じセンサからの追加サンプル収集**を優先（送信は控える）。
    - Epistemic が支配的 → **生データ送信 or 高精度モデルへのオフロード**を優先。

---

# 2. 動的送信制御メカニズム

## 2.1 ファジィ論理制御（Fuzzy Logic Controller, FLC）によるBLEパラメータ制御

- **入力・出力変数**
  - 入力（例）:
    - 不確実性: {Low, Medium, High}（Softmax/Entropy由来）。
    - バッテリ残量: {Critical, Normal, Full}。
    - RSSI（リンク品質）: {Weak, Strong}。
  - 出力:
    - BLE接続間隔: {Short (≈7.5 ms), Medium, Long (≈4 s)}。
    - 送信電力: {Min（-20 dBm）, …, Max（+20 dBm）}。

- **ルール例**
  - `IF Uncertainty is High AND Battery is Normal THEN Interval is Short AND TxPower is Max`
    - 高不確実＋バッテリ余裕 → 確度を優先して高頻度・高出力で送信。
  - `IF Uncertainty is Low AND Battery is Low THEN Interval is Long AND TxPower is Min`
    - 推論は安定＋バッテリ低 → ハートビートのみ、電力極小で維持。

- **パラメタ最適化（PSO利用）**
  - メンバーシップ関数の形状（どこから High とみなすか等）を
    - 粒子群最適化（PSO）で自動調整。
  - 目的関数例:
    - **バッテリ寿命最大化**（平均電流 or mWh/日）。
    - かつ **QoS指標（到達率/正解率）≥95%** を制約として課す。

- **報告されている効果（ウェアラブルBLEデバイスなど）**
  - 静的設定と比較して、
    - 消費電力 **25–45%削減**。
    - 到達率（QoS）は **95%以上** を維持。
    - 「正常・高信頼」期間は実質的な Radio-on duty を **1%未満** に抑制。

---

## 2.2 Restless Multi-Armed Bandit（RMAB）とゲイン・インデックス

- **問題設定**
  - 多数のセンサノードが 1 つのゲートウェイ/UAV を共有する状況。
  - 各ノードは時間とともに
    - **情報の古さ（AoI）**、
    - **不確実性（Entropy など）**
    が変化し続ける。
  - 同時に通信できるノード数には上限がある（帯域制約）。

- **RMAB定式化とポリシー**
  - 各ノード n に対し、状態 s_n（AoI, 不確実性など）から「ゲイン・インデックス g_n」を計算。
  - スケジューラは、各ラウンドで **g_n が大きい順に上位 M ノードを選択**して送信権を与える。
  - g_n は「そのノードからデータを受け取ることで削減できるシステム損失（不確実性＋情報陳腐化）」を表す。

- **特徴と結果**
  - 単純な AoI ベース（古いデータ優先）に比べて、
    - **変化が激しく（高エントロピー）かつ情報が古いノード**を優先するため、
    - 閾値ベースでは難しい「監視すべき対象」に自動的にリソースを集中できる。
  - 代表的な研究では、
    - AoI単独最小化よりも **平均システム損失（L-条件付き交差エントロピーベース）を有意に低減**。

---

## 2.3 早期終了と適応的オフローディング

- **多出口DNN / BranchyNet系**
  - 中間層出口での `S_conf` または `H` を用いて、
    - 高信頼なら**浅い層で打ち切り**（計算＋通信コストを削減）。
    - 低信頼なら深層まで計算 or クラウドオフロード。

- **Cloud-Edge協調LLM（例: 小型SLM + クラウドLLM）**
  - エッジ側の小型モデルがトークンを生成し、各トークンの信頼度を監視。
  - `S_conf ≥ τ` ならそのまま採用（クラウド送信なし）。
  - `S_conf < τ` が続く場合、**コンテキスト（隠れ状態）をクラウドにアップロード**し、大モデルに引き継ぎ。
  - 閾値 τ は、チャネル帯域やRTTに応じて動的調整される例もあり、
    - 通信が高コストな場合は τ を下げてエッジ完結を優先。
    - 通信が安価な場合は τ を上げてクラウド精度を優先。

---

# 3. BLEプロトコル上での実装詳細

## 3.1 Connection Parameter Update Request による接続間隔制御

- **標準メカニズム**
  - BLE接続中、Peripheral（エッジデバイス）は L2CAP の **Connection Parameter Update Request** を通じて、
    - `conn_interval_min/max`（例: 6=7.5 ms〜3200=4 s）、`slave_latency` 等の変更を要求可能。
  - 不確実性に応じた典型的な制御:
    - 高不確実 / 異常兆候 → `conn_interval ≈ 7.5–30 ms`、`slave_latency ≈ 0`。
    - 安定 / 低不確実 → `conn_interval ≈ 数百〜4000 ms`、`slave_latency` を増やし実質的なスリープを延長。

- **OSスタックの制約と回避策**
  - Android / iOS の BLE スタックは、
    - Peripheral からの更新要求を無視・制限する場合がある。
  - 代表的な回避策:
    - **Smart Duty Cycling**
      - 接続間隔自体は比較的短め（例: 30 ms）に固定。
      - 不確実性が低く送信不要なときは **Empty PDU** のみ送信（実データを抑制）。
    - **Slave Latency の活用**
      - 複数回のポーリングをスキップしても接続維持が許されるよう設定し、**平均Radio-on時間を削減**。

---

## 3.2 パケット単位の送信電力制御

- **メカニズム**
  - Nordic nRF52、ST BlueNRG 等のBLE SoC は、
    - API 経由で**パケット単位の TxPower 切替**をサポート。
  - 制御例:
    - 通常テレメトリ: `TxPower = -20 dBm`（低電力で到達性はそこそこ）。
    - 高リスク・高不確実なアラート: `TxPower = +4〜+20 dBm`（最大の到達率を確保）。

- **不確実性との連携**
  - 条件例:
    - `U高` かつ リスククラス=「転倒/心不全疑い」 → TxPower 最大。
    - `U低` かつ 状態=「安定/低リスク」 → TxPower 最小 or 送信スキップ。
  - 実験では、
    - 重要度クラスごとに TxPower と接続間隔を組み合わせることで、
    - **平均消費電力を削減しつつ、重大イベントの到達率はほぼ100%を維持**した報告がある。

---

# 4. リスク指標とセマンティック通信的アプローチ

## 4.1 L-条件付き交差エントロピーと「沈黙のコスト」

- **課題**
  - 単純な AoI（最後の更新からの経過時間）は、「何を見逃しているか」の重みを考慮しない。
  - エッジでは、「送信しないことによるリスク」を定量化する必要がある。

- **L-条件付き交差エントロピー H_L のアイデア**
  - 古い情報 `X_{t-δ}` に基づく推定 `Ŷ_t` が、真の状態 `Y_t` からどれだけズレているかを、
    - 損失関数 `L(Y_t, Ŷ_t)` で重み付けした期待値として定義。
  - 特徴:
    - **リスク非対称性**を表現できる。
      - 異常を見逃す False Negative は非常に大きな損失。
      - 誤警報 False Positive は相対的に小さな損失。

- **通信制御への利用**
  - ノードごとに H_L を評価し、
    - H_L が閾値を超えたときのみ送信（＝沈黙のコストが大きくなったタイミングで通信）。
  - RMABの **ゲイン・インデックス g_n** は、送信による H_L の減少量として定義される例もあり、
    - 「どのノードの沈黙を破るべきか」を理論的に決定できる。

---

## 4.2 セマンティック通信とエッジAI

- **セマンティックシンボル送信**
  - 生データではなく、エンコーダDNNが抽出した特徴ベクトル（意味的シンボル）を送信。
  - デコーダ側は多少のビット誤りがあっても文脈から復元できるため、
    - 再送を減らしつつ、**意味情報の正確性**を維持。

- **不確実性との連携**
  - 受信側デコーダの不確実性が高い場合のみ、
    - **追加のパリティ / 再送要求 / コンテキスト追加送信**を行うハイブリッドARQが提案されている。
  - これにより、
    - 「意味が曖昧になった場合だけ追加コストを払う」形の通信が実現可能。

---

# 5. 代表的ケーススタディ（結果のみ）

以下は、不確実性駆動制御がどの程度の効果を示したかを具体的に報告している代表的事例の要約である。

- **Case 1: モバイルエッジ学習（MEL）におけるタスク割当**
  - プラットフォーム: Jetson Nano 等のエッジGPUクラスタ。
  - 手法: デバイス能力の不確実性を考慮した MED (Minimum Expected Delay) スキーム。
  - 結果:
    - 学習完了時間を **最大 ≈11%短縮**。
    - データドロップ率（送信失敗・間に合わない通信）を **最大 ≈42%削減**。

- **Case 2: ウェアラブルデバイスのBLE電力最適化（FLC + PSO）**
  - プラットフォーム: 心拍モニタ等のBLEウェアラブル。
  - 手法:
    - 不確実性・バッテリ・RSSI を入力とするファジィ論理制御。
    - メンバーシップ関数を PSO で最適化。
  - 結果:
    - 静的なBLE設定と比較して、消費電力 **25–45%削減**。
    - QoS（到達率/有効サンプル率）を **95%以上** で維持。
    - 重要でない期間の **Radio-on duty を ≈1%未満** に抑制。

- **Case 3: 視覚オドメトリにおけるワンパス不確実性＋決定保留**
  - プラットフォーム: 自律移動ロボットのオンボードGPU。
  - 手法:
    - ワンパス不確実性推定により、位置推定が不確実なフレームのみクラウド or 人手へエスカレーション。
  - 結果:
    - ベースライン比で **エネルギー消費最大 ≈28倍削減**。
    - 位置推定精度は、クラウド協調運用により目標値を維持。

- **Case 4: LLMオフローディングにおける信頼度駆動コンテキストアップロード**
  - プラットフォーム: エッジ上の小型LLM + クラウドLLM。
  - 手法:
    - トークンごとの信頼度スコアが閾値を下回り始めた段階で、
      - **バックグラウンドで隠れ状態（コンテキスト）をクラウドに送信**。
      - 実際のオフロード時には既にコンテキストが同期済み → ユーザ体験の「寸断」を回避。
  - 結果:
    - オフロードのレイテンシをユーザが知覚しにくいレベルまで低減。
    - 通信量は、常時クラウド推論に対して大幅に削減（定量値は研究ごとに異なるが、おおむね数十%〜オーダー削減）。

---

本ノートは、ReFormHAR‑Tiny における **U/S/CCS→adv_interval 制御**や将来の **MAB/Safe‑MAB設計**に流用可能な要素（指標設計、制御ロジック、BLE実装、リスク指標）だけを抽出したものである。  
要件定義・設計書へ反映する場合は、ここから該当部分のみを引用し、フェーズごとの役割に応じて簡略化して用いる。
</file>

<file path="トラブルシューティング/BLE省電力計測健全化_統合タイムライン.md">
# BLE省電力計測システム健全化_統合タイムライン

- 作成日: 2025-11-19
- 目的: BLE省電力実験における **計測系の不具合解消〜評価指標確立〜コード差分の整理** までを、時系列で一望できる形にまとめる。
- 関連ドキュメント:
  - `docs/トラブルシューティング/OFF高消費電力_トラブルシューティング.md`
  - `docs/フェーズ0-0/実験ログ_E2_1m_2025-11-09.md`
  - `docs/フェーズ0-0/技術トピック_電力計測健全化.md`

---

## 1. 【発端】「OFFの方が電流が高い」異常の検知

- **現象**:
  - 広告OFF（ベースライン）の平均電流が **約59 mA**、広告ON時が **約10 mA** となり、物理的矛盾が発生。
  - 代表例: `data/実験データ/研究室/1m_off_02/`（OFF_02）で `mean_i ≈ 59 mA`, `rate_hz ≈ 150.8 Hz`, `parse_drop ≈ 1.1e4`。
- **原因特定**:
  - INA219や配線ではなく、**PowerLogger（受信側）の処理能力不足**に起因。
  - SDカード書き込みと浮動小数点演算（`printf`/`sscanf`）が重く、計測ループが遅延。
  - その結果として、
    - データ欠落（`parse_drop > 10,000`）
    - 実効レート低下（設計 500 Hz → 実測 100〜150 Hz）
    が起き、エネルギー積分 `E_total` が正しく計算できていなかった。

※ 本フェーズの詳細は `docs/トラブルシューティング/OFF高消費電力_トラブルシューティング.md` を参照。

---

## 2. 【修正フェーズ1】計測システムの構造改革（パススルー化）

- **実施内容**:
  - PowerLogger を **パススルー＋塊書き込み**構成に変更（`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）。
  - 主な変更点:
    - オンボードでの `sscanf` や複雑な浮動小数点計算を停止。
    - UART受信データを大きなバッファに貯め、**16 KB チャンク単位**で SD へ書き込み。
    - エネルギー積分は「整数mv, µA → p_mW → E_mJ」を軽量に処理。
- **成果**:
  - `parse_drop = 0`（欠損なし）を達成。
  - 実効サンプリングレートが設計値近傍（ON時 ≈500 Hz, OFF時 ≈100 Hz）へ回復。
  - 「測定系として成立していない」状態からの脱出に成功。

---

## 3. 【修正フェーズ2】単位換算バグの発見と修正

- **発覚**:
  - CSV解析中、電力列 `p_mW` の桁が不自然であることに気づく。
- **原因**:
  - 整数化対応（mV, µA）に伴う計算式更新時のミス。
  - 誤実装: `p_mW = (mv * uA) / 1000.0`
  - 正式な定義: `p_mW = (mv * uA) / 1000000.0`（mV×µA → mW なので 1000×1000 で割る）
- **対応**:
  - PowerLogger 側（`TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）の式を `/1e6` に修正（P0案件）。
  - 過去ログはオフライン解析時に修正後の式で再計算することで、再測定なしに正しい値へ復元。

---

## 4. 【戦略策定】評価指標（KPI）の再定義

- **課題**:
  - 測定系（ESP32 + INA219 + UART/SD）のベース消費が **約59 mA** と高く、単純な「平均電流[mA]」だけでは無線部分のコストが見えにくい。
- **決定事項**:
  - 主要KPIとして、**「イベントあたりのエネルギー増加分（ΔE/adv）」** を採用。
  - 定義:

    ```text
    ΔE/adv = (E_ON − E_OFF) / N_adv
    ```

- **効果**:
  - 測定系の定常負荷（CPU/I2C/UARTなど）を相殺しつつ、**「無線1回あたりの純粋なコスト」** を評価できる。
  - フェーズ0-0およびフェーズ1以降の報告では、
    - 平均電流[mA]は補助的な指標
    - 電力評価の主語は ΔE/adv（mJ/adv）
    として扱う方針とした。

---

## 5. 【検証】ΔE/adv の妥当性確認（1m_on_05 / 1m_off_05）

- **条件**:
  - E2 / 距離1 m / 窓60 s / TxPower=0 dBm / adv_interval=100 ms（ON時）
  - ON: `data/実験データ/研究室/1m_on_05`（良品 trial_016〜019）
  - OFF: `data/実験データ/研究室/1m_off_05`（trial_021〜025）
  - サマリ: `results/summary_1m_E2_100ms_on_off_05.md`

- **結果（抜粋）**:
  - ON 側（良品セット）:
    - `E_total_mJ` 平均 ≈ **17528.1 mJ**（≈17.53 J/60 s）
  - OFF 側:
    - `E_total_mJ` 平均 ≈ **14900.5 mJ**（≈14.90 J/60 s）
  - 差分:

    ```text
    ΔE = E_on − E_off ≈ 2627.7 mJ ≈ +2.63 J/60 s
    ΔE/adv ≈ 2627.7 mJ / 600 ≈ 4.38 mJ/adv
    ```

- **解釈**:
  - ΔE > 0 となり、「広告ONの方が電力が増える」という物理的整合性が回復。
  - `ΔE/adv ≈ 4.4 mJ/adv` を、「測定系のベース負荷を差し引いた上での、1広告あたりのエネルギー増分」として解釈できる。

---

## 6. 【展開と新たな発見】条件拡張時のLEDベースライン差（100 ms vs 500 ms）

- **背景**:
  - 100 ms 条件に加え、**500 ms / 1000 ms 条件へ実験を拡張**するため、スイープ版コード `esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino` を導入。
- **発生した現象**:
  - 100 ms（旧 `TX_BLE_Adv_Meter_blocking.ino`）よりも、500 ms（スイープ版）の方が **見かけ上の E_total が大きい** という逆転現象。
  - しかし、500 ms と 1000 ms を **スイープ版コード内で比較**すると、期待通り 1000 ms の方が省電力（E_total が小さい）。
- **原因特定**:
  - 旧 100 ms 用コード（`TX_BLE_Adv_Meter_blocking.ino`）:
    - `syncPulse()` で **起動直後に LED/SYNC を ~100 ms だけ点灯**し、その後は計測中LED消灯。
  - スイープ版コード（`TX_BLE_Adv_Meter_ON_sweep.ino`）:
    - `startTrial()`〜`endTrial()` の間、**LED と SYNC_OUT を trial中ずっと HIGH** に維持。
  - つまり、「100 ms（旧） vs 500 ms（新）」の比較は、**LEDベースラインが異なる2つのコード**での比較になっていた。
- **結論**:
  - 100 ms 条件で有利に見えていた差分のかなりの部分は、**LED常時点灯分のオフセット**であり、アドバタイズ間隔そのものの違いではなかった。
  - 一方で、500 ms vs 1000 ms の比較は同一コード内でLED条件も一致していたため、こちらは正しい階段構造（500 ms > 1000 ms）として解釈してよい。

---

## 7. 現在のステータスと Next Step

### 7.1 現在の到達点

1. **データの完全性**：
   - PASS_THRU 化と塊書き込みにより、`parse_drop ≈ 0`・レート安定を達成。
2. **評価の信頼性**：
   - ΔE/adv を主指標とすることで、ベース電流やLED点灯などの実装差の影響を相殺し、無線コストだけを切り出せる評価ロジックを確立。
3. **物理的妥当性**：
   - 100 ms の ON/OFF 比較で ΔE > 0 を確認。
   - 500 ms → 1000 ms でも、アドバタイズ間隔の増加に応じた省電力効果を確認。

### 7.2 Next Step（コード・実験整備）

1. **コード側のベースライン統一**:
   - スイープ版コード（`TX_BLE_Adv_Meter_ON_sweep.ino`）の SYNC/LED 処理を、旧 100 ms コードの `syncPulse()` に揃える。
     - 例: trial 開始時に短いパルスを出すだけにし、trial中常時点灯はやめる。
2. **再計測**:
   - 修正版コードで 100 / 500 / 1000 ms 条件を撮り直し、**「ベースラインが完全に揃った階段データ」**（100 > 500 > 1000）を取得する。
3. **Phase‑1 以降への展開**:
   - 現在の計測系（TX + TXSD + RX）の構成を固定し、その上で Policy（固定→MAB→Safe‑MAB）だけを差し替える形で評価実験に移行する。

---

## 8. 本トピックの位置づけ

- 本タイムラインは、プロジェクトにおける
  - **技術的負債の解消**（計測系のI/Oボトルネック、単位換算バグ）
  - **評価系の確立**（ΔE/adv を中心としたKPI）
  - **コード仕様差による見かけの矛盾の整理**（LEDベースライン差）
  を一つのストーリーとしてまとめたものである。
- 詳細な仕様や数式は、次のドキュメントに委ねる。
  - 測定装置の仕様: `docs/フェーズ0-0/実験装置最終仕様書.md`
  - ΔE評価系の詳細: `docs/フェーズ0-0/技術トピック_電力計測健全化.md`
  - フェーズ0-0 要件全体: `docs/フェーズ0-0/要件定義.md`
</file>

<file path="トラブルシューティング/OFF高消費電力_トラブルシューティング.md">
# BLE OFF時の高消費電力 トラブルシューティング

- 作成日: 2025-11-09
- 目的: OFF計測（広告OFF, 60 s）で ON より大きな消費が観測される事象の原因切り分けと是正。

## 症状（Summary）
- 条件: E2（干渉強）, 距離 1 m, 窓 60 s, TxPower=0 dBm（ON時）
- ON（1m_ad, n=6）: `E_total ≈ 1.93 J/60 s`, `PDR ≈ 0.858`
- ON再試行（1m_ad_retry, n=2）: `E_total ≈ 1.66 J/60 s`
- OFF（1m_off, n=6）: `E_total ≈ 5.51 J/60 s`
- OFF_02（1m_off_02, n=2）: `E_total ≈ 11.73 J/60 s`, `mean_i ≈ 59 mA`, `rate_hz ≈ 150.8 Hz`, `wifi_mode=OFF`
- 期待に反し、OFF > ON が継続。OFF_02 はさらに増加。

## 環境・構成（現状）
- TX+INA（DUT, OFF用）: `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`（旧 `Combined_TX_Meter_UART_B_nonblocking_OFF.ino`）
  - BLE初期化なし, `WiFi.mode(WIFI_OFF)` 明示, UARTは数値行（v,i,p）のみ送出（2025-11-09修正）
- PowerLogger（OFF用）: `esp32/TXSD_PowerLogger_SYNC_TICK_OFF.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B_OFF.ino`）
  - 受信CSV末尾に `# summary/# diag/# sys` を出力（V×I積分・dt統計・システム状態）
- 受信ロガ（共通）: `esp32/RX_BLE_to_SD_SYNC_B.ino`（旧 `RxLogger_BLE_to_SD_SYNC_B.ino`）
- 供給: DUT=3.3V_A（測定対象）, ロガ/INA=3.3V_B（GND共通）

## データ参照（Paths）
- ON: `data/実験データ/研究室/1m_ad/`（6本）, 要約 `results/フェーズ0-0_E2_1m_100ms_2025-11-09.md`
- ON再試行: `data/実験データ/研究室/1m_ad_retry/`（2本）, 要約 `results/フェーズ0-0_E2_1m_100ms_retry_latest_2025-11-09.md`
- OFF: `data/実験データ/研究室/1m_off/`（6本）, ΔE `results/フェーズ0-0_E2_1m_100ms_deltaE_2025-11-09.md`
- OFF_02: `data/実験データ/研究室/1m_off_02/`（2本）, 要約 `results/フェーズ0-0_E2_1m_100ms_off_02_2025-11-09.md`

## 仮説（Hypotheses）
1) 計測負荷（I2C/printf/UART）によるDUT側平均電流の上振れ（OFFでアイドルに入れず消費増）
2) 供給/配線の取り回し（3.3V_A/Bの混在, シャント向き, GNDループ）による見かけ電流の増加
3) INA219レンジ/オフセットのズレ（ベースの+オフセットが過大）
4) スタック停止状態の差（Wi‑Fiは停止済, BT/BLEはOFFコードで未初期化だが残留がないか）

## 暫定対策（2025-11-09）
- TX（OFF）のUARTから `# diag/# sys` を完全停止 → 数値行のみ送出
- 期待効果: `parse_drop`の桁落ち, 実効レート `rate_hz ≈ 500 Hz` へ回復, 平均電流の低下

## 検証計画（10分テスト）
1) TX（OFF）に上記修正を反映, PowerLogger（OFF）は診断付きのまま
2) 10分（600 s）取得 → PowerLogger CSV末尾の診断を確認
   - `rate_hz ≈ 500`（SAMPLE_US=2000 μs）
   - `parse_drop ≈ 0`
   - `dt_ms_mean ≈ 2.0`（±小）、`dt_ms_std`が過大でない
   - `mean_i` がON時（9–10 mA）に近づくか
3) 併せて ΔE を再集計（`scripts/compute_power_and_pdr.py`）

## 再計算コマンド（例）
- `python scripts/compute_power_and_pdr.py --data-dir data/実験データ/研究室/1m_ad_retry --off-dir data/実験データ/研究室/1m_off_02 --expected-adv-per-trial 600 --out results/summary_1m_E2_100ms_deltaE_retry_off02.md`

## 更新ルール
- 本ファイルに日付見出しで観測・対策・結果を追記していく（YYYY-MM-DD）。

---

## 進捗ログ（Timeline）

### 2025-11-09 Step 0: ベースライン確認
- ON（`data/実験データ/研究室/1m_ad/`, n=6）: E_total ≈ 1.93 J/60 s, PDR ≈ 0.858
- OFF（`data/実験データ/研究室/1m_off/`, n=6）: E_total ≈ 5.51 J/60 s

### 2025-11-09 Step 1: OFF 診断有効化（PowerLogger）
- 末尾に `# summary/# diag/# sys` 追加（rate_hz, mean_v/i/p, dt統計）
- OFF_02（`data/実験データ/研究室/1m_off_02/`, n=2）:
  - mean_i ≈ 59 mA, rate_hz ≈ 150.8 Hz, parse_drop ≈ 1.13e4
  - OFF > ON を再確認。受信/SD 経路の詰まりが示唆

### 2025-11-09 Step 2: TX（OFF）を“数値行のみ”に変更
- `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`（旧 `Combined_TX_Meter_UART_B_nonblocking_OFF.ino`）から `# diag/# sys` を削除（UART1は v,i,p のみ）
- OFF_03（`data/実験データ/研究室/1m_off_03/`, n=2）:
  - rate_hz ≈ 105.7 Hz, parse_drop ≈ 1.40e4（むしろ悪化）
  - ボトルネックが受信/SD 側であることを確証

### 2025-11-09 Step 3: PowerLogger を“パススルー”化（受信→SD 最短）
- `esp32/TXSD_PowerLogger_SYNC_TICK_OFF.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B_OFF.ino`）を改修：
  - UART RXバッファ拡張（16 KB）
  - 行の数値パース/積分を停止。相対ms前置のうえ 8 KB チャンクで SD へ write（flush は終了時のみ）
  - #diag は rate_hz, dt統計のみを残す
- OFF_04（`data/実験データ/研究室/1m_off_04/`, n=2）:
  - rate_hz ≈ 339.6 Hz, parse_drop ≈ 0（欠落解消）
  - オフライン積分: E_total ≈ 11.77 J/60 s（±0.57 mJ）
  - 目標 500 Hz に未達 → さらなる最適化（SD_CHUNK拡大、コピー削減）と TX 側の整数化/バイナリ化へ進む予定

### 2025-11-09 Step 4: ON/OFF比較の再取得（Pass-through統一）
- 条件を揃えるため、ON（広告あり）側も **パススルー系PowerLogger** で再取得（`TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）し、OFF_04と同一パイプラインで解析。
- 結果（代表値）:
  - ON側 E_total は **約14.2 J/60 s**、OFF_04 は **約11.8 J/60 s**。
  - これにより、**E_ON > E_OFF** という物理的に妥当な関係に復帰した。
- 結論:
  - これまでの ΔE<0（OFF>ON）結果は、**PowerLogger側のスループット不足・欠損**によるアーティファクトと確定。
  - ΔE評価では、**OFF_04＋ON(PASS_THRU) 系列のみを有効**とし、従来の OFF/OFF_02/OFF_03 系列は「測定系破綻時のログ」として扱う。

### 2025-11-09 Step 5: 単位換算バグ修正とKPIの見直し
- CSV解析中に、オンボード計算の `p_mW` に桁ズレがあることを確認。
  - 誤: `p_mW = (mv * uA) / 1000.0`
  - 正: `p_mW = (mv * uA) / 1000000.0`（mV×µA → mW なので 1000×1000 で割る必要がある）
- 対応:
  - ON側PowerLogger（`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）の式を `/1e6` に修正済み。
  - 過去ログについては、オフライン処理時に **補正済みの式で再計算**することで再測定を避けた。
- 評価指標の見直し:
  - 測定系そのもののベース電流（約59 mA）が高いため、単純な **平均電流[mA]** だけではBLE無線の省電力効果が見えにくいことが明確になった。
  - 今後のレポートでは、エネルギー指標の主語を **「平均電流」から「1広告イベントあたりのエネルギー増分」** へシフトする。
    - 定義: `ΔE/adv = (E_ON − E_OFF) / N_adv`
    - ねらい: 測定系の定常負荷（I2C/UART/CPU）の影響を相殺し、**「無線1回あたりのコスト」** を直接評価できるようにする。
  - 平均電流[mA]は引き続きレポートに載せるが、**比較・最適化の評価軸は ΔE/adv を優先**する。

### 次の予定（Plan）
- Step 4: SD_CHUNK を 16 KB へ引き上げ、受信のコピー回数削減
- Step 5: TX 送出を整数スケール化 or バイナリ固定長化（受信/整形負荷を継続削減）
- Step 6: TX に seq（2 ms刻み）追加 → dt を送信側時刻基準へ（I/O遅延非依存の積分）
- Step 7: INA219 の vshunt_mV を追加し、I_from_vshunt と getCurrent_mA の整合（±5%以内）を確認
</file>

<file path="トラブルシューティング/計測系_todo.md">
# 計測系・解析パイプライン TODO（ΔE/adv・受信品質・ログ健全性）

ポイントは **「いま手元のデータで自信をもってKPIを出す」ための止血** と、**次回以降で同じ不具合を起こさない根治** の二層構え。  
評価で出てきた課題（uA列の文字化け・単位ズレ・500 ms 内クラスター・旧ログ互換など）を踏まえ、すべて **Why / What / DoD（受け入れ条件）** 付きで整理する。

---

## 0) 全体方針（原則）

- **主KPI** = ΔE/adv（mJ/adv または µJ/adv）を最優先で安定に出す。  
  根拠: TX→TXSD で `ms,mV,µA,p_mW` を記録し、`p_mW=(mV×µA)/1e6`、`E_mJ += p_mW×(dt_ms/1000)` で積分できる仕様。
- 受信品質（PDR / TL / Pout(τ)）は **同じ行に並べて意思決定**（トレードオフを可視化する）。
- Android/iOS の **非理想スキャン（Opportunistic / BG制約）** を前提にし、評価は**端末内A/B比較**で完結させる。
- まずは **止血（A/B）** → 次に **根治（C）** → 最後に **運用/研究（D/E）**。

---

## A) 止血：信頼できる解析対象の確定（優先度: 最上）

進捗メモ（2025-11-20）  
- Manifest: `experiments_manifest.yaml` 新設。1m_on_05/outlier除外、1m_off_05、1m_on/off_04を登録。既知外れ（1m_on_100_01/trial_065_on, 1m_on_1000_01/trial_044_on, 1m_on_500_03/trial_095/096_on）を exclude 済み。  
- パイプライン: `scripts/compute_power_and_pdr.py` が manifest を第一級入力として include=false を自動スキップ。  
- 単位監査: `scripts/check_units.py` 追加。diag mean_p を µWスケール想定で補正し、TXSD互換パーサ（先頭数字採用＋p_mW列優先）で I1/I2 を ±1% 内に収束。  
- TX出力: esp32 TX系を固定桁ASCII化（mv=4桁, uA=6桁）済み。
- ΔE/adv: `scripts/compute_delta_energy.py` を追加（manifest適用で ON/OFF を集計し ΔE/adv を出力）。
- 次の着手: 500 ms 系クラスタリング→manifest反映（高電流クラスタ自動判定）、旧ログヘッダ方言吸収レイヤの実装。

進捗メモ（2025-11-23）
- OFF row_1123_off: `check_units_off.py --mad-multiplier 3` で外れ無し（keep 7/7）。manifest の high_baseline_outlier を off_high_baseline に整理。P_off_mean ≈ 22.106 mW（n=7）。
- ΔE/adv（row_1120 × row_1123_off, MAD3, manifest適用）: 100/500/1000/2000 ms → 2.257 / 9.760 / 19.661 / 39.482 mJ/adv（std: 0.162 / 0.339 / 0.134 / 0.063）。1000ms は MAD>3 の 1 本を除外。
- PDR v1 仕様（msベースを正式指標）: PDR_ms_mean 100=0.814, 500=0.845, 1000=0.872, 2000=0.876。参考: PDR_raw_mean 100=1.149, 500=0.921, 1000=0.921, 2000=0.915 / PDR_unique_mean 100=1.120, 500=0.897, 1000=0.898, 2000=0.888。

### A‑1. トライアル選別マニフェスト（Manifest）

- **Why**  
  外れトライアル（例: `1m_on_500_03` の 095/096, `1m_on_1000_01` の 044, `1m_on_100_01` の 065）を “毎回手作業で除外” しないため。解析の再現性・透明性を担保する。

- **What**  
  `experiments_manifest.yaml` を新設し、trial 単位のメタを明示する。

  - 例: `trial_id, path, interval_ms, set_id, include: true|false, exclude_reason:[…], notes`
  - 自動除外ルール（案）:
    1. **短すぎ**:  
       `ms_total < 0.8 × (N_ADV_PER_TRIAL × ADV_INTERVAL_MS)`
    2. **adv_count 異常**:  
       TICK ありで `|adv_count − N_ADV_PER_TRIAL| > 5`
    3. **高電流外れ**:  
       `mean_i` の **中央値±3×MAD** を超過
    4. **クラスタ逸脱**:  
       同一条件内で 2 クラスターに分かれる場合（B‑0 で判定）から外れた点

  - 例（テンプレ）:

    ```yaml
    - trial_id: 1m_on_500_03/trial_095_on
      path: data/実験データ/研究室/1m_on_500_03/trial_095_on.csv
      interval_ms: 500
      set_id: 500_03
      include: false
      exclude_reason: [high_current_outlier]
      notes: "mean_i ≈ 220 mA class"
    ```

- **DoD（Done の条件）**
  - 解析スクリプトが Manifest を読み、**include=false の trial を自動除外**する。
  - 含有/除外と理由をまとめた CSV（もしくは同等の表）が出力され、後から人が追える。
  - 進捗: `experiments_manifest.yaml` 起票済み（1m_on/off_05, on/off_04, 100/500/1000 ms の既知外れを exclude）。`compute_power_and_pdr.py --manifest` で自動除外が効く状態。

---

### A‑2. uA 列文字化けの救済（軽→重の二段階）

- **Why**  
  UART 経路で `uA` に `! " # % &` などが混入し、現行パーサが「先頭の連続数字のみ」を採用しているため、末尾桁が落ちるケースが多数ある。trial 内では自己一貫しているが、絶対値にはバイアスが乗っている可能性が高い。

- **What（A‑2a: 軽量の止血策）**  
  ASCII プロトコルのまま、**固定桁＋復元**で救済する。

  - TX 側: `mv,uA` を **ゼロ埋め固定幅**（例: `mv=4 桁, uA=6 桁`）で UART 出力する。
  - 解析側: 正規表現で **非数字を除去＋桁長チェック** した上で整数化する。
    - 桁長不足の行は末尾ゼロ補完などのヒューリスティック復元＋フラグ付け。
  - 備考: `p_mW` と `E_mJ` は TXSD 側のロジックで、すでに「文字化け後の整数値」で一貫して計算されている。復元は**表示や絶対値補正**のためであり、**エネルギー整合は A‑3 の単位監査で別途確認**する。

- **What（A‑2b: 重い根治策）**  
  A‑2a を実施しても問題が残る場合のみ、**バイナリ＋CRC（STX/length/payload/CRC/ETX）** に段階的に移行する。

- **DoD**
  - 100 Hz × 10 分程度の連続ログで、復元不能行（エラー行）が **0** である。
  - 復元後の `E_total_mJ` を再積分した結果が、従来ログの `E_total_mJ` と **±1% 以内** に収まる。

---

### A‑3. 単位の整合（p_mW vs E_total_mJ のスケール監査）

- **Why**  
  diag の `mean_p_mW` と summary の `E_total_mJ` の桁を突き合わせると、ラベル上 mW と書いてあっても実質 µW スケールを扱っている可能性がある。**表示ラベル／計算式／保存単位**を一度きちんと揃えておきたい。

- **What**  
  単位監査用のスクリプト（Invariants チェッカー）を作る。

  - I1: `E_total_mJ ≈ ∑ p_mW × (dt_ms / 1000)` が **±1%** 以内。
  - I2: `mean_p_mW × (ms_total / 1000) ≈ E_total_mJ` が **±1%** 以内。
  - I3: `mean_p_mW` の値域が物理的に妥当（数百 mW レンジ）になっているか。明らかな桁ズレがあれば「単位ラベル不一致」として警告。
  - いずれかが NG の場合:
    - diag のラベル修正（例: 実値が µW なら `mean_p_µW` に改名）、または
    - 計算式側の修正（/1e3 ↔ /1e6 等）を Issue 化して切り分ける。

- **DoD**
  - I1〜I3 がすべて OK になるか、そうでない場合も「どのスケールで一貫しているか」が明示される。
  - `docs/フェーズ0-0/実験装置最終仕様書.md` とスクリプトの単位記述が整合している。
  - 進捗: `scripts/check_units.py` 実装済み。diag mean_p を µW→mW へ 1/1000 補正で I2 整合、TXSD互換パーサで I1=±0.01% 程度に収束（1m_on_05）。今後は他セットへ適用。

---

### A‑4. 旧ログ互換レイヤ（ヘッダ差分・メタ不足の吸収）

- **Why**  
  旧ログは `ms,mv,uA,p_mW` 表記や `adv_interval_ms` メタ欠損が残っている。新ログは `ms,mV,µA,p_mW`＋`adv_interval_ms` 付き。**同じ前処理で扱えるようにする吸収レイヤが必要**。

- **What**  
  ローダ側で方言を吸収する。

  - ヘッダ alias: `mv → mV`, `uA → µA`、`p_mW` はそのまま。
  - メタ欠損時: TICK や `t_ms/ADV_INTERVAL_MS` から `adv_interval_ms` を推定し、正規化メタとして付与。
  - ローディング時に「正規化済み trial オブジェクト」を返すインタフェースに揃える。

- **DoD**
  - 旧ログと新ログが混在するディレクトリを渡しても、ローダが自動で正規化して落ちない。
  - 下流の集計コードは「正規化済み」表だけを見ればよくなる。

---

### A‑5. 500 ms 内のクラスター分割とルール化

- **Why**  
  `1m_on_500_02` のように、同一 500 ms 条件でも `mean_i` と `E_total_mJ` が「低電流クラスタ」と「高電流クラスタ」に分かれている。これを 1 本の 500 ms 条件として平均すると代表性が崩れる。

- **What**  
  条件内クラスタリングを行い、セット分割または後半除外をルール化する。

  - 指標: `mean_i`, `E_total_mJ`（必要なら `E_per_adv_µJ` を追加）で K=2 のクラスタリング。
  - 低電流群 / 高電流群のどちらを「正」とみなすか（ex: 低電流群を標準とし、高電流群は `exclude_reason: [high_baseline_current_cluster]`）。
  - Manifest に `cluster_id` を持たせる。

- **DoD**
  - 同一 set_id 内で「include=true の trial だけを見ると、`mean_i` と `E_total_mJ` が ±15% 程度の帯域に収まる」状態になっている。
  - 500 ms 系の ΔE/adv 集計がクラスタに依存しない形で解釈できる。

---

## B) KPIパイプライン：ΔE/adv と受信品質（優先度: 高）

### B‑0. サマリテーブル（一次集約の土台）

- **Why**  
  A 系の選別と単位監査の結果をひとつの表に集約し、B‑1/B‑2 の入力を安定化させる。

- **What**  
  `trials_summary.parquet`（またはCSV）を生成するスクリプトを作る。

  - 1 行 = 1 trial。
  - カラム例:
    - `set_id, interval_ms, ms_total, samples, rate_hz, adv_count, mean_v, mean_i, mean_p, E_total_mJ, E_per_adv_µJ, include, exclude_reason[], cluster_id`
  - `adv_count` は TICK を優先し、TICK がない場合は `t_ms/ADV_INTERVAL_MS` から推定。

- **DoD**
  - B‑1/B‑2 のスクリプトが、この表だけを読めば動く状態になる。

---

### B‑1. ΔE/adv 自動算出（主KPI）

- **Why**  
  省電力評価の主語。ON/OFF の差分を 1 ADV あたりに正規化して比較する。

- **What**  
  `compute_delta_energy.py`（仮）を実装する。

  - ON/OFF のペアリング:
    - 距離・環境・interval_ms で OFF 側の代表値（平均 or 中央）を特定。
  - 計算式:
    - `ΔE/adv = (E_ON_trial − E_OFF_ref) / N_adv`
    - 単位は µJ/adv 推奨（mJ/adv でも可）。
  - 出力:
    - 条件別の平均・分散・95% CI。
    - 箱ひげ or バイオリン図。
    - CSV/Parquet の表。

- **DoD**
  - `adv_interval ∈ {100, 500, 1000, 2000} @ 1m` の ΔE/adv がすべて出力される。
  - Manifest の include フラグ適用後の値で、階段構造（省電力の傾向）が解釈可能になっている。

---

### B‑2. 受信品質（PDR / TL / Pout(τ)）

- **Why**  
  エネルギーだけでなく、受信側の品質を同じ行で比較するため。

- **What**  
  `compute_rx_quality.py`（仮）を実装する。

  - 重複除去窓 = `3 × ADV_INTERVAL_MS`。
  - PDR:
    - TICK があれば TICK ベースの期待値、無い場合は `t_ms/ADV_INTERVAL_MS` からの期待値を使用。
  - TL/Pout:
    - アクティビティ変化トリガ（実験ログに応じて）から見た TL 分布。
    - `Pout(τ)`（例: τ=1/2/3 秒）の算出。
  - B‑0 のサマリ表へ join し、**ΔE/adv・PDR・Pout(τ)・TL p50/p95** を横並びにする。

- **DoD**
  - 各条件で ΔE/adv と PDR/TL/Pout(τ) が同じ行で理解できる統合KPI表ができている。
  - Runbook 側に「この表を見て解釈する手順」が簡潔に追記できる。

---

## C) 根治：計測系の堅牢化（優先度: 中〜高）

### C‑1. ASCII 固定長化 →（必要なら）バイナリ＋CRC

- **Why**  
  A‑2 の軽量対処だけでは不十分な場合に備えた根治策。UART 経路での文字化けを構造的に防ぐ。

- **What**

  - C‑1a: TX の UART 出力を **固定桁**（例: `%04d,%06d\n`）にし、TXSD で **行長・桁長・簡易チェックサム（LRC 等）** を検査。
  - C‑1b: 必要になった段階で、STX/len/payload/CRC/ETX 形式のバイナリプロトコルに移行する。

- **DoD**
  - 230400 bps で 1 時間連続計測しても `parse_drop=0`・文字化け=0 が確認できる。
  - 変更後の仕様が `docs/フェーズ0-0/実験装置最終仕様書.md` に反映されている。

---

### C‑2. LED/SYNC の統一と再計測設計

- **Why**  
  旧 100 ms コードと Sweep 版で LED 常点灯 vs パルスのみ などの差があると、ベースラインがズレる可能性がある。

- **What**

  - Sweep 版 TX コード側で trial 中の LED 常点灯を廃止し、旧 100 ms コードの `syncPulse()` に近い形（境界パルスのみ）に揃える。
  - 統一後のコードで 100/500/1000 ms 条件を再取得し、階段構造が LED 差に依存していないか確認する。

- **DoD**
  - ΔE/adv の階段構造（100 > 500 > 1000…）が LED/SYNC 挙動を揃えた上で再確認されている。
  - 仕様書に LED/SYNC 挙動の統一方針が明記される。

---

### C‑3. TICK/同期のリグレッションテスト

- **Why**  
  TICK は ADV カウントのゴールドスタンダード。割込み取りこぼしやパルス幅不足がないかを継続的に確認したい。

- **What**

  - TICK パルス幅の境界値（例: 150µs / 200µs / 250µs）での受信安定性テストを自動化する。
  - `advCountISR` と理論値（`N_ADV_PER_TRIAL`）との差分を試験ログに残す。

- **DoD**
  - 試験スイートで全条件 Green（取りこぼし無し）が確認される。
  - Runbook に TICK の検証項目が追記されている。

---

## D) 運用整備：自動チェック・ドキュメント（優先度: 中）

### D‑1. ログ健全性チェッカー

- **Why**  
  これまで手作業で見ていた #diag/#summary の整合性チェックを自動化して、漏れを防ぐ。

- **What**

  - `check_logs.py`（仮）で、以下を検査:
    - `samples ≈ ms_total / 10`（100 Hz 前提）
    - `rate_hz = 100 ± 10%`
    - `parse_drop=0`
    - `dt_ms_min ≥ 0`, `dt_ms_max ≤ 60` など

- **DoD**
  - 任意のログディレクトリに対して一発で OK/NG と理由が出せる。
  - 可能であれば CI に組み込む。

---

### D‑2. Runbook / 仕様書のアップデート

- **Why**  
  既知の計測系課題（文字化け・単位・外れ trial・旧ログ方言）と、その回避策（Manifest, 復元, 単位監査, ログチェッカー）をドキュメントに反映しておく。

- **What**

  - `docs/フェーズ1/Runbook.md` / `docs/フェーズ0-0/実験装置最終仕様書.md` に:
    - Phase 0‑0 データの既知問題と、分析時の扱い方
    - 単位監査（A‑3）で使う Invariants の概要
    - 旧ログと新ログの取り扱いポリシー
  を追記。

- **DoD**
  - 新しく入った人がドキュメントだけ読んで、同じ前提・同じフィルタで解析を走らせられる。

---

## E) 研究タスク：非理想スキャン / interval 探索（優先度: 低〜中）

### E‑1. 150 ms など非整数倍 interval の評価

- **Why**  
  BLE interval 単位（0.625 ms）への丸めが実装されたので、150/300/750 ms などを試し、高調波関係の回避や Valley Area の変化を見たい。

- **What**

  - 150/300/750 ms などを追加条件として測定し、ΔE/adv と Pout(τ) を既存 100/500/1000/2000 ms と並べて評価する。

- **DoD**
  - “素数系 or 非整数倍 interval” が高調波由来の Valley Area をどの程度回避できるか、簡単な表や図で説明できる。

---

### E‑2. Opportunistic Scan 前提の品質KPI再検討

- **Why**  
  Android/iOS の実装上、実効スキャンウィンドウは他アプリとの合成（Opportunistic Scan）で時間変動する。PDR/TL/Pout の再現性を評価するには、端末・モードごとの振る舞いを整理しておく必要がある。

- **What**

  - Pixel/Galaxy/iPhone など主要端末ごとに、前景/背景・スキャンモード別の**最低限のテストマトリクス**を作る。
  - Runbook に「Opportunistic Scan 前提」「端末内 A/B 比較で完結させる」旨と簡単なチェックポイントを追加。

- **DoD**
  - 端末差による指標のブレ（PDR/TL/Pout）の範囲を定量的に示した表が作成されている。
</file>

<file path="トラブルシューティング/計測系作業ログ_2025-11-20.md">
# 計測系 TODO 対応ログ（2025-11-20）

- 目的: A系止血（解析対象の確定と単位健全性チェック）を進めた作業ログ。

## 実施内容

- Manifest 起票: `experiments_manifest.yaml` を新設し、`1m_on_05`（trial_015_on を high_current_outlier として除外、016-019 を良品）と `1m_off_05`（021-025 を有効）を記入。`cluster_id` と `exclude_reason` を明示。
- パイプライン対応: `scripts/compute_power_and_pdr.py` に `--manifest` を追加し、manifest の include=false を自動スキップ・理由表示するようにした。
- 単位監査スクリプト: `scripts/check_units.py` を新規追加。I1/I2/I3（E再積分 vs summary, mean_pレンジ）を試験し、manifest除外を考慮。
- I2 定義修正とパーサ互換化:
  - diag の `mean_p_mW` 値が実質 µW スケールである前提で `/1000` 補正して I2 を計算。
  - オフライン積分は TXSD と同じ軽量パーサ（先頭数字採用）を使いつつ、`p_mW` 列があればそれを優先して積分する形に変更。
- Manifest横展開:
  - `1m_on_04`（trial_014_on）、`1m_off_04`（013/014_off）を追加（すべて include=true）。
  - 既知の外れを exclude: `1m_on_100_01/trial_065_on`, `1m_on_1000_01/trial_044_on`, `1m_on_500_03/trial_095_on`, `trial_096_on`。
- 全データセットへの Manifest 自動生成:
  - `experiments_manifest.yaml` を全trial 101件で再生成（meta除外）。interval_ms 推定、cluster_id 付与、既知外れは include=false。
- TX出力の固定桁化:
  - `esp32/TX_BLE_Adv_Meter_blocking.ino`, `TX_BLE_Adv_Meter_ON_10ms.ino`, `TX_BLE_Adv_Meter_OFF_10ms.ino`, `TX_BLE_Adv_Meter_ON_nonblocking.ino`, `esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino` で UART 出力を固定幅（mv=4桁, uA=6桁、p_mW付きはそのまま）に変更。
- ΔE/adv パイプライン雛形:
  - `scripts/compute_delta_energy.py` を追加。manifest遵守で ON/OFF を集計し、ΔE/adv を Markdown 出力するスクリプト。

## チェック結果（1m_on_05, manifest適用）

- 実行: `python3 scripts/check_units.py --data-dir data/実験データ/研究室/1m_on_05 --manifest experiments_manifest.yaml --abs-tol-pct 1.0`
- 結果概要:
  - `trial_015_on.csv` は manifest で除外。
  - 016-019 で I1 差分 ≈ 0%（±0.004%）、I2 差分 ≈ −0.76%（±0.69%）。mean_p_mW=293,198 などの値は diag 上 µW スケールと解釈し `/1000` で mW 換算すると整合。
  - uA列の文字化けは残るが、TXSD互換パーサ＋`p_mW`列優先で再積分すると summary と一致する状態まで到達。

## 次の一手（提案）

- Manifest を他セット（on/off_04, 500 ms 系）にも拡張し、集計の足場を固める。
- TX出力の固定桁化＋解析パーサの非数字除去を適用し、`check_units.py` で I1/I2 を ±1% 内に収める。
- 500 ms 系でクラスタリング（mean_i, E_total_mJ）を走らせ、Manifest に cluster_id と include=false を反映する。

- Sweep版LED/SYNC常時HIGHを廃止し、開始100msパルスのみ（ベースライン差解消）。
</file>

<file path="フェーズ0-0/decision_log_2025-11-29.md">
# ESP32ファームウェア 意思決定ログ (2025-11-29)

## 1. ディレクトリ構成の再編成

### 背景
- 従来の `esp32/`, `esp32_sweep/` ディレクトリ構成では、ON/OFF/CCSモードの区別が不明確
- コードの最新版管理が困難

### 決定事項
`esp32_firmware/` を新設し、以下の3分割構成を採用:

```
esp32_firmware/
├── baseline_on/      # BLE広告ON計測用
│   ├── TX_BLE_Adv.ino         # Node1: BLE TX + INA219
│   ├── TXSD_PowerLogger.ino   # Node2: Power logger (SD)
│   └── RX_BLE_to_SD.ino       # Node3: BLE RX logger (SD)
├── baseline_off/     # BLE広告OFF計測用 (ベースライン電力)
│   ├── TX_BLE_OFF.ino         # Node1: BLE無効, INA219のみ
│   └── TXSD_PowerLogger.ino   # Node2: Power logger (SD)
├── ccs_mode/         # CCS動的インターバル制御用
│   ├── TX_BLE_Adv_CCS_Mode.ino
│   ├── TXSD_PowerLogger_CCS_Mode.ino
│   ├── RX_BLE_to_SD.ino
│   └── ccs_session_data.h     # 生成されたセッションデータ
└── README.md
```

### 理由
- 計測モード別に明確に分離
- 各モードで必要なファームウェアが一目瞭然
- 新規作業者でも迷わない構成

---

## 2. INA219配線の修正

### 問題現象 (2025-11-29 作業者確認)
- 外部電源(PMM25-1TR)の電流表示が不安定 (0.02〜0.11A で変動)
- ESP32のビルド/フラッシュ時にリセットループ発生
- 再接続/再起動で一時的に安定することもあった

### 原因推定 (ChatGPT診断 + 作業者検証)
INA219のVccをVin-（負荷側）から分岐して供給していた可能性:
- ESP32起動時の突入電流でVin-側の電圧が降下
- INA219のVcc電圧も連動して低下
- INA219が不安定動作 → I2C通信エラー → ESP32リセット
- 悪循環でブラウンアウトリセットループ

**注記**: 修正前の配線状態はコード上の記録がなく、作業者の口頭確認に基づく。

### 修正前の配線 (推定・NG)
```
外部3.3V ─→ INA219 Vin+ ─→ INA219 Vin- ─┬→ ESP32 3V3
                                         └→ INA219 Vcc (NG: 負荷側からの分岐)
```

### 修正後の配線 (OK)
```
外部3.3V ─┬→ INA219 Vin+ ─→ INA219 Vin- ─→ ESP32 3V3
          └→ INA219 Vcc (OK: 安定電源に直結)
```

### 結果 (作業者確認: 「安定した！」)
- 電流表示が安定
- ビルド/フラッシュ時のリセットループ解消
- 計測値の信頼性向上

**注記**: 修正前後の定量的比較データ（電流値ログ等）は取得していない。上記は作業者の主観的報告に基づく。将来同様の問題が発生した場合のデバッグ資料として、修正前のデータ取得を推奨。

### 影響
- 配線修正前後で計測条件が異なるため、ON/OFF両方の再計測が必要
- Phase 0-0のベースラインデータ (P_off=22.106mW, ΔE/adv=2256.82µJ) は参考値として保持するが、正式な比較は再計測データで実施

---

## 3. マルチトライアル対応

### 背景
- 単一トライアルでは統計的信頼性が不足
- 平均値・標準偏差の算出には複数回計測が必須

### TX_BLE_OFF.ino (baseline_off)
マルチトライアルループを実装:
- `N_TRIALS = 10` (10回のトライアル)
- `TRIAL_DURATION_MS = 60000` (60秒/トライアル)
- `GAP_BETWEEN_TRIALS_MS = 5000` (5秒間隔)
- 総実行時間: 約11分 (60s × 10 + 5s × 9)

### TX_BLE_Adv.ino (baseline_on)
既存実装を確認・維持:
- `N_TRIALS = 10` (10回のトライアル)
- `N_ADV_PER_TRIAL = 300` (300回広告/トライアル)
- `ADV_INTERVAL_MS = 100` (変更可能: 100/500/1000/2000)
- `GAP_BETWEEN_TRIALS_MS = 5000` (5秒間隔)

**注意: トライアル長はintervalにより変動**:
| ADV_INTERVAL_MS | トライアル長 | 備考 |
|-----------------|-------------|------|
| 100 ms | 30 s | 300 × 0.1s |
| 500 ms | 150 s (2.5 min) | 300 × 0.5s |
| 1000 ms | 300 s (5 min) | 300 × 1.0s |
| 2000 ms | 600 s (10 min) | 300 × 2.0s |

**ベースライン（OFF）との比較方法**:
- OFF計測は60秒固定（トライアル長 = 60s）
- ON計測はinterval依存（30s〜600s）
- ΔE/adv算出時:
  ```
  ΔE/adv = (E_on - P_off × T_on) / N_adv

  E_on  : ON計測の総エネルギー [mJ]
  P_off : OFF計測の平均電力 [mW] ← 60s固定から算出
  T_on  : ON計測の時間 [s] ← interval依存
  N_adv : 広告回数 = 300 (固定)
  ```
- P_offは「電力」（時間あたりのエネルギー消費率）として扱うため、T_onを掛けることでOFF相当エネルギーを正しく推定
- よってOFF/ONのトライアル長が異なっても比較は妥当

### TXSD_PowerLogger.ino
- SYNC信号の立ち上がり/立ち下がりでトライアル開始/終了を検出
- TXの複数トライアルに自動追従（変更不要）

---

## 4. 再計測計画

配線修正後の計測順序:
1. OFF計測 (BLE無効ベースライン) → P_off算出
2. ON計測 (全interval自動実行)

### TX_BLE_Adv.ino 自動実行機能 (2025-11-29 実装)

マルチinterval自動実行を実装。手動でADV_INTERVAL_MSを書き換える必要なし:

```cpp
static const uint16_t intervals[]      = {100, 500, 1000, 2000};  // 自動遷移
static const uint8_t  trialsPerGroup[] = {10,  10,  5,    5};     // グループ別トライアル数
static const uint8_t  N_GROUPS         = 4;
static const uint8_t  START_GROUP_INDEX = 0;  // 開始グループ (0-3で指定可能)
```

| Group | Interval | Trials | 1トライアル長 | グループ所要時間 |
|-------|----------|--------|--------------|-----------------|
| 0 | 100 ms | 10 | 30 s | ~6 min |
| 1 | 500 ms | 10 | 150 s | ~27 min |
| 2 | 1000 ms | 5 | 300 s | ~27 min |
| 3 | 2000 ms | 5 | 600 s | ~52 min |
| **合計** | - | **30** | - | **~112 min** |

中断時は`START_GROUP_INDEX`を変更して途中再開可能。

---

## 5. UARTボーレート変更 (2025-11-29 追記)

### 問題
- 230400 bps でデータ化け発生（µA列に記号混入: `05"400`, `06#100` など）
- 約90%のサンプルがパース不可

### 原因
- 高ボーレートでのビット化け（配線長・ノイズ）

### 対策
- 全ファームウェアのUARTボーレートを **230400 → 115200** に変更
- 変更ファイル:
  - `baseline_off/TX_BLE_OFF.ino`
  - `baseline_off/TXSD_PowerLogger.ino`
  - `baseline_on/TX_BLE_Adv.ino`
  - `baseline_on/TXSD_PowerLogger.ino`

### 結果
- データ化け解消、parse_drop=0 達成

---

## 6. ハードウェア確認事項

### 使用ボード
- **ESP32-WROVER-E (ESP32-DevKitC-VE)** - Espressif純正
- PSRAM搭載のため通常のWROOMより消費電力が高い

### INA219シャント抵抗
- **R100 (0.1Ω)** を確認
- `setCalibration_16V_400mA()` で正しくキャリブレーション

### 電流計測値の差異
| 測定源 | 電流 | 備考 |
|--------|------|------|
| 外部電源表示 | 40 mA | 参考値 |
| INA219読み取り | 56 mA | 約16mAの差あり |

相対比較（ON-OFF）では相殺されるため、ΔE/adv算出には問題なし。

---

## 7. ファイルハッシュ (SHA256)

計算日時: 2025-11-29 (SYNC修正・マルチinterval自動実行実装後)

### baseline_on/
| ファイル | SHA256 |
|----------|--------|
| TX_BLE_Adv.ino | `4653cba23efd9d575e6420857a452dfc7e701ad043a0b92cd0a703f34355536a` |
| TXSD_PowerLogger.ino | `88380db88e2fc1b8ddd7d63f23492caad2300f61f4e0ffc20d50871197f37a12` |
| RX_BLE_to_SD.ino | `932a18a1a2b8a6b000dca8606939f07f92d58227b3839b94eaad583a94b45336` (2025-11-30 USE_SYNC_END=true修正)|

### baseline_off/
| ファイル | SHA256 |
|----------|--------|
| TX_BLE_OFF.ino | `c212e8b8550b8468d6cde64248d02a33fa6baf91c7d83f616cf0ff3b359cf989` |
| TXSD_PowerLogger.ino | `952811247ec79b0495ffa3e589a1811f9a6efea826e88b41dba7ebc9da24499e` |

### ccs_mode/
| ファイル | SHA256 |
|----------|--------|
| TX_BLE_Adv_CCS_Mode.ino | `959f134ecde8551c9abcf796c51aeaf396ba3ac81390dd9c06bf18dc7e450998` |
| TXSD_PowerLogger_CCS_Mode.ino | `0e6da19c0a2ef6513bdb9683909665c14fa2ca0565c6c89c5bdc945abd6e3cb5` |
| RX_BLE_to_SD.ino | `1bfad7c308146d3c2554413f854f72381c36182ed49954926a211e688f29c097` |
| ccs_session_data.h | `6224539c62880a4d71950dd4c909136c1bd01d2303bc335519296f93b1bdc7c8` |

**注**: baseline_on/RX_BLE_to_SD.ino は2025-11-30にUSE_SYNC_END=true修正。ccs_mode版は旧ハッシュのまま。

---

## 8. SYNC信号の修正 (2025-11-29 追記)

### 問題
ON計測時にTXSDのトライアルが5msで終了してしまう:
```
[PWR] end trial=1 t=5ms N=0 E=0.000mJ (ON)
```

一方、RXは正常に60秒動作:
```
[RX] summary trial=1 ms_total=60060, rx=496, rate_hz=8.26
```

### 原因
- **TX側**: `startTrial()`で100msパルスのみ出力し、その後SYNC=LOWになっていた
- **TXSD側**: SYNC=LOWを検出するとendTrial()を呼ぶ設計
- 結果: 100ms後に即終了

### 修正
`baseline_on/TX_BLE_Adv.ino` の `startTrial()` を変更:

**修正前:**
```cpp
// 100msパルスのみ（trial中はLED/SYNCを常時OFFにする）
syncStart();
delay(100);
syncEnd();
```

**修正後:**
```cpp
// トライアル開始: SYNC=HIGH維持（endTrial()でLOWにする）
syncStart();
```

### 動作
- `startTrial()`: SYNC=HIGH（維持）
- トライアル中: SYNC=HIGH継続
- `endTrial()`: SYNC=LOW

これによりTXSDはトライアル全体を正しくログ記録できる。

---

## 9. 関連ドキュメント

- `esp32_firmware/docs/実験装置仕様書_v2.md` - 本ログに基づく更新版仕様書
- `docs/フェーズ0-0/実験装置最終仕様書.md` - 旧版（v1.0、参照用として保持）
</file>

<file path="フェーズ0-0/フェーズ0-0_サマリ.md">
# フェーズ0-0 サマリ（計測系ベースライン確定）

## 実験セット概要
- 条件: E2, 距離1 m, adv_interval={100,500,1000,2000} ms, TxPower=0 dBm
- ONデータ: `data/実験データ/研究室/row_1120/TX`（TXSD）, `.../row_1120/RX`
- OFFデータ: `data/実験データ/研究室/row_1123_off/TX`
- manifest: `experiments_manifest.yaml`（include=false を解析で自動スキップ）

## KPI定義（v1）
- ΔE/adv = (E_on − P_off × T_on) / N_adv [mJ/adv]
  - E_on, T_on, N_adv: ON trial の TXSD #summary (`E_total_mJ`, `ms_total`, `adv_count`)
  - P_off: OFF trial の P_off_trial=E_off/(ms_off/1000) を median±3MAD で外れ除外後の平均
- PDR（正式）: PDR_ms = rx_unique / (ms_rx / interval_ms) （RX mfd seq 去重, max=1.0 で clip）
  - 参考: PDR_raw = rx_count_raw / adv_count, PDR_unique = rx_count_unique / adv_count（どちらも clip可）
- 外れ値ルール
  - ON: E_total_mJ > median+3MAD → include=false, cluster_id="<interval>ms_high_current"
  - OFF: P_off_trial > median+3MAD → include=false, cluster_id="off_high_baseline"

## 使用スクリプト
- 単位/健全性: `scripts/check_units.py`, `scripts/check_units_off.py`
- ΔE/adv計算: `scripts/compute_delta_energy_off.py`（manifest遵守、OFFはMADフィルタでP_off_mean算出）
- PDR計算: `scripts/compute_pdr_join.py`（`--dedup-seq` で seq去重, `--clip-pdr` で max=1.0）

## 集計結果（row_1120 ON × row_1123_off OFF, manifest+MAD3）
- P_off_mean: 22.106 mW（OFF 7/7 keep）
- ΔE/adv [mJ/adv, mean±std]:
  - 100ms: 2.2568 ± 0.1622
  - 500ms: 9.7601 ± 0.3392
  - 1000ms: 19.6611 ± 0.1335（1m_on_1000_005.csv を high_current_outlier で除外済み）
  - 2000ms: 39.4818 ± 0.0631
- PDR_ms_mean（clip済）:
  - 100=0.814, 500=0.845, 1000=0.872, 2000=0.876
- 参考 PDR（clip前の平均）:
  - PDR_raw_mean: 100=1.149, 500=0.921, 1000=0.921, 2000=0.915
  - PDR_unique_mean: 100=1.120, 500=0.897, 1000=0.898, 2000=0.888

## 主な出力ファイル
- ΔE/adv集計: `docs/フェーズ1/results/delta_energy_row1120_row1123_off.md`
- PDR集計: `docs/フェーズ1/results/pdr_row1120_txsd_rx.md`
- フェーズ1まとめ: `docs/フェーズ1/results/phase1_summary.md`

## ルールメモ（再掲）
- ON外れ値: median±3MAD（E_total_mJ）で high_current_outlier。1000ms の 1 本のみ除外、他 interval は現状全採用。
- OFF外れ値: median±3MAD（P_off_trial）で high_baseline_outlier。row_1123_off は 7/7 keep（外れなし）。
- PDR運用:
  - 正式値は PDR_ms（clip済）。PDR_ms>1.1 や <0 の trial は `pdr_inconsistent` として除外候補。
  - PDR_raw/unique は TXSD整合チェック用の参考値。
</file>

<file path="フェーズ0-0/技術トピック_電力計測健全化.md">
以下は、**BLE省電力実験における電力計測・受信評価システムの健全化プロセス**をまとめた技術トピックです。  
フェーズ0-0で発生した「広告OFFの方がONより消費が大きい」という異常を出発点として、**何を、なぜ、どのような順序で行い、今どうなっているか**を整理します。

---

# 1. 背景と課題（発端）

フェーズ0-0のデータ取得において、**広告OFF（ベースライン）の消費電力が広告ON時より高い**という物理的に矛盾した現象が発生しました。

- 代表例: `data/実験データ/研究室/1m_off_02/`（OFF_02）
  - 平均電流 ≈ **59 mA**
  - サンプリングレート ≈ **150 Hz**（設計値 500 Hz に対して大幅低下）
  - `parse_drop`（パース失敗行数）が **1万行以上**（全行の10%以上）
- 一方、ON側（`data/実験データ/研究室/1m_ad/` や再試行 `1m_ad_retry`）では、平均電流 ≈ **10 mA** 程度で推移しており、**OFF > ON** という逆転現象になっていた。

**原因仮説**：

- 計測ハードウェア（INA219）の不具合ではなく、**PowerLogger（受信・記録側）のI/Oボトルネック**が主因と判断した。
  - UART受信バッファ溢れ
  - 浮動小数点演算（`printf`/`sscanf`）の負荷
  - SDカードへの行ごとの書き込み
- これらにより、**計測データの欠落と dt（時間差）の歪み**が発生し、エネルギー積分 `E_total` が不正確になっていた。

このフェーズの詳細なトラブルシナリオは `docs/トラブルシューティング/OFF高消費電力_トラブルシューティング.md` に記録されている。本トピックでは、その後の「解決プロセス」と「最終的な評価系」の確立に焦点を当てる。

---

# 2. 実施した修正アプローチ（The Fix）

異常な ΔE（E_ON − E_OFF）を正し、物理的に妥当なエネルギー差を観測できるようにするため、以下の3段階で修正した。

## 2.1 送信側（TX）の軽量化：整数CSV化

- **目的**：
  - 送信データ量と文字列処理コストを削減し、UARTまわりのボトルネックを緩和する。
  - PowerLogger側が、**数値行のみ**を前提に単純・高速なパーサを利用できるようにする。

- **主な変更**：
  - TX（計測対象）の UART 出力を、従来の浮動小数点表現（例: `3.300,0.059,...`）から、**整数表現（例: `3300,59000` = mV, µA）** に変更。
  - UART1 上の診断行（`# diag`, `# sys` など）を**送信しない**ようにし、**「mv,uA」の2カラムのみ**を送る構成に統一。

## 2.2 受信側（PowerLogger）の構造改革：パススルー＆塊書き込み

最もクリティカルな修正は PowerLogger（TXSD）の構造見直しである。

- **対象スケッチ**：`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`

- **主な変更点**：
  - **パススルー実装**：
    - 重い `sscanf`／浮動小数点フォーマット処理を廃止。
    - 受信した1行を軽量な整数パーサで `mv,uA` にだけ変換し、**必要最小限の計算**（p_mW, E_mJ）だけを行う。
  - **非同期・塊（Chunk）書き込み**：
    - SDカードへの書き込みを「1行ごと」から、「**16 KB バッファ単位**」の塊書き込みに変更。
    - 受信中はバッファに追記し、バッファが埋まったタイミングまたは trial 終了時に一括書き込みすることで、I/O ブロック時間を最小化。
  - **積分ロジックの適正化**：
    - エネルギー計算を `E_mJ += p_mW * (dt / 1000.0)` に統一。
    - `p_mW = (mv * uA) / 1000000.0`（mV×µA → mW）とし、**単位換算バグ（/1000）を修正**。
    - `dt` は PowerLogger側の `millis()` 差分で算出し、サンプリングレートの揺らぎも含めて正しく積分できるようにした。

- **成果**：
  - 実効サンプリングレートが **約500 Hz**（ON時、SAMPLE_US=2000 µs）に復帰。
  - OFF側でも設計どおり **約100 Hz**（SAMPLE_US=10000 µs）で安定。
  - `parse_drop` は **ほぼ0** となり、計測データの欠落が事実上消失。

## 2.3 計測条件の標準化（Phase-1 要件準拠）

フェーズ1要件で想定していた **「ON時はTICKで広告回数をカウント、OFF時は無線スタックを完全停止」** という構成に合わせて、ON/OFF の条件を整理した。

- **ON（広告ON, 100 ms）**：
  - TX: `esp32/TX_BLE_Adv_Meter_blocking.ino`
    - BLE広告 100 ms 固定。
    - INA219 は 2 ms 周期でサンプリング（約500 Hz）。
    - GPIO27 から **TICKパルス**を出力し、PowerLogger 側で `adv_count` を物理カウント。
- **OFF（ベースライン, 広告OFF）**：
  - TX: `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`
    - Wi‑Fi/BLE スタックを明示的に OFF。
    - INA219 は 10 ms 周期でサンプリング（約100 Hz）。
    - TICK は未配線（`adv_count=0`）。
- **PowerLogger（ON/OFF共通）**：
  - `esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`
  - ON時は TICK_IN=33 で `adv_count` をカウント、OFF時は未接続。
- **RX Logger**：
  - `esp32/RX_BLE_to_SD_SYNC_B.ino`
  - SYNC信号で trial を区切り、`/logs/rx_trial_XXX.csv` に PDR/TL評価用ログを保存。

---

# 3. 検証結果と現状（Evidence）

修正後の構成を用いて実施した `1m_on_05` / `1m_off_05` 実験（E2, 1 m, 100 ms, 60 s）により、以下が確認できた。詳細な数値は `results/summary_1m_E2_100ms_on_off_05.md` を参照。

## 3.1 エネルギー整合性（ΔE > 0）

- ON 良品セット（`data/実験データ/研究室/1m_on_05`, trial_016〜019）：
  - `E_total_mJ` 平均 ≈ **17528.1 mJ**（≈ **17.53 J/60 s**）
  - ばらつき ≈ 0.5%
- OFF セット（`data/実験データ/研究室/1m_off_05`, trial_021〜025）：
  - `E_total_mJ` 平均 ≈ **14900.5 mJ**（≈ **14.90 J/60 s**）
  - ばらつき ≈ 0.07%
- 差分：

```text
ΔE = E_on − E_off ≈ 2627.7 mJ ≈ +2.63 J/60 s
```

- これにより、**「広告を出すとエネルギー消費が増える（E_ON > E_OFF）」** という物理的に正しい関係が確認できた。

## 3.2 指標の確立（ΔE/adv）

- ON 側の `adv_count = 600`（TICK カウント）を分母として、

```text
ΔE/adv ≈ 2627.7 mJ / 600 ≈ 4.38 mJ/adv
```

- この値は、「測定系（INA219＋TXSD）のベース負荷がON/OFFで共通である」という前提のもと、**「広告をONにしたことで追加で消費されるエネルギー（1 advあたり）」** を意味する。
- フェーズ0-0および今後のフェーズでは、**電力評価の主指標を ΔE/adv とし、平均電流[mA]は補助的な指標**として扱う。

## 3.3 サンプリングレート間の互換性

- 別途実施した 10 ms サンプリング（100 Hz）ベースの ON実験（例: `1m_on_06`）でも、60 s 換算の `E_total_mJ` は `1m_on_05` の結果と整合している。
- これにより、
  - サンプリング周期を変えても、dtを正しく積分する限り **総エネルギーは安定して再現できる** こと。
  - PowerLoggerの現実装（PASS_THRU + 正しい dt処理）が、少なくとも 100〜500 Hz の範囲で**エネルギー積分として十分に堅牢**であること。
  が確認できた。

## 3.4 条件拡張時に判明したLEDベースライン差（100 ms vs 500 ms）

- フェーズ0-0の後半では、**アドバタイズ間隔を 100 ms → 500 ms → 1000 ms に拡張**するため、スイープ版コード（`esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino`）を導入した。
- その結果、以下の現象が観測された。
  - 100 ms（旧 `TX_BLE_Adv_Meter_blocking.ino`）よりも、500 ms（スイープ版）の方が **見かけ上 E_total が大きい**。
  - ただし、500 ms と 1000 ms を **同じスイープ版コード内で比較**すると、期待どおり 1000 ms の方が小さい（省電力）という「階段」は確認できていた。
- 調査の結果、**LED（GPIO2）と SYNC 出力の扱いの違い**が主因であることが分かった。
  - 旧 100 ms 用コード（`TX_BLE_Adv_Meter_blocking.ino`）では、`syncPulse()` で **起動直後に100 msだけLED/SYNCを点灯**し、その後は計測中LED消灯。
  - スイープ版コード（`TX_BLE_Adv_Meter_ON_sweep.ino`）では、`startTrial()`〜`endTrial()` の間、**LEDと SYNC_OUT を常時HIGH** としており、trial中ずっとLED点灯分の消費が上乗せされていた。
- このため、
  - 「100 ms（旧） vs 500 ms（新）」の比較は、**LEDベースラインが異なる2つのコード**を比較していたことになり、純粋なアドバタイズ間隔の差ではなく LED オフセットを含んだ差分となっていた。
  - 一方、「500 ms vs 1000 ms」の比較は**同一コード内**でLED条件も同じであるため、正しい階段（500 ms > 1000 ms）が確認できていた。
- 対応方針：
  - 条件を跨いだ比較（100/500/1000 ms）を行う際は、**LED/SYNC の扱いを統一した同一コード**のみによるデータを基準とする（旧コードとスイープ版コードの混在比較は行わない）。
  - スイープ版コード側の SYNC 出力は、今後 **「trial中常時HIGH」から「短いパルス（syncPulse相当）」へ揃える**ことを検討中（LED点灯の有無を含め、ベースラインを揃えるため）。

---

# 4. システム構成要素（現時点の「正解」）

現時点で、フェーズ0-0の E2/1 m/100 ms 条件の ON/OFF 実験を再現するための「正解構成（Golden Master）」は以下の通り。

| 役割 | ファイル | 要約 |
| :--- | :--- | :--- |
| **TX (ON用)** | `esp32/TX_BLE_Adv_Meter_blocking.ino` | 100 ms BLE広告、INA219 2 ms サンプリング、整数CSV `mv,uA` 出力、TICK付き |
| **TX (OFF用)** | `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino` | 無線完全停止、INA219 10 ms サンプリング、整数CSV `mv,uA` 出力、TICKなし |
| **PowerLogger** | `esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino` | PASS_THRU版。ON/OFF共通。`ms,mv,uA,p_mW` をSDに記録しつつ E_mJ を積分、TICK入力で `adv_count` カウント |
| **RX Logger** | `esp32/RX_BLE_to_SD_SYNC_B.ino` | SYNC入力で trial を区切り、PDR/TL 評価用の `rx_trial_XXX.csv` を記録 |

この構成と `results/summary_1m_E2_100ms_on_off_05.md` により、当該条件での ΔE/adv ≈ **4.4 mJ/adv** を「代表値」として再現できる。

---

# 5. 将来フェーズへの橋渡し（簡易）

本トピックで行った修正は、単なるバグ修正ではなく、**今後のフェーズ1/2/3に共通で流用できる計測基盤の整備**でもある。

- **PowerLoggerの役割の明確化**：
  - 「電圧・電流・時間」をできるだけ素直に記録する**土管（Pipe）**に徹し、アプリケーションロジック（HAR/MAB/Safe‑MAB）は TX 側に閉じ込める。
  - これにより、TX 側の方策（固定間隔 → MAB → Safe‑MAB）が変わっても、**計測系はそのまま再利用**できる。
- **KPIの互換性**：
  - 本トピックで確立した **ΔE/adv, PDR, TL, Pout(τ)** は、そのままフェーズ1要件定義書で述べている KPI と整合しており、**学習・評価時の報酬／制約指標として直接利用可能**である。
- **データ品質の保証**：
  - `parse_drop ≈ 0`、`rate_hz` の安定、E_total の再現性（±0.5〜1%）を満たすことで、**学習データとしての品質基準（QA）** を満たしている。

---

# 6. 結論

- フェーズ0-0における「広告OFFの方が電力が大きい」という異常は、**PowerLogger側のI/Oボトルネックと単位換算ミス**による計測系の破綻が原因だった。
- TXの整数CSV化、PowerLoggerのPASS_THRU化（塊書き込み＋正しい dt積分）、ON/OFF条件の標準化により、
  - **E_ON > E_OFF**
  - **ΔE/adv ≈ 4.4 mJ/adv**
  を安定して再現できる状態に到達した。
- 現在の計測システムは、**フェーズ1で要求される電力・受信品質評価を実施できる水準**にあり、その上で MAB/Safe‑MAB などの方策を評価していくための基盤として利用可能である。
</file>

<file path="フェーズ0-0/実験ログ_E2_1m_2025-11-09.md">
# フェーズ0-0 実験ログ（E2, 1 m, 100 ms）

- 日付: 2025-11-09
- 現在フェーズ: フェーズ0-0（ベースライン）
- 目的: 100 ms固定のベースラインで電力と受信品質の基準値を取得し、計測系の安定性を確認する。

## 実施条件（要約）
- 距離 1 m / 環境 E2（干渉強）/ 窓 60 s × 6本
- adv_interval=100 ms / TxPower=0 dBm
- 使用コード（ON/OFF非分離の共通版）
  - TX+計測: `esp32/TX_BLE_Adv_Meter_blocking.ino`（旧 `Combined_TX_Meter_UART_B.ino`）
  - 電力ロガ: `esp32/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B.ino`）
  - 受信ロガ: `esp32/RX_BLE_to_SD_SYNC_B.ino`（旧 `RxLogger_BLE_to_SD_SYNC_B.ino`）
- データ: `data/実験データ/研究室/1m_ad/`

## 記録後の状況
- 電力（V×I積分）
  - `E_total_mJ` 平均 1933.47 mJ（±10.06 mJ）
  - `E_per_adv_uJ` 平均 3222.45 μJ（±16.75 μJ）
- 受信品質
  - `PDR` 平均 0.858（±0.009）
  - `RSSI` 中央値 −35 dBm

## 記録からわかったこと
- 電力計測の再現性は良好（±0.6%程度）。
- E2環境でも PDR≈0.86 程度を維持しており、ベースライン品質として妥当。
- `adv_count` は TICK未配線のため t/100ms 近似（=600）。厳密化にはTICK配線を推奨。

## 次アクション（フェーズ移行に向けて）
- 広告OFF（60 s）を同条件で取得し、ΔE = E_on − E_off を算出。
- TICK配線（27→33）＋ `USE_TICK_INPUT=true` で `adv_count` を厳密化。
- TL分布・Pout(τ)の算出スクリプトを当該データに適用し、受入基準（Pout(1 s), TL p95）の確認を開始。

## 追加: OFF取得とΔE（2025-11-09）
- OFFデータ: `data/実験データ/研究室/1m_off/`（広告OFF, 60 s × 6本）
- 集計（OFF）: `E_total_mJ` 平均 5511.02 mJ（±111.55）
- ΔE = ON − OFF = −3577.55 mJ（60 sあたり）
  - 想定外（OFF>ON）のため、配線・レンジ・供給系・無線停止状態の点検を推奨（詳細は `results/フェーズ0-0_E2_1m_100ms_deltaE_2025-11-09.md` 参照）。

### 追記（ON再試行: data/実験データ/研究室/1m_ad_retry/）
- 集計（ON再試行）: `E_total_mJ` 平均 1664.99 mJ（±240.26）, `E_per_adv_uJ` 平均 2775.00 μJ
- 受信（ON再試行）: `PDR` 平均 0.865（±0.000）, `RSSI` 中央値 −28 dBm
- ΔE（ON再試行 − OFF）: −3846.04 mJ（60 sあたり）。OFF>ONは継続。`results/フェーズ0-0_E2_1m_100ms_retry_latest_2025-11-09.md` 参照。

### 追記（OFF再取得: data/実験データ/研究室/1m_off_02/）
- 集計（OFF_02）: `E_total_mJ` 平均 11732.93 mJ（±9.26）。rate_hz ≈ 150.8 Hz, mean_i ≈ 59.18 mA。
- ΔE（ON再試行 − OFF_02）: −10067.94 mJ（60 sあたり）。詳細は `results/フェーズ0-0_E2_1m_100ms_off_02_2025-11-09.md` と `results/summary_1m_E2_100ms_deltaE_retry_off02.md` を参照。

### 追記（OFF再取得: data/実験データ/研究室/1m_off_03/）
- 集計（OFF_03）: `E_total_mJ` 平均 11825.47 mJ（±0.86）。rate_hz ≈ 105.7 Hz, mean_i ≈ 59.34 mA。
- ΔE（ON再試行 − OFF_03）: −10160.48 mJ（60 sあたり）。詳細は `results/フェーズ0-0_E2_1m_100ms_off_03_2025-11-09.md` と `results/summary_1m_E2_100ms_deltaE_retry_off03.md` を参照。

### 追記（OFF再取得: data/実験データ/研究室/1m_off_04/）
- ダイアグ: rate_hz ≈ 339.6 Hz（parse_drop ≈ 0）, dt_mean ≈ 2.94 ms
- オフライン積分: `E_total_mJ` ≈ 11773.60 mJ（±0.57）
- 参考: `results/フェーズ0-0_E2_1m_100ms_off_04_2025-11-09.md`

### 追記（評価指標と結論の更新: 2025-11-09）
- 上記 OFF/ON 系列のうち、**OFF/ OFF_02/ OFF_03** は `parse_drop ≫ 0` かつ `rate_hz` が大きく劣化しており、**PowerLogger の処理遅延による測定系破綻が原因**で ΔE<0（OFF>ON）となっていたことが確定した。
- PowerLogger を **パススルー化（PASS_THRU）** し、OFF_04 系列では `parse_drop ≈ 0` かつ安定したサンプリングが得られている。
- ON 側も同じパイプラインで再取得した結果、代表的な 60 s 窓で
  - E_ON ≈ 14.2 J/60 s
  - E_OFF（OFF_04） ≈ 11.8 J/60 s
 となり、**E_ON > E_OFF** という物理的に妥当な関係に復帰した。
- これにより、本ログ前半で報告している ΔE（ON−OFF）が負となる集計は、**「旧PowerLogger構成による異常値」**として扱い、以後の評価・レポートでは **OFF_04＋ON(PASS_THRU) 系列のみを有効なΔE計測として採用する。**

### 追記（ΔE/adv を主指標とする方針: 2025-11-09）
- 測定系（ESP32 + INA219 + UART/SD）のベース電流が高く、**単純な平均電流[mA]だけではBLE広告の省電力性が見えにくい**ことが分かった。
- フェーズ0-0 の電力評価では、以下の指標を使い分ける。
  - **ΔE（60 sあたり）**: ONとOFFの総エネルギー差の符号・オーダー確認（物理的整合性チェック用）。
  - **ΔE/adv**: `ΔE/adv = (E_ON − E_OFF) / N_adv` を **主指標（KPI）** とし、「無線1回あたりのエネルギー増分」を評価する。
  - **平均電流[mA]**: 補助的な指標としてログに残すが、最適化の主語には用いない。
- 以後のレポートおよびスクリプト（`results/summary_*.md`）では、**電力関連の議論を ΔE/adv（mJ/adv）中心に行う**ことを基本方針とする。

### 再計算手順（スクリプト）
- 依存: Python 3.8+（標準ライブラリのみ）
- 実行:
  - 現セット（ONのみ）の要約
    `python scripts/compute_power_and_pdr.py --data-dir data/実験データ/研究室/1m_ad --expected-adv-per-trial 600 --out results/summary_1m_E2_100ms.md`
  - OFF取得後のΔE計算
    `python scripts/compute_power_and_pdr.py --data-dir data/実験データ/研究室/1m_ad_on --off-dir data/実験データ/研究室/1m_ad_off --expected-adv-per-trial 600 --out results/summary_1m_E2_100ms_deltaE.md`

## メタ情報
- SYNC: GPIO25（100 ms High）→ SYNC_IN=26（立上り開始・固定窓終了）
- 受信: ρ=1の受動スキャン（MFD `MFxxxx` 抽出, 最初に見えたTXにロック）
- チェックサム: `data/実験データ/SHA256.txt` に統合
- 参考: 結果サマリ `results/フェーズ0-0_E2_1m_100ms_2025-11-09.md`
</file>

<file path="フェーズ0-0/実験装置最終仕様書.md">
以下は **ESP32三ノード実験装置 最終仕様書（フェーズ0-0）** です。  
BLE広告の電力と受信品質（Pout, TL, PDR）を測るための **TX / TXSD / RX の3台構成**について、回路・配線・コード挙動を現状仕様として固定します。  
将来のHARやMABなど制御側の設計は別ドキュメントに分離し、本書には記載しません。

---

# 1. 文書メタ

- **文書ID**：ADV-PWR-RIG-PH0-0-v1.0
- **対象フェーズ**：Phase 0-0（ΔEベースライン計測）
- **対象モジュール**：
  - `TX`：送信＋電流測定ノード（esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino）
  - `TXSD`：電力ロガノード（esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino）
  - `RX`：受信ロガノード（esp32_sweep/RX_BLE_to_SD_SYNC_B.ino）
- **スコープ**：
  - 回路・配線・電源条件
  - GPIOピン割り当て
  - 計測シーケンスとログ仕様

---

# 2. システム全体構成

目的：  
BLE広告の電力と品質（Pout, TL, PDR）を測るために、以下の3ノード構成とする。

- **TX**：BLE広告を送信しつつ、INA219で自ノード電流を測定し UART で出力する。
- **TXSD**：TX からの UART を受信し、**電流ログ＋イベント電荷**を SD に記録する。
- **RX**：空間中の BLE広告をパッシブスキャンし、**受信ログ**を SD に記録する。

**共通の重要ポイント**：

- **3台すべての GND を外部電源の GND と共通化する（直結）**。
  - 外部電源GND ↔ TX.GND ↔ INA219.GND ↔ TXSD.GND ↔ RX.GND を1点接続で共有する。

---

# 3. 回路・配線仕様

## 3.1 TX（送信＋電流測定）

- **ファイル**：`esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino`
- **役割**：
  - BLE広告を一定間隔（`ADV_INTERVAL_MS`）で送信する。
  - INA219 で TXボード全体の電流/電圧を測定し、UART1 から `"mv,uA"` 形式で出力する。
  - トライアル開始～終了を SYNC信号で示し、TXSD/RX のログ区切りに使う。
  - 各広告イベントごとに TICKパルスを出力し、TXSDで ADV回数をカウントできるようにする。

### 3.1.1 電源

- 外部電源（例：PMM25 等）から **3.3V** を供給する。
- 推奨配線：
  - 外部電源 +3.3V → **INA219 VIN+**
  - INA219 VIN− → **ESP32 TX の 3V3ピン**
  - 外部電源 GND → **ESP32 TX の GNDピン** ＋ **INA219 GND**
  - 上記 GND を TXSD・RX 側の GND と共通化する。
- 注意事項：
  - ESP32 DevKit の **VINピンに3.3Vを入力しない**。オンボードLDOでさらに降圧されるため、**3V3ピンに直接給電**する。
  - INA219 のシャント抵抗は **0.1Ω（`RSHUNT_MILLIOHM = 100`）** を前提とする。

### 3.1.2 GPIOピン割り当て

```cpp
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN      = 2;
static const int I2C_SDA      = 21;
static const int I2C_SCL      = 22;
static const int UART_TX      = 4;
```

- **GPIO25 (`SYNC_OUT_PIN`)**
  - トライアル開始〜終了の間 HIGH を出力する。
  - 接続先：
    - TXSD の **GPIO26 (`SYNC_IN`)**
    - RX の **GPIO26 (`SYNC_IN`)**
- **GPIO27 (`TICK_OUT_PIN`)**
  - 各アドバタイズ更新時に **約200µsの HIGH パルス（3.3 Vレベル）** を出力する。
  - 割込みで確実に検出するには、受信側のサンプリングや割込み遅延を踏まえ、200µs以上のパルス幅を確保する。
  - 接続先：
    - TXSD の **GPIO33 (`TICK_IN`)**
- **GPIO2 (`LED_PIN`)**
  - `syncStart()` 呼び出し時に HIGH（点灯）、`syncEnd()` で LOW（消灯）。
  - トライアル中のインジケータとして使用する。
- **GPIO21 / GPIO22（`I2C_SDA` / `I2C_SCL`）**
  - INA219 との I2C 通信に使用する。
- **GPIO4 (`UART_TX`)**
  - `HardwareSerial uart1(1)` の TX ピン。
  - 接続先：
    - TXSD の **GPIO34 (`RX_PIN`)**

### 3.1.3 主なソフトウェア定数

```cpp
static const uint16_t ADV_INTERVAL_MS   = 100;    // 100 / 500 / 1000 / 2000 ...
static const uint32_t SAMPLE_US         = 10000;  // 10ms ≒ 100Hz（INAサンプル周期）
static const uint16_t N_ADV_PER_TRIAL   = 300;    // 1トライアルあたり広告回数
static const uint8_t  N_TRIALS          = 10;     // トライアル回数
static const uint32_t GAP_BETWEEN_TRIALS_MS = 5000;
static const uint8_t  RUN_GROUP_ID      = 1;      // 条件ID（例: 1=100ms, 2=500ms ...）
static const bool     USE_TICK_OUT      = true;
```

---

## 3.2 TXSD（PowerLogger）

- **ファイル**：`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`
- **役割**：
  - TX からの UART (`"mv,uA"`) を受信し、**「ms,mV,µA,p_mW」形式のCSV**として SD に記録する。
  - SYNC信号で trial 開始/終了を検出する。
  - TICK信号で ADV回数を厳密カウントし、エネルギーを **「1広告イベントあたりの平均エネルギー（µJ）」** まで集計する。

### 3.2.1 電源

- ESP32 DevKit を **USB 5V給電**する。
- GNDは **外部電源GND（TX/INA219側）と共通**にする。
  - 外部GNDをブレッドボードなどで引き回し、TXSD.GND と直結する。

### 3.2.2 GPIOピン割り当て

```cpp
static const int RX_PIN   = 34;
static const int SD_CS    = 5;
static const int SYNC_IN  = 26;
static const int TICK_IN  = 33;
```

コメント（コード内）：

```cpp
// UART RX=34 ← ② TX=4（クロス、GPIO34は入力専用ピンに注意）
// SYNC_IN=26 ← ② SYNC_OUT=25
// TICK_IN=33 ← ② TICK_OUT=27（推奨）
// SD: CS=5, SCK=18, MISO=19, MOSI=23
```

- **GPIO34 (`RX_PIN`)**
  - TX の GPIO4 (`UART_TX`) からの `"mv,uA"` CSV を受信する。
  - UART1 設定：`baud=230400, SERIAL_8N1, RX=34, TX=-1`。
- **GPIO26 (`SYNC_IN`)**
  - TX の GPIO25 (`SYNC_OUT`) から入力する。
  - 立ち上がりエッジで `startTrial()`、立ち下がりエッジで `endTrial()` を呼び出す。
- **GPIO33 (`TICK_IN`)**
  - TX の GPIO27 (`TICK_OUT`) から入力する。
  - 割込みハンドラ `onTick()` で RISINGエッジごとに `advCountISR++` する。
- **SPI / SDカード**
  - `SPI.begin(18,19,23,SD_CS);`（SCK=18, MISO=19, MOSI=23, CS=5）
  - `/logs/trial_XXX_on.csv` として SD 直下に保存する。

---

## 3.3 RX（BLE受信ロガ）

- **ファイル**：`esp32_sweep/RX_BLE_to_SD_SYNC_B.ino`
- **役割**：
  - TX の BLE広告（ManufacturerData `"MFxxxx"`）をパッシブスキャンで受信する。
  - SYNC信号に合わせて、**「時刻、RSSI、アドレス、MFD」** を SD に記録する。
  - trial終端で簡易的な PDR を推定する。

### 3.3.1 電源

- ESP32 DevKit を **USB給電**する。
- GNDは TX / TXSD と同じ外部GNDに合流させる。

### 3.3.2 GPIOピン割り当て

```cpp
static const int SD_CS   = 5;
static const int SYNC_IN = 26;
...
SPI.begin(18,19,23,SD_CS);
```

コメント（コード内）：

```cpp
// SYNC_IN=26 ← ①の SYNC_OUT=25
// SD: CS=5, SCK=18, MISO=19, MOSI=23
```

- **GPIO26 (`SYNC_IN`)**
  - TX の GPIO25 (`SYNC_OUT`) から入力する。
  - TXSD と並列接続とし、同一の SYNC信号で trial を同期する。
- **SPI / SDカード**
  - ピン配置は TXSD と同一（CS=5, SCK=18, MISO=19, MOSI=23）。
  - `/logs/rx_trial_XXX.csv` として SD に保存する。

---

# 4. コード挙動仕様

## 4.1 TX：`TX_BLE_Adv_Meter_ON_sweep.ino`

### 4.1.1 基本挙動

- BLEデバイス名：`"TXM_ESP32"`。
- 送信電力：`TX_PWR = ESP_PWR_LVL_N0`（0 dBm）。
- アドバタイズ間隔：
  - `ADV_INTERVAL_MS` [ms] を **BLE interval単位（0.625ms）** に変換して設定する。
  - `itv = (uint16_t)(ADV_INTERVAL_MS / 0.625f);`

### 4.1.2 トライアル制御

- `setup()`：
  - GPIO（LED/SYNC/TICK）初期化。
  - BLE初期化、初期Advertise開始。
  - INA219 初期化（I2C）。
  - UART1 初期化（TX=GPIO4, 230400bps）。
  - `delay(2000)` 後に `trialIndex=0; startTrial();` を呼ぶ。
- `startTrial()`：
  - `advCountInTrial=0; seq=0; hold0=8; trialRunning=true;` をセットする。
  - `nextSampleUs = micros() + SAMPLE_US;`
  - `nextAdvMs    = nowMs + ADV_INTERVAL_MS;`
  - `syncStart()` を呼び、**LED点灯＋SYNC_OUT=HIGH** とする。
  - `Serial` に開始ログ（グループID、trial番号、adv_interval_ms）を出力する。
- `loop()`（`trialRunning == true` の間）：
  - `SAMPLE_US`（デフォルト10ms）ごとに INA219 をサンプリングし、`"mv,uA\n"` を UART1 に出力する。
  - `nowMs >= nextAdvMs` となったタイミングでアドバタイズ更新を行う。
- アドバタイズ更新時の挙動：
  - `sendSeq = (hold0>0) ? 0 : seq;`
  - ManufacturerData を `"MF%04X"`（seq）に更新する。
  - `hold0` が 0 になるまでは `"MF0000"` を送信し続ける。
  - `USE_TICK_OUT == true` の場合、TICK_OUTに **約200µsのHIGHパルス**を出力する。
  - `advCountInTrial++` し、`advCountInTrial >= N_ADV_PER_TRIAL` で `endTrial()` を呼ぶ。
- `endTrial()`：
  - `trialRunning=false; trialEndMs=millis();` をセットし、`syncEnd()` で SYNC_OUT=LOW・LED消灯とする。
  - `Serial` に trial終了ログ（adv_sent, dur_ms など）を出力する。
- トライアル間の制御：
  - `trialRunning == false` の間は `GAP_BETWEEN_TRIALS_MS` 経過後に `startTrial()` を再実行する（`trialIndex++`）。
  - `trialIndex + 1 >= N_TRIALS` の場合は全トライアル終了状態となり、`vTaskDelay(10)` でアイドル動作を維持する。

---

## 4.2 TXSD：`TXSD_PowerLogger_PASS_THRU_ON_v2.ino`

### 4.2.1 トライアル制御

- SYNC割込み：

```cpp
void IRAM_ATTR onSync(){
  bool s = digitalRead(SYNC_IN);
  if (s != syncLvl){ syncLvl=s; syncEdge=true; }
}
```

- `loop()` 内での処理：
  - `syncEdge == true` のときに SYNCレベルを読み取り、状態遷移を行う。
  - `s == HIGH` かつ `logging == false` の場合 `startTrial()` を呼ぶ。
  - `s == LOW` かつ `logging == true` の場合 `endTrial()` を呼ぶ。

### 4.2.2 startTrial()

- 次のパスを `/logs/trial_XXX_on.csv` 形式で生成し、SD にオープンする。
- 1行目にヘッダを書き出す：

```csv
ms,mv,uA,p_mW
```

- `trialIndex++` と `# meta` 行を出力する。
- 状態を初期化する：
  - `logging=true;`
  - `t0_ms = millis(); tPrev = t0_ms;`
  - `E_mJ=0.0; sampN=0; sum_mv=sum_uA=0;`
  - `sumDt=sumDt2=0.0; dtMin=0xFFFFFFFF; dtMax=0;`
  - `advCountISR=0;`
- UARTバッファを空にしてから計測を開始する。

### 4.2.3 UART受信・SD書き出し・集計

- UART1 から1文字ずつ読み取り、`'\n'` で1行として確定する。
- 行バッファ `lineBuf` を `"mv,uA"` 形式として `parse_mvuA()` でパースする。
- パースに成功した場合：
  - `tNow = millis(); dt = tNow - tPrev; tPrev = tNow;`
  - サンプル数・電圧・電流・時間間隔を集計する。
  - `p_mW = mv * uA / 1e6` として電力[mW]を計算する。
  - `E_mJ += p_mW * (dt / 1000.0);` としてエネルギー[mJ]を積分する。
  - SDには `"ms,mv,uA,p_mW\r\n"` 形式で書き出す（msは `tNow - t0_ms`）。
- SD書き込みは内部バッファ `sdBuf` にため、一定サイズ（`SD_CHUNK_BYTES`）ごとに `sd_flush_chunk()` でまとめて書く。

### 4.2.4 endTrial()

- `logging == true` のときのみ実行する。
- trial全体時間 `t_ms = millis() - t0_ms` を計算する。
- ADV回数の推定：

```cpp
uint32_t Nadv = USE_TICK_INPUT ? advCountISR
                               : (uint32_t)((t_ms / (double)ADV_INTERVAL_MS) + 0.5);
```

- `Eper_uJ = (Nadv>0) ? (E_mJ * 1000.0 / Nadv) : 0.0;` を計算する。
- SDに summary 行を出力する：

```text
# summary, ms_total=..., adv_count=..., E_total_mJ=..., E_per_adv_uJ=...
```

- 併せて diag 行・sys 行を出力する：
  - `# diag`：サンプル数、サンプリングレート、平均電圧/電流/電力、dt統計、パース失敗行数。
  - `# sys`：CPU周波数、WiFiモード、free_heap。
- 最後に `flush()` と `close()` を呼び、`Serial` に trial終了ログを出力する。

---

## 4.3 RX：`RX_BLE_to_SD_SYNC_B.ino`

### 4.3.1 トライアル制御

- SYNC割込み：

```cpp
void IRAM_ATTR onSync(){
  bool s=digitalRead(SYNC_IN);
  if (s!=syncLvl){ syncLvl=s; syncEdge=true; }
}
```

- `loop()` 内での処理：
  - `syncEdge == true` のとき SYNCレベルを読み取り、状態遷移を行う。
  - `s == HIGH` かつ `trial == false` の場合 `startTrial()` を呼ぶ。
  - `s == LOW` かつ `trial == true` の場合 `endTrial()` を呼ぶ。

### 4.3.2 startTrial()

- `/logs/rx_trial_XXX.csv` 形式で次のパスを探索し、SD にオープンする。
- ヘッダを書き出す：

```csv
ms,event,rssi,addr,mfd
```

- `trialIndex++` と `# meta` 行を出力する。
- `t0Ms = millis(); trial = true; txLock = ""; rxCount = 0;` をセットし、`Serial` に開始ログを出力する。

### 4.3.3 BLEスキャンとログ

- NimBLE または Arduino BLEライブラリを用いて、**パッシブスキャン（`activeScan=false`）** を実行する。
- コールバックでは以下の条件でログ記録する：
  - ManufacturerData 文字列を取り出し、`parseMFD()` で `"MFxxxx"` 形式かを確認する。
  - 最初に受信した送信機のアドレスを `txLock` に保存し、それ以外の送信機からの広告は無視する。
  - trial中であれば `ms = millis() - t0Ms;` を計算し、以下の形式で1行を出力する。

```csv
ms,ADV,RSSI,addr,mfd
```

- `rxCount` は trial中に受信した有効広告の行数としてカウントする。

### 4.3.4 endTrial()

- `trial == true` のときのみ実行する。
- `trial = false` とし、ファイルを `flush()` / `close()` する。
- `t_ms = millis() - t0Ms` から以下を計算する：
  - `dur_s = t_ms / 1000.0`
  - `rate_hz = rxCount / dur_s`（受信レート）
  - `expected = t_ms / ADV_INTERVAL_MS`（期待受信回数、ADV_INTERVAL_MS は RX 側定義）
  - `pdr = rxCount / expected`（期待値に対する比としての PDR 推定）
- `Serial` に summary 行（ms_total, rx, rate_hz, est_pdr）と `[RX] end` を出力する。

---

# 5. 計測シーケンス

## 5.1 事前確認

- **GND配線**：
  - 外部電源GND ↔ TX.GND ↔ INA219.GND ↔ TXSD.GND ↔ RX.GND がすべて導通していること。
- **信号配線**：
  - TX.GPIO25 (`SYNC_OUT`) → TXSD.GPIO26 (`SYNC_IN`) および RX.GPIO26 (`SYNC_IN`)。
  - TX.GPIO27 (`TICK_OUT`) → TXSD.GPIO33 (`TICK_IN`)。
  - TX.GPIO4 (`UART_TX`) → TXSD.GPIO34 (`RX_PIN`)。
- **SDカード**：
  - TXSD・RX の両方に適切にフォーマットされた SDカードが挿入されていること。

## 5.2 計測手順

1. **RX と TXSD を USB で PC に接続する。**  
   - 必要に応じてシリアルモニタを開き、ログ開始を確認できる状態にしておく。
2. **外部電源 ON → TX 起動。**  
   - 約2秒後、TX の GPIO2 の LED が点灯し、`startTrial()` 実行と SYNC_OUT=HIGH を示す。
   - これに同期して、RX 側に `[RX] start ...`、TXSD 側に `[PWR] start ...` が出力される。
3. **trial中の動作。**
   - TX は `ADV_INTERVAL_MS` 間隔で BLE広告 `"MFxxxx"` を送信し、各送信ごとに TICK_OUT パルスを出力する。
   - RX は広告を受信し、`/logs/rx_trial_XXX.csv` に RSSI を含むログを記録する。
   - TXSD は UART (`"mv,uA"`) を読み取り、`/logs/trial_XXX_on.csv` に電流ログ＋p_mW を記録しつつ、エネルギーを積分する。
4. **所定の `N_ADV_PER_TRIAL` に到達。**
   - TX は `endTrial()` を呼び出し、`syncEnd()` で SYNC_OUT=LOW・LED消灯とする。
   - RX/TXSD は SYNC下降エッジを検出し、それぞれ `endTrial()` を呼び、CSV をクローズして summary を出力する。
5. **トライアルの繰り返し。**
   - TX は `GAP_BETWEEN_TRIALS_MS` 経過後に次の trial を自動開始する。
   - RX/TXSD も SYNC信号に従って自動的に次の trial を開始し、ログを継続する。

---

本仕様書は、ESP32三ノード構成による BLE広告電力・受信品質計測の **現行実装の固定版** として扱う。  
配線変更やスケッチ差し替えを行った場合は、本書を更新し、計測条件との対応関係を明示すること。


## 更新（2025-11-20）計測コードとログ運用
- **LED/SYNC**: スイープ版 `esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino` は trial 中のLED/SYNC常時HIGHを廃止し、開始時100 msパルスのみ。ベースライン差をなくすためにこの版を使用する。
- **UART出力**: TX系は固定桁ASCII（mv=4桁, uA=6桁、p_mW付きはそのまま）。PowerLogger側は `TXSD_PowerLogger_PASS_THRU_ON_v2.ino` を推奨。
- **ヘッダ方言吸収**: パーサは mv/mV, ua/µA, p_mW の alias を吸収し、p_mW=mv*uA/1e6 で再積分する。
- **Manifest**: `experiments_manifest.yaml` を用いて include=false を自動除外。500ms 高電流クラスタは `scripts/cluster_500ms.py` で自動判定し manifest 反映。
</file>

<file path="フェーズ0-0/実験装置仕様書_v2.md">
# ESP32三ノード実験装置 仕様書 v2.0

BLE広告の電力と受信品質（Pout, TL, PDR）を測るための **TX / TXSD / RX の3台構成**について、回路・配線・コード挙動を現状仕様として固定します。

---

## 1. 文書メタ

| 項目 | 内容 |
|------|------|
| 文書ID | ADV-PWR-RIG-v2.0 |
| 作成日 | 2025-11-29 |
| 対象フェーズ | Phase 0-0 / Phase 0-1 ベースライン計測 |
| 前版からの主な変更 | ディレクトリ再編、INA219配線修正、ボーレート変更、マルチinterval対応 |

### 対象ファームウェア

| モード | TX | TXSD | RX |
|--------|-----|------|-----|
| baseline_on | `baseline_on/TX_BLE_Adv.ino` | `baseline_on/TXSD_PowerLogger.ino` | `baseline_on/RX_BLE_to_SD.ino` |
| baseline_off | `baseline_off/TX_BLE_OFF.ino` | `baseline_off/TXSD_PowerLogger.ino` | N/A |
| ccs_mode | `ccs_mode/TX_BLE_Adv_CCS_Mode.ino` | `ccs_mode/TXSD_PowerLogger_CCS_Mode.ino` | `ccs_mode/RX_BLE_to_SD.ino` |

---

## 2. ハードウェア構成

### 2.1 使用機材

| ノード | ボード | 役割 |
|--------|--------|------|
| TX | ESP32-WROVER-E (ESP32-DevKitC-VE) | BLE広告送信 + INA219電流測定 + UART送信 |
| TXSD | ESP32-WROVER-E (ESP32-DevKitC-VE) | 電力ログ記録 (SD) |
| RX | ESP32-WROVER-E (ESP32-DevKitC-VE) | BLE受信ログ記録 (SD) |
| 電流センサ | INA219 (シャント抵抗 0.1Ω = R100) | TX電流測定 |
| 外部電源 | PMM25-1TR など | 3.3V安定化電源 |

### 2.2 消費電力参考値 (ESP32-WROVER-E)

| 状態 | 電流 (実測) | 電力 @ 3.3V |
|------|-------------|-------------|
| BLE OFF (WiFi OFF) | 約40 mA | 約132 mW |
| BLE ON (100ms interval) | TBD | TBD |

※ WROVER-EはPSRAM搭載のため、通常のWROOMより消費電力が高い

---

## 3. 回路・配線仕様

### 3.1 システム全体図

```
┌─────────────────────────────────────────────────────────────────┐
│                        外部電源 (PMM25等)                        │
│                     3.3V (+) ─────┬──────── GND (-)             │
└───────────────────────────────────┼──────────────┼──────────────┘
                                    │              │
                    ┌───────────────┼──────────────┼───────────────┐
                    │               ▼              ▼               │
                    │         ┌─────────────────────────┐          │
                    │         │       INA219            │          │
                    │         │  Vin+ ◄── 外部3.3V      │          │
                    │         │  Vin- ──► TX 3V3       │          │
                    │         │  VCC  ◄── 外部3.3V ★   │          │
                    │         │  GND  ◄── 共通GND      │          │
                    │         │  SDA  ◄──► TX GPIO21   │          │
                    │         │  SCL  ◄──► TX GPIO22   │          │
                    │         └─────────────────────────┘          │
                    │                      │                       │
┌───────────────────┼──────────────────────┼───────────────────────┼────────────────┐
│                   │                      ▼                       │                │
│  ┌────────────────┴────────────┐    ┌─────────────────┐    ┌─────┴──────────┐     │
│  │         RX (受信)           │    │    TX (送信)    │    │  TXSD (ロガー) │     │
│  │  ┌──────────────────────┐   │    │                 │    │                │     │
│  │  │ ESP32 + SD           │   │    │  ESP32 + INA219 │    │  ESP32 + SD    │     │
│  │  │                      │   │    │                 │    │                │     │
│  │  │ GPIO26 ◄─ SYNC ──────┼───┼────┼─ GPIO25 SYNC ───┼────┼─► GPIO26       │     │
│  │  │ GND    ◄─────────────┼───┼────┼─ GND ───────────┼────┼─► GND          │     │
│  │  │                      │   │    │ GPIO27 TICK ────┼────┼─► GPIO33       │     │
│  │  │ USB給電              │   │    │ GPIO4  UART ────┼────┼─► GPIO34       │     │
│  │  └──────────────────────┘   │    │                 │    │                │     │
│  └─────────────────────────────┘    │ INA219経由給電  │    │  USB給電       │     │
│                                     └─────────────────┘    └────────────────┘     │
└───────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 INA219配線 (重要)

**正しい配線:**
```
外部3.3V ─┬─► INA219 Vin+ ─► INA219 Vin- ─► ESP32 TX 3V3ピン
          │
          └─► INA219 VCC  ★ 外部電源から直接取る

外部GND ──┬─► INA219 GND
          ├─► ESP32 TX GND
          ├─► ESP32 TXSD GND
          └─► ESP32 RX GND
```

**間違った配線 (過去の問題):**
```
外部3.3V ─► INA219 Vin+ ─► INA219 Vin- ─┬► ESP32 TX 3V3ピン
                                        │
                                        └► INA219 VCC  ✗ Vin-側から取るとブラウンアウト発生
```

### 3.3 GPIOピン割り当て

#### TX (送信ノード)

| GPIO | 機能 | 接続先 |
|------|------|--------|
| 25 | SYNC_OUT | TXSD GPIO26, RX GPIO26 |
| 27 | TICK_OUT | TXSD GPIO33 |
| 4 | UART_TX | TXSD GPIO34 |
| 21 | I2C SDA | INA219 SDA |
| 22 | I2C SCL | INA219 SCL |
| 2 | LED | (内蔵LED) |

#### TXSD (電力ロガー)

| GPIO | 機能 | 接続先 |
|------|------|--------|
| 26 | SYNC_IN | TX GPIO25 |
| 33 | TICK_IN | TX GPIO27 |
| 34 | UART_RX | TX GPIO4 |
| 5 | SD_CS | SDカード |
| 18 | SD_SCK | SDカード |
| 19 | SD_MISO | SDカード |
| 23 | SD_MOSI | SDカード |

#### RX (受信ロガー)

| GPIO | 機能 | 接続先 |
|------|------|--------|
| 26 | SYNC_IN | TX GPIO25 |
| 5 | SD_CS | SDカード |
| 18 | SD_SCK | SDカード |
| 19 | SD_MISO | SDカード |
| 23 | SD_MOSI | SDカード |

---

## 4. ソフトウェア仕様

### 4.1 共通設定

| パラメータ | 値 | 備考 |
|-----------|-----|------|
| UART_BAUD | 115200 | v1.0の230400から変更（ノイズ耐性向上） |
| SAMPLE_US | 10000 | INA219サンプリング周期 10ms = 100Hz |
| I2C_CLOCK | 400000 | I2C 400kHz |

### 4.2 baseline_on モード

#### TX_BLE_Adv.ino 設定

```cpp
// マルチinterval自動実行
static const uint16_t intervals[]      = {100, 500, 1000, 2000};
static const uint8_t  trialsPerGroup[] = {10,  10,  5,    5};
static const uint8_t  N_GROUPS         = 4;
static const uint8_t  START_GROUP_INDEX = 0;  // 開始グループ (0-3)

static const uint16_t N_ADV_PER_TRIAL        = 300;    // 広告回数/トライアル (固定)
static const uint32_t GAP_BETWEEN_TRIALS_MS  = 5000;   // トライアル間隔
static const uint32_t GAP_BETWEEN_GROUPS_MS  = 10000;  // グループ間隔
```

#### 実行時間見積もり

| Group | Interval | Trials | Trial長 | Group計 |
|-------|----------|--------|---------|---------|
| 1 | 100ms | 10 | 30s | ~5分 |
| 2 | 500ms | 10 | 150s | ~25分 |
| 3 | 1000ms | 5 | 300s | ~25分 |
| 4 | 2000ms | 5 | 600s | ~50分 |
| **合計** | | **30** | | **~105分** |

### 4.3 baseline_off モード

#### TX_BLE_OFF.ino 設定

```cpp
static const uint32_t TRIAL_DURATION_MS    = 60000;   // 60秒/トライアル
static const uint8_t  N_TRIALS             = 10;      // トライアル回数
static const uint32_t GAP_BETWEEN_TRIALS_MS = 5000;   // トライアル間隔
```

- WiFi/BLEは明示的にOFF
- 実行時間: 約11分 (60s × 10 + 5s × 9)

---

## 5. 出力ファイル形式

### 5.1 電力ログ (TXSD)

**ファイル名:** `/logs/trial_XXX_on.csv` または `/logs/trial_XXX_off.csv`

```csv
ms,mV,µA,p_mW
# meta, firmware=TXSD_PowerLogger_PASS_THRU_ON_v2, trial_index=1, adv_interval_ms=100
10,3272,052400,170.8
20,3276,059100,193.6
...
# summary, ms_total=30000, adv_count=300, E_total_mJ=5123.456, E_per_adv_uJ=17078.2
# diag, samples=3000, rate_hz=100.00, mean_v=3.273, mean_i=52.34, mean_p_mW=171.3
# diag, dt_ms_mean=10.000, dt_ms_std=0.5, dt_ms_min=9, dt_ms_max=12, parse_drop=0
# sys, cpu_mhz=240, wifi_mode=OFF, free_heap=256680
```

### 5.2 受信ログ (RX)

**ファイル名:** `/logs/rx_trial_XXX.csv`

```csv
ms,event,rssi,addr,mfd
# meta, firmware=RX_BLE_to_SD_SYNC_B, trial_index=1, adv_interval_ms=100
123,ADV,-45,aa:bb:cc:dd:ee:ff,MF0000
234,ADV,-42,aa:bb:cc:dd:ee:ff,MF0001
...
```

---

## 6. 計測手順

### 6.1 OFF計測 (P_off測定)

1. TX に `baseline_off/TX_BLE_OFF.ino` をフラッシュ
2. TXSD に `baseline_off/TXSD_PowerLogger.ino` をフラッシュ
3. TXSD を USB接続、SDカード挿入
4. 外部電源ON → TX起動
5. 10トライアル自動実行 (約11分)
6. SDカードから `trial_XXX_off.csv` を回収

### 6.2 ON計測 (ΔE/adv測定)

1. TX に `baseline_on/TX_BLE_Adv.ino` をフラッシュ
2. TXSD に `baseline_on/TXSD_PowerLogger.ino` をフラッシュ
3. (任意) RX に `baseline_on/RX_BLE_to_SD.ino` をフラッシュ
4. 全ノードを接続、SDカード挿入
5. 外部電源ON → TX起動
6. 4グループ×複数トライアル自動実行 (約105分)
7. SDカードから `trial_XXX_on.csv`, `rx_trial_XXX.csv` を回収

### 6.3 途中から再開する場合

`TX_BLE_Adv.ino` の `START_GROUP_INDEX` を変更:

| 値 | 開始interval | 実行されるGroup |
|----|-------------|----------------|
| 0 | 100ms | 100 → 500 → 1000 → 2000 |
| 1 | 500ms | 500 → 1000 → 2000 |
| 2 | 1000ms | 1000 → 2000 |
| 3 | 2000ms | 2000 のみ |

---

## 7. ΔE/adv 算出方法

```
ΔE/adv = (E_total_ON - P_off × T) / N_adv
```

| 変数 | 説明 | 取得元 |
|------|------|--------|
| E_total_ON | ON計測の総エネルギー [mJ] | summary行の E_total_mJ |
| P_off | OFF計測の平均電力 [mW] | OFF計測のmean_p_mW |
| T | ON計測の総時間 [s] | summary行の ms_total / 1000 |
| N_adv | 広告送信回数 | summary行の adv_count (TICK計測) |

---

## 8. 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|---------|
| 2025-11-20 | v1.0 | 初版 (フェーズ0-0) |
| 2025-11-29 | v2.0 | ディレクトリ再編、INA219配線修正、ボーレート115200化、マルチinterval対応 |

### v2.0 主な変更点

1. **ディレクトリ構成変更**
   - `esp32_sweep/` → `esp32_firmware/{baseline_on, baseline_off, ccs_mode}/`

2. **INA219 VCC配線修正**
   - Vin-側からの分岐 → 外部電源から直接取る（ブラウンアウト対策）

3. **UARTボーレート変更**
   - 230400 → 115200 (ノイズ耐性向上)

4. **マルチinterval自動実行**
   - 100ms → 500ms → 1000ms → 2000ms を自動で順次実行
   - START_GROUP_INDEX で開始位置を指定可能

5. **ハードウェア明記**
   - ESP32-WROVER-E (ESP32-DevKitC-VE) を使用
   - INA219シャント抵抗 R100 (0.1Ω)
</file>

<file path="フェーズ0-0/要件定義.md">
以下は、**フェーズ0-0（先行デモ）要件定義書**です。フェーズ1で定義されたログ構造とKPIを維持しつつ、HARの完成を待たずにBLE安全バンディット系の評価を開始するための準備段階を示します。

# フェーズ0-0 要件定義書（先行デモ）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH0‑0‑v1.0  
**対象**: 擬似U/S信号によるCCS→広告間隔制御の検証  
**成功見込み**: 95%

## 1. 目的
- HAR（人的活動認識, Human Activity Recognition）非依存の擬似U（不確実度, Uncertainty）・S（安定度, Stability）を生成し、CCS（複合スコア, Composite score）→アドバタイズ間隔の全系を“動かす”。
- BLE安全バンディットに必要な期限超過率（Pout, τ）、初回到達遅延（Time-to-first-Receive, TL）、電力メトリクスの評価線をフェーズ1と同一スキーマで作成する。
- 後続フェーズに向けてログ、閾値、ヒステリシスの実装差分を最小化し、方策差し替えの準備を整える。

## 2. スコープと境界
- **対象機能**: BLEレガシー・アドバタイジング（BLE Legacy Advertising, 3チャネル固定）、アドバタイズ間隔（adv_interval）∈ {100, 500, 1000, 2000} ms、擬似U/Sに基づくCCS写像。
- **擬似信号仕様**:
  - `U_dummy = normalize(|acc|の窓内分散)`（高振幅=高不確実度）
  - `S_dummy = clamp(1 − ΔE_norm, 0, 1)`（エネルギー変化率が低いほど安定）
  - `CCS = 0.6×U_dummy + 0.4×(1 − S_dummy)` をヒステリシス±0.05で段階写像。
- **除外**: HARモデル実装、MAB/Safe‑MAB学習、チャネル可変、Tx電力最適化。

## 3. 成功指標と受入基準
- **期限超過率（Pout, τ=1 s）**: 固定100 ms条件と比較して違反率の増加が±0.5 pt以内。
- **平均電流**: 固定100 ms条件比で**≥5–10%削減**の傾向を確認（参考指標）。
- **イベント電荷**: フェーズ1の測定手順に従い±5%以内で再現。
- **ΔE/adv（イベントあたりのエネルギー増分）**: OFF（無線OFF）とON（無線ON）のエネルギー差を `ΔE/adv = (E_ON − E_OFF) / N_adv` として算出し、**省電力性の評価はこの指標を主語として行う**（測定系のベース電流を相殺し、純粋な「無線1回あたりのコスト」を見る）。
- **ログ完全性**: 欠損率<1%、U/S/CCS∈[0,1]、閾値・ヒステリシスの記録あり。

## 4. 主な作業レーン
1. 擬似U/S算出モジュールのパラメタ確定（窓長1.0 s、50%重畳、重力除去OFF）。
2. フォールバック（1000 ms）・ヒステリシス・最小滞在時間（≥2 s）の実装確認。
3. Runbook（`docs/フェーズ1/Runbook.md`）準拠の実験：環境E1/E2 × 条件5 × 各≥2反復。
4. KPI集計（期限超過率, Pout／初回到達遅延, TL p50/p95／平均電流／イベント電荷）と比較プロット。

## 5. 成果物
- 擬似U/S仕様書（式、パラメタ、正規化係数）。
- 実装時の設定ファイル（CCS閾値、ヒステリシス、最小滞在時間、フォールバック区分）。
- KPIレポート（固定基準との比較、95% CI付き）。
- ログ一式（送信・受信・電力・導出KPI）およびDecisionMeta。

## 6. リスクと緩和
- **擬似指標の過度な振動** → 移動平均（3窓）とヒステリシス強化で抑制。
- **振幅変動が環境依存** → 窓内標準化と環境別スケーリング係数をRunbookに記録。
- **評価遅延の偏り** → TLのCDFと期限超過率（Pout, τ=1/2/3 s）を必ず比較し、逸脱時はパラメタ調整。

## 7. フェーズ1との接続
- ログスキーマ、写像表、閾値定義はフェーズ1（弱い構成）と完全互換。
- 評価レポートはフェーズ1の要件定義に記載されたKPI差分表フォーマットを流用。
- 成果物はフェーズ1のPolicy Engineにそのまま供給でき、後続のHAR更新時は擬似U/Sを実U/Sに差し替えるだけで連続運用可能。
</file>

<file path="フェーズ0-1/phase0-1_to_phase1_handover.md">
# Phase0-1 → Phase1 ハンドオーバー（レター執筆向け・次AIへの指示）
更新日: 2025-11-26  
目的: Phase0-1での意思決定／要件調整／現状の到達点を整理し、Phase1担当AIがレター執筆と実験を継続できるようにする。

## 1. 背景とゴール
- ゴール: 「3軸の小型HAR + U/S/CCS で adv interval を動的制御し、固定100msより平均電流を5–10%削減しつつ Pout/TL を劣化させない」ことを実機で示す。
- レター論文は docs/paper 配下で執筆。BLE設計・非理想スキャン・制御戦略の考察は既存リサーチノートに集約。

## 2. 要件・優先度（調整済み）
- HAR/TinyML 必須: 4c BAcc ≥ 0.80（MUST）、Stationary↔Loc誤り ≤10%（MUST）。F1目標は 0.80–0.85 に柔軟化（当初0.85必須は厳しすぎと判断）。
- キャリブレーション: ECE(4c) 目標 0.05（0.05–0.10 なら注記の上可）、Unknown率 5–15%。
- TinyML: t_inf ≤20ms @ESP32-S3、Arena ≤64–80KB、TFLiteサイズ目標22KB（多少の超過は理由付きで可）。
- BLE KPI: 平均電流 5–10% 改善 vs 100ms、Pout(1s)+1pt以内、TL p95 +10%以内、再現性±5%。

## 3. モデル現状
- A0（参照）: 3軸 acc.v1, params 63,180, TFLite 92,768B。fold90 test: 12c BAcc 0.828 / 4c BAcc 0.960 / 4c F1 0.7345 / ECE≈0.092 / Unknown≈4.35%。PT↔TFLite: 0.98 / MAE 0.0277。
- A_tiny（現行 v2_tiny, stem32/dw48-64/FC64, dropout0.2）: fold90 test: 12c BAcc 0.858 / 4c BAcc 0.730 / 4c F1 0.728（4c未達）。TFLite未生成/未測定。
- 課題: fold90特有の4c性能低下。TFLiteサイズ・FLOPs・Reliability図・方向別混同行列が未取得。

## 4. 次AIへの最優先TODO（Phase1開始前）
1) A_tiny改良 or 代替幅の検討  
   - 4c BAcc ≥0.80・Stationary誤り≤10%を満たすまで微調整（層/幅/FC/epoch）。fold90で固定条件。  
   - 4c F1は 0.80–0.85 で現実ライン設定（A0が0.734）。
2) 量子化・TFLite計測  
   - PTQ int8（rep_data.npy）→ TFLiteサイズ実測、PT↔TFLite一致率/MAE取得。  
   - TFLite出力で τ/θ_low/high を再キャリブ。Reliability図と4c混同行列（方向別誤り）を生成。  
   - FLOPs、モデルパラメータ精算、TFLite SHA256記録。
3) ESP32-S3 実測  
   - t_inf（avg/p95, 1000回, esp-nn有無明記）、Arena最小/推奨を測定。  
4) BLE実験設計・実施  
   - Policy: ACTIVE(100ms)/UNCERTAIN(500ms)/QUIET(2000ms), θ_low/high, ヒステリシス, min_stay=2s, max_rate=1Hz, fallback=1000ms。  
   - 条件: 固定{100,500,1000,2000} + 不確実度（A_tiny）× 環境E1/E2 × ≥3反復。  
   - ログ: TX(CCS/U/S/adv_interval), TXSD(ΔE/adv, avg current), RX(Pout 1/2/3s, TL p50/p95)。  
   - KPI判定を表にまとめる。
5) レター執筆  
   - 仕様書 `har/001/docs/A_tiny_paper_spec_acm_ieee.md` をベースに、docs/paper のインデックスとリサーチノートを参照。  
   - 参考図表: モデルレイヤ表、4c混同行列、Reliability図、BLE状態遷移図、総合サマリ表（HAR/Calibration/TinyML/BLE）。

## 5. 重要な意思決定（履歴）
- 要件緩和: 4c F1 必須0.85→現実ライン0.80–0.85、サイズ22KBは目標（理由付き超過可）。  
- 評価軸: BLE制御に直結する4c/Stationary誤りを最優先、12cは監視レベル。  
- CCS定義: conf=max_prob, CCS=0.7*conf+0.3*S、θ_low/highは再キャリブ前提（旧0.40/0.70）。  
- ポリシー: ACTIVE/UNCERTAIN/QUIET 3状態、ヒステリシス±0.05, min_stay=2s, max_rate=1Hz, fallback=1000ms。  
- 非理想スキャン・KPI考察は docs/paper のリサーチノートを正にする（har/配下には書かない）。

## 6. 参照パス（主要）
- 仕様: `har/001/docs/A_tiny_paper_spec_acm_ieee.md`
- Tiny実験: `har/004/configs/phase0-1.acc.v2_tiny.yaml`, `har/004/tools/train_phase0-1_tiny.py`, `har/004/runs/phase0-1-acc-tiny/fold90/metrics.json`
- A0: `har/001/docs/A0_acc_v1_baseline_summary.md`, `har/004/runs/phase0-1-acc/fold90/metrics.json`, `har/004/export/acc_v1_keras/manifest.json`
- 分割: `docs/フェーズ0-1/splits_subject90.yaml`
- BLE要件: `docs/フェーズ1/要件定義.md`
- リサーチノート（考察枠）: `docs/paper/BLE非理想スキャン_RL最適化_リサーチノート.md`, `docs/paper/literature_review_ble_dynamic_adv.md`, `docs/paper/TinyML制約付き学習_リサーチノート.md`, `docs/paper/不確実性駆動送信制御_リサーチノート.md`
- インデックス: `docs/paper/index.md`

## 7. 未完タスク（明示）
- A_tiny: 4c性能回復、TFLite生成/誤差/サイズ、FLOPs算出、Reliability図、4c混同行列（方向別）、τ/θ再キャリブ。
- ESP32: t_inf・Arena計測（esp-nn有/無明記）。
- BLE実験: 条件別 KPI 表作成（省電力/品質/再現性）。

## 8. 注意（編集禁止領域）
- `docs/フェーズ0-1/` はマスター（変更禁止）。参照のみ。
- BLE KPI・非理想スキャンの考察は `docs/paper` 側に集約し、har/ 配下には書かない。
</file>

<file path="フェーズ0-1/splits_subject90.yaml">
folds:
  - id: fold90
    train: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    val: []        # 空の場合はtrainからval_ratioでサブサンプル
    test: [10]
</file>

<file path="フェーズ0-1/splits.yaml">
folds:
  - id: fold1
    test: [1]
    val: [2]
    train: [3,4,5,6,7,8,9,10]
  - id: fold2
    test: [2]
    val: [3]
    train: [1,4,5,6,7,8,9,10]
  - id: fold3
    test: [3]
    val: [4]
    train: [1,2,5,6,7,8,9,10]
  - id: fold4
    test: [4]
    val: [5]
    train: [1,2,3,6,7,8,9,10]
  - id: fold5
    test: [5]
    val: [6]
    train: [1,2,3,4,7,8,9,10]
  - id: fold6
    test: [6]
    val: [7]
    train: [1,2,3,4,5,8,9,10]
  - id: fold7
    test: [7]
    val: [8]
    train: [1,2,3,4,5,6,9,10]
  - id: fold8
    test: [8]
    val: [9]
    train: [1,2,3,4,5,6,7,10]
  - id: fold9
    test: [9]
    val: [10]
    train: [1,2,3,4,5,6,7,8]
  - id: fold10
    test: [10]
    val: [1]
    train: [2,3,4,5,6,7,8,9]
</file>

<file path="フェーズ0-1/要件定義.md">
以下は、**フェーズ0-1（データ整合リファイン）要件定義書**です。フェーズ1のポリシ全体像を維持しつつ、mHealth胸装着データに合わせたHARモデルの再学習と較正を通じて安定したU/S/CCSを提供することを目的とします。

# フェーズ0-1 要件定義書（データ整合リファイン）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH0‑1‑v1.0  
**対象**: mHealth胸装着データへのモデル転移と較正  
**成功見込み**: 70–80%

## 1. 目的
- モデル入力（軸・窓長・前処理）をmHealth胸装着データに合わせ、U（不確実度, Uncertainty）とCCS（複合スコア, Composite score）が素直に機能する状態を再構築する。
- フェーズ1の決め打ち写像とBLE計測を止めずに、HAR推論部のみを差し替え可能な形式で提供する。
- バランス精度（Balanced Accuracy）≥0.80、期待較正誤差（Expected Calibration Error, ECE）≤0.05、未知率（Unknown rate）5–15%を満たし、BLE評価へ合流する。

## 2. スコープと境界
- **対象処理**: 6軸（加速度＋ジャイロ）入力、窓長1.5–2.0 s、50%重畳、被験者別z-score正規化、温度スケーリングによる較正。
- **モデル更新**: 既存DS‑CNN系の最後の畳み込みブロックまでを凍結し、分類ヘッドを再学習。必要に応じて最終ブロックのみ解凍。
- **データ前処理緩和**: 窓純度しきい値0.7–0.8、境界除外±0.25–0.5 s、HPFは0.4 Hzに緩和。
- **除外**: 完全な新規モデル探索、MAB方策の更新、BLEチャネル制御。

## 3. 成功指標と受入基準
- **バランス精度（Balanced Accuracy）**: Validationで≥0.80（12クラス維持）。
- **マクロ平均F1スコア（F1 macro）**: フェーズ1既定モデル比で上昇し、動的クラスの崩落を解消。
- **期待較正誤差（Expected Calibration Error, ECE）**: ≤0.05（温度スケーリング適用後）。
- **未知率（Unknown rate）**: 5–15%（最大確率<τでUnknown、τは適合率-再現率曲線（Precision-Recall, PR）で最適化）。
- **CCS挙動**: 高U時にACTIVE（100 ms）へ、低U/S高時にQUIET（2000 ms）へ遷移する正負例タイムラインを確認。

## 4. 主な作業レーン
1. データ同期・整形: 6軸化、欠損補間、被験者別z-score、窓長2.0 s（比較として1.5 sも評価）。
2. モデル転移: 既存重み読み込み→ヘッド再学習→必要時に最終DWConvも解凍→量子化（QAT optional）。
3. 較正と閾値決定: 温度スケーリングでECEを0.05以下に調整し、{θ_low, θ_high}を受信者操作特性（Receiver Operating Characteristic, ROC）と適合率-再現率曲線（Precision-Recall, PR）で決定。
4. BLE接続評価: フェーズ0-0の評価線を流用し、U/S/CCSを差し替えてPout、TL、電力の変化を測定。

## 5. 成果物
- データ前処理仕様（窓長、重畳、純度、境界、フィルタ、正規化）。
- 再学習レポート（バランス精度, Balanced Accuracy／マクロ平均F1スコア, F1 macro／期待較正誤差, Expected Calibration Error／未知率, Unknown rate／混同行列）。
- 温度スケーリング係数Tと新しきい値{θ_low, θ_high}（Runbook差し替え用）。
- 更新後`.tflite`モデル、Arena/t_inf計測ログ、写像テーブルへの反映手順。

## 6. リスクと緩和
- **分布シフトの過小評価** → 6軸化・窓延長・HPF緩和をセットで適用し、再現データでA/B比較。
- **学習データ不足** → 窓純度しきい値を0.7–0.8に緩和し、被験者分割のfoldを増やす。
- **Unknownしきい値の不一致** → PRカーブでτを決定し、フェーズ1 Runbookにしきい値マッピングを追記。

## 7. フェーズ1との接続
- Policy EngineとBLE Advertiserはフェーズ1設計のまま使用し、HarOutのU/S/CCSのみを差し替える。
- ログスキーマ（model_id, calib_T, window_len, overlap, W_sec）はフェーズ1フォーマットを継続。
- 合格後はフェーズ1要件定義のFR‑2/FR‑3評価に本接続し、MAB導入前の初期方策としてWarm‑startを提供する。

---

# フェーズ0–1 要件定義 v0.1（HAR→BLE接続のための最小決めごと）

## 1) データ仕様（mHealth; chest 前提）

**決めること**

* サンプリング周波数: **50 Hz**
* 単位: **m/s²（加速度）**, **deg/s（ジャイロ）**（異なる場合はスケール変換）
* 軸順序: **Acc[X,Y,Z], Gyro[X,Y,Z]**（右手系; ファイルの列順に合わせて変換）
* 姿勢: 胸センサの**装着方向**（X: 左↔右, Y: 下↔上, Z: 背↔胸）。不明時は**重力ベクトルで補正**（低域通過でg推定）。
* 6軸化: **可**。欠損処理は**線形補間（≤200 ms）/ それ以上は窓ごと除外**。
* データ出所・版管理: `data/MHEALTHDATASET/` 配下に **README.md**, **SHA256.txt**（全ファイルのハッシュ）を置く。

**SHAの作り方（例）**

```bash
find data/MHEALTHDATASET -type f -exec shasum -a 256 {} \; | sort > data/MHEALTHDATASET/SHA256.txt
```

---

## 2) クラス設計（内部12→運用クラス）

**原則**

* 学習は**内部12クラス**（mHealth定義準拠）で実施 → 運用で**後段マッピング**（情報落ちを回避）。
* Unknownは**学習に含めない**（推論時に閾値で排他）。

**マッピング表（例）**
（※語は短縮：Sta=Stationary, Wal=Walking, Jog=Jogging, Run=Running, Bik=Cycling, UpS=Upstairs, DnS=Downstairs, Sit=Sit, Stan=Stand, Lie=Lie, Tras=Transport, Null=Null）

| 内部12 | 運用4        |
| ---- | ---------- |
| Sta  | Locomotion |
| Wal  | Locomotion |
| Jog  | Locomotion |
| Run  | Locomotion |
| Bik  | Locomotion |
| UpS  | Transition |
| DnS  | Transition |
| Sit  | Stationary |
| Stan | Stationary |
| Lie  | Stationary |
| Tras | Ignore     |
| Null | Ignore     |

**併合/除外の基準**

* **Ignore**は評価から除外（train: Hard negativeとして使わない）
* デモ段階は運用4に合算してメトリクスも出す（12も保存）

---

## 3) 分割戦略

* スキーム: **LOSO 5-fold（subject-wise）**
* 例（仮）: `fold-1: train=[S2..S9], val=[S10], test=[S1]` …（全foldでローテーション）
* seed: **42** 固定（NumPy/torch/TF）

**追記ファイル**

* `docs/フェーズ0-1/splits.yaml` に fold ごとの **train/val/test subject_id** を列挙

---

## 4) 前処理パラメータ（デフォルト）

* 入力: **6軸（Acc+Gyro）**
* 窓: **2.0 s**, **50%重畳**
* HPF: **0.4 Hz（一階）**（重力除去は過剰適用せず）
* 正規化: **被験者別 z-score**
* 窓純度: **≥0.75**
* 境界除外: **±0.25 s**
* 安定度Sの窓: **W=10 s**（ラベル遷移/代理指標用）

---

## 5) 学習・較正・評価（最小一式）

**学習**

* Optim: **Adam**, lr=**1e-3**, batch=**256**, max **80** epoch, **early-stop=10**, weight decay **1e-4**
* 損失: **重み付きCE**（クラス頻度逆数で正規化）
* 増強: **±10% 時間伸縮**, **±5° ランダム回転**, **白色ノイズ SNR>20dB**

**較正**

* **ECE**: **等頻度 15-bin**
* **温度スケーリング**: val で **T** を最小化（NLL/ECE両監視）→ **T** を保存

**Unknown判定**

* ルール: **max-softmax < τ** → **Unknown**
* τの決め方: valで **Unknownカバレッジ 5–15%** のレンジで **F1macro** 最大の τ を選ぶ（PRで確認）

**CCSの閾値（θ_low/θ_high）**

* CCS = **0.6·U + 0.4·(1−S)**  
  （注：フェーズ1の統一式〔CCS=0.7×confidence+0.3×stability〕との整合はP1で再較正し、Runbookの置換表に反映）
* val で **ROC/PR**を引き、**低頻度(2000ms)**, **中(500ms)**, **高(100ms)** の3段切替を最適化
* デフォルト初期値: **θ_high=0.70 / θ_low=0.40**, 最小滞在 **2 s**, 切替回数**≤1回/s**

**評価指標**

* **Balanced Accuracy**, **F1(macro)**, **ECE**, **Unknown率**, **推論レイテンシ**
* 運用4クラスに合算した **BAcc/F1** も併記

---

## 6) デプロイ仕様（TinyML）

* 量子化: **PTQ**（per-channel conv）→ 改善余地あれば **QAT 8–15 epoch**
* 校正データ: **2k 窓**（被験者横断）
* TFLM: **Op互換確認**（Conv, DWConv, Add, Mul, Relu/ReLU6, AvgPool, Softmax）
* モデル命名: `model_id=HAR_chest6x_2s_vYYMMDD_NN`
* リソース計測: **Arena ≤ 80 KB, t_inf ≤ 20 ms @240 MHz**（実測値を `docs/フェーズ0-1/deploy_metrics.md` に追記）

---

## 7) ログ拡張（再現用メタ）

**列追加（推奨）**

* `subject_id, activity_id, dataset_version, preproc_hash, split_id, model_id, calib_T, tau_unknown, theta_low, theta_high`

**設定ハッシュ**

* `preproc_hash = SHA256(窓/HPF/zscore/純度/境界/増強のJSON)`
* `run_hash = SHA256(preproc_hash + split_id + model_id + seed)`

---

## 8) ゲート / フォールバック（レーン移行）

* **Go to BLE本接続（レーン1→2）**:
  `BAcc ≥ 0.80` **かつ** `ECE ≤ 0.05` **かつ** `Unknown 5–15%`
* **Fallback（腰寄せ or 擬似U/Sで進行）**:
  `BAcc < 0.80` **または** `ECE > 0.05` を **2 回の微調整**後も満たせない場合、**レーン2**へ移行
  （締切目安：**3実験日 or 2 iteration**）

---

# 付録A：設定ファイルの雛形

**`configs/phase0-1.yaml`**

```yaml
data:
  fs_hz: 50
  axes: [AccX, AccY, AccZ, GyroX, GyroY, GyroZ]
  unit: {acc: "m/s2", gyro: "deg/s"}
  posture: {x: "left->right", y: "down->up", z: "back->chest"}
  missing: {interp_ms_max: 200, drop_window_if_exceeds: true}
  version: "mhealth_v1"
window:
  length_s: 2.0
  hop_s: 1.0
  purity_min: 0.75
  boundary_exclude_s: 0.25
preprocess:
  hpf_hz: 0.4
  zscore_scope: "per_subject"
split:
  scheme: "LOSO_5fold"
  seed: 42
train:
  optim: "adam"
  lr: 1e-3
  batch: 256
  max_epoch: 80
  early_stop_patience: 10
  weight_decay: 1e-4
  loss: "weighted_ce"
  aug: {time_stretch: 0.1, rot_deg: 5, noise_snr_db: 20}
calibration:
  ece_bins: 15
  ece_binning: "equal_frequency"
  temp_scale: true
unknown:
  tau_target_coverage: [0.05, 0.15]
  select_by: "max_F1_macro"
ccs:
  alpha: 0.6  # U weight
  beta: 0.4   # (1-S)
  theta_low: 0.40
  theta_high: 0.70
  min_stay_s: 2.0
  max_switch_per_s: 1
deploy:
  quant: {ptq: true, qat: false, calib_windows: 2000, per_channel: true}
  limits: {arena_kb_max: 80, t_inf_ms_max: 20}
```

---

# 付録B：評価プロトコル（要点だけ）

1. **分割固定** → train で学習 → val で **T, τ, θ** を確定 → test で**一回**評価
2. **指標**：BAcc/F1macro（12 & 運用4）、ECE、Unknown率、t_inf、Arena
3. **ログ**：`*_summary.json` に **seed, split_id, preproc_hash, model_id, calib_T, tau, theta** を必ず保存
4. **BLE接続の準備**：`pred.csv` に `entropy, U, S, CCS` を列追加（BLE側がそのまま読める）

---

# 付録C：小さなFAQ（詰まり回避）

* **GMP(wl=24)で0.43の頭打ち** → **6軸化 & 窓2s**にまず上げる。3軸×短窓は胸では厳しい。
* **Jog/Run/BikがStairs/Staに崩れる** → HPFを弱く、**ジャイロ追加**、**2s窓**で周期特徴を回収。
* **サンプルが少ない**（純度/境界除外で激減）→ **純度0.75/境界0.25s**へ緩和。
* **Uが暴れる** → **温度スケーリング＋移動平均（3–5窓）＋ヒステリシス**。

---

# 次アクション（30分でできること）

1. `configs/phase0-1.yaml` をリポジトリに追加
2. `docs/フェーズ0-1/要件定義.md` に本内容のコピペ＋分割表（splits.yaml）を作成
3. mHealth配下の**SHA256.txt**を作成
4. 既存スクリプトのログ列に**preproc_hash, split_id, model_id, calib_T, tau, theta**を追加
</file>

<file path="フェーズ0-2/要件定義.md">
以下は、**フェーズ0-2（腰装着フォールバック）要件定義書**です。フェーズ1で定義した評価系を維持しつつ、高精度かつ安定した不確実度を短期間で確保するための保険レーンと追加伸びしろを整理します。

# フェーズ0-2 要件定義書（腰装着フォールバック）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH0‑2‑v1.0  
**対象**: 腰装着データの迅速取得・学習および早期出口の評価  
**成功見込み**: 80–90%（腰データ）、60–70%（早期出口）

## 1. 目的
- 腰装着シナリオ向けに正解率（Accuracy）とバランス精度（Balanced Accuracy）≥0.90、期待較正誤差（Expected Calibration Error, ECE）≤0.03のHARモデルを短期間で確立し、BLE評価の母体を確保する。
- BLE安全バンディット評価を止めずに、腰データ版のU/S/CCSを供給し、フェーズ1のKPI算出を継続する。
- 余力がある場合は早期出口（Early-exit）構成を試験し、推論エネルギーとUの一貫性を改善する。

## 2. スコープと境界
- **腰ミニ計測**: 静止/歩行/走行/階段 × 各1分（計≈4分）、必要に応じて追加クラス（上下昇降等）。
- **代替データ**: 公開腰装着データセット（4–6クラス）を利用する場合はセンサ軸を合わせ、Runbookに出典・SHA256を記録。
- **モデル**: 小型1D-CNN（例: DS‑CNN 4–6クラス版）をゼロから学習、量子化（int8）、Arena ≤64 KB、t_inf ≤10 ms。
- **評価**: バランス精度（Balanced Accuracy）/マクロ平均F1スコア（F1 macro）、期待較正誤差（Expected Calibration Error, ECE）、未知率（Unknown rate）、Uの秩序性（易→低U、難→高U）を測定。
- **除外**: BLEチャネル集合変更、MAB導入、長期オンライン学習。

## 3. 成功指標と受入基準
- **正解率/バランス精度（Accuracy/Balanced Accuracy）**: Validationで≥0.90。
- **期待較正誤差（Expected Calibration Error, ECE）**: ≤0.03（温度スケーリング適用後）。
- **未知率（Unknown rate）**: 5–15%、秩序性テストで難クラス時のUが閾値を超過。
- **BLE指標**: フェーズ0-0の擬似U/S比較で期限超過率（Pout, τ=1/2/3 s）が同等以内、平均電流は腰モデルでも削減効果が維持。
- **早期出口（任意）**: 平均t_infを≥10%削減し、マクロ平均F1スコア（F1 macro）低下≤1.0 pt、Pout(1 s)/TL p95に悪化なし。

## 4. 主な作業レーン
1. 計測/データ収集: ミニセッション撮影、姿勢・装着位置の記録、センサ校正ログ取得。
2. 学習: 小型CNNで学習→被験者内/被験者間評価→量子化→Arena/t_inf計測。
3. 較正: 温度スケーリングでECE ≤0.03に合わせ、Unknown閾値τを適合率-再現率曲線（Precision-Recall, PR）から決定。
4. BLE統合: HarOut（腰モデル）をフェーズ1 Policy Engineへ供給し、Pout・TL・電力を評価。
5. 余力（レーン3）: 多出口CNN＋出力ブロック予測器を試験し、推論エネルギー削減とUの階調改善を観測。

## 5. 成果物
- データ取得メモ（環境、姿勢、収録時刻、端末設定）、公開データ利用時は出典・バージョン・SHA256。
- 腰モデル仕様書（アーキテクチャ、パラメタ数、Arena、t_inf、量子化情報）。
- 評価レポート（正解率/バランス精度, Accuracy/Balanced Accuracy／マクロ平均F1スコア, F1 macro／期待較正誤差, Expected Calibration Error／未知挙動／U秩序性／可視化：混同行列・TL/Pout比較）。
- 早期出口検証ノート（ON/OFF比較、エネルギー/レイテンシ差分、閾値設定）。

## 6. リスクと緩和
- **3分計測の品質不足** → 被験者2名以上・各条件≥1分を推奨、足りない場合は公開データで補完。
- **腰と胸のCCS差異** → ウィンドウパラメタとUnknown閾値を独立管理し、Runbookに両者の対照表を追加。
- **早期出口の不安定化** → Exit判定をHAR出力後移動平均で平滑、Uが暴発する場合はExit無効化でフォールバック。

## 7. フェーズ1との接続
- BLE評価系、ログスキーマ、KPI算出はフェーズ1の要件・設計文書をそのまま利用する。
- フェーズ0-2の成果でバランス精度（Balanced Accuracy）≥0.90、期待較正誤差（Expected Calibration Error, ECE）≤0.03を達成した場合、フェーズ1のFR‑2/FR‑5を腰モデルで先行検証できる。
- フェーズ0-1の準備が完了したら、本フェーズで得た腰モデルは比較ベースラインとして保持し、MAB導入時の安全側アーム生成に活用する。
</file>

<file path="フェーズ1/results/delta_energy_row1120_row1123_off.md">
# ΔE/adv (flex patterns, time-scaled OFF)

- ON dir: `data/実験データ/研究室/row_1120/TX`
- OFF dir: `data/実験データ/研究室/row_1123_off/TX`
- manifest: `experiments_manifest.yaml` (include=false skipped)
- MAD filter: upper = median + 3.0 * MAD on P_off_trial
- OFF trials kept: 7/7
- OFF mean E_total_mJ (raw, pre-MAD): 1326.381
- OFF mean P_mW (after filters): 22.106

|interval_ms|on_trials|P_off_mW|ΔE_per_adv_mJ_mean|ΔE_per_adv_mJ_std|ΔE_per_adv_µJ_mean|
|---|---|---|---|---|---|
|100|10|22.106|2.256817|0.162236|2256.82|
|500|10|22.106|9.760084|0.339166|9760.08|
|1000|4|22.106|19.661114|0.133517|19661.11|
|2000|2|22.106|39.481759|0.063065|39481.76|
</file>

<file path="フェーズ1/results/pdr_row1120_txsd_rx.md">
# PDR (TXSD + RX join)

- TXSD dir: `data/実験データ/研究室/row_1120/TX`
- RX dir: `data/実験データ/研究室/row_1120/RX`
- manifest: `experiments_manifest.yaml` (include=false skipped)

|interval_ms|file|adv_count|rx_count_raw|rx_count_unique|PDR_raw|PDR_unique|PDR_ms|PDR_raw_clip|PDR_unique_clip|PDR_ms_clip|ms_on|ms_rx|
|---|---|---|---|---|---|---|---|---|---|---|---|
|100|1m_on_100_001.csv|222|258|254|1.162|1.144|0.861|1.000|1.000|0.861|22141|29501|
|100|1m_on_100_002.csv|221|243|239|1.100|1.081|0.798|1.000|1.000|0.798|22035|29947|
|100|1m_on_100_003.csv|220|253|245|1.150|1.114|0.819|1.000|1.000|0.819|21928|29926|
|100|1m_on_100_004.csv|219|245|238|1.119|1.087|0.795|1.000|1.000|0.795|21820|29944|
|100|1m_on_100_005.csv|218|254|247|1.165|1.133|0.827|1.000|1.000|0.827|21713|29875|
|100|1m_on_100_006.csv|216|240|233|1.111|1.079|0.779|1.000|1.000|0.779|21598|29917|
|100|1m_on_100_007.csv|215|252|246|1.172|1.144|0.823|1.000|1.000|0.823|21489|29897|
|100|1m_on_100_008.csv|214|251|245|1.173|1.145|0.820|1.000|1.000|0.820|21397|29880|
|100|1m_on_100_009.csv|213|247|240|1.160|1.127|0.803|1.000|1.000|0.803|21272|29891|
|100|1m_on_100_010.csv|212|250|243|1.179|1.146|0.814|1.000|1.000|0.814|21165|29865|
|500|1m_on_500_001.csv|283|256|249|0.905|0.880|0.833|0.905|0.880|0.833|141013|149426|
|500|1m_on_500_002.csv|282|258|251|0.915|0.890|0.840|0.915|0.890|0.840|140937|149383|
|500|1m_on_500_003.csv|282|267|259|0.947|0.918|0.864|0.947|0.918|0.864|140827|149870|
|500|1m_on_500_004.csv|282|255|250|0.904|0.887|0.834|0.904|0.887|0.834|140711|149841|
|500|1m_on_500_005.csv|282|263|255|0.933|0.904|0.853|0.933|0.904|0.853|140597|149397|
|500|1m_on_500_006.csv|281|258|251|0.918|0.893|0.840|0.918|0.893|0.840|140472|149433|
|500|1m_on_500_007.csv|281|252|245|0.897|0.872|0.819|0.897|0.872|0.819|140364|149509|
|500|1m_on_500_008.csv|281|271|264|0.964|0.940|0.886|0.964|0.940|0.886|140246|149008|
|500|1m_on_500_009.csv|281|257|252|0.915|0.897|0.842|0.915|0.897|0.842|140128|149637|
|500|1m_on_500_010.csv|281|257|251|0.915|0.893|0.839|0.915|0.893|0.839|140015|149569|
|1000|1m_on_1000_001.csv|290|268|262|0.924|0.903|0.876|0.924|0.903|0.876|289905|299248|
|1000|1m_on_1000_002.csv|290|271|263|0.934|0.907|0.880|0.934|0.907|0.880|289781|298772|
|1000|1m_on_1000_003.csv|290|266|261|0.917|0.900|0.875|0.917|0.900|0.875|289661|298316|
|1000|1m_on_1000_004.csv|290|263|256|0.907|0.883|0.857|0.907|0.883|0.857|289540|298823|
|2000|1m_on_2000_001.csv|295|268|260|0.908|0.881|0.868|0.908|0.881|0.868|589146|599094|
|2000|1m_on_2000_002.csv|295|272|264|0.922|0.895|0.884|0.922|0.895|0.884|589058|597607|

## Interval summary
|interval_ms|trials|PDR_raw_mean|PDR_raw_std|PDR_unique_mean|PDR_unique_std|PDR_ms_mean|PDR_ms_std|PDR_raw_clip_mean|PDR_unique_clip_mean|PDR_ms_clip_mean|adv_mean|rx_raw_mean|rx_unique_mean|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|100|10|1.149|0.027|1.120|0.027|0.814|0.021|1.000|1.000|0.814|217.0|249.3|243.0|
|500|10|0.921|0.020|0.897|0.019|0.845|0.018|0.921|0.897|0.845|281.6|259.4|252.7|
|1000|4|0.921|0.010|0.898|0.009|0.872|0.009|0.921|0.898|0.872|290.0|267.0|260.5|
|2000|2|0.915|0.007|0.888|0.007|0.876|0.008|0.915|0.888|0.876|295.0|270.0|262.0|
</file>

<file path="フェーズ1/results/phase1_summary.md">
# フェーズ1 基準セットサマリ（row_1120 ON × row_1123_off OFF, manifest+MAD適用）

- OFF baseline: P_off_mean ≈ 22.106 mW（row_1123_off, keep 7/7, MAD=3）
- ΔE/adv (mJ/adv, mean ± std):
  - 100ms: 2.2568 ± 0.1622
  - 500ms: 9.7601 ± 0.3392
  - 1000ms: 19.6611 ± 0.1335（1 trial high_current_outlier 除外）
  - 2000ms: 39.4818 ± 0.0631
- PDR (TXSD+RX join, `--dedup-seq`, `--clip-pdr`):
  - PDR_ms (正式, clip済): 100=0.814, 500=0.845, 1000=0.872, 2000=0.876
  - 参考: PDR_raw_mean 100=1.149, 500=0.921, 1000=0.921, 2000=0.915 / PDR_unique_mean 100=1.120, 500=0.897, 1000=0.898, 2000=0.888
- ソース:
  - ΔE/adv: `docs/フェーズ1/results/delta_energy_row1120_row1123_off.md`
  - PDR: `docs/フェーズ1/results/pdr_row1120_txsd_rx.md`

備考:
- ON: ADV 300回送出設計。manifest で high_current_outlier (median+3MAD) を除外。
- OFF: 60s固定窓、P_off_trial に median+3MAD 適用。高基線は manifest で include=false。
</file>

<file path="フェーズ1/実験設計書.md">
# Phase 1 実験設計書: 決め打ちルールの評価

## 1. 実験の目的

1. **CCS制御の省エネ効果**を固定間隔と比較して定量化
2. **Pout(τ)モデルの妥当性**を実測で検証
3. **Pout-μCトレードオフ曲線**を描く

---

## 2. 実験条件

### 2.1 環境条件

| 項目 | 値 | 備考 |
|------|-----|------|
| 環境 | E1（干渉弱）, E2（干渉強） | 2環境で評価 |
| 距離 | 1m | フェーズ0-0と同条件 |
| Tx Power | 0 dBm | 固定 |
| スキャンモード | Android LOW_LATENCY | 固定 |

### 2.2 制御条件（3条件）

| 条件ID | 条件名 | T_adv | 説明 |
|--------|--------|-------|------|
| C1 | FIXED-100 | 100ms固定 | 高エネルギー・低遅延ベースライン |
| C2 | FIXED-2000 | 2000ms固定 | 低エネルギー・高遅延ベースライン |
| C3 | CCS | 100/500/2000ms可変 | 提案手法 |

### 2.3 反復設計

```
3条件 × 2環境 × 10セッション = 60セッション
```

- 各条件・環境の組み合わせで10回反復
- 総実験時間: 60 × 15分 = 15時間

---

## 3. セッション構成

### 3.1 1セッションの流れ（15分）

| 時間 | 活動 | 期待CCS | 期待T_adv（CCS条件） |
|------|------|---------|---------------------|
| 0-5分 | 座位（Stationary） | 高（≥0.70） | 2000ms |
| 5-10分 | 歩行（Locomotion） | 中〜低 | 500ms or 100ms |
| 10-15分 | 座位（Stationary） | 高（≥0.70） | 2000ms |

### 3.2 活動遷移イベント

1セッションで**2回の活動遷移**:
- 5分時点: 座位→歩行
- 10分時点: 歩行→座位

**評価対象**: この遷移時点でのPout(τ)とTL

### 3.3 データソース

- **mHealth CCS時系列**を事前計算し、ESP32で再生
- 実際の人間の動きではなく、**CCS時系列のリプレイ**で再現性を確保

---

## 4. 計測項目

### 4.1 計測機器

| 項目 | 機器 | 計測対象 |
|------|------|---------|
| 電力 | PPK-II | ESP32のVBAT電流 |
| 送信ログ | ESP32 SD | timestamp, T_adv, CCS, U, S |
| 受信ログ | Android | timestamp, RSSI, seq |
| 同期マーカー | LED/GPIO | セッション開始・終了 |

### 4.2 ログスキーマ

**Txログ（ESP32）**:
```
timestamp_ms, session_id, seq, T_adv, CCS, U, S, activity_label
```

**Rxログ（Android）**:
```
timestamp_ms, session_id, seq, rssi, rx_channel
```

**Powerログ（PPK-II）**:
```
timestamp_ms, current_uA, voltage_mV
```

---

## 5. データ処理

### 5.1 μC/event算出

```
μC_event = (E_on - P_baseline × T_on) / N_event
```

| 変数 | 定義 | 取得方法 |
|------|------|---------|
| E_on | セッション総エネルギー [μJ] | PPK-II積分 |
| P_baseline | ベースライン電力 [mW] | 22.1mW（フェーズ0-0実測） |
| T_on | セッション時間 [s] | 900s |
| N_event | 活動遷移イベント数 | 2 |

### 5.2 Pout(τ)算出

```
TL_j = t_rx_first(j) - t_event_start(j)
Pout(τ) = count(TL_j > τ) / N_event
```

| 変数 | 定義 |
|------|------|
| t_event_start(j) | 活動遷移jの開始時刻（CCS変化点） |
| t_rx_first(j) | 遷移j後の最初の受信時刻 |
| TL_j | 遷移jのTime-to-first-Receive |
| τ | 許容遅延（1s, 2s, 3sで評価） |

### 5.3 理論値との比較

**Pout(τ)の理論モデル**:
```
Pout_theory(τ | T_adv) = (1 - p_d)^⌊τ / T_adv⌋
```

- p_d = 0.85（フェーズ0-0実測）
- 理論値と実測値のトレンド一致を検証

---

## 6. 評価指標

### 6.1 一次指標

| 指標 | 計算式 | 比較方法 |
|------|--------|---------|
| μC/event | mean(μC_event) per session | 3条件で比較、95%CI付き |
| Pout(τ) | 上記、τ=1,2,3s | 3条件で比較 |
| TL_p50, TL_p95 | percentile(TL_j) | 分布比較 |

### 6.2 二次指標

| 指標 | 計算式 | 目的 |
|------|--------|------|
| 省エネ率 | 1 - μC_CCS / μC_FIXED100 | 提案手法の効果 |
| Pout改善率 | 1 - Pout_CCS / Pout_FIXED2000 | QoS改善効果 |
| PDR | N_rx / N_tx | 参考値 |

### 6.3 トレードオフ曲線

- **X軸**: μC/event
- **Y軸**: Pout(τ=2s)
- **プロット**: 3条件（FIXED-100, FIXED-2000, CCS）
- **重ね書き**: 理論曲線

---

## 7. 成功基準

### 7.1 最低ライン（レター成立）

| 基準 | 条件 |
|------|------|
| 省エネ効果 | μC_CCS < μC_FIXED100 (p < 0.05) |
| QoS維持 | Pout_CCS(2s) ≤ Pout_FIXED100(2s) + 0.01 |
| モデル妥当性 | 理論と実測のトレンド一致（相関係数 ≥ 0.8） |

### 7.2 理想ライン（強いレター）

| 基準 | 条件 |
|------|------|
| 省エネ率 | ≥ 30% |
| Uの有用性 | CCS制御 vs 活動種別のみ制御 のアブレーション |
| オフラインSim | Safe-UCBシミュレーション1図 |

---

## 8. 実験手順

### 8.1 準備

1. mHealth CCS時系列を生成（3条件分）
2. ESP32ファームウェアにCCS→T_adv写像を実装
3. Android受信アプリを準備
4. PPK-IIの計測環境を構築

### 8.2 セッション実行

```
1. 機器接続・同期確認
2. セッション開始（LED点灯）
3. CCS時系列再生開始
4. 15分待機
5. セッション終了（LED消灯）
6. データ保存・バックアップ
```

### 8.3 データ集約

```
1. Tx/Rx/Powerログを時刻同期
2. 活動遷移イベントを抽出
3. TL, μC, Poutを算出
4. 条件・環境ごとに集計
```

---

## 9. 実験スケジュール（案）

| Week | タスク | 成果物 |
|------|--------|--------|
| 1 | mHealth CCS時系列生成、ESP32ファームウェア準備 | CCS再生スクリプト、ファームウェア |
| 2 | E1環境で30セッション実施 | 生データ（E1） |
| 3 | E2環境で30セッション実施 + データ処理 | 生データ（E2）、集計結果 |
| 4 | 分析・図表作成・執筆 | レター原稿 |

---

## 10. リスクと対策

| リスク | 兆候 | 対策 |
|--------|------|------|
| 同期ずれ | TLが負値 | NTPまたはGPIO同期マーカー |
| BLE干渉 | PDR急落 | E2条件として記録、解析時に考慮 |
| データ欠損 | ログ途切れ | セッション後に即時確認、再実施 |
| 機器故障 | 計測異常 | 予備機器準備 |

---

## 11. 成果物

| 成果物 | 形式 | 用途 |
|--------|------|------|
| 生データ | CSV | 再現用アーカイブ |
| 集計結果 | JSON/CSV | 分析・図表生成 |
| トレードオフ曲線 | PNG/PDF | レター掲載 |
| 統計検定結果 | テキスト | レター記載 |

---

## 12. Phase 2への接続

Phase 1実験データは、Phase 2で以下のように活用:

| Phase 1成果物 | Phase 2での利用 |
|---------------|----------------|
| μC実測値（条件別） | 報酬正規化辞書 |
| Pout(τ)実測値 | 制約関数の較正 |
| CCS時系列 | オフラインシミュレーション入力 |
| p_d推定値 | Poutモデルパラメータ |

---

*Last updated: 2025-11-27*
</file>

<file path="フェーズ1/要件定義.md">
# Phase 1 要件定義: 決め打ちルールの実装と評価指標の確立

## 1. 概要

### 1.1 位置づけ

Phase 1はPhase 2（Safe Contextual Bandit）の**前段階**として以下を確立する:

- Safe-MABの「warm-start用ベースライン」を作る
- 評価指標（Pout(τ), μC）の測定系を確立する
- 単純なルールでも「効果がある」ことを示し、将来の学習ベース手法の土台を作る

### 1.2 主張

> 「HAR不確実度に基づくBLE広告間隔の適応制御において、単純な閾値ルールでも固定間隔と比較して省電力効果が得られることを示した。提案手法は、将来のSafe Contextual Banditによるオンライン最適化の基盤となる。」

---

## 2. スコープ

### 2.1 IN（Phase 1でやること）

| 項目 | 内容 |
|------|------|
| 問題定式化 | Pout(τ)制約下でのエネルギー最小化問題（Safe Bandit形式） |
| 決め打ち方策 | CCS→T_adv の閾値写像（Safe Banditのwarm-start用） |
| 評価指標 | Pout(τ), μC/event の測定系確立 |
| 実験評価 | 固定100ms / 固定2000ms / CCS制御 の比較 |
| モデル検証 | Pout(τ)の理論値と実測の比較 |
| Future Work | Safe Contextual Banditへの拡張を記載 |

### 2.2 OUT（Phase 1でやらないこと）

| 項目 | 理由 |
|------|------|
| Safe-UCBの実装 | Phase 2で実施 |
| オンライン学習 | Phase 2で実施 |
| HAR誤認識の統合（RoME） | スコープ外、BLE側に集中 |
| 複数データセット評価 | 概念実証として十分 |
| Tx電力・PHY最適化 | スコープ外 |

---

## 3. 問題定式化（Phase 2への橋渡し）

### 3.1 最適化問題

```
minimize   E[μC(a)]           # エネルギー最小化
subject to Pout(τ | a) ≤ δ    # QoS制約
where      a = π(U, S)        # 方策：コンテキストから行動を選択
```

### 3.2 構成要素

| 要素 | 記号 | 定義 | Phase 1での値 |
|------|------|------|--------------|
| **コンテキスト** | (U, S) | HAR不確実度、安定度 | [0,1] × [0,1] |
| **行動** | a ∈ A | 広告間隔 T_adv | {100, 500, 1000, 2000} ms |
| **報酬** | r(a) | -μC(a) | 負のエネルギー |
| **制約** | g(a) | Pout(τ \| a) | トレードオフ曲線で評価 |
| **方策** | π(U, S) | コンテキスト→行動 | 閾値ルール（固定） |

---

## 4. コンテキスト定義

### 4.1 不確実度 U

```
U = -Σ p_k log(p_k) / log(K)  ∈ [0, 1]
```

- p_k: クラスkの事後確率
- K: クラス数（4-class: sitting, standing, walking, lying）
- U=0: 確信度100%、U=1: 完全に不確実

### 4.2 安定度 S

```
S = 1 - min(1, n_trans / W)  ∈ [0, 1]
```

- n_trans: 過去W窓での予測ラベル遷移回数
- W: 窓数（5窓 = 2.5秒 @ 0.5秒/窓）
- S=1: 安定、S=0: 頻繁に遷移

### 4.3 複合スコア CCS

```
CCS = 0.7 × (1 - U) + 0.3 × S  ∈ [0, 1]
     = 0.7 × confidence + 0.3 × stability
```

**根拠**（docs/全体像.md 参照）:
1. CCS = Composite Confidence Score。高い値が「確信がある」という解釈と一致
2. CCS高い → 確信あり → 長い間隔OK → 省電力。単調な写像で直感的
3. confidence（瞬時の推論品質）を主成分、stability（時間的一貫性）を補助

---

## 5. 決め打ち方策

### 5.1 CCS→T_adv写像

```
T_adv(CCS) =
    2000ms  if CCS ≥ θ_high (0.70)    # 確信高い→省電力優先
    500ms   if θ_low ≤ CCS < θ_high   # 中間
    100ms   if CCS < θ_low (0.40)     # 確信低い→QoS優先
```

**閾値の根拠**: 実験2のA0で仮設定。Phase 1実験で検証。

### 5.2 ヒステリシス

- 上り閾値: θ_high=0.70, θ_low=0.40
- 下り閾値: θ_high-0.05=0.65, θ_low-0.05=0.35
- 最小滞在時間: 2秒

**目的**: 切替振動の抑制

---

## 6. 評価指標（KPI）

### 6.1 一次KPI

| KPI | 定義 | 測定方法 | 成功基準 |
|-----|------|---------|---------|
| **Pout(τ)** | P(TL > τ) | Android受信ログからTL算出 | 固定100msと同等以下 |
| **μC/event** | イベントあたり電荷 | PPK-II実測 | 固定100ms比で削減 |
| **TL_p95** | 遅延の95パーセンタイル | Android受信ログ | 参考値 |

### 6.2 二次KPI

| KPI | 定義 | 算出方法 |
|-----|------|---------|
| **省エネ率** | 1 - μC_CCS / μC_100ms | 計算 |
| **PDR** | 受信成功率 | 参考値 |
| **平均電流** | 平均消費電流 [mA] | PPK-II |

### 6.3 Pout(τ)の理論モデル

```
Pout(τ | T_adv) ≈ (1 - p_d)^⌊τ / T_adv⌋
```

- p_d: 1広告の受信成功確率（≈0.85、フェーズ0-0実測）
- τ: 許容遅延（評価では τ = 1, 2, 3秒）

**Phase 1での検証**: 理論値と実測のトレンド一致を確認

---

## 7. 実験計画

### 7.1 条件

| 条件 | T_adv | 説明 |
|------|-------|------|
| Baseline-Short | 100ms固定 | QoS最良、エネルギー最大 |
| Baseline-Long | 2000ms固定 | エネルギー最小、QoS最悪 |
| CCS-Control | CCS写像 | 提案手法 |

### 7.2 環境

- E1: 低干渉環境
- E2: 高Wi-Fi干渉環境（オプション）

### 7.3 繰り返し

- 各条件 × 各環境 で ≥3回

---

## 8. 成功基準

### 8.1 最低ライン（レターとして成立）

1. CCS制御が固定100msより省エネ（μC削減）
2. CCS制御が固定2000msよりPout(τ)改善
3. Pout(τ)の理論モデルと実測がトレンド一致

### 8.2 理想ライン（強いレター）

1. 上記 + Uの有用性を示すアブレーション（CCS制御 vs 活動種別のみ制御）
2. 上記 + Safe-UCBのオフラインシミュレーション1図

---

## 9. 成果物

| 成果物 | 説明 |
|--------|------|
| 評価指標の確立 | Pout(τ), μC/event の測定パイプライン |
| warm-start用ベースライン | CCS→T_adv写像テーブル |
| KPIパイプライン | ログ→KPI算出スクリプト |
| レター論文 | 問題定式化、実験結果、Future Work |

---

## 10. Phase 2への接続

Phase 1の成果物は、Phase 2（Safe Contextual Bandit）で以下のように活用:

| Phase 1成果物 | Phase 2での利用 |
|---------------|----------------|
| CCS→T_adv写像 | Warm-Start初期方策 |
| μC実測値 | 報酬正規化の辞書 |
| Pout(τ)実測値 | 制約関数の較正 |
| ログスキーマ | arm, reward, context列を追加して拡張 |

---

*Last updated: 2025-11-27*
</file>

<file path="フェーズ2/実験設計書.md">
# Phase 2 実験設計書: Safe Contextual Bandit評価

## 1. 実験の目的

1. **Safe-UCBアルゴリズムの有効性**を検証（制約満足 + 報酬最大化）
2. **Warm-Start（Phase 1引き継ぎ）の効果**を定量化
3. **環境変化への適応性**を評価
4. **累積後悔（Regret）の収束性**を確認

---

## 2. 実験の種類

Phase 2では**2種類の実験**を実施:

| 種類 | 目的 | 環境 |
|------|------|------|
| **オフライン評価** | アルゴリズム比較、パラメータ調整 | シミュレーション |
| **オンライン評価** | 実機での有効性検証 | 実環境 |

---

## 3. オフライン評価（シミュレーション）

### 3.1 目的

- アルゴリズム間の比較（Safe-UCB vs UCB vs Fixed）
- ハイパーパラメータの調整
- Warm-Start効果の検証

### 3.2 シミュレーション設定

**入力データ**: Phase 1で収集したCCS時系列

**報酬モデル**:
```
r(a) = -μC(a)
μC(a) = q_adv × (D / T_adv)
```
- q_adv: Phase 1実測値から取得
- D: イベント持続時間（シナリオ設定）

**制約モデル**:
```
g(a) = Pout(τ | a) = (1 - p_d)^⌊τ / T_adv⌋
```
- p_d: Phase 1実測値（≈0.85）
- τ = 2s

**ノイズモデル**:
```
r_observed = r(a) + ε_r,  ε_r ~ N(0, σ_r²)
g_observed = g(a) + ε_g,  ε_g ~ N(0, σ_g²)
```
- σ_r, σ_g: Phase 1実測の標準偏差から設定

### 3.3 比較アルゴリズム

| アルゴリズム | 説明 |
|-------------|------|
| **Safe-UCB** | 提案手法。制約LCBを考慮した腕選択 |
| **UCB** | 制約なしUCB（ベースライン） |
| **Fixed-CCS** | Phase 1の固定写像（ベースライン） |
| **Oracle** | 最適腕を常に選択（理論上界） |

### 3.4 評価指標

| 指標 | 定義 | 目標 |
|------|------|------|
| **累積後悔** | Σ(r* - r_t) | 亜線形成長 O(√T) |
| **制約違反率** | #{g_t > δ} / T | ≤ δ |
| **収束ラウンド** | 最適腕選択率≥90%に達するラウンド | 参考値 |

### 3.5 シナリオ

| シナリオ | 内容 | 評価目的 |
|----------|------|---------|
| S1: 定常環境 | p_d, q_adv固定 | 基本性能 |
| S2: 環境変化 | T=5000でp_d変化 | 適応性 |
| S3: 高ノイズ | σ_r, σ_gを2倍 | ロバスト性 |

### 3.6 Warm-Start実験

| 条件 | 初期化方法 |
|------|-----------|
| **Cold-Start** | μ̂_r = 0, μ̂_g = 0.5 |
| **Warm-Start** | μ̂_r = Phase1_μC, μ̂_g = Phase1_Pout |

**評価**: 収束ラウンド、初期後悔の比較

---

## 4. オンライン評価（実機実験）

### 4.1 目的

- 実環境でのSafe-UCBの動作確認
- 長時間運用での安定性検証
- 環境変化時の適応性評価

### 4.2 実験条件

| 項目 | 値 | 備考 |
|------|-----|------|
| 環境 | E1（干渉弱）, E2（干渉強） | Phase 1と同条件 |
| 距離 | 1m | 固定 |
| Tx Power | 0 dBm | 固定 |
| スキャンモード | Android LOW_LATENCY | 固定 |
| セッション時間 | 60分 | 長時間運用 |

### 4.3 制御条件

| 条件ID | 条件名 | 説明 |
|--------|--------|------|
| C1 | Fixed-CCS | Phase 1の固定写像（ベースライン） |
| C2 | Safe-UCB-Cold | Cold-Start Safe-UCB |
| C3 | Safe-UCB-Warm | Warm-Start Safe-UCB |

### 4.4 反復設計

```
3条件 × 2環境 × 5セッション = 30セッション
```

- 各セッション60分 → 総実験時間: 30時間

### 4.5 セッション構成（60分）

| 時間 | 活動パターン | 目的 |
|------|-------------|------|
| 0-20分 | 座位主体（高CCS） | 学習初期の挙動 |
| 20-40分 | 歩行主体（低CCS） | 活動変化への対応 |
| 40-60分 | 混合（変動CCS） | 適応性評価 |

### 4.6 計測項目

| 項目 | 機器 | 計測対象 |
|------|------|---------|
| 電力 | PPK-II | ESP32のVBAT電流 |
| 送信ログ | ESP32 SD | timestamp, T_adv, CCS, U, S, arm_selected |
| 受信ログ | Android | timestamp, RSSI, seq |
| 学習ログ | ESP32 SD | μ̂_r, μ̂_g, UCB, LCB, N(a) |

### 4.7 ログスキーマ（Phase 2拡張）

**Txログ（Phase 1 + 拡張）**:
```
timestamp_ms, session_id, seq, T_adv, CCS, U, S, activity_label,
arm_selected, reward, constraint_value
```

**Learningログ（Phase 2新規）**:
```
timestamp_ms, round_t, arm, mu_r_hat, mu_g_hat, ucb_r, lcb_g, n_pulls
```

---

## 5. 評価指標

### 5.1 オフライン評価指標

| 指標 | 計算式 | 成功基準 |
|------|--------|---------|
| 累積後悔 | Σ(r* - r_t) | O(√T)成長 |
| 制約違反率 | #{g_t > δ} / T | ≤ δ (例: 5%) |
| 平均報酬 | mean(r_t) for t > T/2 | Fixed-CCS以上 |

### 5.2 オンライン評価指標

| 指標 | 計算式 | 成功基準 |
|------|--------|---------|
| μC/event | Phase 1と同様 | Fixed-CCS以上の削減 |
| Pout(τ) | Phase 1と同様 | ≤ δ を維持 |
| 腕選択分布 | histogram(arm_selected) | 合理的な分布 |
| 学習収束 | μ̂の変動収束 | セッション後半で安定 |

### 5.3 Warm-Start効果指標

| 指標 | 計算式 | 目標 |
|------|--------|------|
| 初期後悔削減率 | 1 - Regret_Warm(T=100) / Regret_Cold(T=100) | ≥ 30% |
| 収束ラウンド短縮 | T_conv_Cold - T_conv_Warm | > 0 |
| 初期違反率 | 違反率(T < 100) | Warm < Cold |

---

## 6. 成功基準

### 6.1 最低ライン（論文成立）

| 基準 | 条件 |
|------|------|
| 制約満足 | Pout(τ) ≤ δ を長期的に維持 |
| 報酬改善 | μC_Safe-UCB ≤ μC_Fixed-CCS |
| 累積後悔 | 亜線形成長を確認 |

### 6.2 理想ライン（トップカンファレンス級）

| 基準 | 条件 |
|------|------|
| 理論バウンド | O(√T log T)の後悔バウンド証明 |
| 適応性 | 環境変化後の再収束を確認 |
| Warm-Start | 収束ラウンド50%短縮 |

---

## 7. 実験スケジュール（案）

### 7.1 オフライン評価

| Week | タスク | 成果物 |
|------|--------|--------|
| 1 | シミュレータ実装 | Python実装 |
| 2 | アルゴリズム比較実験 | 比較結果 |
| 3 | Warm-Start実験 | 効果検証結果 |

### 7.2 オンライン評価

| Week | タスク | 成果物 |
|------|--------|--------|
| 4 | ESP32 Safe-UCB実装 | ファームウェア |
| 5 | E1環境で15セッション | 生データ（E1） |
| 6 | E2環境で15セッション | 生データ（E2） |
| 7 | 分析・執筆 | 論文原稿 |

---

## 8. リスクと対策

| リスク | 兆候 | 対策 |
|--------|------|------|
| 制約違反頻発 | Pout > δ が連続 | δを保守的に設定、Fallback発動 |
| 収束しない | μ̂が発散 | 学習率調整、正則化 |
| 計算リソース不足 | ESP32で処理遅延 | 軽量実装、更新頻度削減 |
| メモリ不足 | RAM枯渇 | 履歴のウィンドウ制限 |

---

## 9. 成果物

| 成果物 | 形式 | 用途 |
|--------|------|------|
| シミュレータ | Python | 再現・パラメータ調整 |
| ESP32実装 | C++ | 実機評価 |
| 実験ログ | CSV | 再現用アーカイブ |
| 後悔曲線 | PNG/PDF | 論文掲載 |
| 制約違反推移 | PNG/PDF | 論文掲載 |

---

## 10. Phase 1との差分

| 項目 | Phase 1 | Phase 2 |
|------|---------|---------|
| 方策 | 固定写像 | オンライン学習 |
| セッション時間 | 15分 | 60分 |
| ログ拡張 | Tx/Rx/Power | + Learning |
| 評価指標 | μC, Pout | + Regret, 収束 |
| 実験回数 | 60セッション | 30セッション |

---

## 11. Phase 3への接続

Phase 2実験データは、Phase 3で以下のように活用:

| Phase 2成果物 | Phase 3での発展 |
|---------------|----------------|
| Safe-UCB実装 | マルチ制約への拡張 |
| 学習パラメータ | 知識蒸留の入力 |
| 適応性データ | 非定常Banditへの発展 |

---

*Last updated: 2025-11-27*
</file>

<file path="フェーズ2/要件定義.md">
# Phase 2 要件定義: Safe Contextual Bandit最適化

## 1. 概要

### 1.1 位置づけ

Phase 2は研究テーマの核心部分:

> **「HAR不確実度を活用したBLE広告のSafe Contextual Bandit最適化」**

Phase 1で確立した評価指標とベースラインを用いて、**オンライン学習による自律的な最適化**を実現する。

### 1.2 新規性

1. HAR不確実度をContextual Banditの「コンテキスト」として初めて使用
2. Pout(τ)を「制約」として扱うSafe Bandit定式化
3. アプリ層（HAR）→通信層（BLE）のクロスレイヤー最適化

### 1.3 前提条件（Phase 1からの引き継ぎ）

| 項目 | Phase 1成果物 |
|------|--------------|
| 評価指標 | Pout(τ), μC/event の測定パイプライン |
| ベースライン | CCS→T_adv写像テーブル |
| 実測データ | μC辞書、Pout(τ)実測値 |

---

## 2. 問題定式化

### 2.1 Safe Contextual Bandit問題

**目的関数**:
```
π* = argmax_π  E_{(U,S)~D} [ r(π(U,S)) ]
     subject to E_{(U,S)~D} [ g(π(U,S)) ] ≤ δ
```

- π: コンテキスト→行動の方策
- r: 報酬（-μC）
- g: 制約関数（Pout(τ)）
- δ: 許容違反率

### 2.2 構成要素

| 要素 | 記号 | 定義 | 詳細 |
|------|------|------|------|
| **コンテキスト** | x = (U, S) | HAR不確実度、安定度 | [0,1] × [0,1] |
| **行動** | a ∈ A | 広告間隔 T_adv | {100, 500, 1000, 2000} ms |
| **報酬** | r(a) | -μC(a) | エネルギー最小化 |
| **制約** | g(a) | Pout(τ \| a) | QoS保証 |
| **方策** | π(x) | コンテキスト→行動 | 学習対象 |

### 2.3 報酬関数

**イベント電荷**:
```
μC(a) = q_adv × (D / T_adv)
```
- q_adv: 1広告あたりの電荷（Phase 1実測から取得）
- D: イベント持続時間
- T_adv: 広告間隔

**報酬**:
```
r(a) = -μC(a)  # エネルギー最小化 = 報酬最大化
```

### 2.4 制約関数

**Pout(τ | a)**:
```
Pout(τ | a) = P(初回受信遅延 > τ | T_adv = a)
            ≈ (1 - p_d)^⌊τ / T_adv⌋
```
- p_d: 1広告の受信成功確率（Phase 1実測から取得）
- τ: 許容遅延（例: 2秒）

**制約**:
```
g(a) = Pout(τ | a) ≤ δ
```
- δ: 許容違反率（例: 5%）

---

## 3. アルゴリズム

### 3.1 候補アルゴリズム

| アルゴリズム | 特徴 | 適用可能性 |
|-------------|------|-----------|
| **Conservative UCB** | 制約を保守的に扱う | ◎ 最有力 |
| **SafeOpt** | 安全領域を段階的に拡張 | ○ 連続行動空間向け |
| **Constrained Thompson Sampling** | ベイズ的制約処理 | ○ サンプル効率良い |
| **Lagrangian Bandit** | ラグランジュ乗数で制約処理 | △ 収束遅い可能性 |

### 3.2 Safe-UCB型アルゴリズム（基本設計）

```python
for each round t:
    # 1. コンテキスト観測
    observe context x_t = (U_t, S_t)

    # 2. 各腕の評価
    for each arm a in A:
        # 報酬のUCB（楽観的）
        UCB_reward[a] = μ_r_hat(a, x_t) + c * sqrt(log(t) / N(a, x_t))

        # 制約のLCB（悲観的 = 安全側）
        LCB_constraint[a] = μ_g_hat(a, x_t) - c * sqrt(log(t) / N(a, x_t))

    # 3. 安全な腕の中から最良を選択
    safe_arms = { a : LCB_constraint[a] ≤ δ }
    if safe_arms is empty:
        a_t = fallback_arm  # 100ms（最も安全）
    else:
        a_t = argmax { UCB_reward[a] : a in safe_arms }

    # 4. 行動実行・観測・更新
    execute a_t
    observe r_t, g_t
    update μ_r_hat, μ_g_hat, N
```

### 3.3 Warm-Start（Phase 1からの引き継ぎ）

```python
# Phase 1の写像テーブルで初期化
initial_policy = {
    (U < 0.30, S > 0.60): 2000ms,  # 高CCS
    (0.30 ≤ U < 0.60, ...): 500ms,  # 中CCS
    (U ≥ 0.60, ...): 100ms,  # 低CCS
}

# 初期推定値をPhase 1実測で設定
μ_r_hat[a] = Phase1_μC[a]  # 報酬の事前推定
μ_g_hat[a] = Phase1_Pout[a]  # 制約の事前推定
```

---

## 4. 評価指標（KPI）

### 4.1 一次KPI（Phase 1から継続）

| KPI | 定義 | Phase 2での評価 |
|-----|------|----------------|
| **Pout(τ)** | P(TL > τ) | 制約δを常に満たすか |
| **μC/event** | イベントあたり電荷 | Phase 1ベースラインより改善 |
| **TL_p95** | 遅延の95パーセンタイル | 参考値 |

### 4.2 Phase 2固有KPI

| KPI | 定義 | 目標 |
|-----|------|------|
| **累積後悔（Regret）** | Σ(r* - r_t) | 亜線形（sublinear）成長 |
| **制約違反率** | #{g_t > δ} / T | ≤ δ（長期的に） |
| **収束速度** | 最適腕選択率が安定するまでのラウンド数 | 参考値 |

---

## 5. 実験計画

### 5.1 オフライン評価（シミュレーション）

| 実験 | 内容 | 目的 |
|------|------|------|
| Regret比較 | Safe-UCB vs UCB vs Fixed | 学習効率の検証 |
| 制約満足度 | 違反率の推移 | 安全性の検証 |
| Warm-Start効果 | With/Without Phase 1初期化 | 引き継ぎの価値 |

### 5.2 オンライン評価（実機）

| 実験 | 内容 | 目的 |
|------|------|------|
| 長時間運用 | 数時間〜1日の連続運用 | 実用性の検証 |
| 環境変化適応 | E1→E2切替時の挙動 | 適応性の検証 |
| 端末差異 | 複数スマホでの評価 | 汎用性の検証 |

---

## 6. 成功基準

### 6.1 最低ライン（論文として成立）

1. Safe-UCBがPout(τ) ≤ δを維持しながら学習
2. 固定方策（Phase 1ベースライン）よりμC改善
3. 累積後悔が亜線形成長

### 6.2 理想ライン（トップカンファレンス級）

1. 上記 + 複数環境での適応性実証
2. 上記 + 理論的後悔バウンドの導出
3. 上記 + 実機での長時間安定運用

---

## 7. リスクと対策

| リスク | 兆候 | 対策 |
|--------|------|------|
| 制約違反頻発 | Pout > δが連続 | Fallback（100ms）へ退避 |
| 学習初期の後悔 | 違反スパイク | Warm-Start強化 |
| 収束しない | 推定値が発散 | 学習率調整、正則化 |
| 環境変化に追従できない | 最適腕が変化 | 減衰係数導入（非定常対応） |

---

## 8. 成果物

| 成果物 | 説明 |
|--------|------|
| Safe-UCBアルゴリズム実装 | ESP32上で動作するC++実装 |
| オフラインシミュレータ | Python実装、ログリプレイ機能 |
| 論文（修論/ジャーナル） | 定式化、アルゴリズム、実験結果 |
| 実験ログ・再現パッケージ | Runbook、データ、スクリプト |

---

## 9. Phase 3への接続

Phase 2の成果物は、Phase 3（Semantic-driven Communication）で以下のように発展:

| Phase 2成果物 | Phase 3での発展 |
|---------------|----------------|
| Safe-UCB | マルチ制約、マルチ目的への拡張 |
| コンテキスト(U, S) | アプリ緊急度、端末状態の追加 |
| 単一デバイス最適化 | マルチデバイス協調 |
| BLE広告間隔 | Tx電力、PHY、チャネル選択への拡張 |

---

## 10. 参考文献（Phase 2で参照）

- Sui, Y., et al. "Safe Exploration for Optimization with Gaussian Processes" (SafeOpt)
- Amani, S., et al. "Linear Stochastic Bandits Under Safety Constraints"
- Kazerouni, A., et al. "Conservative Contextual Linear Bandits"

---

*Last updated: 2025-11-27*
</file>

<file path="TODO.md">
# HAR-BLE Safe Contextual Bandit 実験計画書

**文書ID**: RHT-EXP-PLAN-v1.2
**作成日**: 2025-11-27
**最終更新**: 2025-11-30
**ステータス**: ドラフト（Baseline再計測中、実地検証で発見した問題を反映）

---

## 0. 前提条件の確認

### 0.1 既存資産の棚卸し

- [ ] **フェーズ0-0データの確認** (再計測中 2025-11-30)
  - [ ] ΔE/adv実測値（100/500/1000/2000ms） → **再計測中**
    - 旧データ: `docs/フェーズ1/results/delta_energy_row1120_row1123_off.md` (参考値)
    - 2025-11-29 INA219配線修正後、再計測が必要 (`docs/フェーズ0-0/decision_log_2025-11-29.md`)
  - [ ] P_off_mean → **再計測中**
    - 旧値 22.106 mW は配線修正前のため参考値
    - OFF計測完了(11 trials)、解析待ち
  - [x] PDR実測値（p_d ≈ 0.85）の根拠データがあるか → OK (`docs/フェーズ1/results/pdr_row1120_txsd_rx.md`)

- [x] **HARモデル（A0）の確認** (2025-11-27 完了)
  - [x] TFLite int8モデル（90.6KB）がエクスポート済みか → OK (`har/004/export/acc_v1_keras/phase0-1-acc.v1.int8.tflite`)
  - [x] 校正パラメータ（T=0.7443, τ=0.66）が確定しているか → OK (`har/001/docs/A0_acc_v1_baseline_summary.md`)
  - [x] θ_low=0.80, θ_high=0.90 の閾値が設定済みか → **調整済み** (`logs/threshold_adjustment_2025-11-27.md`)
    - 旧デフォルト: θ_low=0.40, θ_high=0.70
    - mHealthのCCS分布が高め(0.84-0.93)のため閾値を上げて調整

- [x] **mHealthデータセットの確認** (2025-11-27 完了)
  - [x] 生データへのアクセスがあるか → OK (`data/MHEALTHDATASET/`)
  - [x] 被験者数・セッション数・活動ラベルの把握 → 10名、12活動、6,768窓
  - [x] データ前処理パイプラインが動作するか → OK (`har/001/data_processed/subject*.npz`)

**棚卸しログ**: `logs/inventory_0.1_2025-11-27.md`

### 0.2 ハードウェア準備状況

- [x] **ESP32ボード** (2025-11-27 確認)
  - [x] 型番: ESP32 Dev Module (3台: TX/TXSD/RX)
  - [x] 動作確認済み

- [x] **電力計測** (2025-11-29 配線修正済み)
  - [x] **INA219構成を継続**（PPK-IIは使用しない）
  - [x] INA219 Vcc配線修正済み（外部3.3V直結）
  - **注意**: Phase 0-0とは構成が異なる（配線修正後）

- [x] **Android端末** (2025-11-28 確認完了)
  - [x] 機種名: Galaxy S9 (SCV38)
  - [x] OSバージョン: **Android 10** (One UI 2.1)
  - [x] BLE受信アプリ: nRF Connect for Mobile

- [ ] **実験環境** (一部未確認)
  - [ ] E1（干渉弱）環境: 未確認
  - [x] E2（干渉強）環境: 確保済み（簡易に実施可能）
  - [ ] 距離1mの固定方法: 要確認

- [x] **配線修正** (2025-11-29 完了)
  - [x] INA219 Vcc配線を外部3.3V直結に修正
  - [x] UARTボーレート 230400→115200 に変更（ノイズ対策）
  - [x] 詳細: `docs/フェーズ0-0/decision_log_2025-11-29.md`
  - **注意**: 修正前のP_off/ΔE/advは参考値、再計測が必要

**ハードウェアログ**: `logs/inventory_0.2_2025-11-27.md`, `docs/フェーズ0-0/decision_log_2025-11-29.md`

---

## 1. 準備フェーズ（Week 1）

### 1.1 mHealth CCS時系列生成 ✅ (2025-11-27 完了)

**目的**: mHealthデータからU, S, CCS時系列を生成し、ESP32で再生可能な形式にする

#### 1.1.1 HAR推論パイプライン構築 ✅

- [x] **統合スクリプト作成**: `scripts/generate_ccs_sequences.py`
  - 既存の前処理済みデータ `har/001/data_processed/subject*.npz` を使用
  - TFLite int8モデルで推論 → U, S, CCS計算 → CSV出力
  - 全10被験者分のCCS時系列を生成

#### 1.1.2 CCS→T_adv変換 ✅

- [x] **ヒステリシス付き写像関数**: `scripts/generate_ccs_sequences.py` 内に実装
  - **閾値調整済み (2025-11-27)**: θ_high=0.90, θ_low=0.80, hysteresis=0.05, min_stay=2.0s
  - 理由: mHealthのCCS分布が高め(0.84-0.93)のため、閾値を上げて間隔多様性を確保
  - 変更ログ: `logs/threshold_adjustment_2025-11-27.md`
- [x] **CCS時系列出力**: `data/ccs_sequences/subject{01-10}_ccs.csv`

#### 1.1.3 代表セッションの選定 ✅

- [x] **セッション選定スクリプト**: `scripts/create_esp32_sessions.py`
  - mHealthデータ制約（各被験者約11分）により15分→**10分セッション**に変更
  - 遷移回数、間隔多様性、CCS範囲をスコアリングして選定

**成果物**:
- [x] `data/ccs_sequences/subject{01-10}_ccs.csv` - 被験者別CCS時系列
- [x] `data/esp32_sessions/session_{01-10}.csv` - ESP32再生用10分セッション
- [x] `data/esp32_sessions/session_selection_report.md` - 選定レポート
- [x] `data/esp32_sessions/session_manifest.json` - セッションメタデータ

**セッション概要** (10分 = 600秒, θ_high=0.90, θ_low=0.80):
| Session | Subject | CCS Mean | Transitions | 100ms% | 500ms% | 2000ms% |
|---------|---------|----------|-------------|--------|--------|---------|
| 01 | 06 | 0.90 | 13 | 26.2% | 2.3% | 71.5% |
| 02 | 08 | 0.86 | 32 | 27.3% | 4.7% | 68.0% |
| 10 | 10 | 0.85 | 66 | 36.7% | 13.2% | 50.2% |

---

### 1.2 ESP32ファームウェア開発 🔧 (実地検証で問題発見・修正中)

**目的**: CCS時系列に基づき、T_advを動的に変更するファームウェア

**既存資産** (Phase 0-0から継承、2025-11-29 ディレクトリ再編済み):
- `esp32_firmware/baseline_on/TX_BLE_Adv/` - TX送信+電流測定（マルチinterval自動実行対応）
- `esp32_firmware/baseline_on/TXSD_PowerLogger/` - 電力ロガー
- `esp32_firmware/baseline_on/RX_BLE_to_SD/` - BLE受信ロガー
- `esp32_firmware/baseline_off/` - OFF計測用（BLE無効ベースライン）
- `esp32_firmware/ccs_mode/` - CCS動的インターバル制御用
- `docs/フェーズ0-0/decision_log_2025-11-29.md` - 最新の設計決定ログ

#### 1.2.1 基本機能実装 ✅ (既存コードで対応)

- [x] **BLE Advertising制御** - `esp32_firmware/baseline_on/TX_BLE_Adv/TX_BLE_Adv.ino`
  - マルチinterval自動実行（100→500→1000→2000ms）
  - N_ADV_PER_TRIAL=300固定、interval別トライアル長
  - INA219による電流測定、UART出力実装済み
- [x] **ログ出力機能** - TX→TXSD→SD構成で実装済み
  - フォーマット: `mv,uA` (10ms周期)

#### 1.2.2 実験モード実装 ✅ (全モード完了)

- [x] **Baseline ON計測** - `esp32_firmware/baseline_on/` (マルチinterval自動実行)
- [x] **Baseline OFF計測** - `esp32_firmware/baseline_off/` (60秒固定窓)
- [x] **CCSモード** - `esp32_firmware/ccs_mode/TX_BLE_Adv_CCS_Mode.ino`
  - `RUN_MODE` で `MODE_FIXED_100` / `MODE_FIXED_2000` / `MODE_CCS` を選択
  - CCS時系列は `ccs_session_data.h` として定数配列に埋め込み
  - 1秒解像度でT_adv動的変更（100/500/2000ms）
  - BLE interval動的再設定: `adv->stop()` → `setMinInterval/setMaxInterval` → `adv->start()`

#### 1.2.3 同期機能実装 ✅ (既存コードで実装済み)

- [x] **SYNC_OUT_PIN (GPIO25)** - トライアル開始/終了マーカー
- [x] **TICK_OUT_PIN (GPIO27)** - 各広告イベントのパルス
- [x] **LED_PIN (GPIO2)** - 状態インジケータ

#### 1.2.4 ビルド手順（CCSモード）

```bash
# 1. セッションヘッダー生成
python3 scripts/convert_session_to_header.py --session 01

# 2. TX_BLE_Adv_CCS_Mode.ino で RUN_MODE を設定
#    MODE_FIXED_100, MODE_FIXED_2000, MODE_CCS から選択

# 3. Arduino IDEでビルド・書き込み
#    Board: ESP32 Dev Module
```

**成果物チェックリスト** (2025-11-29 ディレクトリ再編後):
- [x] `esp32_firmware/baseline_on/TX_BLE_Adv/TX_BLE_Adv.ino` - マルチinterval自動実行TX
- [x] `esp32_firmware/baseline_on/TXSD_PowerLogger/TXSD_PowerLogger.ino` - ON用電力ロガー
- [x] `esp32_firmware/baseline_on/RX_BLE_to_SD/RX_BLE_to_SD.ino` - BLE受信ロガー
  - **修正済み (2025-11-30)**: USE_SYNC_END=true に変更（トライアル数不一致問題を解消）
- [x] `esp32_firmware/baseline_off/TX_BLE_OFF/TX_BLE_OFF.ino` - OFF計測TX
- [x] `esp32_firmware/baseline_off/TXSD_PowerLogger/TXSD_PowerLogger.ino` - OFF用電力ロガー
- [x] `esp32_firmware/ccs_mode/TX_BLE_Adv_CCS_Mode.ino` - CCSモード対応TX
- [x] `esp32_firmware/ccs_mode/TXSD_PowerLogger_CCS_Mode.ino` - CCSモード対応TXSD
- [x] `esp32_firmware/ccs_mode/ccs_session_data.h` - セッションデータ（自動生成）
- [x] `scripts/convert_session_to_header.py` - CSV→ヘッダー変換スクリプト
- [x] `docs/フェーズ0-0/decision_log_2025-11-29.md`（最新の設計決定ログ）

#### 1.2.5 実地検証で発見した問題 (2025-11-30)

| 問題 | 状態 | 対応 |
|------|------|------|
| UARTデータ化け (230400bps) | ✅ 解決 | 115200bpsに変更 |
| SYNC信号パルス問題 | ✅ 解決 | TX側でSYNC=HIGH維持に変更 |
| RXトライアル数不一致 | ✅ 修正済み | USE_SYNC_END=true (要再書き込み) |
| TXSD SD open FAIL | ✅ 解決 | SDカード接触/ファイル数確認で解消 |
| TXSD SD init FAIL | ✅ 解決 | 電源再投入で解消 |

**詳細**: `docs/フェーズ0-0/decision_log_2025-11-29.md`

---

### 1.3 Android受信アプリ準備 ✅ (nRF Connect使用)

**目的**: BLE広告を受信し、タイムスタンプ付きでログを記録

**使用アプリ**: **nRF Connect for Mobile** (Nordic Semiconductor)
- Google Play: https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp

#### 1.3.1 nRF Connect設定

- [x] **スキャン設定**
  - Scanner → Settings → Scan mode: Low Latency
  - フィルタ: "TXM_ESP32" (デバイス名)

- [x] **ログ記録項目** (nRF Connectで自動取得)
  - タイムスタンプ
  - RSSI
  - Advertising Data (Manufacturer Specific Data含む)

- [x] **ログ出力**
  - Scanner → Export → CSV形式

#### 1.3.2 運用手順

1. nRF Connectを起動
2. Scanner画面でフィルタ設定（"TXM_ESP32"）
3. スキャン開始
4. 実験終了後、Export → CSVで保存

**成果物チェックリスト**:
- [x] 使用アプリ: nRF Connect for Mobile
- [ ] ログフォーマットのサンプル取得（実験時に確認）

---

### 1.4 電力計測セットアップ 🔧 (配線修正済み、再校正中)

**目的**: INA219でESP32の電力を正確に計測する（PPK-IIは使用しない）

**既存資産**: `docs/フェーズ0-0/decision_log_2025-11-29.md` に最新構成を記載

#### 1.4.1 配線 ✅ (2025-11-29 修正済み)

- [x] ESP32 3V3ピンへの外部電源供給（INA219経由）
- [x] INA219 VIN+/VIN-で電流測定
- [x] GND共通化（TX/TXSD/RX/外部電源）
- [x] **INA219 Vcc配線修正**: 外部3.3V直結（旧: Vin-分岐でブラウンアウト発生）

#### 1.4.2 計測設定 ✅ (既存コードで実装済み)

- [x] サンプリングレート: 100Hz (10ms周期)
- [x] UART出力: `mv,uA` 形式
- [x] TXSDでSDカードに記録

#### 1.4.3 動作確認 (再計測中 2025-11-30)

- [x] Phase 0-0で実施済み（**配線修正前のため参考値**）
  - 旧ΔE/adv: `docs/フェーズ1/results/delta_energy_row1120_row1123_off.md`
  - 旧P_off = 22.106 mW
- [ ] **配線修正後の再計測** (進行中)
  - [x] OFF計測完了 (11 trials) → P_off再算出待ち
  - [ ] ON計測 (100/500/1000/2000ms 自動実行中)
  - [ ] 解析スクリプト: `scripts/analyze_baseline_v2.py`
- [ ] Phase 1実験前の最終校正
  - 旧基準値 (100ms): ΔE/adv = 2256.82 µJ（参考）
  - 新基準値: 再計測後に確定

**成果物チェックリスト**:
- [x] 配線図: `docs/フェーズ0-0/decision_log_2025-11-29.md` セクション2
- [ ] 再計測レポート（Baseline ON/OFF）
- [ ] Phase 1校正確認レポート

---

## 2. 実験実施フェーズ（Week 2-3）

### 2.1 実験プロトコル

#### 2.1.1 セッション手順

**注意: 計測タイプによりセッション長が異なる**

| 計測タイプ | セッション長 | 説明 |
|------------|-------------|------|
| **Baseline ON計測** | interval依存 | N_ADV=300固定、100ms→30s, 500ms→150s, 1000ms→5min, 2000ms→10min |
| **Baseline OFF計測** | 60秒固定 | P_off算出用 |
| **CCSモード** | 10分固定 | mHealthセッション再生（mHealthデータ制約により15分→10分）|

```
[開始前]
1. ESP32にCCS時系列をビルド（CCSモードの場合）
2. ESP32のモード選択（FIXED-100 / FIXED-2000 / CCS）
3. Android受信アプリ起動、ログ記録開始
4. INA219計測準備（TX→TXSD構成）
5. ESP32電源ON

[セッション中]
6. 同期マーカー（SYNC_OUT HIGH→LOW）を記録
7. 10分間待機（介入なし）
8. 終了マーカーを記録

[終了後]
9. ESP32電源OFF
10. TXSD SDカードから電力ログ回収
11. Androidログ保存
12. RX SDカードからBLE受信ログ回収
13. ファイル名をセッションIDでリネーム
```

#### 2.1.2 命名規則

```
セッションID: {env}_{condition}_{rep}
例: E1_FIXED100_01, E2_CCS_05

ファイル名:
- 送信ログ: tx_{session_id}.csv
- 受信ログ: rx_{session_id}.csv
- 電力ログ: pwr_{session_id}.csv
```

### 2.2 実験スケジュール

#### Week 2: E1環境（30セッション）

| 日 | 条件 | セッション数 | 累計 |
|----|------|-------------|------|
| Day 1 | FIXED-100 | 10 | 10 |
| Day 2 | FIXED-2000 | 10 | 20 |
| Day 3 | CCS | 10 | 30 |

- [ ] Day 1 完了
- [ ] Day 2 完了
- [ ] Day 3 完了
- [ ] E1データバックアップ完了

#### Week 3前半: E2環境（30セッション）

| 日 | 条件 | セッション数 | 累計 |
|----|------|-------------|------|
| Day 4 | FIXED-100 | 10 | 40 |
| Day 5 | FIXED-2000 | 10 | 50 |
| Day 6 | CCS | 10 | 60 |

- [ ] Day 4 完了
- [ ] Day 5 完了
- [ ] Day 6 完了
- [ ] E2データバックアップ完了

### 2.3 品質管理チェックリスト

各セッション終了後に確認:

- [ ] 送信ログのadv_countが期待値±5%以内
- [ ] 受信ログのrx_countがadv_countの70%以上
- [ ] 電力ログに異常スパイク（>100mA）がないか
- [ ] 同期マーカーが送信・受信・電力ログで一致
- [ ] CCSモードの場合、T_adv遷移が発生しているか

**異常時の対応**:
- ログ欠損 → セッション再実施
- 電力異常 → 配線確認後、再実施
- 同期ずれ → 手動補正 or 再実施

---

## 3. データ処理フェーズ（Week 3後半）

### 3.1 データ統合

- [ ] **ログ同期**
  - 送信・受信・電力ログのタイムスタンプを統一
  - 同期マーカーを基準にオフセット補正
  - ファイル: `scripts/sync_logs.py`

- [ ] **マニフェスト作成**
  - 全60セッションのメタデータ一覧
  - 除外セッションがあればフラグ付与
  - ファイル: `data/experiments_manifest.yaml`

### 3.2 KPI算出

#### 3.2.1 μC/event算出

- [ ] **イベント定義**
  - CCSモード: T_adv遷移が発生した時点
  - FIXEDモード: 活動遷移時点（CCS時系列から推定）

- [ ] **電荷計算**
  ```python
  def compute_event_charge(power_log, events, P_off=22.106):
      results = []
      for event in events:
          t_start, t_end = event['start'], event['end']
          segment = power_log[(power_log.t >= t_start) & (power_log.t < t_end)]
          E_on = integrate(segment.current_mA) * segment.duration_s  # mJ
          E_idle = P_off * segment.duration_s / 1000  # mJ
          mu_c = (E_on - E_idle) / event['adv_count']  # mJ/adv
          results.append(mu_c)
      return results
  ```
  - ファイル: `scripts/compute_event_charge.py`

#### 3.2.2 Pout(τ)算出

- [ ] **TL（検知遅延）計算**
  ```python
  def compute_tl(tx_log, rx_log, events):
      results = []
      for event in events:
          t_event = event['start']
          # イベント後の最初の受信を探す
          rx_after = rx_log[rx_log.t > t_event]
          if len(rx_after) > 0:
              t_first_rx = rx_after.iloc[0].t
              tl = t_first_rx - t_event
          else:
              tl = float('inf')  # 未受信
          results.append(tl)
      return results
  ```

- [ ] **Pout計算**
  ```python
  def compute_pout(tl_list, tau=2.0):
      violations = sum(1 for tl in tl_list if tl > tau)
      return violations / len(tl_list)
  ```
  - ファイル: `scripts/compute_pout.py`

#### 3.2.3 集計

- [ ] **条件別集計**
  ```
  | 条件 | 環境 | μC/event (mean±std) | Pout(2s) | N |
  |------|------|---------------------|----------|---|
  | FIXED-100 | E1 | x.xx ± x.xx | x.xx% | 10 |
  | FIXED-100 | E2 | x.xx ± x.xx | x.xx% | 10 |
  | FIXED-2000 | E1 | x.xx ± x.xx | x.xx% | 10 |
  | FIXED-2000 | E2 | x.xx ± x.xx | x.xx% | 10 |
  | CCS | E1 | x.xx ± x.xx | x.xx% | 10 |
  | CCS | E2 | x.xx ± x.xx | x.xx% | 10 |
  ```
  - ファイル: `results/kpi_summary.csv`

### 3.3 図表作成

- [ ] **Figure 1: Pout-μCトレードオフ曲線**
  - X軸: μC/event [mJ]
  - Y軸: Pout(τ=2s) [%]
  - プロット: 6点（3条件×2環境）+ 誤差バー
  - 理論曲線: Pout = (1-p_d)^⌊τ/T_adv⌋ を重ねる

- [ ] **Figure 2: CCS制御の時系列例**
  - 上段: CCS(t)とT_adv(t)
  - 下段: 電流波形
  - 1セッション分の代表例

- [ ] **Figure 3: 省エネ率の比較**
  - 棒グラフ: FIXED-100基準の省エネ率
  - E1/E2を並べて表示

- [ ] **Table 1: 実験条件**
- [ ] **Table 2: KPI集計結果**

**成果物チェックリスト**:
- [ ] `figures/fig1_tradeoff.pdf`
- [ ] `figures/fig2_timeseries.pdf`
- [ ] `figures/fig3_energy_saving.pdf`
- [ ] `results/kpi_summary.csv`
- [ ] `results/statistical_tests.md`（t検定等）

---

## 4. 執筆フェーズ（Week 4）

### 4.1 論文構成（IEICE ComEX想定、4ページ）

```
1. Introduction (0.5p)
   - 背景: ウェアラブルHAR + BLE通信の課題
   - 問題: 固定広告間隔の非効率性
   - 提案: HAR不確実度に基づく適応制御
   - 貢献: 3点

2. System Model (0.75p)
   - 2.1 Problem Formulation（Safe Bandit定式化）
   - 2.2 CCS-based Policy（決め打ちルール）
   - 2.3 Pout(τ) Model（理論式）

3. Experimental Setup (0.5p)
   - 3.1 Hardware Configuration
   - 3.2 mHealth Dataset
   - 3.3 Evaluation Metrics

4. Results (1.0p)
   - 4.1 Energy Reduction
   - 4.2 Pout-μC Tradeoff
   - 4.3 Model Validation

5. Conclusion (0.25p)
   - まとめ
   - Future Work: Safe Contextual Banditへの拡張

References (~15件)
```

### 4.2 執筆チェックリスト

- [ ] **Introduction**
  - [ ] 背景の記述（先行研究3-5件引用）
  - [ ] 問題設定の明確化
  - [ ] 貢献の3点リスト

- [ ] **System Model**
  - [ ] 数式の整合性確認
  - [ ] 記号表の作成
  - [ ] 図1（システム構成図）の作成

- [ ] **Experimental Setup**
  - [ ] ハードウェア仕様の記載
  - [ ] データセット情報の記載
  - [ ] 再現可能な実験条件の記述

- [ ] **Results**
  - [ ] 図表の挿入
  - [ ] 統計的有意性の記載（あれば）
  - [ ] 考察の記述

- [ ] **Conclusion**
  - [ ] 主要結果の要約
  - [ ] Future Workの明記

- [ ] **その他**
  - [ ] 英文校正
  - [ ] フォーマット確認（IEICE ComEX template）
  - [ ] 参考文献フォーマット確認

---

## 5. リスク管理

### 5.1 技術リスク

| リスク | 影響 | 対策 |
|--------|------|------|
| ESP32のT_adv動的変更が不安定 | 実験不可 | 事前に100セッション分の安定性テスト |
| Android受信漏れ | Pout過大評価 | LOW_LATENCYモード固定、バックグラウンド処理停止 |
| PPK-II同期ずれ | μC算出誤差 | GPIOマーカーで±10ms以内に補正 |
| mHealthのCCS分布が偏る | 効果が見えない | 事前にCCS分布を確認、必要なら複数被験者使用 |

### 5.2 スケジュールリスク

| リスク | 影響 | 対策 |
|--------|------|------|
| 準備が遅延 | 実験期間圧縮 | Week1で最低限動く状態を優先 |
| 実験環境が使えない | 実験不可 | 代替環境を事前に確保 |
| データ処理で問題発覚 | 再実験 | 毎日の品質チェックで早期発見 |

### 5.3 Goサイン判定基準

**Week 1終了時点で以下が揃っていればGo**:
- [ ] CCS時系列10セッション分が生成済み
- [ ] ESP32ファームウェアが3モードで動作
- [ ] Android受信ログが正常に取れる
- [ ] PPK-IIでの電力計測がフェーズ0-0と整合

**揃っていない場合**:
- 不足分の優先対応
- 実験スケジュールの後ろ倒し
- 最悪、セッション数を30に削減（5反復）

---

## 6. 成果物一覧

### コード

**CCS生成（完了）**:
- [x] `scripts/generate_ccs_sequences.py` - TFLite推論+U/S/CCS計算+時系列出力
- [x] `scripts/create_esp32_sessions.py` - ESP32用セッション選定

**ESP32ファームウェア（完了、2025-11-29 ディレクトリ再編済み）**:
- [x] `esp32_firmware/baseline_on/` - マルチinterval自動実行（TX/TXSD/RX）
- [x] `esp32_firmware/baseline_off/` - OFF計測（TX/TXSD）
- [x] `esp32_firmware/ccs_mode/` - CCSモード（TX/TXSD/RX + ccs_session_data.h）
- [x] ハッシュ記録: `docs/フェーズ0-0/decision_log_2025-11-29.md` Section 7

**データ処理（未実装）**:
- [ ] `scripts/sync_logs.py` - TX/RX/電力ログのタイムスタンプ統一
- [ ] `scripts/compute_event_charge.py` - μC/event算出
- [ ] `scripts/compute_pout.py` - Pout(τ)算出

**暫定代替**: `scripts/analyze_baseline_v2.py` でbaseline ON/OFF計測のΔE/adv算出は可能

### データ

**CCS時系列（完了）**:
- [x] `data/ccs_sequences/subject{01-10}_ccs.csv`
- [x] `data/ccs_sequences/generation_summary.json`
- [x] `data/esp32_sessions/session_{01-10}.csv`
- [x] `data/esp32_sessions/session_manifest.json`
- [x] `data/esp32_sessions/session_selection_report.md`

**実験データ（未取得）**:
- [ ] `data/raw/E1/`, `data/raw/E2/`
- [ ] `data/experiments_manifest.yaml`

### 結果
- [ ] `results/kpi_summary.csv`
- [ ] `results/statistical_tests.md`
- [ ] `figures/fig1_tradeoff.pdf`
- [ ] `figures/fig2_timeseries.pdf`
- [ ] `figures/fig3_energy_saving.pdf`

### 文書
- [x] `data/esp32_sessions/session_selection_report.md`
- [ ] `docs/experiment_log.md`
- [ ] `paper/main.tex`

---

## 次のアクション

**完了済み（2025-11-27）**:
- [x] 0.1 既存資産の棚卸し
- [x] 0.2 ハードウェア準備状況の確認
- [x] 1.1 mHealth CCS時系列生成
- [x] 閾値調整（θ_high=0.90, θ_low=0.80）

**残タスク**:
1. [x] ~~1.2 CCSモード拡張~~ (2025-11-28 完了)
2. [x] ~~1.3 Android受信アプリ~~ → nRF Connect使用 (2025-11-28 決定)
3. [x] ~~0.2 Android OSバージョン確認~~ → Android 10 (2025-11-28 確認)
4. [x] ~~配線修正~~ → INA219 Vcc直結、UART 115200bps (2025-11-29 完了)
5. [ ] **Baseline再計測** (進行中 2025-11-30)
   - [x] OFF計測完了 (11 trials)
   - [ ] ON計測 (100/500/1000/2000ms 自動実行中)
6. [ ] 1.4.3 P_off/ΔE/adv再校正（Baseline再計測データで算出）
7. [ ] 0.2 E1環境確認、距離1mマーキング確認

---

*Last updated: 2025-11-30*
</file>

<file path="全体像.md">
# ReFormHAR-Tiny: Vision / World Model

本ドキュメントは、**ReFormHAR-Tiny** プロジェクトの研究ビジョンと世界観を体系的に記述する。
他のAI・研究者がプロジェクトの方向性を正しく理解し、一貫した判断ができるようにすることを目的とする。

---

## 0) 研究ビジョンの階層構造

### Phase 1: 今回のレター（短期目標）

> **「Safe Contextual Banditの前段階として、決め打ちルールの実装と評価指標の確立」**

**位置づけ**:
- Safe-MABの「warm-start用ベースライン」を作る
- 評価指標（Pout(τ), μC）の測定系を確立する
- 単純なルールでも「効果がある」ことを示し、将来の学習ベース手法の土台を作る

**主張**:
> 「HAR不確実度に基づくBLE広告間隔の適応制御において、単純な閾値ルールでも固定間隔と比較して省電力効果が得られることを示した。提案手法は、将来のSafe Contextual Banditによるオンライン最適化の基盤となる。」

**レターに含めるもの**:
1. 問題定式化: Pout(τ)制約下でのエネルギー最小化問題
2. 評価指標: Pout(τ), μC/eventの定義と測定方法
3. 決め打ちルール: CCS→T_adv写像の実装
4. 実験評価: 固定100ms / 固定2000ms / CCS制御の比較
5. Future Work: Safe Contextual Banditへの拡張

**レターに含めないもの（Future Work）**:
- MAB/RLの学習アルゴリズム
- 非理想スキャンのモデリング
- HAR誤認識の統合評価（RoME）

### Phase 2: 研究テーマ（修論〜博士前期）

> **「HAR不確実度を活用したBLE広告のSafe Contextual Bandit最適化」**

**問題定式化**:
- **コンテキスト**: HAR推論の不確実度 U、安定度 S
- **行動（Arm）**: 広告間隔 T_adv ∈ {100, 500, 1000, 2000ms}
- **報酬**: −μC（エネルギー最小化）
- **制約**: Pout(τ) ≤ δ（QoS保証）

**新規性**:
1. HAR不確実度をContextual Banditの「コンテキスト」として初めて使用
2. Pout(τ)を「制約」として扱うSafe Bandit定式化
3. アプリ層（HAR）→通信層（BLE）のクロスレイヤー最適化

### Phase 3: 究極のゴール（5-10年スパン）

> **「アプリ層のセマンティクスが通信層を自律制御する、エッジAIの新しいパラダイム」**

- TinyMLデバイスが「今この瞬間、どれだけ確信を持っているか」を通信スタックに伝える
- 通信層は、そのセマンティクスに応じてリソース配分を動的に変える
- 人間の介入なく、デバイスが自律的に「省電力」と「QoS保証」を両立する

---

## 1) World Model（世界観の骨格）

### 1.1 役者（Actors）

| Actor | 役割 | 備考 |
|-------|------|------|
| **Edge Node / DUT** | IMU＋MCUでHARをオンデバイス推論。U, S, CCSを生成しBLE広告を制御 | ESP32-S3/C3想定 |
| **Gateway（スマホ/受信機）** | BLE広告の受信主体。スキャンは非理想（チャネル巡回・隙間・モード差） | Android LOW_LATENCY |
| **Observer / Orchestrator** | ログ収集、KPI算出。クラウド常時接続は不要 | 実験・運用時 |
| **Safety Oracle（概念）** | QoS制約（Pout(τ) ≤ δ）を定義。方策が守るべき境界 | 規格書的存在 |
| **Policy Engine** | 通信層の意思決定器。Phase 1はルール、Phase 2でSafe-MAB | 段階的進化 |

### 1.2 能力（Capabilities）— 5つの柱

1. **Perception（知覚）**: IMU → HAR → 確率分布 (p_k) → U（不確実度）、S（安定度）
2. **Decision（意思決定）**: CCS をコンテキストに BLE広告間隔を決定
3. **Communication（通信）**: μC/event最小で、Pout(τ)制約を満たす広告
4. **Safety（安全）**: 常時 Pout(τ) ≤ δ を満たす制約の中で最適化。違反兆候で安全側へ退避
5. **Observability（可観測性）**: すべての意思決定に根拠ログ（U, S, CCS, 閾値, 切替理由）を残す

### 1.3 不変条件（Invariants）

- **オンデバイス優先**: 生センサは外に出さない（プライバシ）
- **QoS優先の最適化**: Pout(τ) を常に制約として扱い、その範囲内で電力最小化
- **後方互換のIF**: `decide_interval(context) → interval` のIFは固定（将来MAB/Safe-MABでも同じ）
- **単一真実のKPI**: μC/event、Pout(τ)、TL分布を一次指標。平均電流やmWh/日は従属

### 1.4 境界条件（Operating Envelope）

- **MCU制約**: RAM ≤ 256KB / Flash ≤ 1MB、INT8演算前提
- **BLE制約**: Legacy Advertising、3ch（37/38/39）、Tx/EIRPとDutyは地域規制遵守
- **受信制約**: スマホは連続スキャンではない（モードで挙動が変化）。理想化しない

---

## 2) Ontology（用語・データ辞書）

### 2.1 概念・変数

| 変数 | 定義 | 範囲 |
|------|------|------|
| **(p_k)** | HARのクラス確率 | Σp_k = 1 |
| **U** | 正規化エントロピー（不確実度） | [0, 1] |
| **S** | 安定度（遷移が少ないほど1に近い） | [0, 1] |
| **confidence** | 1 − U | [0, 1] |
| **CCS** | Composite Confidence Score = 0.7×confidence + 0.3×S | [0, 1] |
| **T_adv / Arm** | 広告間隔。Phase 1: {100, 500, 1000, 2000}ms | ms |
| **TL** | Time-to-first-Receive。イベント検知→初回受信までの遅延 | ms |
| **Pout(τ)** | Outage probability。期限τ内に初回受信できない確率 | [0, 1] |
| **μC/event** | 広告イベント1回あたりの電流積分 | μC |

### 2.2 CCS定義の根拠と感度分析

**採用定義**: CCS = 0.7 × (1 − U) + 0.3 × S = 0.7 × confidence + 0.3 × S

**根拠**:
1. **変数名との整合性**: CCS = Composite Confidence Score。高い値が「確信がある」という解釈と一致
2. **Safe Banditとの整合性**: CCS高い → 確信あり → 長い間隔OK → 省電力。単調な写像で直感的
3. **論文での説明容易性**: "Higher CCS indicates the system can safely extend advertising intervals."
4. **主成分の重視**: 推論の確信度（confidence）を0.7、時間的安定性（S）を0.3で補助的に扱う

**係数の選択**:
- α=0.7, β=0.3 は経験的初期値
- confidence（瞬時の推論品質）を主成分とし、stability（時間的一貫性）を補助とする設計意図

**感度分析（Future Work）**:
- 係数 (α, β) の変動が KPI（μC, Pout(τ), TL_p95）に与える影響を評価
- 候補: (0.8, 0.2), (0.7, 0.3), (0.6, 0.4), (0.5, 0.5)
- 評価方法: 同一実験データに対して係数を変えた場合の省電力効果とQoS劣化のトレードオフを可視化
- 最適係数はアプリケーション依存（QoS重視 vs 省電力重視）であり、ユースケース毎に調整可能とする

### 2.3 ログスキーマ

| ログ種別 | 主キー |
|----------|--------|
| **Tx** | `t, session_id, adv_interval, ch_mask, tx_dbm, state, U, S, CCS, reason` |
| **Rx** | `t, session_id, phone_model, scan_mode, rx_uuid, rssi, dedup_flag` |
| **Power** | `t, current_mA, voltage_V, event_marker` |
| **KPI** | `avg_current, event_charge_uC, TL_p50, TL_p95, Pout_1s/_2s/_3s, PDR` |

> すべて列追加で拡張可能（後方互換）。将来のMAB拡張時に `arm, reward, context` 列を追加。

---

## 3) 研究の段階（Phases）

### Phase 1: Rule-based（今回のレター）

| 項目 | 内容 |
|------|------|
| **何をするか** | CCSで adv_interval を切替（100/500/1000/2000ms）。ヒステリシス＋滞在時間で安定化 |
| **なぜ意味があるか** | μC/eventと平均電流を削減しつつ、Pout(τ)・TLが基準と同等であることを示せる |
| **成果物** | 評価指標の確立、warm-start用ベースライン、KPIパイプライン |
| **残る課題** | 環境・端末依存性を考慮できない。最適点は状況で変わる |

### Phase 2: Safe Contextual Bandit（修論テーマ）

| 項目 | 内容 |
|------|------|
| **何をするか** | コンテキスト=(U,S)、腕=T_adv、報酬=−μC、制約=Pout(τ)≤δ のSafe Bandit |
| **なぜ意味があるか** | 環境ごとに最適点へ自律収束しつつ、QoS保証を維持 |
| **アルゴリズム候補** | Conservative UCB, SafeOpt, Constrained Thompson Sampling |
| **残る課題** | 先験情報（端末スキャン挙動）の活用、学習初期の後悔 |

### Phase 3: Semantic-driven Communication（長期ビジョン）

| 項目 | 内容 |
|------|------|
| **何をするか** | アプリ層のセマンティクス（確信度、緊急度、価値）が通信層を自律制御 |
| **なぜ意味があるか** | 人間介入なしで省電力とQoS保証を両立。エッジAIの新パラダイム |
| **発展方向** | 知識蒸留によるwarm-start、マルチデバイス協調、アプリ横断の優先度制御 |

---

## 4) 価値の地図（Value Map）

### 4.1 定量KPI

| 区分 | KPI |
|------|-----|
| **一次（Primary）** | μC/event, Pout(τ), TL_p95 |
| **二次（Secondary）** | 平均電流, mWh/日, PDR, F1/Acc |
| **複合（Composite）** | J/decision（1検出あたりエネルギ）, QoS違反率 |

### 4.2 ユースケース枠

| ユースケース | 要件 |
|--------------|------|
| **見守り**（転倒・無動作） | 偽陰性 < 偽陽性、Pout(2s) ≪ δ |
| **労働安全**（急変姿勢通知） | TL_p95 ≤ 500ms、電池寿命30日↑ |
| **スポーツ**（フォーム変化検知） | 遷移期だけ濃く、安定期は薄く |

---

## 5) ガバナンス（Governance Model）

- **規格準拠**: BLE広告・出力規制・Duty規制の上限はPolicyが越えない
- **安全網**: QoS違反兆候 → 安全側へ退避（短間隔×3ch固定）
- **説明責任**: 各ラウンドの Decision Rationale は不可欠ログ
- **データ最小化**: ログは匿名化。生IMUは外に出さない
- **監査可能性**: 実験再現用の Runbook と KPIパイプラインを常備

---

## 6) リスク & フェイルセーフ

| リスク | 兆候 | フェイルセーフ | 恒久対策 |
|--------|------|----------------|----------|
| QoS違反（Pout上昇） | TL分布が右シフト | 短間隔×3ch | Safe-MABの制約強化 |
| 受信端末差 | PDR低下・端末依存 | 端末切替/再起動 | 端末別事前重み |
| 切替振動 | 切替頻発ログ | ヒステリシス/滞在時間 | U/S較正、窓W調整 |
| 学習初期の後悔 | 違反スパイク | Warm-Start | 知識蒸留（禁止腕/初期重み） |

---

## 7) ロードマップ

```
Phase 1 (レター)          Phase 2 (修論)           Phase 3 (長期)
─────────────────────────────────────────────────────────────────
決め打ちルール実装    →   Safe Contextual Bandit  →  Semantic-driven
評価指標確立              Pout(τ)制約保証             Communication
warm-startベースライン    環境適応学習                 マルチデバイス協調
```

---

## 8) 要約（AIが誤読しないための短文仕様）

- **Goal**: Pout(τ)を守りながら、μC/eventを最小化（端末内完結）
- **Signals**: U ∈ [0,1], S ∈ [0,1], CCS = 0.7×(1−U) + 0.3×S
- **Policy IF（不変）**: `context(U, S, CCS) → interval`（将来Safe-MABでも同じ）
- **KPI（一次）**: μC/event, Pout(τ), TL_p95
- **Safety**: Pout(τ) ≤ δ を制約として常時満たす（Phase 2以降）
- **Fallback**: いつでも `interval=短/3ch` に退避可
- **Logs**: Decision Rationale を毎切替で出力
- **Growth**: Phase 1（ルール）→ Phase 2（Safe Bandit）→ Phase 3（セマンティック制御）

---

## 9) 参考リソース

- **TinyML**: A Comprehensive Survey on TinyML
- **BLE受信の非理想性**: スキャン挙動の実機観測・モデル化
- **HAR省電力**: システム最適化の俯瞰

> これらは世界観の根拠としての役割を持つ。必要に応じてKPI式・閾値・境界条件を抽出。

---

*Last updated: 2025-11-27*
</file>

</files>
