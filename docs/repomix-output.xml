This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.obsidian/
  app.json
  appearance.json
  core-plugins.json
  workspace.json
paper/
  BLE非理想スキャン_RL最適化_リサーチノート.md
  literature_review_ble_dynamic_adv.md
  repomix-output.xml
  TinyML制約付き学習_リサーチノート.md
  不確実性駆動送信制御_リサーチノート.md
トラブルシューティング/
  BLE省電力計測健全化_統合タイムライン.md
  OFF高消費電力_トラブルシューティング.md
フェーズ0-0/
  技術トピック_電力計測健全化.md
  実験ログ_E2_1m_2025-11-09.md
  実験装置最終仕様書.md
  要件定義.md
フェーズ0-1/
  要件定義.md
フェーズ0-2/
  要件定義.md
フェーズ1/
  model定義.md
  Runbook.md
  詳細設計定義書_送信ログテンプレート.csv
  詳細設計定義書.md
  詳細要件定義書.md
  設計定義書.md
  用語集.md
  要件定義.md
全体像.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".obsidian/app.json">
{}
</file>

<file path=".obsidian/appearance.json">
{}
</file>

<file path=".obsidian/core-plugins.json">
{
  "file-explorer": true,
  "global-search": true,
  "switcher": true,
  "graph": true,
  "backlink": true,
  "canvas": true,
  "outgoing-link": true,
  "tag-pane": true,
  "footnotes": false,
  "properties": false,
  "page-preview": true,
  "daily-notes": true,
  "templates": true,
  "note-composer": true,
  "command-palette": true,
  "slash-command": false,
  "editor-status": true,
  "bookmarks": true,
  "markdown-importer": false,
  "zk-prefixer": false,
  "random-note": false,
  "outline": true,
  "word-count": true,
  "slides": false,
  "audio-recorder": false,
  "workspaces": false,
  "file-recovery": true,
  "publish": false,
  "sync": true,
  "bases": true,
  "webviewer": false
}
</file>

<file path=".obsidian/workspace.json">
{
  "main": {
    "id": "e34f05f72a0026ab",
    "type": "split",
    "children": [
      {
        "id": "766df89df37addb6",
        "type": "tabs",
        "children": [
          {
            "id": "ce2e5c235d3db0bc",
            "type": "leaf",
            "state": {
              "type": "empty",
              "state": {},
              "icon": "lucide-file",
              "title": "新規タブ"
            }
          }
        ]
      }
    ],
    "direction": "vertical"
  },
  "left": {
    "id": "f115f74a67ced9b6",
    "type": "split",
    "children": [
      {
        "id": "64cbbb82342fa1ab",
        "type": "tabs",
        "children": [
          {
            "id": "9d2a1d4898dceacb",
            "type": "leaf",
            "state": {
              "type": "file-explorer",
              "state": {
                "sortOrder": "alphabetical",
                "autoReveal": false
              },
              "icon": "lucide-folder-closed",
              "title": "ファイルエクスプローラ"
            }
          },
          {
            "id": "a12366f22a6989f5",
            "type": "leaf",
            "state": {
              "type": "search",
              "state": {
                "query": "",
                "matchingCase": false,
                "explainSearch": false,
                "collapseAll": false,
                "extraContext": false,
                "sortOrder": "alphabetical"
              },
              "icon": "lucide-search",
              "title": "検索"
            }
          },
          {
            "id": "fa31cdedfd666456",
            "type": "leaf",
            "state": {
              "type": "bookmarks",
              "state": {},
              "icon": "lucide-bookmark",
              "title": "ブックマーク"
            }
          }
        ]
      }
    ],
    "direction": "horizontal",
    "width": 300
  },
  "right": {
    "id": "f340c6adcb6274c7",
    "type": "split",
    "children": [
      {
        "id": "0206ba7a953049d7",
        "type": "tabs",
        "children": [
          {
            "id": "cbc9f5c4fb889eed",
            "type": "leaf",
            "state": {
              "type": "backlink",
              "state": {
                "collapseAll": false,
                "extraContext": false,
                "sortOrder": "alphabetical",
                "showSearch": false,
                "searchQuery": "",
                "backlinkCollapsed": false,
                "unlinkedCollapsed": true
              },
              "icon": "links-coming-in",
              "title": "バックリンク"
            }
          },
          {
            "id": "f927578b5314fb6c",
            "type": "leaf",
            "state": {
              "type": "outgoing-link",
              "state": {
                "linksCollapsed": false,
                "unlinkedCollapsed": true
              },
              "icon": "links-going-out",
              "title": "アウトゴーイングリンク"
            }
          },
          {
            "id": "0cfa520619b6188d",
            "type": "leaf",
            "state": {
              "type": "tag",
              "state": {
                "sortOrder": "frequency",
                "useHierarchy": true,
                "showSearch": false,
                "searchQuery": ""
              },
              "icon": "lucide-tags",
              "title": "タグ"
            }
          },
          {
            "id": "e9f9f7b795895ffe",
            "type": "leaf",
            "state": {
              "type": "outline",
              "state": {
                "followCursor": false,
                "showSearch": false,
                "searchQuery": ""
              },
              "icon": "lucide-list",
              "title": "アウトライン"
            }
          }
        ]
      }
    ],
    "direction": "horizontal",
    "width": 300,
    "collapsed": true
  },
  "left-ribbon": {
    "hiddenItems": {
      "switcher:クイックスイッチャーを開く": false,
      "graph:グラフビューを開く": false,
      "canvas:新規キャンバスを作成": false,
      "daily-notes:今日のデイリーノートを開く": false,
      "templates:テンプレートを挿入": false,
      "command-palette:コマンドパレットを開く": false,
      "bases:Create new base": false
    }
  },
  "active": "9d2a1d4898dceacb",
  "lastOpenFiles": [
    "paper/repomix-output.xml",
    "paper/BLE非理想スキャン_RL最適化_リサーチノート.md",
    "paper/TinyML制約付き学習_リサーチノート.md",
    "paper/不確実性駆動送信制御_リサーチノート.md",
    "全体像.md",
    "paper/literature_review_ble_dynamic_adv.md",
    "paper",
    "トラブルシューティング/BLE省電力計測健全化_統合タイムライン.md",
    "フェーズ0-0/技術トピック_電力計測健全化.md",
    "フェーズ0-0/実験装置最終仕様書.md"
  ]
}
</file>

<file path="paper/BLE非理想スキャン_RL最適化_リサーチノート.md">
以下は、**非理想的なスマホスキャン環境下でのBLEアドバタイズ最適化**に関するリサーチノートです。  
理論的な一般論ではなく、**スマホOSの挙動・数理モデル・MAB/RLアルゴリズム・シミュレータ・実装戦略**といった深い部分だけを抜き出して整理します。

---

# 1. 非理想スキャン環境の具体像

## 1.1 BLE近隣発見の基本モデル（再掲）

- アドバタイザ側:
  - アドバタイズ間隔 `T_adv` ごとに、3チャネル（37/38/39）へ送信。
  - BLE仕様上、各イベントに 0〜10 ms 程度の疑似ランダム遅延が混入。
- スキャナ側:
  - スキャン間隔 `T_scan` ごとに、スキャンウィンドウ `d_scan` だけ受信。
  - デューティ比 `δ = d_scan / T_scan`。
- 発見遅延 L:
  - アドバタイズイベントとスキャンウィンドウの **オーバーラップまでの時間**。
  - スロットレスだが、ランダム遅延と `T_adv`, `T_scan` の相互作用から分布が決まる。

---

## 1.2 決定論的ブラインドスポット（Valley Area）

- **高調波関係問題**
  - `T_adv` と `T_scan` が整数比（高調波）に近い場合、
    - アドバタイズが系統的にスキャナのスリープ区間に入り続け、
    - 半ば決定論的に「ほぼ見つからない」組み合わせが生じる。
- **ランダム遅延の限界**
  - 仕様上のランダム遅延は偶然の位相ずれを生むが、
    - エネルギー制約のある端末ではイベント数自体が少なく、
    - 最悪ケース遅延や Valley Area を確率論的に打ち消すには不十分な場合がある。
- **高密度環境**
  - 多数のアドバタイザが同時に送信する場合、
    - スキャナ側の受信スロットが飽和 → 衝突・競合でパケットロス。
  - 理想モデル（ランダム一様・単一ペア）から大きく逸脱する。

---

## 1.3 Android の非理想スキャン挙動（2023–2025）

- **スキャンモードと実際のデューティ**
  - `SCAN_MODE_LOW_LATENCY`
    - フロント（画面ON・アプリフォアグラウンド）時のみ **ほぼ連続スキャン**に近い動作。
  - `SCAN_MODE_BALANCED` / `LOW_POWER`
    - バックグラウンドでは、例として「500 ms スキャン / 5000 ms スリープ」など、
      - デューティ `δ < 10%` 程度に強制的に落とされるケースが多い。
  - 実際のウィンドウ/間隔は端末・OSバージョン依存であり、**アプリ側からは取得できない**。

- **Doze / App Standby / Android 15 の変更**
  - Dozeモード:
    - 端末がアイドル（画面OFF・充電無し）に入ると、
      - スキャンは OS により間欠的にしか実行されない。
  - Android 15:
    - `BLUETOOTH_SCAN` 権限導入でプライバシー分離を行いつつ、
      - バックグラウンドスキャンのスロットリングが強化。
    - 「オポチュニスティック・スキャン」:
      - 他アプリのスキャンに便乗して結果を共有する形になり、
      - **自アプリが明示的に連続スキャンしているわけではない**。
    - 実務報告レベルでは、「バックグラウンド連続スキャンが 30 分程度で OS によって止まる」という事象が観測されている。

---

## 1.4 iOS の非理想スキャン挙動（iOS 18 まで）

- **バックグラウンド制約**
  - アプリがバックグラウンドに落ちると、
    - BLEスキャンの **頻度・長さはOS内部ロジックにより大幅に縮退**。
    - 実測では「数秒〜数分に一度、数 ms のウィンドウ」というレベルになる事例も報告。
  - **Duplicate Filtering 強制**
    - バックグラウンドでは、**同じ周辺機器からのアドバタイザは最初の1回しか通知されない**。
    - 継続的な RSSI 監視や連続データを受け取るには、接続モードに移行するか、アドバタイザ側が UUID/アドレスを変える等トリッキーな手が必要。

- **iOS 18 / AccessorySetupKit**
  - アクセサリセットアップを簡略化するフレームワーク。
  - ただし、「ユーザ主導のペアリング」を前提とした API であり、
    - 不特定多数のビーコンをバックグラウンドで検出し続ける用途の制限は緩和されていない。

---

## 1.5 オポチュニスティック・スキャンと合成ウィンドウ

- 複数アプリが異なるパラメータでスキャンする場合、
  - 実際のRFレベルでは「スキャンウィンドウの和集合」がハードウェアで実行される。
  - これを **Opportunistic Scan** と呼ぶ。
- アドバタイザからは、
  - 合成されたスキャンパターンは完全に未知であり、時間とともに変化。
  - この「未知で非定常なスキャナ」を前提にした制御問題として扱うのが妥当。

---

# 2. MAB / RL によるアドバタイズ最適化

## 2.1 Hasegawa/Kitagawa 系列の MAB アプローチ

- **問題設定**
  - アーム `a`：アドバタイズ間隔 × チャンネルマスク（37/38/39 の組み合わせ）。
    - 例：interval ∈ {100, 500, 1000 ms} × mask ∈ {3ch, 2ch, 1ch}。
  - 時刻 t ごとにアームを選び、その設定で広告 → 成功/失敗とエネルギーを観測。

- **報酬設計（例）**

  ```text
  R_t = α · 1{Success_t} − β · E_t
  ```

  - `Success_t`:
    - Scan Request / Connect Request を受信できたかどうか。
  - `E_t`:
    - その送信条件で消費したエネルギー（電流積分や、SF/TxPower/回数の近似式）。
  - α, β で「発見率 vs 省電力」のトレードオフを調整。

- **重要なポイント**
  - スキャナの `T_scan, d_scan, δ` を一切明示的に知らなくても、
    - 成功フラグだけを見て「スキャナと噛み合いやすい interval/mask」を暗黙に学習。
  - 混雑度や OS スケジューラの変化は「報酬分布の変動」として現れ、
    - アルゴリズムが自動的に再適応する。

---

## 2.2 UCB1‑tuned と Tug‑of‑War (TOW)

- **UCB1‑tuned**
  - 通常の UCB は「平均報酬 + √(ln t / n_k)」のみを見るが、
    - 無線環境では報酬分散が大きい（混雑・フェージングなど）。
  - UCB1‑tuned は分散推定 `σ_hat_k^2` を入れて上界を調整：

    ```text
    UCB_k = μ_hat_k + sqrt{ (ln t / n_k) * min(1/4, σ_hat_k^2 + sqrt(2 ln t / n_k)) }
    ```

  - 分散が大きいアームは探索項が増える一方、
    - 極端に不安定なアームは早めに見切りをつけやすく、収束が安定。

- **Tug‑of‑War (TOW) ダイナミクス**
  - よりシンプルで演算も軽い更新則を持つ意思決定アルゴリズム。
  - 利点:
    - 非定常環境（スキャナ挙動が頻繁に変わる）で、
      - 重い UCB 系よりも素早く「当たりのアーム」に切り替えられるケースがある。
  - BLE環境では、短時間接触（すれ違い）や瞬間的な負荷変動に対する追従性が評価されている。

---

## 2.3 Q-Learning / Deep RL による長期的最適化

- **状態と行動の例**
  - 状態 S:
    - バッテリ残量（離散化）、直近の成功率（窓平均）、推定混雑度（loss率）。
  - 行動 A:
    - アドバタイズ間隔の増減（100→500→1000msなど）。
    - 送信電力の調整（TxPower ステップアップ/ダウン）。

- **効果**
  - シミュレーションでは、
    - ランダム/固定方式に比べてネットワーク寿命を大幅に延長しつつ、
    - 最大遅延制約（例: TL p95 ≤ τ）を満たす方策を獲得。

- **課題**
  - Q-Learning は**収束までの試行数が多い**（Warm‑up が長い）。
  - スマホとの接触時間が短いシナリオ（すれ違い広告など）では、
    - 学習が終わる前に通信機会が終わる危険。
  - これに対し、**事前にオフライン学習した DQN ポリシーを MCUに焼き込む**形で、
    - 初期からそこそこ良い行動をとれるようにする研究もある。

---

## 2.4 コンテキストMAB：Wi‑Fi/外部情報の利用

- **アイデア**
  - BLE だけでなく、スマホが頻繁に行っている Wi‑Fi スキャン結果などを「コンテキスト」として利用。
  - 例:
    - 周辺 Wi‑Fi AP の RSSI 分布や BSSID 数から「端末がアクティブに通信している状況か」を推定。
    - このとき BLE スキャンも動いている可能性が高いと仮定し、広告間隔を一時的に短縮。

- **類似事例**
  - mmWave 近隣発見の研究では、
    - Wi‑Fi の情報からビーム方向や探索優先度を学習するコンテキストバンディットが提案されており、
    - BLEのチャンネル／interval 選択にもコンセプトが応用可能。

---

# 3. シミュレーションフレームワークと決定論的検証

## 3.1 Blender フレームワーク（トレース駆動）

- **従来シミュレータの問題**
  - スキャナを「一定の確率で On/Off するランダムプロセス」としてモデル化。
  - 実際の OS スケジューラは決定論的であり、
    - 例: 「1.5s スキャン、3.5s スリープ」を正確に繰り返す端末など。
  - この場合、理論上「見つかるはず」のパラメータが**永遠に見つからない**ことがありうる。

- **Blender の特徴**
  - **トレース駆動（trace‑driven）**
    - 実機 Android/iOS から収集したスキャンログを入力。
  - **全位相探索**
    - `T_adv, T_scan, d_scan, loss_rate` を与えると、
      - 可能な全ての位相差に対する遅延分布を決定論的に計算。
    - パラメタ例:
      - `adv_interval`: 20〜10240 ms
      - `scan_interval`, `scan_window`: 20〜10240 ms
      - `loss_rate`: 0〜99%
  - 結果:
    - **最悪ケース遅延** や Valley Area を明示的に把握できる。
    - MAB/RLで学んだポリシーが、特定のOSや端末で「穴」にはまらないか検証可能。

---

## 3.2 ElastiCast：インターバル多重化戦略

- **発想**
  - 単一の固定 `T_adv` では、全てのスキャナに対して良い性能を出すことは困難。
  - そこで、**複数の `T_adv` を時間的に多重化**する。
    - 例: 素数関係にある複数の interval を組み合わせる。

- **効果**
  - 高調波関係による Valley Area を避け、
    - どのような `T_scan, d_scan` を持つ端末でも、
    - ある程度の時間内には必ずオーバーラップするように設計する。
  - 「学習で環境に合わせる」アプローチに対し、
    - ElastiCast は「**決定論的設計で最悪ケースを潰す**」方向の戦略。

---

## 3.3 ReND：推論ベース近隣発見（Reasoning-based ND）

- **三段論法によるトリガー**
  - 大前提: クラウドDBに「BLEビーコンXはWi‑Fi AP Yの近くにある」という知識を保存。
  - 小前提: スマホが Wi‑Fi スキャンで AP Y を発見。
  - 結論: 「ビーコンXが近くにいる可能性が高い」と推論。
- **実装**
  - 推論成立時に、アプリが OS に対して「高頻度BLEスキャン」を一時的に要求。
  - 通常は数％の duty に抑えつつ、
    - **必要な瞬間だけ 100% に近いスキャン**を実行し、一発で発見する。

- **強化学習との関係**
  - MAB/RL が「アドバタイザがスキャナに合わせに行く」アプローチだとすると、
    - ReND は「スキャナの duty をアプリ側から引き上げる」アプローチ。
  - 両者は補完的:
    - ReNDでチャンスを作り、
    - その中で MAB/RL で最適 interval/mask を当てる、という組み合わせも考えられる。

---

# 4. 実装上の示唆（ReFormHAR‑Tiny への応用視点）

- **アドバタイザ側（ESP32/TX）**
  - 低コストな MAB（UCB1‑tuned or TOW）をファームウェア内に実装し、
    - 報酬を「ScanReq/ConnectReq 成功 − λ·消費エネルギー」で設計。
  - 将来的に LinUCB などコンテキストバンディットを使う場合は、
    - 受信側ログや外部メタデータを簡約した「コンテキスト特徴」をどう埋め込むかを設計する余地あり。

- **スキャナ側（スマホアプリ）**
  - Android:
    - `SCAN_MODE_LOW_LATENCY` を必要時だけ On にする **オンデマンドスキャン**。
    - 他アプリのトレースを収集し、Blender 系のフレームワークで Valley Area を事前解析。
  - iOS:
    - Backgroud Duplicate Filtering を前提に、
      - 「単発検出」用途に割り切るか、
      - 接続モードへの移行や ReND 的トリガーを利用するかを設計段階で決める必要あり。

- **評価**
  - 単に平均 PDR/TL でなく、
    - Blender 等で **最悪ケースTL** と Valley Area の有無を指標化することが重要。
  - 実験時は、ターゲット端末（Pixel系, Galaxy系, iPhone世代別）ごとにトレースを収集しておくとよい。

このノートは、BLE広告最適化を「非理想スキャナ前提」で考えるための材料として、OS挙動・MAB/RL・シミュレータ・実システムの接続方法をまとめたものである。  
フェーズ2以降の MAB/Safe‑MAB や ReND的なトリガー設計を検討する際に、必要な要素だけを抜き出して使えるようにしている。
</file>

<file path="paper/literature_review_ble_dynamic_adv.md">
以下は、BLEアドバタイズ間隔制御と省電力・到達性評価・バンディット学習適用に関する先行研究の整理ノートです。  
ReFormHAR‑Tiny プロジェクトのペーパー用バックグラウンドとして位置づけ、要件定義や設計書からは独立に管理します。

---

# 1. 調査の目的と観点

本調査では、次の 3 点を同時に満たす先行研究が存在するかを確認した。

1. **BLEアドバタイズ間隔を動的に調整して省電力化すること**  
2. **実機で電力と通信到達性（PDR, TL, Pout など）を同時に測定して評価していること**  
3. **マルチアーム・バンディット（MAB）等のオンライン学習で環境適応を行っていること**  

これらを満たす研究が既にあるか、もしくは部分的に満たす研究の組み合わせがどの程度存在するかを確認した。

---

# 2. 動的アドバタイズ間隔制御に関する先行研究

## 2.1 ヒューリスティック／ルールベースな制御

- 無線チャネルの混雑度やビーコン受信状況に応じて、**広告間隔を伸縮させるヒューリスティックな手法**はいくつか報告されている。
  - 例: 周囲のトラフィック密度（近接ビーコン数やスキャン成功率）に応じて、`adv_interval` を段階的に増減させる方式。
  - 例: 電子棚札やデジタルサイネージにおいて、**人気度・アクセス頻度**に応じて広告頻度を下げることで電力を節約する方式。
- 多くの場合、
  - 制御則は「if 混雑度>閾値 then intervalを伸ばす」といった**固定ロジック**であり、
  - オフラインで決めたパラメタに従って挙動するに留まる。

## 2.2 最適化問題としての扱い

- 一部の研究では、「発見遅延」と「消費電力」のトレードオフを解析的にモデル化し、**最適な広告間隔を数値的に求める**手法が提案されている。
  - 例: ビーコン発見までの期待遅延を解析し、許容遅延の範囲内で電力を最小化する `adv_interval` を導出する研究。
- これらは主に
  - 理論解析やシミュレーションに基づき、
  - 実システムへの実装は「固定値（最適値）」として適用する形が多い。
- 一方で、
  - **環境が時間とともに変動すること**を前提にした「オンライン最適化」としての扱いは少なく、
  - 「混雑度に応じてローカルルールで伸縮する」レベルで止まっているものが多い。

## 2.3 調査からの示唆

- 「動的に広告間隔を変える」というアイデア自体は先行研究にも見られるが、
  - その多くは **ヒューリスティック／ルールベース**であり、
  - **オンライン学習で逐次的に最適化する枠組み**までは踏み込んでいない。

---

# 3. 電力・到達性の実機評価に関する先行研究

## 3.1 BLE性能の一般的なレビュー

- BLEのスループット・到達距離・省電力性に関するレビュー論文では、
  - 理論スループット（≈230 kbps）に対して実効スループットは ≈100 kbps 程度、
  - 送信電力に依存しつつも、屋内で数十メートル程度の到達距離、
  - 接続型 vs 非接続型の損得（スキャン負荷など）
  といった整理が行われている。
- しかし、
  - **アドバタイズ間隔を複数条件で振りつつ**、
  - **実機で電力と到達性（PDR, TL, Pout）を同時に詳細測定**した研究は限定的である。

## 3.2 実機を用いた計測事例

- いくつかの論文では、BLEビーコンやウェアラブル機器の**電流波形をオシロスコープや専用電力計で測定**し、
  - 省電力モードの比較、
  - 通信パターン（接続間隔や広告間隔）の比較
  を行っている。
- ただし多くは、
  - 評価対象が「平均電流」や「バッテリ寿命推定」に留まり、
  - **受信側ログ（PDR/TL）と統合した評価**までは行っていない。

## 3.3 本調査から見えたギャップ

- 「アドバタイズ間隔を変えながら、**同時に**電力と通信到達性を実機で測る」という観点は、
  - レビュー論文でも「十分に行われていない」と指摘されている。
- 特に以下の点は、ほとんどカバーされていない。
  - **固定でない adv_interval（動的制御）**
  - **ΔE/adv のようなイベント単位のエネルギー指標**
  - **PDR/TL/Pout を同じ実験系で併記した評価**

---

# 4. バンディット学習・機械学習の適用状況

## 4.1 バンディット学習を用いたBLE制御

- 近年（2024年頃）の研究において、BLEの
  - **広告チャネル数**、
  - **広告間隔の粗い離散集合**
  をアームとみなし、**マルチアーム・バンディット（MAB）** で省電力化を図る例がある。
  - 例: チャネル数や広告頻度を調整し、最大約40%の省電力効果を報告した研究。
- ただし多くの場合、
  - 状態空間は比較的粗く、
  - 目的関数も「平均エネルギー」や「成功率」のような単一指標に近い。
- また、
  - 学習の一部または大半が **シミュレーション環境** で実施され、
  - 実機での**逐次学習（online learning）**は限定的であることが多い。

## 4.2 その他の機械学習的アプローチ

- BLEビーコン配置やチャンネル割り当てに対して、教師あり学習や強化学習を用いる研究も存在する。
  - 例: 人の流れ・滞在時間を予測し、それに合わせてビーコン出力を調整するモデル。
  - 例: シミュレーション上で強化学習によりデューティ比を最適化する研究。
- しかし、
  - 多くは**離線のログ**を使ったモデル学習や、
  - シミュレーション上での評価に留まっており、
  - 実機で広告間隔をオンライン最適化しながら電力と到達性を観測する事例はほぼ見当たらない。

---

# 5. 総合的な位置づけと新規性

## 5.1 調査のまとめ

- 先行研究には、以下のような部分的な要素は存在する。
  - BLE広告間隔をヒューリスティックに動的制御する手法。
  - 電力あるいは到達性のどちらかを中心にした実機評価。
  - BLE関連設定（チャネル数や間隔）に対する MAB や機械学習の適用。
- しかし、本プロジェクトが掲げる次の 3 点を **同時に**満たす研究は確認できなかった。

1. **広告間隔を動的に調整することによる省電力効果の検証**  
2. **実機で「電力＋通信到達性（PDR/TL/Pout）」を同時に計測する評価系**  
3. **マルチアーム・バンディット等によるオンライン環境適応（実環境での逐次学習）**  

## 5.2 本プロジェクトの位置づけ

- ReFormHAR‑Tiny / Phase‑0/1 の計画（擬似U/S → CCS → adv_interval制御、ΔE/adv＋PDR/TL/Pout評価、Phase‑2/3でのMAB/Safe‑MAB化）は、
  - 既存研究に散在する「動的間隔」「実測電力」「到達性」「バンディット学習」の要素を **1つの実験系に統合** するものと位置づけられる。
- 特に以下の点は、先行研究と比較して特徴的である。
  - **ΔE/adv（イベントあたりのエネルギー増分）**を軸とした電力評価。
  - **PDR/TL/Pout** を同時に取る実機実験系（TX/TXSD/RXの三ノード構成）。
  - 将来フェーズでの **Safe‑MAB によるオンライン制御** を見据えた設計。

## 5.3 要件・設計への示唆（メモ）

- 要件定義・設計定義に反映する場合の候補（反映はオーナー承認後）：
  - フェーズ1のKPI項目における **ΔE/adv の位置づけ**（すでにフェーズ0-0で採用済みの考え方を、Phase‑1/2にも明示するかどうか）。
  - 「既存研究との違い」を整理した **非機能要件（再現性・外的妥当性・学習安定性）** の補足。
  - MAB/Safe‑MABフェーズに向けた「オンライン学習実験」の要件定義（評価指標や安全側フォールバック条件など）。

（現時点では要件定義・設計書への直接の修正は行わず、本ファイルはペーパー準備用のリサーチノートとして扱う。）
</file>

<file path="paper/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
BLE非理想スキャン_RL最適化_リサーチノート.md
literature_review_ble_dynamic_adv.md
TinyML制約付き学習_リサーチノート.md
不確実性駆動送信制御_リサーチノート.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="BLE非理想スキャン_RL最適化_リサーチノート.md">
以下は、**非理想的なスマホスキャン環境下でのBLEアドバタイズ最適化**に関するリサーチノートです。  
理論的な一般論ではなく、**スマホOSの挙動・数理モデル・MAB/RLアルゴリズム・シミュレータ・実装戦略**といった深い部分だけを抜き出して整理します。

---

# 1. 非理想スキャン環境の具体像

## 1.1 BLE近隣発見の基本モデル（再掲）

- アドバタイザ側:
  - アドバタイズ間隔 `T_adv` ごとに、3チャネル（37/38/39）へ送信。
  - BLE仕様上、各イベントに 0〜10 ms 程度の疑似ランダム遅延が混入。
- スキャナ側:
  - スキャン間隔 `T_scan` ごとに、スキャンウィンドウ `d_scan` だけ受信。
  - デューティ比 `δ = d_scan / T_scan`。
- 発見遅延 L:
  - アドバタイズイベントとスキャンウィンドウの **オーバーラップまでの時間**。
  - スロットレスだが、ランダム遅延と `T_adv`, `T_scan` の相互作用から分布が決まる。

---

## 1.2 決定論的ブラインドスポット（Valley Area）

- **高調波関係問題**
  - `T_adv` と `T_scan` が整数比（高調波）に近い場合、
    - アドバタイズが系統的にスキャナのスリープ区間に入り続け、
    - 半ば決定論的に「ほぼ見つからない」組み合わせが生じる。
- **ランダム遅延の限界**
  - 仕様上のランダム遅延は偶然の位相ずれを生むが、
    - エネルギー制約のある端末ではイベント数自体が少なく、
    - 最悪ケース遅延や Valley Area を確率論的に打ち消すには不十分な場合がある。
- **高密度環境**
  - 多数のアドバタイザが同時に送信する場合、
    - スキャナ側の受信スロットが飽和 → 衝突・競合でパケットロス。
  - 理想モデル（ランダム一様・単一ペア）から大きく逸脱する。

---

## 1.3 Android の非理想スキャン挙動（2023–2025）

- **スキャンモードと実際のデューティ**
  - `SCAN_MODE_LOW_LATENCY`
    - フロント（画面ON・アプリフォアグラウンド）時のみ **ほぼ連続スキャン**に近い動作。
  - `SCAN_MODE_BALANCED` / `LOW_POWER`
    - バックグラウンドでは、例として「500 ms スキャン / 5000 ms スリープ」など、
      - デューティ `δ < 10%` 程度に強制的に落とされるケースが多い。
  - 実際のウィンドウ/間隔は端末・OSバージョン依存であり、**アプリ側からは取得できない**。

- **Doze / App Standby / Android 15 の変更**
  - Dozeモード:
    - 端末がアイドル（画面OFF・充電無し）に入ると、
      - スキャンは OS により間欠的にしか実行されない。
  - Android 15:
    - `BLUETOOTH_SCAN` 権限導入でプライバシー分離を行いつつ、
      - バックグラウンドスキャンのスロットリングが強化。
    - 「オポチュニスティック・スキャン」:
      - 他アプリのスキャンに便乗して結果を共有する形になり、
      - **自アプリが明示的に連続スキャンしているわけではない**。
    - 実務報告レベルでは、「バックグラウンド連続スキャンが 30 分程度で OS によって止まる」という事象が観測されている。

---

## 1.4 iOS の非理想スキャン挙動（iOS 18 まで）

- **バックグラウンド制約**
  - アプリがバックグラウンドに落ちると、
    - BLEスキャンの **頻度・長さはOS内部ロジックにより大幅に縮退**。
    - 実測では「数秒〜数分に一度、数 ms のウィンドウ」というレベルになる事例も報告。
  - **Duplicate Filtering 強制**
    - バックグラウンドでは、**同じ周辺機器からのアドバタイザは最初の1回しか通知されない**。
    - 継続的な RSSI 監視や連続データを受け取るには、接続モードに移行するか、アドバタイザ側が UUID/アドレスを変える等トリッキーな手が必要。

- **iOS 18 / AccessorySetupKit**
  - アクセサリセットアップを簡略化するフレームワーク。
  - ただし、「ユーザ主導のペアリング」を前提とした API であり、
    - 不特定多数のビーコンをバックグラウンドで検出し続ける用途の制限は緩和されていない。

---

## 1.5 オポチュニスティック・スキャンと合成ウィンドウ

- 複数アプリが異なるパラメータでスキャンする場合、
  - 実際のRFレベルでは「スキャンウィンドウの和集合」がハードウェアで実行される。
  - これを **Opportunistic Scan** と呼ぶ。
- アドバタイザからは、
  - 合成されたスキャンパターンは完全に未知であり、時間とともに変化。
  - この「未知で非定常なスキャナ」を前提にした制御問題として扱うのが妥当。

---

# 2. MAB / RL によるアドバタイズ最適化

## 2.1 Hasegawa/Kitagawa 系列の MAB アプローチ

- **問題設定**
  - アーム `a`：アドバタイズ間隔 × チャンネルマスク（37/38/39 の組み合わせ）。
    - 例：interval ∈ {100, 500, 1000 ms} × mask ∈ {3ch, 2ch, 1ch}。
  - 時刻 t ごとにアームを選び、その設定で広告 → 成功/失敗とエネルギーを観測。

- **報酬設計（例）**

  ```text
  R_t = α · 1{Success_t} − β · E_t
  ```

  - `Success_t`:
    - Scan Request / Connect Request を受信できたかどうか。
  - `E_t`:
    - その送信条件で消費したエネルギー（電流積分や、SF/TxPower/回数の近似式）。
  - α, β で「発見率 vs 省電力」のトレードオフを調整。

- **重要なポイント**
  - スキャナの `T_scan, d_scan, δ` を一切明示的に知らなくても、
    - 成功フラグだけを見て「スキャナと噛み合いやすい interval/mask」を暗黙に学習。
  - 混雑度や OS スケジューラの変化は「報酬分布の変動」として現れ、
    - アルゴリズムが自動的に再適応する。

---

## 2.2 UCB1‑tuned と Tug‑of‑War (TOW)

- **UCB1‑tuned**
  - 通常の UCB は「平均報酬 + √(ln t / n_k)」のみを見るが、
    - 無線環境では報酬分散が大きい（混雑・フェージングなど）。
  - UCB1‑tuned は分散推定 `σ_hat_k^2` を入れて上界を調整：

    ```text
    UCB_k = μ_hat_k + sqrt{ (ln t / n_k) * min(1/4, σ_hat_k^2 + sqrt(2 ln t / n_k)) }
    ```

  - 分散が大きいアームは探索項が増える一方、
    - 極端に不安定なアームは早めに見切りをつけやすく、収束が安定。

- **Tug‑of‑War (TOW) ダイナミクス**
  - よりシンプルで演算も軽い更新則を持つ意思決定アルゴリズム。
  - 利点:
    - 非定常環境（スキャナ挙動が頻繁に変わる）で、
      - 重い UCB 系よりも素早く「当たりのアーム」に切り替えられるケースがある。
  - BLE環境では、短時間接触（すれ違い）や瞬間的な負荷変動に対する追従性が評価されている。

---

## 2.3 Q-Learning / Deep RL による長期的最適化

- **状態と行動の例**
  - 状態 S:
    - バッテリ残量（離散化）、直近の成功率（窓平均）、推定混雑度（loss率）。
  - 行動 A:
    - アドバタイズ間隔の増減（100→500→1000msなど）。
    - 送信電力の調整（TxPower ステップアップ/ダウン）。

- **効果**
  - シミュレーションでは、
    - ランダム/固定方式に比べてネットワーク寿命を大幅に延長しつつ、
    - 最大遅延制約（例: TL p95 ≤ τ）を満たす方策を獲得。

- **課題**
  - Q-Learning は**収束までの試行数が多い**（Warm‑up が長い）。
  - スマホとの接触時間が短いシナリオ（すれ違い広告など）では、
    - 学習が終わる前に通信機会が終わる危険。
  - これに対し、**事前にオフライン学習した DQN ポリシーを MCUに焼き込む**形で、
    - 初期からそこそこ良い行動をとれるようにする研究もある。

---

## 2.4 コンテキストMAB：Wi‑Fi/外部情報の利用

- **アイデア**
  - BLE だけでなく、スマホが頻繁に行っている Wi‑Fi スキャン結果などを「コンテキスト」として利用。
  - 例:
    - 周辺 Wi‑Fi AP の RSSI 分布や BSSID 数から「端末がアクティブに通信している状況か」を推定。
    - このとき BLE スキャンも動いている可能性が高いと仮定し、広告間隔を一時的に短縮。

- **類似事例**
  - mmWave 近隣発見の研究では、
    - Wi‑Fi の情報からビーム方向や探索優先度を学習するコンテキストバンディットが提案されており、
    - BLEのチャンネル／interval 選択にもコンセプトが応用可能。

---

# 3. シミュレーションフレームワークと決定論的検証

## 3.1 Blender フレームワーク（トレース駆動）

- **従来シミュレータの問題**
  - スキャナを「一定の確率で On/Off するランダムプロセス」としてモデル化。
  - 実際の OS スケジューラは決定論的であり、
    - 例: 「1.5s スキャン、3.5s スリープ」を正確に繰り返す端末など。
  - この場合、理論上「見つかるはず」のパラメータが**永遠に見つからない**ことがありうる。

- **Blender の特徴**
  - **トレース駆動（trace‑driven）**
    - 実機 Android/iOS から収集したスキャンログを入力。
  - **全位相探索**
    - `T_adv, T_scan, d_scan, loss_rate` を与えると、
      - 可能な全ての位相差に対する遅延分布を決定論的に計算。
    - パラメタ例:
      - `adv_interval`: 20〜10240 ms
      - `scan_interval`, `scan_window`: 20〜10240 ms
      - `loss_rate`: 0〜99%
  - 結果:
    - **最悪ケース遅延** や Valley Area を明示的に把握できる。
    - MAB/RLで学んだポリシーが、特定のOSや端末で「穴」にはまらないか検証可能。

---

## 3.2 ElastiCast：インターバル多重化戦略

- **発想**
  - 単一の固定 `T_adv` では、全てのスキャナに対して良い性能を出すことは困難。
  - そこで、**複数の `T_adv` を時間的に多重化**する。
    - 例: 素数関係にある複数の interval を組み合わせる。

- **効果**
  - 高調波関係による Valley Area を避け、
    - どのような `T_scan, d_scan` を持つ端末でも、
    - ある程度の時間内には必ずオーバーラップするように設計する。
  - 「学習で環境に合わせる」アプローチに対し、
    - ElastiCast は「**決定論的設計で最悪ケースを潰す**」方向の戦略。

---

## 3.3 ReND：推論ベース近隣発見（Reasoning-based ND）

- **三段論法によるトリガー**
  - 大前提: クラウドDBに「BLEビーコンXはWi‑Fi AP Yの近くにある」という知識を保存。
  - 小前提: スマホが Wi‑Fi スキャンで AP Y を発見。
  - 結論: 「ビーコンXが近くにいる可能性が高い」と推論。
- **実装**
  - 推論成立時に、アプリが OS に対して「高頻度BLEスキャン」を一時的に要求。
  - 通常は数％の duty に抑えつつ、
    - **必要な瞬間だけ 100% に近いスキャン**を実行し、一発で発見する。

- **強化学習との関係**
  - MAB/RL が「アドバタイザがスキャナに合わせに行く」アプローチだとすると、
    - ReND は「スキャナの duty をアプリ側から引き上げる」アプローチ。
  - 両者は補完的:
    - ReNDでチャンスを作り、
    - その中で MAB/RL で最適 interval/mask を当てる、という組み合わせも考えられる。

---

# 4. 実装上の示唆（ReFormHAR‑Tiny への応用視点）

- **アドバタイザ側（ESP32/TX）**
  - 低コストな MAB（UCB1‑tuned or TOW）をファームウェア内に実装し、
    - 報酬を「ScanReq/ConnectReq 成功 − λ·消費エネルギー」で設計。
  - 将来的に LinUCB などコンテキストバンディットを使う場合は、
    - 受信側ログや外部メタデータを簡約した「コンテキスト特徴」をどう埋め込むかを設計する余地あり。

- **スキャナ側（スマホアプリ）**
  - Android:
    - `SCAN_MODE_LOW_LATENCY` を必要時だけ On にする **オンデマンドスキャン**。
    - 他アプリのトレースを収集し、Blender 系のフレームワークで Valley Area を事前解析。
  - iOS:
    - Backgroud Duplicate Filtering を前提に、
      - 「単発検出」用途に割り切るか、
      - 接続モードへの移行や ReND 的トリガーを利用するかを設計段階で決める必要あり。

- **評価**
  - 単に平均 PDR/TL でなく、
    - Blender 等で **最悪ケースTL** と Valley Area の有無を指標化することが重要。
  - 実験時は、ターゲット端末（Pixel系, Galaxy系, iPhone世代別）ごとにトレースを収集しておくとよい。

このノートは、BLE広告最適化を「非理想スキャナ前提」で考えるための材料として、OS挙動・MAB/RL・シミュレータ・実システムの接続方法をまとめたものである。  
フェーズ2以降の MAB/Safe‑MAB や ReND的なトリガー設計を検討する際に、必要な要素だけを抜き出して使えるようにしている。
</file>

<file path="literature_review_ble_dynamic_adv.md">
以下は、BLEアドバタイズ間隔制御と省電力・到達性評価・バンディット学習適用に関する先行研究の整理ノートです。  
ReFormHAR‑Tiny プロジェクトのペーパー用バックグラウンドとして位置づけ、要件定義や設計書からは独立に管理します。

---

# 1. 調査の目的と観点

本調査では、次の 3 点を同時に満たす先行研究が存在するかを確認した。

1. **BLEアドバタイズ間隔を動的に調整して省電力化すること**  
2. **実機で電力と通信到達性（PDR, TL, Pout など）を同時に測定して評価していること**  
3. **マルチアーム・バンディット（MAB）等のオンライン学習で環境適応を行っていること**  

これらを満たす研究が既にあるか、もしくは部分的に満たす研究の組み合わせがどの程度存在するかを確認した。

---

# 2. 動的アドバタイズ間隔制御に関する先行研究

## 2.1 ヒューリスティック／ルールベースな制御

- 無線チャネルの混雑度やビーコン受信状況に応じて、**広告間隔を伸縮させるヒューリスティックな手法**はいくつか報告されている。
  - 例: 周囲のトラフィック密度（近接ビーコン数やスキャン成功率）に応じて、`adv_interval` を段階的に増減させる方式。
  - 例: 電子棚札やデジタルサイネージにおいて、**人気度・アクセス頻度**に応じて広告頻度を下げることで電力を節約する方式。
- 多くの場合、
  - 制御則は「if 混雑度>閾値 then intervalを伸ばす」といった**固定ロジック**であり、
  - オフラインで決めたパラメタに従って挙動するに留まる。

## 2.2 最適化問題としての扱い

- 一部の研究では、「発見遅延」と「消費電力」のトレードオフを解析的にモデル化し、**最適な広告間隔を数値的に求める**手法が提案されている。
  - 例: ビーコン発見までの期待遅延を解析し、許容遅延の範囲内で電力を最小化する `adv_interval` を導出する研究。
- これらは主に
  - 理論解析やシミュレーションに基づき、
  - 実システムへの実装は「固定値（最適値）」として適用する形が多い。
- 一方で、
  - **環境が時間とともに変動すること**を前提にした「オンライン最適化」としての扱いは少なく、
  - 「混雑度に応じてローカルルールで伸縮する」レベルで止まっているものが多い。

## 2.3 調査からの示唆

- 「動的に広告間隔を変える」というアイデア自体は先行研究にも見られるが、
  - その多くは **ヒューリスティック／ルールベース**であり、
  - **オンライン学習で逐次的に最適化する枠組み**までは踏み込んでいない。

---

# 3. 電力・到達性の実機評価に関する先行研究

## 3.1 BLE性能の一般的なレビュー

- BLEのスループット・到達距離・省電力性に関するレビュー論文では、
  - 理論スループット（≈230 kbps）に対して実効スループットは ≈100 kbps 程度、
  - 送信電力に依存しつつも、屋内で数十メートル程度の到達距離、
  - 接続型 vs 非接続型の損得（スキャン負荷など）
  といった整理が行われている。
- しかし、
  - **アドバタイズ間隔を複数条件で振りつつ**、
  - **実機で電力と到達性（PDR, TL, Pout）を同時に詳細測定**した研究は限定的である。

## 3.2 実機を用いた計測事例

- いくつかの論文では、BLEビーコンやウェアラブル機器の**電流波形をオシロスコープや専用電力計で測定**し、
  - 省電力モードの比較、
  - 通信パターン（接続間隔や広告間隔）の比較
  を行っている。
- ただし多くは、
  - 評価対象が「平均電流」や「バッテリ寿命推定」に留まり、
  - **受信側ログ（PDR/TL）と統合した評価**までは行っていない。

## 3.3 本調査から見えたギャップ

- 「アドバタイズ間隔を変えながら、**同時に**電力と通信到達性を実機で測る」という観点は、
  - レビュー論文でも「十分に行われていない」と指摘されている。
- 特に以下の点は、ほとんどカバーされていない。
  - **固定でない adv_interval（動的制御）**
  - **ΔE/adv のようなイベント単位のエネルギー指標**
  - **PDR/TL/Pout を同じ実験系で併記した評価**

---

# 4. バンディット学習・機械学習の適用状況

## 4.1 バンディット学習を用いたBLE制御

- 近年（2024年頃）の研究において、BLEの
  - **広告チャネル数**、
  - **広告間隔の粗い離散集合**
  をアームとみなし、**マルチアーム・バンディット（MAB）** で省電力化を図る例がある。
  - 例: チャネル数や広告頻度を調整し、最大約40%の省電力効果を報告した研究。
- ただし多くの場合、
  - 状態空間は比較的粗く、
  - 目的関数も「平均エネルギー」や「成功率」のような単一指標に近い。
- また、
  - 学習の一部または大半が **シミュレーション環境** で実施され、
  - 実機での**逐次学習（online learning）**は限定的であることが多い。

## 4.2 その他の機械学習的アプローチ

- BLEビーコン配置やチャンネル割り当てに対して、教師あり学習や強化学習を用いる研究も存在する。
  - 例: 人の流れ・滞在時間を予測し、それに合わせてビーコン出力を調整するモデル。
  - 例: シミュレーション上で強化学習によりデューティ比を最適化する研究。
- しかし、
  - 多くは**離線のログ**を使ったモデル学習や、
  - シミュレーション上での評価に留まっており、
  - 実機で広告間隔をオンライン最適化しながら電力と到達性を観測する事例はほぼ見当たらない。

---

# 5. 総合的な位置づけと新規性

## 5.1 調査のまとめ

- 先行研究には、以下のような部分的な要素は存在する。
  - BLE広告間隔をヒューリスティックに動的制御する手法。
  - 電力あるいは到達性のどちらかを中心にした実機評価。
  - BLE関連設定（チャネル数や間隔）に対する MAB や機械学習の適用。
- しかし、本プロジェクトが掲げる次の 3 点を **同時に**満たす研究は確認できなかった。

1. **広告間隔を動的に調整することによる省電力効果の検証**  
2. **実機で「電力＋通信到達性（PDR/TL/Pout）」を同時に計測する評価系**  
3. **マルチアーム・バンディット等によるオンライン環境適応（実環境での逐次学習）**  

## 5.2 本プロジェクトの位置づけ

- ReFormHAR‑Tiny / Phase‑0/1 の計画（擬似U/S → CCS → adv_interval制御、ΔE/adv＋PDR/TL/Pout評価、Phase‑2/3でのMAB/Safe‑MAB化）は、
  - 既存研究に散在する「動的間隔」「実測電力」「到達性」「バンディット学習」の要素を **1つの実験系に統合** するものと位置づけられる。
- 特に以下の点は、先行研究と比較して特徴的である。
  - **ΔE/adv（イベントあたりのエネルギー増分）**を軸とした電力評価。
  - **PDR/TL/Pout** を同時に取る実機実験系（TX/TXSD/RXの三ノード構成）。
  - 将来フェーズでの **Safe‑MAB によるオンライン制御** を見据えた設計。

## 5.3 要件・設計への示唆（メモ）

- 要件定義・設計定義に反映する場合の候補（反映はオーナー承認後）：
  - フェーズ1のKPI項目における **ΔE/adv の位置づけ**（すでにフェーズ0-0で採用済みの考え方を、Phase‑1/2にも明示するかどうか）。
  - 「既存研究との違い」を整理した **非機能要件（再現性・外的妥当性・学習安定性）** の補足。
  - MAB/Safe‑MABフェーズに向けた「オンライン学習実験」の要件定義（評価指標や安全側フォールバック条件など）。

（現時点では要件定義・設計書への直接の修正は行わず、本ファイルはペーパー準備用のリサーチノートとして扱う。）
</file>

<file path="TinyML制約付き学習_リサーチノート.md">
以下は、**TinyML環境（MCU）における制約付き強化学習／Multi‑armed Bandit実装**に関するリサーチノートです。  
イントロ的な一般論は省き、**MCU上で実際にどう実装するか／どこまでできているか**に関する深い部分だけを整理します。

---

# 1. TinyML向け学習の制約構造

- **二つの強い制約**
  - **ハードウェア制約**
    - RAM は数 KB〜数百 KB（例：STM32F103 20 KB, Nano 33 BLE 256 KB, Teensy 4.1 1 MB）。
    - Flash は 64 KB〜数 MB。コードと定数は置けるが、頻繁な書き換えには不向き。
    - 動的メモリ（`malloc/new`）は断片化リスクから避けるのが前提 → **静的配列／スタック確保が基本**。
    - FPU/DSP命令有無で実現可能なアルゴリズムが変わる（Cortex‑M3 と M4F/M7 の差は大きい）。
  - **安全・QoS制約**
    - LoRaWAN デューティサイクル、規制上限（1%）などを**絶対に越えられない**。
    - 医療系やインフラ監視では「試行錯誤の失敗」が人命・法令違反に直結 → 無制限探索不可。
- **結論として必要なアーキテクチャ**
  - 学習アルゴリズムそのものは「通常の」報酬最適化に徹し、
  - その外側に **軽量な Safety Filter（Action Masking / CBF など）** を置いてハード制約を担保する構造が現実解として採用されている。

---

# 2. MCU上の Multi‑armed Bandit / LinUCB 実装

## 2.1 単純 MAB（ε‑Greedy, UCB1）

- **特徴**
  - 必要状態は「各アームの平均報酬」「訪問回数」だけ → メモリ O(K)。
  - 8‑bit MCU でも実装可能（tabular Q‑learning と同程度）。
- **限界**
  - コンテキスト（SNR, バッテリ, 位置など）を考慮できないため、通信制御などの実用シナリオでは表現力不足。

---

## 2.2 線形コンテキストバンディット（LinUCB）

- **モデル**
  - 各アーム a の期待報酬：`E[r | x_a] = x_a^T θ*`（x_a∈ℝ^d）。
  - 推定量：`θ_hat = A^-1 b`  
    - `A = Σ x x^T + λI`、`b = Σ r x`。
  - UCB スコア：`score(a) = x_a^T θ_hat + α sqrt(x_a^T A^-1 x_a)`。

- **MCU上の最大のボトルネック**
  - d×d 行列 A とその逆行列 A^-1 を保持・更新する必要がある。
  - 朴素な逆行列計算は O(d^3) → 数十 MHz クラスMCUには重い。

---

## 2.3 Sherman–Morrison 公式による高速化

- **ランク1更新**
  - 新サンプル (x_t, r_t) に対し、`A_{t+1} = A_t + x_t x_t^T`。
  - Sherman‑Morrison により、

    ```text
    A_{t+1}^{-1}
      = A_t^{-1} - (A_t^{-1} x_t x_t^T A_t^{-1}) / (1 + x_t^T A_t^{-1} x_t)
    ```

  - 必要な計算は
    - ベクトル v = A_t^-1 x_t（O(d^2)）
    - スカラー s = 1 + x_t^T v（O(d)）
    - A^-1 のランク1更新（O(d^2)）
  - → **1ステップあたり O(d^2)** に削減（O(d^3)→O(d^2)）。

- **実装上の工夫（C/C++）**
  - 行列は `float A_inv[d*d]` の 1次元配列に格納（SIMD／キャッシュ友好）。
  - 中間ベクトル `v[d]` などはクラスメンバとして **静的確保**（ヒープ不使用）。
  - 対称性（A^-1 は対称）を活かした上三角のみの格納も理論上は可能だが、
    - index計算が複雑化し、SIMD化が難しくなるため、
    - 多くの実装では「フル行列＋SIMD」の方を採用。

- **報告されている性能**
  - Cortex‑M4（STM32 Nucleo）上の最適化版 LinUCB:
    - d=16 の場合、朴素版 ≈ 5 ms/step → Woodbury＋SIMD で ≈ 0.3 ms/step に短縮（約1/15）。
  - RAM 使用量は d=16, K≲30 の設定で **1 KBオーダー** に収まる。

---

## 2.4 プラットフォーム適合性（抜粋）

- **20 KB RAM級（STM32F103など）**
  - 可能：Tabular Q‑learning, ε‑Greedy/UCB1, **ごく小さい d（≤4）** の LinUCB。
  - 限界：d が少し増えると A/A^-1 で RAM を使い切る。
- **256 KB RAM級（Arduino Nano 33 BLE, Cortex‑M4F）**
  - 可能：d≲16 の LinUCB、軽量 DNN を用いた Deep RL（小規模）。
  - FPU + DSP 命令あり → CMSIS‑DSP で行列演算高速化。
- **1 MB RAM級（Teensy 4.1, Cortex‑M7）**
  - 可能：d≳32 の LinUCB、PPO/SAC 等の Deep RL 学習も（RLtools 利用前提）。
- **ESP32**
  - RAM ≈ 520 KB、Flash ≈ 4 MB。
  - Wi‑Fi/BLE 内蔵のため、**Federated Learning や Multi‑agent Bandit** の通信基盤として有利。

---

# 3. 安全性制約の実装メカニズム

## 3.1 アクションマスキング（Validity Masking）

- **考え方**
  - 状態 s_t で「絶対に取ってはいけない行動 a」を、
    - 学習アルゴリズムの**外側で**除外し、
    - バンディット／RL側には「選べるアーム集合 A_valid」だけを渡す。
  - → 学習中も**ハード制約を破らない**。

- **LoRaWAN デューティサイクル例**
  - 制約：サブギガ帯で **Duty ≤ 1%**。
  - 各アーム a = (SF, TxPower) について、Time‑on‑Air `T_air(a)` を LoRaWAN 仕様から算出。
  - 直近履歴から「累積 ToA」と「回復までの残り」を計算し、
    - `current_ToA + T_air(a) > budget` なら a を INVALID に設定。
  - LinUCB/UCB1/Thompson 等は、A_valid からのみアクションを選ぶ。
  - 数理的には「Volatile Bandit（可用アーム集合が時間変動）」として扱われる。

---

## 3.2 Control Barrier Functions（CBF）の簡略フィルタ

- **用途**
  - 慣性のある系（ロボット・ドローン等）で、**「その行動を選んだ瞬間はOKだが、その後のダイナミクスで衝突する」**ケースを防ぐ。
- **理論（概念レベル）**
  - 安全集合 h(x)≥0 に対し、

    ```text
    d/dt h(x) + α h(x) ≥ 0 を満たす u のみ許容
    ```

- **MCU向け簡略実装**
  - バリア条件をそのままQPで解くのではなく、
    - 状態 x と提案行動 u_nominal に対して「危険かどうか」を安価に判定し、
    - 危険なら `u_safe` に置き換える**関数として実装**する。
  - C++イメージ:

    ```cpp
    float safety_filter(float u_nominal, const State& x) {
        if (is_violation_likely(x, u_nominal)) {
            return calculate_safe_u(x); // 速度/位置制限など
        }
        return u_nominal;
    }
    ```

  - 学習アルゴリズムは、この `u_safe` とその結果の報酬を観測するため、
    - 結果的に「安全領域内での最適方策」を学ぶことになる。

---

# 4. ケーススタディ：LoRaWAN ADR用 LinUCB（制約付き）

## 4.1 問題設定

- **目的**
  - LoRaWAN エンドデバイスで、
    - PDR を維持しつつ、
    - 消費エネルギー（送信電力＋ToA）を最小化。
- **変数**
  - コンテキスト x_t（例）:
    - 直近 N 回の SNR の平均／分散。
    - 直近の成功/失敗フラグ。
    - バッテリ残量。
  - アーム a:
    - SF ∈ {7,…,12} × TxPower ∈ {2,…,14 dBm} → K≈30。
  - 報酬 r_t（例）:

    ```text
    r_t = α * (PDR_t / PDR_target) - (1-α) * (Energy_t / Energy_max)
    ```

- **制約**
  - 法定 Duty ≤ 1% → **Action Masking** で保証。

---

## 4.2 MCU実装

- **ターゲット**
  - STM32L0 クラス（RAM ≈ 20 KB, 超低消費電力）。
- **状態保持**
  - d=4 とすると、
    - A_inv: 4×4 float = 64 bytes。
    - θ: 4 float = 16 bytes。
    - 各アームの平均報酬・選択回数：数百バイト。
  - 全体で **1 KB 未満** に収まる構成が可能。

- **動作イメージ**
  - 各送信結果ごとに LinUCB 更新（Sherman‑Morrison）。
  - 次の送信タイミングで、Action Masking されたアーム集合から UCB 最大のアームを選択。

- **報告されている効果**
  - シミュレーション／実機評価では、
    - 標準 ADR と比較して、**エネルギー効率 15–30% 改善**。
    - PDR は同等か、それ以上を維持。
  - 混雑環境でも「SF 上げすぎによるネットワーク崩壊」を避けられるケースが報告されている。

---

# 5. ケーススタディ：ECG サンプリングレート制御（TinyRL）

## 5.1 問題設定

- **用途**
  - 不整脈検知用 ECG ウェアラブル。
  - 常時 500 Hz サンプリングはバッテリ的に非現実的。
- **目的**
  - 不整脈検知精度 ≈99% を維持しつつ、
  - 平均消費電力をできるだけ下げる。

---

## 5.2 RLtools を用いた DQN Lite

- **構成**
  - MCU: Arduino Nano 33 BLE (Cortex‑M4F, 256 KB RAM)。
  - 特徴量: R‑R 間隔、QRS 幅などの軽量特徴から状態ベクトル s_t（4次元程度）を作成。
  - アクション:
    - {低レート, 中レート, 高レート} = {125 Hz, 250 Hz, 500 Hz}。
  - Policy/Qネットワーク（RLtools）:
    - 4 → 16 → 3 の全結合ネットワーク（ReLU）。
    - パラメータ数 = (4×16+16) + (16×3+3) = 131。
    - 単精度 float でも重みだけで ≈524 バイト + 中間バッファ含めても数 KB 程度。

- **学習の運用パターン**
  - 日中: 推論のみ（学習オフ）、報酬候補となるイベントをログに蓄積。
  - 夜間充電中 or 定期タイミング: ログを用いてバッチ学習（オンデバイス）／または Replay Buffer を用いたオンライン学習。
  - RLtools により、同じ C++ コードを PC シミュレータ＋MCU の両方で実行できるため、
    - まず PC 上でハイパラを詰めてから MCU に移植、というワークフローが取られている。

- **報告されている効果**
  - 常時 500 Hz サンプリングと比較して、
    - 不整脈検知精度 ≈99% を維持しつつ、
    - **平均消費電力 ≈1/7** まで削減。
  - 直前数十秒の HRV や `S_conf` の揺らぎが大きくなると高レートを選び、
    - 安定期は低レートに落とすポリシーを自律的に獲得。

---

# 6. 実装ベストプラクティス（TinyML学習用）

- **静的割り当ての徹底**
  - `std::vector`, `std::map` は基本的に使わない。
  - RLtools / ETL などの静的コンテナ、もしくは生配列を用いてヒープをゼロにする。
  - リンカの `.map` を確認し、`.bss/.data` サイズとスタックマージンを常に把握する。

- **PCシミュレーション→MCU移植**
  - 同じ C++ コードを
    - PC（Linux/macOS）でシミュレーション（OpenAI Gym 等）、
    - その後クロスコンパイルして MCU 上で動かす、
  - という 2段階開発が、TinyRL では実用的に採用されている。

- **数値精度と FPU の扱い**
  - FPUなし（Cortex‑M3 等）では float はソフトウェア実装 → 可能なら M4F 以上を使う。
  - LinUCB の A^-1 更新など、数値安定性が重要な部分は float（単精度）が最低ライン。
  - 固定小数点化は可能だが、実装・検証コストが高いため、まずは FPU 付きMCU＋float が現実解。

---

本ノートは、TinyML 環境において **「どの程度までバンディット/RLが現実的か」** を判断するための材料として、実装レベルの情報と具体的な削減効果のみを抜き出している。  
フェーズ2以降の MAB/Safe‑MAB 設計時には、ここに挙げた LinUCB 最適化・Action Masking・簡易CBF・RLtools のパターンを必要に応じて流用する。
</file>

<file path="不確実性駆動送信制御_リサーチノート.md">
以下は、**エッジデバイスにおける不確実性認識型・信頼度駆動型データ送信制御**に関する2021–2025年の主要研究を、**具体的なメカニズム・メトリクス・プロトコル実装・実験結果**に絞って整理したリサーチノートです。  
一般的なサマリーやパラダイム転換の議論は省き、実装上有用な「深い部分」のみを記録します。

---

# 1. 不確実性指標とオンデバイス実装

## 1.1 信頼度スコア（Softmax最大値）とキャリブレーション

- **定義**
  - `S_conf = max(softmax(z))`（z はロジットベクトル）。
  - エッジでは追加計算コストがゼロに近く、**最安の不確実性代理指標**として広く利用。

- **エッジでの具体的利用パターン**
  - **適応的認識 / サンプリング制御**
    - ウェアラブルの行動認識や端末内HARで、連続フレームの `S_conf` を監視。
    - 例: `S_conf > 0.85` が一定時間続く場合 → 推論が安定したとみなし、
      - センササンプリングレート↓（例: 50 Hz → 10–20 Hz）
      - 通信周期↑（例: 100 ms → 500–2000 ms）
    - `S_conf` が揺らぐ区間（過渡期）は、逆にサンプリング・通信頻度を一時的に増やす。
  - **早期終了（Early Exit）**
    - BranchyNet系の多出口CNNや Cloud-Edge協調LLMでは、中間層ごとの `S_conf` を監視。
    - `S_conf ≥ τ_exit`（例: 0.9）なら中間出口で推論を打ち切って結果を採用。
    - `S_conf < τ_exit` の場合のみ、より深い層 or クラウドにフォワード。
    - これにより、**平均演算量と送信頻度を同時に削減**。

- **問題点と対策**
  - Softmax は**過信（overconfidence）しやすい**ため、そのまま通信制御の閾値に使うと危険。
  - エッジ向け研究では、以下のような軽量キャリブレーションが実装されている。
    - **温度スケーリング（Temperature Scaling）**
      - 追加パラメータ T（スカラー）を導入し、`softmax(z/T)` で後処理。
      - バリデーション上の NLL/ECE を最小にする T を1次元探索で決定。
    - **Platt Scaling / 平滑化**
      - 出力の上側（0.5–1.0）に集中する確率を圧縮し、実際の正解率との整合を向上。
  - これらの処理により、**「S_conf > 0.9」なら実際の精度も ≈90%** 程度になるよう整えてから、送信制御に用いる。

---

## 1.2 情報エントロピーと優先度スケジューリング

- **定義**
  - `H = - Σ p_i log p_i`（p_i はクラス確率）。
  - 分布が平坦（迷っている）ほど H が高く、**モデルの迷いを直接表現**。

- **通信制御への具体的利用**
  - **トラフィック異常検知系**
    - IoTゲートウェイが、センサの通信パターン（ポート/パケットサイズ/周期）の分布から H を算出。
    - 通常時: H が低く安定 → ログ送信を抑制（定期サマリのみ）。
    - 異常時: H が急上昇（予測不能な通信パターン） → 詳細ログやパケットダンプを集中送信。
  - **UAV支援データ収集**
    - 多数の地上センサに対し、「AoI（Age of Information）」と「エントロピー」を組み合わせて優先度を算出。
    - `priority ∝ H × f(AoI)` とし、
      - H が低く変化の少ないノードは巡回頻度↓、
      - H が高く、かつ AoI が大きいノードを優先的に訪問・データ回収。
    - 結果として、限られた飛行時間の中で **「情報価値の高いノード」からの取得率を最大化**。

- **特徴**
  - Softmax最大値と異なり、**「どの程度迷っているか」** を多クラスで扱えるため、
    - 未知クラス検知、緩やかな変化検知、優先度制御に向いている。

---

## 1.3 ワンパス不確実性推定（Single-Pass Uncertainty）

- **従来手法の問題**
  - MC-Dropout やベイジアンNNによる不確実性推定は、
    - 同じ入力に対して **数十回の推論** を実行して分散を推定。
    - レイテンシ・消費電力ともに **O(N_samples)** で増大 → バッテリ駆動エッジには不適。

- **ワンパス系の解法（代表例）**
  - モデル側の正則化・構造変更により、
    - **1回のフォワードパスだけで「予測値＋不確実性」の両方を出力**する。
  - 典型的な構成要素:
    - **スペクトル正規化（Spectral Normalization）** による重みの制御。
    - **層ごとの分布近似**（例えば、最終層でガウス分布の平均・分散を直接出力）。
    - 損失関数に、**不確実性に基づくペナルティ項**を組み込む。

- **実験結果（Jetson Nano / TX2 等）**
  - 推論ごとに「予測＋分散」を得て、その分散を基準に
    - 送信/破棄/クラウドオフロードを判定。
  - ベースライン（MC-Dropout等）と比較して:
    - **エネルギー消費が最大 ≈28倍削減**。
    - レイテンシは、通常の推論＋行列演算数回増の範囲に収まる（実時間制御可能）。

---

## 1.4 偶然的不確実性（Aleatoric）と認識的不確実性（Epistemic）の分離

- **目的**
  - 「不確実だから送信する」のではなく、
    - **ノイズ起因の不確実性（Aleatoric）**：再サンプリングやローカル処理で対処すべき。
    - **知識不足起因の不確実性（Epistemic）**：クラウドや人間による再評価が必要。
  - この区別により、**不要なクラウド送信を抑えつつ、本当に重要なケースだけオフロード**できる。

- **オンデバイスでの扱い**
  - モデル側で「予測の分散」を
    - 観測ノイズに対応する成分（出力ヘッド側の分散）、
    - モデル不確実性に対応する成分（パラメタ分布由来）、
    に分解する設計が提案されている。
  - 制御ロジック例:
    - Aleatoric が支配的 → **同じセンサからの追加サンプル収集**を優先（送信は控える）。
    - Epistemic が支配的 → **生データ送信 or 高精度モデルへのオフロード**を優先。

---

# 2. 動的送信制御メカニズム

## 2.1 ファジィ論理制御（Fuzzy Logic Controller, FLC）によるBLEパラメータ制御

- **入力・出力変数**
  - 入力（例）:
    - 不確実性: {Low, Medium, High}（Softmax/Entropy由来）。
    - バッテリ残量: {Critical, Normal, Full}。
    - RSSI（リンク品質）: {Weak, Strong}。
  - 出力:
    - BLE接続間隔: {Short (≈7.5 ms), Medium, Long (≈4 s)}。
    - 送信電力: {Min（-20 dBm）, …, Max（+20 dBm）}。

- **ルール例**
  - `IF Uncertainty is High AND Battery is Normal THEN Interval is Short AND TxPower is Max`
    - 高不確実＋バッテリ余裕 → 確度を優先して高頻度・高出力で送信。
  - `IF Uncertainty is Low AND Battery is Low THEN Interval is Long AND TxPower is Min`
    - 推論は安定＋バッテリ低 → ハートビートのみ、電力極小で維持。

- **パラメタ最適化（PSO利用）**
  - メンバーシップ関数の形状（どこから High とみなすか等）を
    - 粒子群最適化（PSO）で自動調整。
  - 目的関数例:
    - **バッテリ寿命最大化**（平均電流 or mWh/日）。
    - かつ **QoS指標（到達率/正解率）≥95%** を制約として課す。

- **報告されている効果（ウェアラブルBLEデバイスなど）**
  - 静的設定と比較して、
    - 消費電力 **25–45%削減**。
    - 到達率（QoS）は **95%以上** を維持。
    - 「正常・高信頼」期間は実質的な Radio-on duty を **1%未満** に抑制。

---

## 2.2 Restless Multi-Armed Bandit（RMAB）とゲイン・インデックス

- **問題設定**
  - 多数のセンサノードが 1 つのゲートウェイ/UAV を共有する状況。
  - 各ノードは時間とともに
    - **情報の古さ（AoI）**、
    - **不確実性（Entropy など）**
    が変化し続ける。
  - 同時に通信できるノード数には上限がある（帯域制約）。

- **RMAB定式化とポリシー**
  - 各ノード n に対し、状態 s_n（AoI, 不確実性など）から「ゲイン・インデックス g_n」を計算。
  - スケジューラは、各ラウンドで **g_n が大きい順に上位 M ノードを選択**して送信権を与える。
  - g_n は「そのノードからデータを受け取ることで削減できるシステム損失（不確実性＋情報陳腐化）」を表す。

- **特徴と結果**
  - 単純な AoI ベース（古いデータ優先）に比べて、
    - **変化が激しく（高エントロピー）かつ情報が古いノード**を優先するため、
    - 閾値ベースでは難しい「監視すべき対象」に自動的にリソースを集中できる。
  - 代表的な研究では、
    - AoI単独最小化よりも **平均システム損失（L-条件付き交差エントロピーベース）を有意に低減**。

---

## 2.3 早期終了と適応的オフローディング

- **多出口DNN / BranchyNet系**
  - 中間層出口での `S_conf` または `H` を用いて、
    - 高信頼なら**浅い層で打ち切り**（計算＋通信コストを削減）。
    - 低信頼なら深層まで計算 or クラウドオフロード。

- **Cloud-Edge協調LLM（例: 小型SLM + クラウドLLM）**
  - エッジ側の小型モデルがトークンを生成し、各トークンの信頼度を監視。
  - `S_conf ≥ τ` ならそのまま採用（クラウド送信なし）。
  - `S_conf < τ` が続く場合、**コンテキスト（隠れ状態）をクラウドにアップロード**し、大モデルに引き継ぎ。
  - 閾値 τ は、チャネル帯域やRTTに応じて動的調整される例もあり、
    - 通信が高コストな場合は τ を下げてエッジ完結を優先。
    - 通信が安価な場合は τ を上げてクラウド精度を優先。

---

# 3. BLEプロトコル上での実装詳細

## 3.1 Connection Parameter Update Request による接続間隔制御

- **標準メカニズム**
  - BLE接続中、Peripheral（エッジデバイス）は L2CAP の **Connection Parameter Update Request** を通じて、
    - `conn_interval_min/max`（例: 6=7.5 ms〜3200=4 s）、`slave_latency` 等の変更を要求可能。
  - 不確実性に応じた典型的な制御:
    - 高不確実 / 異常兆候 → `conn_interval ≈ 7.5–30 ms`、`slave_latency ≈ 0`。
    - 安定 / 低不確実 → `conn_interval ≈ 数百〜4000 ms`、`slave_latency` を増やし実質的なスリープを延長。

- **OSスタックの制約と回避策**
  - Android / iOS の BLE スタックは、
    - Peripheral からの更新要求を無視・制限する場合がある。
  - 代表的な回避策:
    - **Smart Duty Cycling**
      - 接続間隔自体は比較的短め（例: 30 ms）に固定。
      - 不確実性が低く送信不要なときは **Empty PDU** のみ送信（実データを抑制）。
    - **Slave Latency の活用**
      - 複数回のポーリングをスキップしても接続維持が許されるよう設定し、**平均Radio-on時間を削減**。

---

## 3.2 パケット単位の送信電力制御

- **メカニズム**
  - Nordic nRF52、ST BlueNRG 等のBLE SoC は、
    - API 経由で**パケット単位の TxPower 切替**をサポート。
  - 制御例:
    - 通常テレメトリ: `TxPower = -20 dBm`（低電力で到達性はそこそこ）。
    - 高リスク・高不確実なアラート: `TxPower = +4〜+20 dBm`（最大の到達率を確保）。

- **不確実性との連携**
  - 条件例:
    - `U高` かつ リスククラス=「転倒/心不全疑い」 → TxPower 最大。
    - `U低` かつ 状態=「安定/低リスク」 → TxPower 最小 or 送信スキップ。
  - 実験では、
    - 重要度クラスごとに TxPower と接続間隔を組み合わせることで、
    - **平均消費電力を削減しつつ、重大イベントの到達率はほぼ100%を維持**した報告がある。

---

# 4. リスク指標とセマンティック通信的アプローチ

## 4.1 L-条件付き交差エントロピーと「沈黙のコスト」

- **課題**
  - 単純な AoI（最後の更新からの経過時間）は、「何を見逃しているか」の重みを考慮しない。
  - エッジでは、「送信しないことによるリスク」を定量化する必要がある。

- **L-条件付き交差エントロピー H_L のアイデア**
  - 古い情報 `X_{t-δ}` に基づく推定 `Ŷ_t` が、真の状態 `Y_t` からどれだけズレているかを、
    - 損失関数 `L(Y_t, Ŷ_t)` で重み付けした期待値として定義。
  - 特徴:
    - **リスク非対称性**を表現できる。
      - 異常を見逃す False Negative は非常に大きな損失。
      - 誤警報 False Positive は相対的に小さな損失。

- **通信制御への利用**
  - ノードごとに H_L を評価し、
    - H_L が閾値を超えたときのみ送信（＝沈黙のコストが大きくなったタイミングで通信）。
  - RMABの **ゲイン・インデックス g_n** は、送信による H_L の減少量として定義される例もあり、
    - 「どのノードの沈黙を破るべきか」を理論的に決定できる。

---

## 4.2 セマンティック通信とエッジAI

- **セマンティックシンボル送信**
  - 生データではなく、エンコーダDNNが抽出した特徴ベクトル（意味的シンボル）を送信。
  - デコーダ側は多少のビット誤りがあっても文脈から復元できるため、
    - 再送を減らしつつ、**意味情報の正確性**を維持。

- **不確実性との連携**
  - 受信側デコーダの不確実性が高い場合のみ、
    - **追加のパリティ / 再送要求 / コンテキスト追加送信**を行うハイブリッドARQが提案されている。
  - これにより、
    - 「意味が曖昧になった場合だけ追加コストを払う」形の通信が実現可能。

---

# 5. 代表的ケーススタディ（結果のみ）

以下は、不確実性駆動制御がどの程度の効果を示したかを具体的に報告している代表的事例の要約である。

- **Case 1: モバイルエッジ学習（MEL）におけるタスク割当**
  - プラットフォーム: Jetson Nano 等のエッジGPUクラスタ。
  - 手法: デバイス能力の不確実性を考慮した MED (Minimum Expected Delay) スキーム。
  - 結果:
    - 学習完了時間を **最大 ≈11%短縮**。
    - データドロップ率（送信失敗・間に合わない通信）を **最大 ≈42%削減**。

- **Case 2: ウェアラブルデバイスのBLE電力最適化（FLC + PSO）**
  - プラットフォーム: 心拍モニタ等のBLEウェアラブル。
  - 手法:
    - 不確実性・バッテリ・RSSI を入力とするファジィ論理制御。
    - メンバーシップ関数を PSO で最適化。
  - 結果:
    - 静的なBLE設定と比較して、消費電力 **25–45%削減**。
    - QoS（到達率/有効サンプル率）を **95%以上** で維持。
    - 重要でない期間の **Radio-on duty を ≈1%未満** に抑制。

- **Case 3: 視覚オドメトリにおけるワンパス不確実性＋決定保留**
  - プラットフォーム: 自律移動ロボットのオンボードGPU。
  - 手法:
    - ワンパス不確実性推定により、位置推定が不確実なフレームのみクラウド or 人手へエスカレーション。
  - 結果:
    - ベースライン比で **エネルギー消費最大 ≈28倍削減**。
    - 位置推定精度は、クラウド協調運用により目標値を維持。

- **Case 4: LLMオフローディングにおける信頼度駆動コンテキストアップロード**
  - プラットフォーム: エッジ上の小型LLM + クラウドLLM。
  - 手法:
    - トークンごとの信頼度スコアが閾値を下回り始めた段階で、
      - **バックグラウンドで隠れ状態（コンテキスト）をクラウドに送信**。
      - 実際のオフロード時には既にコンテキストが同期済み → ユーザ体験の「寸断」を回避。
  - 結果:
    - オフロードのレイテンシをユーザが知覚しにくいレベルまで低減。
    - 通信量は、常時クラウド推論に対して大幅に削減（定量値は研究ごとに異なるが、おおむね数十%〜オーダー削減）。

---

本ノートは、ReFormHAR‑Tiny における **U/S/CCS→adv_interval 制御**や将来の **MAB/Safe‑MAB設計**に流用可能な要素（指標設計、制御ロジック、BLE実装、リスク指標）だけを抽出したものである。  
要件定義・設計書へ反映する場合は、ここから該当部分のみを引用し、フェーズごとの役割に応じて簡略化して用いる。
</file>

</files>
</file>

<file path="paper/TinyML制約付き学習_リサーチノート.md">
以下は、**TinyML環境（MCU）における制約付き強化学習／Multi‑armed Bandit実装**に関するリサーチノートです。  
イントロ的な一般論は省き、**MCU上で実際にどう実装するか／どこまでできているか**に関する深い部分だけを整理します。

---

# 1. TinyML向け学習の制約構造

- **二つの強い制約**
  - **ハードウェア制約**
    - RAM は数 KB〜数百 KB（例：STM32F103 20 KB, Nano 33 BLE 256 KB, Teensy 4.1 1 MB）。
    - Flash は 64 KB〜数 MB。コードと定数は置けるが、頻繁な書き換えには不向き。
    - 動的メモリ（`malloc/new`）は断片化リスクから避けるのが前提 → **静的配列／スタック確保が基本**。
    - FPU/DSP命令有無で実現可能なアルゴリズムが変わる（Cortex‑M3 と M4F/M7 の差は大きい）。
  - **安全・QoS制約**
    - LoRaWAN デューティサイクル、規制上限（1%）などを**絶対に越えられない**。
    - 医療系やインフラ監視では「試行錯誤の失敗」が人命・法令違反に直結 → 無制限探索不可。
- **結論として必要なアーキテクチャ**
  - 学習アルゴリズムそのものは「通常の」報酬最適化に徹し、
  - その外側に **軽量な Safety Filter（Action Masking / CBF など）** を置いてハード制約を担保する構造が現実解として採用されている。

---

# 2. MCU上の Multi‑armed Bandit / LinUCB 実装

## 2.1 単純 MAB（ε‑Greedy, UCB1）

- **特徴**
  - 必要状態は「各アームの平均報酬」「訪問回数」だけ → メモリ O(K)。
  - 8‑bit MCU でも実装可能（tabular Q‑learning と同程度）。
- **限界**
  - コンテキスト（SNR, バッテリ, 位置など）を考慮できないため、通信制御などの実用シナリオでは表現力不足。

---

## 2.2 線形コンテキストバンディット（LinUCB）

- **モデル**
  - 各アーム a の期待報酬：`E[r | x_a] = x_a^T θ*`（x_a∈ℝ^d）。
  - 推定量：`θ_hat = A^-1 b`  
    - `A = Σ x x^T + λI`、`b = Σ r x`。
  - UCB スコア：`score(a) = x_a^T θ_hat + α sqrt(x_a^T A^-1 x_a)`。

- **MCU上の最大のボトルネック**
  - d×d 行列 A とその逆行列 A^-1 を保持・更新する必要がある。
  - 朴素な逆行列計算は O(d^3) → 数十 MHz クラスMCUには重い。

---

## 2.3 Sherman–Morrison 公式による高速化

- **ランク1更新**
  - 新サンプル (x_t, r_t) に対し、`A_{t+1} = A_t + x_t x_t^T`。
  - Sherman‑Morrison により、

    ```text
    A_{t+1}^{-1}
      = A_t^{-1} - (A_t^{-1} x_t x_t^T A_t^{-1}) / (1 + x_t^T A_t^{-1} x_t)
    ```

  - 必要な計算は
    - ベクトル v = A_t^-1 x_t（O(d^2)）
    - スカラー s = 1 + x_t^T v（O(d)）
    - A^-1 のランク1更新（O(d^2)）
  - → **1ステップあたり O(d^2)** に削減（O(d^3)→O(d^2)）。

- **実装上の工夫（C/C++）**
  - 行列は `float A_inv[d*d]` の 1次元配列に格納（SIMD／キャッシュ友好）。
  - 中間ベクトル `v[d]` などはクラスメンバとして **静的確保**（ヒープ不使用）。
  - 対称性（A^-1 は対称）を活かした上三角のみの格納も理論上は可能だが、
    - index計算が複雑化し、SIMD化が難しくなるため、
    - 多くの実装では「フル行列＋SIMD」の方を採用。

- **報告されている性能**
  - Cortex‑M4（STM32 Nucleo）上の最適化版 LinUCB:
    - d=16 の場合、朴素版 ≈ 5 ms/step → Woodbury＋SIMD で ≈ 0.3 ms/step に短縮（約1/15）。
  - RAM 使用量は d=16, K≲30 の設定で **1 KBオーダー** に収まる。

---

## 2.4 プラットフォーム適合性（抜粋）

- **20 KB RAM級（STM32F103など）**
  - 可能：Tabular Q‑learning, ε‑Greedy/UCB1, **ごく小さい d（≤4）** の LinUCB。
  - 限界：d が少し増えると A/A^-1 で RAM を使い切る。
- **256 KB RAM級（Arduino Nano 33 BLE, Cortex‑M4F）**
  - 可能：d≲16 の LinUCB、軽量 DNN を用いた Deep RL（小規模）。
  - FPU + DSP 命令あり → CMSIS‑DSP で行列演算高速化。
- **1 MB RAM級（Teensy 4.1, Cortex‑M7）**
  - 可能：d≳32 の LinUCB、PPO/SAC 等の Deep RL 学習も（RLtools 利用前提）。
- **ESP32**
  - RAM ≈ 520 KB、Flash ≈ 4 MB。
  - Wi‑Fi/BLE 内蔵のため、**Federated Learning や Multi‑agent Bandit** の通信基盤として有利。

---

# 3. 安全性制約の実装メカニズム

## 3.1 アクションマスキング（Validity Masking）

- **考え方**
  - 状態 s_t で「絶対に取ってはいけない行動 a」を、
    - 学習アルゴリズムの**外側で**除外し、
    - バンディット／RL側には「選べるアーム集合 A_valid」だけを渡す。
  - → 学習中も**ハード制約を破らない**。

- **LoRaWAN デューティサイクル例**
  - 制約：サブギガ帯で **Duty ≤ 1%**。
  - 各アーム a = (SF, TxPower) について、Time‑on‑Air `T_air(a)` を LoRaWAN 仕様から算出。
  - 直近履歴から「累積 ToA」と「回復までの残り」を計算し、
    - `current_ToA + T_air(a) > budget` なら a を INVALID に設定。
  - LinUCB/UCB1/Thompson 等は、A_valid からのみアクションを選ぶ。
  - 数理的には「Volatile Bandit（可用アーム集合が時間変動）」として扱われる。

---

## 3.2 Control Barrier Functions（CBF）の簡略フィルタ

- **用途**
  - 慣性のある系（ロボット・ドローン等）で、**「その行動を選んだ瞬間はOKだが、その後のダイナミクスで衝突する」**ケースを防ぐ。
- **理論（概念レベル）**
  - 安全集合 h(x)≥0 に対し、

    ```text
    d/dt h(x) + α h(x) ≥ 0 を満たす u のみ許容
    ```

- **MCU向け簡略実装**
  - バリア条件をそのままQPで解くのではなく、
    - 状態 x と提案行動 u_nominal に対して「危険かどうか」を安価に判定し、
    - 危険なら `u_safe` に置き換える**関数として実装**する。
  - C++イメージ:

    ```cpp
    float safety_filter(float u_nominal, const State& x) {
        if (is_violation_likely(x, u_nominal)) {
            return calculate_safe_u(x); // 速度/位置制限など
        }
        return u_nominal;
    }
    ```

  - 学習アルゴリズムは、この `u_safe` とその結果の報酬を観測するため、
    - 結果的に「安全領域内での最適方策」を学ぶことになる。

---

# 4. ケーススタディ：LoRaWAN ADR用 LinUCB（制約付き）

## 4.1 問題設定

- **目的**
  - LoRaWAN エンドデバイスで、
    - PDR を維持しつつ、
    - 消費エネルギー（送信電力＋ToA）を最小化。
- **変数**
  - コンテキスト x_t（例）:
    - 直近 N 回の SNR の平均／分散。
    - 直近の成功/失敗フラグ。
    - バッテリ残量。
  - アーム a:
    - SF ∈ {7,…,12} × TxPower ∈ {2,…,14 dBm} → K≈30。
  - 報酬 r_t（例）:

    ```text
    r_t = α * (PDR_t / PDR_target) - (1-α) * (Energy_t / Energy_max)
    ```

- **制約**
  - 法定 Duty ≤ 1% → **Action Masking** で保証。

---

## 4.2 MCU実装

- **ターゲット**
  - STM32L0 クラス（RAM ≈ 20 KB, 超低消費電力）。
- **状態保持**
  - d=4 とすると、
    - A_inv: 4×4 float = 64 bytes。
    - θ: 4 float = 16 bytes。
    - 各アームの平均報酬・選択回数：数百バイト。
  - 全体で **1 KB 未満** に収まる構成が可能。

- **動作イメージ**
  - 各送信結果ごとに LinUCB 更新（Sherman‑Morrison）。
  - 次の送信タイミングで、Action Masking されたアーム集合から UCB 最大のアームを選択。

- **報告されている効果**
  - シミュレーション／実機評価では、
    - 標準 ADR と比較して、**エネルギー効率 15–30% 改善**。
    - PDR は同等か、それ以上を維持。
  - 混雑環境でも「SF 上げすぎによるネットワーク崩壊」を避けられるケースが報告されている。

---

# 5. ケーススタディ：ECG サンプリングレート制御（TinyRL）

## 5.1 問題設定

- **用途**
  - 不整脈検知用 ECG ウェアラブル。
  - 常時 500 Hz サンプリングはバッテリ的に非現実的。
- **目的**
  - 不整脈検知精度 ≈99% を維持しつつ、
  - 平均消費電力をできるだけ下げる。

---

## 5.2 RLtools を用いた DQN Lite

- **構成**
  - MCU: Arduino Nano 33 BLE (Cortex‑M4F, 256 KB RAM)。
  - 特徴量: R‑R 間隔、QRS 幅などの軽量特徴から状態ベクトル s_t（4次元程度）を作成。
  - アクション:
    - {低レート, 中レート, 高レート} = {125 Hz, 250 Hz, 500 Hz}。
  - Policy/Qネットワーク（RLtools）:
    - 4 → 16 → 3 の全結合ネットワーク（ReLU）。
    - パラメータ数 = (4×16+16) + (16×3+3) = 131。
    - 単精度 float でも重みだけで ≈524 バイト + 中間バッファ含めても数 KB 程度。

- **学習の運用パターン**
  - 日中: 推論のみ（学習オフ）、報酬候補となるイベントをログに蓄積。
  - 夜間充電中 or 定期タイミング: ログを用いてバッチ学習（オンデバイス）／または Replay Buffer を用いたオンライン学習。
  - RLtools により、同じ C++ コードを PC シミュレータ＋MCU の両方で実行できるため、
    - まず PC 上でハイパラを詰めてから MCU に移植、というワークフローが取られている。

- **報告されている効果**
  - 常時 500 Hz サンプリングと比較して、
    - 不整脈検知精度 ≈99% を維持しつつ、
    - **平均消費電力 ≈1/7** まで削減。
  - 直前数十秒の HRV や `S_conf` の揺らぎが大きくなると高レートを選び、
    - 安定期は低レートに落とすポリシーを自律的に獲得。

---

# 6. 実装ベストプラクティス（TinyML学習用）

- **静的割り当ての徹底**
  - `std::vector`, `std::map` は基本的に使わない。
  - RLtools / ETL などの静的コンテナ、もしくは生配列を用いてヒープをゼロにする。
  - リンカの `.map` を確認し、`.bss/.data` サイズとスタックマージンを常に把握する。

- **PCシミュレーション→MCU移植**
  - 同じ C++ コードを
    - PC（Linux/macOS）でシミュレーション（OpenAI Gym 等）、
    - その後クロスコンパイルして MCU 上で動かす、
  - という 2段階開発が、TinyRL では実用的に採用されている。

- **数値精度と FPU の扱い**
  - FPUなし（Cortex‑M3 等）では float はソフトウェア実装 → 可能なら M4F 以上を使う。
  - LinUCB の A^-1 更新など、数値安定性が重要な部分は float（単精度）が最低ライン。
  - 固定小数点化は可能だが、実装・検証コストが高いため、まずは FPU 付きMCU＋float が現実解。

---

本ノートは、TinyML 環境において **「どの程度までバンディット/RLが現実的か」** を判断するための材料として、実装レベルの情報と具体的な削減効果のみを抜き出している。  
フェーズ2以降の MAB/Safe‑MAB 設計時には、ここに挙げた LinUCB 最適化・Action Masking・簡易CBF・RLtools のパターンを必要に応じて流用する。
</file>

<file path="paper/不確実性駆動送信制御_リサーチノート.md">
以下は、**エッジデバイスにおける不確実性認識型・信頼度駆動型データ送信制御**に関する2021–2025年の主要研究を、**具体的なメカニズム・メトリクス・プロトコル実装・実験結果**に絞って整理したリサーチノートです。  
一般的なサマリーやパラダイム転換の議論は省き、実装上有用な「深い部分」のみを記録します。

---

# 1. 不確実性指標とオンデバイス実装

## 1.1 信頼度スコア（Softmax最大値）とキャリブレーション

- **定義**
  - `S_conf = max(softmax(z))`（z はロジットベクトル）。
  - エッジでは追加計算コストがゼロに近く、**最安の不確実性代理指標**として広く利用。

- **エッジでの具体的利用パターン**
  - **適応的認識 / サンプリング制御**
    - ウェアラブルの行動認識や端末内HARで、連続フレームの `S_conf` を監視。
    - 例: `S_conf > 0.85` が一定時間続く場合 → 推論が安定したとみなし、
      - センササンプリングレート↓（例: 50 Hz → 10–20 Hz）
      - 通信周期↑（例: 100 ms → 500–2000 ms）
    - `S_conf` が揺らぐ区間（過渡期）は、逆にサンプリング・通信頻度を一時的に増やす。
  - **早期終了（Early Exit）**
    - BranchyNet系の多出口CNNや Cloud-Edge協調LLMでは、中間層ごとの `S_conf` を監視。
    - `S_conf ≥ τ_exit`（例: 0.9）なら中間出口で推論を打ち切って結果を採用。
    - `S_conf < τ_exit` の場合のみ、より深い層 or クラウドにフォワード。
    - これにより、**平均演算量と送信頻度を同時に削減**。

- **問題点と対策**
  - Softmax は**過信（overconfidence）しやすい**ため、そのまま通信制御の閾値に使うと危険。
  - エッジ向け研究では、以下のような軽量キャリブレーションが実装されている。
    - **温度スケーリング（Temperature Scaling）**
      - 追加パラメータ T（スカラー）を導入し、`softmax(z/T)` で後処理。
      - バリデーション上の NLL/ECE を最小にする T を1次元探索で決定。
    - **Platt Scaling / 平滑化**
      - 出力の上側（0.5–1.0）に集中する確率を圧縮し、実際の正解率との整合を向上。
  - これらの処理により、**「S_conf > 0.9」なら実際の精度も ≈90%** 程度になるよう整えてから、送信制御に用いる。

---

## 1.2 情報エントロピーと優先度スケジューリング

- **定義**
  - `H = - Σ p_i log p_i`（p_i はクラス確率）。
  - 分布が平坦（迷っている）ほど H が高く、**モデルの迷いを直接表現**。

- **通信制御への具体的利用**
  - **トラフィック異常検知系**
    - IoTゲートウェイが、センサの通信パターン（ポート/パケットサイズ/周期）の分布から H を算出。
    - 通常時: H が低く安定 → ログ送信を抑制（定期サマリのみ）。
    - 異常時: H が急上昇（予測不能な通信パターン） → 詳細ログやパケットダンプを集中送信。
  - **UAV支援データ収集**
    - 多数の地上センサに対し、「AoI（Age of Information）」と「エントロピー」を組み合わせて優先度を算出。
    - `priority ∝ H × f(AoI)` とし、
      - H が低く変化の少ないノードは巡回頻度↓、
      - H が高く、かつ AoI が大きいノードを優先的に訪問・データ回収。
    - 結果として、限られた飛行時間の中で **「情報価値の高いノード」からの取得率を最大化**。

- **特徴**
  - Softmax最大値と異なり、**「どの程度迷っているか」** を多クラスで扱えるため、
    - 未知クラス検知、緩やかな変化検知、優先度制御に向いている。

---

## 1.3 ワンパス不確実性推定（Single-Pass Uncertainty）

- **従来手法の問題**
  - MC-Dropout やベイジアンNNによる不確実性推定は、
    - 同じ入力に対して **数十回の推論** を実行して分散を推定。
    - レイテンシ・消費電力ともに **O(N_samples)** で増大 → バッテリ駆動エッジには不適。

- **ワンパス系の解法（代表例）**
  - モデル側の正則化・構造変更により、
    - **1回のフォワードパスだけで「予測値＋不確実性」の両方を出力**する。
  - 典型的な構成要素:
    - **スペクトル正規化（Spectral Normalization）** による重みの制御。
    - **層ごとの分布近似**（例えば、最終層でガウス分布の平均・分散を直接出力）。
    - 損失関数に、**不確実性に基づくペナルティ項**を組み込む。

- **実験結果（Jetson Nano / TX2 等）**
  - 推論ごとに「予測＋分散」を得て、その分散を基準に
    - 送信/破棄/クラウドオフロードを判定。
  - ベースライン（MC-Dropout等）と比較して:
    - **エネルギー消費が最大 ≈28倍削減**。
    - レイテンシは、通常の推論＋行列演算数回増の範囲に収まる（実時間制御可能）。

---

## 1.4 偶然的不確実性（Aleatoric）と認識的不確実性（Epistemic）の分離

- **目的**
  - 「不確実だから送信する」のではなく、
    - **ノイズ起因の不確実性（Aleatoric）**：再サンプリングやローカル処理で対処すべき。
    - **知識不足起因の不確実性（Epistemic）**：クラウドや人間による再評価が必要。
  - この区別により、**不要なクラウド送信を抑えつつ、本当に重要なケースだけオフロード**できる。

- **オンデバイスでの扱い**
  - モデル側で「予測の分散」を
    - 観測ノイズに対応する成分（出力ヘッド側の分散）、
    - モデル不確実性に対応する成分（パラメタ分布由来）、
    に分解する設計が提案されている。
  - 制御ロジック例:
    - Aleatoric が支配的 → **同じセンサからの追加サンプル収集**を優先（送信は控える）。
    - Epistemic が支配的 → **生データ送信 or 高精度モデルへのオフロード**を優先。

---

# 2. 動的送信制御メカニズム

## 2.1 ファジィ論理制御（Fuzzy Logic Controller, FLC）によるBLEパラメータ制御

- **入力・出力変数**
  - 入力（例）:
    - 不確実性: {Low, Medium, High}（Softmax/Entropy由来）。
    - バッテリ残量: {Critical, Normal, Full}。
    - RSSI（リンク品質）: {Weak, Strong}。
  - 出力:
    - BLE接続間隔: {Short (≈7.5 ms), Medium, Long (≈4 s)}。
    - 送信電力: {Min（-20 dBm）, …, Max（+20 dBm）}。

- **ルール例**
  - `IF Uncertainty is High AND Battery is Normal THEN Interval is Short AND TxPower is Max`
    - 高不確実＋バッテリ余裕 → 確度を優先して高頻度・高出力で送信。
  - `IF Uncertainty is Low AND Battery is Low THEN Interval is Long AND TxPower is Min`
    - 推論は安定＋バッテリ低 → ハートビートのみ、電力極小で維持。

- **パラメタ最適化（PSO利用）**
  - メンバーシップ関数の形状（どこから High とみなすか等）を
    - 粒子群最適化（PSO）で自動調整。
  - 目的関数例:
    - **バッテリ寿命最大化**（平均電流 or mWh/日）。
    - かつ **QoS指標（到達率/正解率）≥95%** を制約として課す。

- **報告されている効果（ウェアラブルBLEデバイスなど）**
  - 静的設定と比較して、
    - 消費電力 **25–45%削減**。
    - 到達率（QoS）は **95%以上** を維持。
    - 「正常・高信頼」期間は実質的な Radio-on duty を **1%未満** に抑制。

---

## 2.2 Restless Multi-Armed Bandit（RMAB）とゲイン・インデックス

- **問題設定**
  - 多数のセンサノードが 1 つのゲートウェイ/UAV を共有する状況。
  - 各ノードは時間とともに
    - **情報の古さ（AoI）**、
    - **不確実性（Entropy など）**
    が変化し続ける。
  - 同時に通信できるノード数には上限がある（帯域制約）。

- **RMAB定式化とポリシー**
  - 各ノード n に対し、状態 s_n（AoI, 不確実性など）から「ゲイン・インデックス g_n」を計算。
  - スケジューラは、各ラウンドで **g_n が大きい順に上位 M ノードを選択**して送信権を与える。
  - g_n は「そのノードからデータを受け取ることで削減できるシステム損失（不確実性＋情報陳腐化）」を表す。

- **特徴と結果**
  - 単純な AoI ベース（古いデータ優先）に比べて、
    - **変化が激しく（高エントロピー）かつ情報が古いノード**を優先するため、
    - 閾値ベースでは難しい「監視すべき対象」に自動的にリソースを集中できる。
  - 代表的な研究では、
    - AoI単独最小化よりも **平均システム損失（L-条件付き交差エントロピーベース）を有意に低減**。

---

## 2.3 早期終了と適応的オフローディング

- **多出口DNN / BranchyNet系**
  - 中間層出口での `S_conf` または `H` を用いて、
    - 高信頼なら**浅い層で打ち切り**（計算＋通信コストを削減）。
    - 低信頼なら深層まで計算 or クラウドオフロード。

- **Cloud-Edge協調LLM（例: 小型SLM + クラウドLLM）**
  - エッジ側の小型モデルがトークンを生成し、各トークンの信頼度を監視。
  - `S_conf ≥ τ` ならそのまま採用（クラウド送信なし）。
  - `S_conf < τ` が続く場合、**コンテキスト（隠れ状態）をクラウドにアップロード**し、大モデルに引き継ぎ。
  - 閾値 τ は、チャネル帯域やRTTに応じて動的調整される例もあり、
    - 通信が高コストな場合は τ を下げてエッジ完結を優先。
    - 通信が安価な場合は τ を上げてクラウド精度を優先。

---

# 3. BLEプロトコル上での実装詳細

## 3.1 Connection Parameter Update Request による接続間隔制御

- **標準メカニズム**
  - BLE接続中、Peripheral（エッジデバイス）は L2CAP の **Connection Parameter Update Request** を通じて、
    - `conn_interval_min/max`（例: 6=7.5 ms〜3200=4 s）、`slave_latency` 等の変更を要求可能。
  - 不確実性に応じた典型的な制御:
    - 高不確実 / 異常兆候 → `conn_interval ≈ 7.5–30 ms`、`slave_latency ≈ 0`。
    - 安定 / 低不確実 → `conn_interval ≈ 数百〜4000 ms`、`slave_latency` を増やし実質的なスリープを延長。

- **OSスタックの制約と回避策**
  - Android / iOS の BLE スタックは、
    - Peripheral からの更新要求を無視・制限する場合がある。
  - 代表的な回避策:
    - **Smart Duty Cycling**
      - 接続間隔自体は比較的短め（例: 30 ms）に固定。
      - 不確実性が低く送信不要なときは **Empty PDU** のみ送信（実データを抑制）。
    - **Slave Latency の活用**
      - 複数回のポーリングをスキップしても接続維持が許されるよう設定し、**平均Radio-on時間を削減**。

---

## 3.2 パケット単位の送信電力制御

- **メカニズム**
  - Nordic nRF52、ST BlueNRG 等のBLE SoC は、
    - API 経由で**パケット単位の TxPower 切替**をサポート。
  - 制御例:
    - 通常テレメトリ: `TxPower = -20 dBm`（低電力で到達性はそこそこ）。
    - 高リスク・高不確実なアラート: `TxPower = +4〜+20 dBm`（最大の到達率を確保）。

- **不確実性との連携**
  - 条件例:
    - `U高` かつ リスククラス=「転倒/心不全疑い」 → TxPower 最大。
    - `U低` かつ 状態=「安定/低リスク」 → TxPower 最小 or 送信スキップ。
  - 実験では、
    - 重要度クラスごとに TxPower と接続間隔を組み合わせることで、
    - **平均消費電力を削減しつつ、重大イベントの到達率はほぼ100%を維持**した報告がある。

---

# 4. リスク指標とセマンティック通信的アプローチ

## 4.1 L-条件付き交差エントロピーと「沈黙のコスト」

- **課題**
  - 単純な AoI（最後の更新からの経過時間）は、「何を見逃しているか」の重みを考慮しない。
  - エッジでは、「送信しないことによるリスク」を定量化する必要がある。

- **L-条件付き交差エントロピー H_L のアイデア**
  - 古い情報 `X_{t-δ}` に基づく推定 `Ŷ_t` が、真の状態 `Y_t` からどれだけズレているかを、
    - 損失関数 `L(Y_t, Ŷ_t)` で重み付けした期待値として定義。
  - 特徴:
    - **リスク非対称性**を表現できる。
      - 異常を見逃す False Negative は非常に大きな損失。
      - 誤警報 False Positive は相対的に小さな損失。

- **通信制御への利用**
  - ノードごとに H_L を評価し、
    - H_L が閾値を超えたときのみ送信（＝沈黙のコストが大きくなったタイミングで通信）。
  - RMABの **ゲイン・インデックス g_n** は、送信による H_L の減少量として定義される例もあり、
    - 「どのノードの沈黙を破るべきか」を理論的に決定できる。

---

## 4.2 セマンティック通信とエッジAI

- **セマンティックシンボル送信**
  - 生データではなく、エンコーダDNNが抽出した特徴ベクトル（意味的シンボル）を送信。
  - デコーダ側は多少のビット誤りがあっても文脈から復元できるため、
    - 再送を減らしつつ、**意味情報の正確性**を維持。

- **不確実性との連携**
  - 受信側デコーダの不確実性が高い場合のみ、
    - **追加のパリティ / 再送要求 / コンテキスト追加送信**を行うハイブリッドARQが提案されている。
  - これにより、
    - 「意味が曖昧になった場合だけ追加コストを払う」形の通信が実現可能。

---

# 5. 代表的ケーススタディ（結果のみ）

以下は、不確実性駆動制御がどの程度の効果を示したかを具体的に報告している代表的事例の要約である。

- **Case 1: モバイルエッジ学習（MEL）におけるタスク割当**
  - プラットフォーム: Jetson Nano 等のエッジGPUクラスタ。
  - 手法: デバイス能力の不確実性を考慮した MED (Minimum Expected Delay) スキーム。
  - 結果:
    - 学習完了時間を **最大 ≈11%短縮**。
    - データドロップ率（送信失敗・間に合わない通信）を **最大 ≈42%削減**。

- **Case 2: ウェアラブルデバイスのBLE電力最適化（FLC + PSO）**
  - プラットフォーム: 心拍モニタ等のBLEウェアラブル。
  - 手法:
    - 不確実性・バッテリ・RSSI を入力とするファジィ論理制御。
    - メンバーシップ関数を PSO で最適化。
  - 結果:
    - 静的なBLE設定と比較して、消費電力 **25–45%削減**。
    - QoS（到達率/有効サンプル率）を **95%以上** で維持。
    - 重要でない期間の **Radio-on duty を ≈1%未満** に抑制。

- **Case 3: 視覚オドメトリにおけるワンパス不確実性＋決定保留**
  - プラットフォーム: 自律移動ロボットのオンボードGPU。
  - 手法:
    - ワンパス不確実性推定により、位置推定が不確実なフレームのみクラウド or 人手へエスカレーション。
  - 結果:
    - ベースライン比で **エネルギー消費最大 ≈28倍削減**。
    - 位置推定精度は、クラウド協調運用により目標値を維持。

- **Case 4: LLMオフローディングにおける信頼度駆動コンテキストアップロード**
  - プラットフォーム: エッジ上の小型LLM + クラウドLLM。
  - 手法:
    - トークンごとの信頼度スコアが閾値を下回り始めた段階で、
      - **バックグラウンドで隠れ状態（コンテキスト）をクラウドに送信**。
      - 実際のオフロード時には既にコンテキストが同期済み → ユーザ体験の「寸断」を回避。
  - 結果:
    - オフロードのレイテンシをユーザが知覚しにくいレベルまで低減。
    - 通信量は、常時クラウド推論に対して大幅に削減（定量値は研究ごとに異なるが、おおむね数十%〜オーダー削減）。

---

本ノートは、ReFormHAR‑Tiny における **U/S/CCS→adv_interval 制御**や将来の **MAB/Safe‑MAB設計**に流用可能な要素（指標設計、制御ロジック、BLE実装、リスク指標）だけを抽出したものである。  
要件定義・設計書へ反映する場合は、ここから該当部分のみを引用し、フェーズごとの役割に応じて簡略化して用いる。
</file>

<file path="トラブルシューティング/BLE省電力計測健全化_統合タイムライン.md">
# BLE省電力計測システム健全化_統合タイムライン

- 作成日: 2025-11-19
- 目的: BLE省電力実験における **計測系の不具合解消〜評価指標確立〜コード差分の整理** までを、時系列で一望できる形にまとめる。
- 関連ドキュメント:
  - `docs/トラブルシューティング/OFF高消費電力_トラブルシューティング.md`
  - `docs/フェーズ0-0/実験ログ_E2_1m_2025-11-09.md`
  - `docs/フェーズ0-0/技術トピック_電力計測健全化.md`

---

## 1. 【発端】「OFFの方が電流が高い」異常の検知

- **現象**:
  - 広告OFF（ベースライン）の平均電流が **約59 mA**、広告ON時が **約10 mA** となり、物理的矛盾が発生。
  - 代表例: `data/実験データ/研究室/1m_off_02/`（OFF_02）で `mean_i ≈ 59 mA`, `rate_hz ≈ 150.8 Hz`, `parse_drop ≈ 1.1e4`。
- **原因特定**:
  - INA219や配線ではなく、**PowerLogger（受信側）の処理能力不足**に起因。
  - SDカード書き込みと浮動小数点演算（`printf`/`sscanf`）が重く、計測ループが遅延。
  - その結果として、
    - データ欠落（`parse_drop > 10,000`）
    - 実効レート低下（設計 500 Hz → 実測 100〜150 Hz）
    が起き、エネルギー積分 `E_total` が正しく計算できていなかった。

※ 本フェーズの詳細は `docs/トラブルシューティング/OFF高消費電力_トラブルシューティング.md` を参照。

---

## 2. 【修正フェーズ1】計測システムの構造改革（パススルー化）

- **実施内容**:
  - PowerLogger を **パススルー＋塊書き込み**構成に変更（`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）。
  - 主な変更点:
    - オンボードでの `sscanf` や複雑な浮動小数点計算を停止。
    - UART受信データを大きなバッファに貯め、**16 KB チャンク単位**で SD へ書き込み。
    - エネルギー積分は「整数mv, µA → p_mW → E_mJ」を軽量に処理。
- **成果**:
  - `parse_drop = 0`（欠損なし）を達成。
  - 実効サンプリングレートが設計値近傍（ON時 ≈500 Hz, OFF時 ≈100 Hz）へ回復。
  - 「測定系として成立していない」状態からの脱出に成功。

---

## 3. 【修正フェーズ2】単位換算バグの発見と修正

- **発覚**:
  - CSV解析中、電力列 `p_mW` の桁が不自然であることに気づく。
- **原因**:
  - 整数化対応（mV, µA）に伴う計算式更新時のミス。
  - 誤実装: `p_mW = (mv * uA) / 1000.0`
  - 正式な定義: `p_mW = (mv * uA) / 1000000.0`（mV×µA → mW なので 1000×1000 で割る）
- **対応**:
  - PowerLogger 側（`TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）の式を `/1e6` に修正（P0案件）。
  - 過去ログはオフライン解析時に修正後の式で再計算することで、再測定なしに正しい値へ復元。

---

## 4. 【戦略策定】評価指標（KPI）の再定義

- **課題**:
  - 測定系（ESP32 + INA219 + UART/SD）のベース消費が **約59 mA** と高く、単純な「平均電流[mA]」だけでは無線部分のコストが見えにくい。
- **決定事項**:
  - 主要KPIとして、**「イベントあたりのエネルギー増加分（ΔE/adv）」** を採用。
  - 定義:

    ```text
    ΔE/adv = (E_ON − E_OFF) / N_adv
    ```

- **効果**:
  - 測定系の定常負荷（CPU/I2C/UARTなど）を相殺しつつ、**「無線1回あたりの純粋なコスト」** を評価できる。
  - フェーズ0-0およびフェーズ1以降の報告では、
    - 平均電流[mA]は補助的な指標
    - 電力評価の主語は ΔE/adv（mJ/adv）
    として扱う方針とした。

---

## 5. 【検証】ΔE/adv の妥当性確認（1m_on_05 / 1m_off_05）

- **条件**:
  - E2 / 距離1 m / 窓60 s / TxPower=0 dBm / adv_interval=100 ms（ON時）
  - ON: `data/実験データ/研究室/1m_on_05`（良品 trial_016〜019）
  - OFF: `data/実験データ/研究室/1m_off_05`（trial_021〜025）
  - サマリ: `results/summary_1m_E2_100ms_on_off_05.md`

- **結果（抜粋）**:
  - ON 側（良品セット）:
    - `E_total_mJ` 平均 ≈ **17528.1 mJ**（≈17.53 J/60 s）
  - OFF 側:
    - `E_total_mJ` 平均 ≈ **14900.5 mJ**（≈14.90 J/60 s）
  - 差分:

    ```text
    ΔE = E_on − E_off ≈ 2627.7 mJ ≈ +2.63 J/60 s
    ΔE/adv ≈ 2627.7 mJ / 600 ≈ 4.38 mJ/adv
    ```

- **解釈**:
  - ΔE > 0 となり、「広告ONの方が電力が増える」という物理的整合性が回復。
  - `ΔE/adv ≈ 4.4 mJ/adv` を、「測定系のベース負荷を差し引いた上での、1広告あたりのエネルギー増分」として解釈できる。

---

## 6. 【展開と新たな発見】条件拡張時のLEDベースライン差（100 ms vs 500 ms）

- **背景**:
  - 100 ms 条件に加え、**500 ms / 1000 ms 条件へ実験を拡張**するため、スイープ版コード `esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino` を導入。
- **発生した現象**:
  - 100 ms（旧 `TX_BLE_Adv_Meter_blocking.ino`）よりも、500 ms（スイープ版）の方が **見かけ上の E_total が大きい** という逆転現象。
  - しかし、500 ms と 1000 ms を **スイープ版コード内で比較**すると、期待通り 1000 ms の方が省電力（E_total が小さい）。
- **原因特定**:
  - 旧 100 ms 用コード（`TX_BLE_Adv_Meter_blocking.ino`）:
    - `syncPulse()` で **起動直後に LED/SYNC を ~100 ms だけ点灯**し、その後は計測中LED消灯。
  - スイープ版コード（`TX_BLE_Adv_Meter_ON_sweep.ino`）:
    - `startTrial()`〜`endTrial()` の間、**LED と SYNC_OUT を trial中ずっと HIGH** に維持。
  - つまり、「100 ms（旧） vs 500 ms（新）」の比較は、**LEDベースラインが異なる2つのコード**での比較になっていた。
- **結論**:
  - 100 ms 条件で有利に見えていた差分のかなりの部分は、**LED常時点灯分のオフセット**であり、アドバタイズ間隔そのものの違いではなかった。
  - 一方で、500 ms vs 1000 ms の比較は同一コード内でLED条件も一致していたため、こちらは正しい階段構造（500 ms > 1000 ms）として解釈してよい。

---

## 7. 現在のステータスと Next Step

### 7.1 現在の到達点

1. **データの完全性**：
   - PASS_THRU 化と塊書き込みにより、`parse_drop ≈ 0`・レート安定を達成。
2. **評価の信頼性**：
   - ΔE/adv を主指標とすることで、ベース電流やLED点灯などの実装差の影響を相殺し、無線コストだけを切り出せる評価ロジックを確立。
3. **物理的妥当性**：
   - 100 ms の ON/OFF 比較で ΔE > 0 を確認。
   - 500 ms → 1000 ms でも、アドバタイズ間隔の増加に応じた省電力効果を確認。

### 7.2 Next Step（コード・実験整備）

1. **コード側のベースライン統一**:
   - スイープ版コード（`TX_BLE_Adv_Meter_ON_sweep.ino`）の SYNC/LED 処理を、旧 100 ms コードの `syncPulse()` に揃える。
     - 例: trial 開始時に短いパルスを出すだけにし、trial中常時点灯はやめる。
2. **再計測**:
   - 修正版コードで 100 / 500 / 1000 ms 条件を撮り直し、**「ベースラインが完全に揃った階段データ」**（100 > 500 > 1000）を取得する。
3. **Phase‑1 以降への展開**:
   - 現在の計測系（TX + TXSD + RX）の構成を固定し、その上で Policy（固定→MAB→Safe‑MAB）だけを差し替える形で評価実験に移行する。

---

## 8. 本トピックの位置づけ

- 本タイムラインは、プロジェクトにおける
  - **技術的負債の解消**（計測系のI/Oボトルネック、単位換算バグ）
  - **評価系の確立**（ΔE/adv を中心としたKPI）
  - **コード仕様差による見かけの矛盾の整理**（LEDベースライン差）
  を一つのストーリーとしてまとめたものである。
- 詳細な仕様や数式は、次のドキュメントに委ねる。
  - 測定装置の仕様: `docs/フェーズ0-0/実験装置最終仕様書.md`
  - ΔE評価系の詳細: `docs/フェーズ0-0/技術トピック_電力計測健全化.md`
  - フェーズ0-0 要件全体: `docs/フェーズ0-0/要件定義.md`
</file>

<file path="トラブルシューティング/OFF高消費電力_トラブルシューティング.md">
# BLE OFF時の高消費電力 トラブルシューティング

- 作成日: 2025-11-09
- 目的: OFF計測（広告OFF, 60 s）で ON より大きな消費が観測される事象の原因切り分けと是正。

## 症状（Summary）
- 条件: E2（干渉強）, 距離 1 m, 窓 60 s, TxPower=0 dBm（ON時）
- ON（1m_ad, n=6）: `E_total ≈ 1.93 J/60 s`, `PDR ≈ 0.858`
- ON再試行（1m_ad_retry, n=2）: `E_total ≈ 1.66 J/60 s`
- OFF（1m_off, n=6）: `E_total ≈ 5.51 J/60 s`
- OFF_02（1m_off_02, n=2）: `E_total ≈ 11.73 J/60 s`, `mean_i ≈ 59 mA`, `rate_hz ≈ 150.8 Hz`, `wifi_mode=OFF`
- 期待に反し、OFF > ON が継続。OFF_02 はさらに増加。

## 環境・構成（現状）
- TX+INA（DUT, OFF用）: `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`（旧 `Combined_TX_Meter_UART_B_nonblocking_OFF.ino`）
  - BLE初期化なし, `WiFi.mode(WIFI_OFF)` 明示, UARTは数値行（v,i,p）のみ送出（2025-11-09修正）
- PowerLogger（OFF用）: `esp32/TXSD_PowerLogger_SYNC_TICK_OFF.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B_OFF.ino`）
  - 受信CSV末尾に `# summary/# diag/# sys` を出力（V×I積分・dt統計・システム状態）
- 受信ロガ（共通）: `esp32/RX_BLE_to_SD_SYNC_B.ino`（旧 `RxLogger_BLE_to_SD_SYNC_B.ino`）
- 供給: DUT=3.3V_A（測定対象）, ロガ/INA=3.3V_B（GND共通）

## データ参照（Paths）
- ON: `data/実験データ/研究室/1m_ad/`（6本）, 要約 `results/フェーズ0-0_E2_1m_100ms_2025-11-09.md`
- ON再試行: `data/実験データ/研究室/1m_ad_retry/`（2本）, 要約 `results/フェーズ0-0_E2_1m_100ms_retry_latest_2025-11-09.md`
- OFF: `data/実験データ/研究室/1m_off/`（6本）, ΔE `results/フェーズ0-0_E2_1m_100ms_deltaE_2025-11-09.md`
- OFF_02: `data/実験データ/研究室/1m_off_02/`（2本）, 要約 `results/フェーズ0-0_E2_1m_100ms_off_02_2025-11-09.md`

## 仮説（Hypotheses）
1) 計測負荷（I2C/printf/UART）によるDUT側平均電流の上振れ（OFFでアイドルに入れず消費増）
2) 供給/配線の取り回し（3.3V_A/Bの混在, シャント向き, GNDループ）による見かけ電流の増加
3) INA219レンジ/オフセットのズレ（ベースの+オフセットが過大）
4) スタック停止状態の差（Wi‑Fiは停止済, BT/BLEはOFFコードで未初期化だが残留がないか）

## 暫定対策（2025-11-09）
- TX（OFF）のUARTから `# diag/# sys` を完全停止 → 数値行のみ送出
- 期待効果: `parse_drop`の桁落ち, 実効レート `rate_hz ≈ 500 Hz` へ回復, 平均電流の低下

## 検証計画（10分テスト）
1) TX（OFF）に上記修正を反映, PowerLogger（OFF）は診断付きのまま
2) 10分（600 s）取得 → PowerLogger CSV末尾の診断を確認
   - `rate_hz ≈ 500`（SAMPLE_US=2000 μs）
   - `parse_drop ≈ 0`
   - `dt_ms_mean ≈ 2.0`（±小）、`dt_ms_std`が過大でない
   - `mean_i` がON時（9–10 mA）に近づくか
3) 併せて ΔE を再集計（`scripts/compute_power_and_pdr.py`）

## 再計算コマンド（例）
- `python scripts/compute_power_and_pdr.py --data-dir data/実験データ/研究室/1m_ad_retry --off-dir data/実験データ/研究室/1m_off_02 --expected-adv-per-trial 600 --out results/summary_1m_E2_100ms_deltaE_retry_off02.md`

## 更新ルール
- 本ファイルに日付見出しで観測・対策・結果を追記していく（YYYY-MM-DD）。

---

## 進捗ログ（Timeline）

### 2025-11-09 Step 0: ベースライン確認
- ON（`data/実験データ/研究室/1m_ad/`, n=6）: E_total ≈ 1.93 J/60 s, PDR ≈ 0.858
- OFF（`data/実験データ/研究室/1m_off/`, n=6）: E_total ≈ 5.51 J/60 s

### 2025-11-09 Step 1: OFF 診断有効化（PowerLogger）
- 末尾に `# summary/# diag/# sys` 追加（rate_hz, mean_v/i/p, dt統計）
- OFF_02（`data/実験データ/研究室/1m_off_02/`, n=2）:
  - mean_i ≈ 59 mA, rate_hz ≈ 150.8 Hz, parse_drop ≈ 1.13e4
  - OFF > ON を再確認。受信/SD 経路の詰まりが示唆

### 2025-11-09 Step 2: TX（OFF）を“数値行のみ”に変更
- `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`（旧 `Combined_TX_Meter_UART_B_nonblocking_OFF.ino`）から `# diag/# sys` を削除（UART1は v,i,p のみ）
- OFF_03（`data/実験データ/研究室/1m_off_03/`, n=2）:
  - rate_hz ≈ 105.7 Hz, parse_drop ≈ 1.40e4（むしろ悪化）
  - ボトルネックが受信/SD 側であることを確証

### 2025-11-09 Step 3: PowerLogger を“パススルー”化（受信→SD 最短）
- `esp32/TXSD_PowerLogger_SYNC_TICK_OFF.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B_OFF.ino`）を改修：
  - UART RXバッファ拡張（16 KB）
  - 行の数値パース/積分を停止。相対ms前置のうえ 8 KB チャンクで SD へ write（flush は終了時のみ）
  - #diag は rate_hz, dt統計のみを残す
- OFF_04（`data/実験データ/研究室/1m_off_04/`, n=2）:
  - rate_hz ≈ 339.6 Hz, parse_drop ≈ 0（欠落解消）
  - オフライン積分: E_total ≈ 11.77 J/60 s（±0.57 mJ）
  - 目標 500 Hz に未達 → さらなる最適化（SD_CHUNK拡大、コピー削減）と TX 側の整数化/バイナリ化へ進む予定

### 2025-11-09 Step 4: ON/OFF比較の再取得（Pass-through統一）
- 条件を揃えるため、ON（広告あり）側も **パススルー系PowerLogger** で再取得（`TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）し、OFF_04と同一パイプラインで解析。
- 結果（代表値）:
  - ON側 E_total は **約14.2 J/60 s**、OFF_04 は **約11.8 J/60 s**。
  - これにより、**E_ON > E_OFF** という物理的に妥当な関係に復帰した。
- 結論:
  - これまでの ΔE<0（OFF>ON）結果は、**PowerLogger側のスループット不足・欠損**によるアーティファクトと確定。
  - ΔE評価では、**OFF_04＋ON(PASS_THRU) 系列のみを有効**とし、従来の OFF/OFF_02/OFF_03 系列は「測定系破綻時のログ」として扱う。

### 2025-11-09 Step 5: 単位換算バグ修正とKPIの見直し
- CSV解析中に、オンボード計算の `p_mW` に桁ズレがあることを確認。
  - 誤: `p_mW = (mv * uA) / 1000.0`
  - 正: `p_mW = (mv * uA) / 1000000.0`（mV×µA → mW なので 1000×1000 で割る必要がある）
- 対応:
  - ON側PowerLogger（`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`）の式を `/1e6` に修正済み。
  - 過去ログについては、オフライン処理時に **補正済みの式で再計算**することで再測定を避けた。
- 評価指標の見直し:
  - 測定系そのもののベース電流（約59 mA）が高いため、単純な **平均電流[mA]** だけではBLE無線の省電力効果が見えにくいことが明確になった。
  - 今後のレポートでは、エネルギー指標の主語を **「平均電流」から「1広告イベントあたりのエネルギー増分」** へシフトする。
    - 定義: `ΔE/adv = (E_ON − E_OFF) / N_adv`
    - ねらい: 測定系の定常負荷（I2C/UART/CPU）の影響を相殺し、**「無線1回あたりのコスト」** を直接評価できるようにする。
  - 平均電流[mA]は引き続きレポートに載せるが、**比較・最適化の評価軸は ΔE/adv を優先**する。

### 次の予定（Plan）
- Step 4: SD_CHUNK を 16 KB へ引き上げ、受信のコピー回数削減
- Step 5: TX 送出を整数スケール化 or バイナリ固定長化（受信/整形負荷を継続削減）
- Step 6: TX に seq（2 ms刻み）追加 → dt を送信側時刻基準へ（I/O遅延非依存の積分）
- Step 7: INA219 の vshunt_mV を追加し、I_from_vshunt と getCurrent_mA の整合（±5%以内）を確認
</file>

<file path="フェーズ0-0/技術トピック_電力計測健全化.md">
以下は、**BLE省電力実験における電力計測・受信評価システムの健全化プロセス**をまとめた技術トピックです。  
フェーズ0-0で発生した「広告OFFの方がONより消費が大きい」という異常を出発点として、**何を、なぜ、どのような順序で行い、今どうなっているか**を整理します。

---

# 1. 背景と課題（発端）

フェーズ0-0のデータ取得において、**広告OFF（ベースライン）の消費電力が広告ON時より高い**という物理的に矛盾した現象が発生しました。

- 代表例: `data/実験データ/研究室/1m_off_02/`（OFF_02）
  - 平均電流 ≈ **59 mA**
  - サンプリングレート ≈ **150 Hz**（設計値 500 Hz に対して大幅低下）
  - `parse_drop`（パース失敗行数）が **1万行以上**（全行の10%以上）
- 一方、ON側（`data/実験データ/研究室/1m_ad/` や再試行 `1m_ad_retry`）では、平均電流 ≈ **10 mA** 程度で推移しており、**OFF > ON** という逆転現象になっていた。

**原因仮説**：

- 計測ハードウェア（INA219）の不具合ではなく、**PowerLogger（受信・記録側）のI/Oボトルネック**が主因と判断した。
  - UART受信バッファ溢れ
  - 浮動小数点演算（`printf`/`sscanf`）の負荷
  - SDカードへの行ごとの書き込み
- これらにより、**計測データの欠落と dt（時間差）の歪み**が発生し、エネルギー積分 `E_total` が不正確になっていた。

このフェーズの詳細なトラブルシナリオは `docs/トラブルシューティング/OFF高消費電力_トラブルシューティング.md` に記録されている。本トピックでは、その後の「解決プロセス」と「最終的な評価系」の確立に焦点を当てる。

---

# 2. 実施した修正アプローチ（The Fix）

異常な ΔE（E_ON − E_OFF）を正し、物理的に妥当なエネルギー差を観測できるようにするため、以下の3段階で修正した。

## 2.1 送信側（TX）の軽量化：整数CSV化

- **目的**：
  - 送信データ量と文字列処理コストを削減し、UARTまわりのボトルネックを緩和する。
  - PowerLogger側が、**数値行のみ**を前提に単純・高速なパーサを利用できるようにする。

- **主な変更**：
  - TX（計測対象）の UART 出力を、従来の浮動小数点表現（例: `3.300,0.059,...`）から、**整数表現（例: `3300,59000` = mV, µA）** に変更。
  - UART1 上の診断行（`# diag`, `# sys` など）を**送信しない**ようにし、**「mv,uA」の2カラムのみ**を送る構成に統一。

## 2.2 受信側（PowerLogger）の構造改革：パススルー＆塊書き込み

最もクリティカルな修正は PowerLogger（TXSD）の構造見直しである。

- **対象スケッチ**：`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`

- **主な変更点**：
  - **パススルー実装**：
    - 重い `sscanf`／浮動小数点フォーマット処理を廃止。
    - 受信した1行を軽量な整数パーサで `mv,uA` にだけ変換し、**必要最小限の計算**（p_mW, E_mJ）だけを行う。
  - **非同期・塊（Chunk）書き込み**：
    - SDカードへの書き込みを「1行ごと」から、「**16 KB バッファ単位**」の塊書き込みに変更。
    - 受信中はバッファに追記し、バッファが埋まったタイミングまたは trial 終了時に一括書き込みすることで、I/O ブロック時間を最小化。
  - **積分ロジックの適正化**：
    - エネルギー計算を `E_mJ += p_mW * (dt / 1000.0)` に統一。
    - `p_mW = (mv * uA) / 1000000.0`（mV×µA → mW）とし、**単位換算バグ（/1000）を修正**。
    - `dt` は PowerLogger側の `millis()` 差分で算出し、サンプリングレートの揺らぎも含めて正しく積分できるようにした。

- **成果**：
  - 実効サンプリングレートが **約500 Hz**（ON時、SAMPLE_US=2000 µs）に復帰。
  - OFF側でも設計どおり **約100 Hz**（SAMPLE_US=10000 µs）で安定。
  - `parse_drop` は **ほぼ0** となり、計測データの欠落が事実上消失。

## 2.3 計測条件の標準化（Phase-1 要件準拠）

フェーズ1要件で想定していた **「ON時はTICKで広告回数をカウント、OFF時は無線スタックを完全停止」** という構成に合わせて、ON/OFF の条件を整理した。

- **ON（広告ON, 100 ms）**：
  - TX: `esp32/TX_BLE_Adv_Meter_blocking.ino`
    - BLE広告 100 ms 固定。
    - INA219 は 2 ms 周期でサンプリング（約500 Hz）。
    - GPIO27 から **TICKパルス**を出力し、PowerLogger 側で `adv_count` を物理カウント。
- **OFF（ベースライン, 広告OFF）**：
  - TX: `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`
    - Wi‑Fi/BLE スタックを明示的に OFF。
    - INA219 は 10 ms 周期でサンプリング（約100 Hz）。
    - TICK は未配線（`adv_count=0`）。
- **PowerLogger（ON/OFF共通）**：
  - `esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`
  - ON時は TICK_IN=33 で `adv_count` をカウント、OFF時は未接続。
- **RX Logger**：
  - `esp32/RX_BLE_to_SD_SYNC_B.ino`
  - SYNC信号で trial を区切り、`/logs/rx_trial_XXX.csv` に PDR/TL評価用ログを保存。

---

# 3. 検証結果と現状（Evidence）

修正後の構成を用いて実施した `1m_on_05` / `1m_off_05` 実験（E2, 1 m, 100 ms, 60 s）により、以下が確認できた。詳細な数値は `results/summary_1m_E2_100ms_on_off_05.md` を参照。

## 3.1 エネルギー整合性（ΔE > 0）

- ON 良品セット（`data/実験データ/研究室/1m_on_05`, trial_016〜019）：
  - `E_total_mJ` 平均 ≈ **17528.1 mJ**（≈ **17.53 J/60 s**）
  - ばらつき ≈ 0.5%
- OFF セット（`data/実験データ/研究室/1m_off_05`, trial_021〜025）：
  - `E_total_mJ` 平均 ≈ **14900.5 mJ**（≈ **14.90 J/60 s**）
  - ばらつき ≈ 0.07%
- 差分：

```text
ΔE = E_on − E_off ≈ 2627.7 mJ ≈ +2.63 J/60 s
```

- これにより、**「広告を出すとエネルギー消費が増える（E_ON > E_OFF）」** という物理的に正しい関係が確認できた。

## 3.2 指標の確立（ΔE/adv）

- ON 側の `adv_count = 600`（TICK カウント）を分母として、

```text
ΔE/adv ≈ 2627.7 mJ / 600 ≈ 4.38 mJ/adv
```

- この値は、「測定系（INA219＋TXSD）のベース負荷がON/OFFで共通である」という前提のもと、**「広告をONにしたことで追加で消費されるエネルギー（1 advあたり）」** を意味する。
- フェーズ0-0および今後のフェーズでは、**電力評価の主指標を ΔE/adv とし、平均電流[mA]は補助的な指標**として扱う。

## 3.3 サンプリングレート間の互換性

- 別途実施した 10 ms サンプリング（100 Hz）ベースの ON実験（例: `1m_on_06`）でも、60 s 換算の `E_total_mJ` は `1m_on_05` の結果と整合している。
- これにより、
  - サンプリング周期を変えても、dtを正しく積分する限り **総エネルギーは安定して再現できる** こと。
  - PowerLoggerの現実装（PASS_THRU + 正しい dt処理）が、少なくとも 100〜500 Hz の範囲で**エネルギー積分として十分に堅牢**であること。
  が確認できた。

## 3.4 条件拡張時に判明したLEDベースライン差（100 ms vs 500 ms）

- フェーズ0-0の後半では、**アドバタイズ間隔を 100 ms → 500 ms → 1000 ms に拡張**するため、スイープ版コード（`esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino`）を導入した。
- その結果、以下の現象が観測された。
  - 100 ms（旧 `TX_BLE_Adv_Meter_blocking.ino`）よりも、500 ms（スイープ版）の方が **見かけ上 E_total が大きい**。
  - ただし、500 ms と 1000 ms を **同じスイープ版コード内で比較**すると、期待どおり 1000 ms の方が小さい（省電力）という「階段」は確認できていた。
- 調査の結果、**LED（GPIO2）と SYNC 出力の扱いの違い**が主因であることが分かった。
  - 旧 100 ms 用コード（`TX_BLE_Adv_Meter_blocking.ino`）では、`syncPulse()` で **起動直後に100 msだけLED/SYNCを点灯**し、その後は計測中LED消灯。
  - スイープ版コード（`TX_BLE_Adv_Meter_ON_sweep.ino`）では、`startTrial()`〜`endTrial()` の間、**LEDと SYNC_OUT を常時HIGH** としており、trial中ずっとLED点灯分の消費が上乗せされていた。
- このため、
  - 「100 ms（旧） vs 500 ms（新）」の比較は、**LEDベースラインが異なる2つのコード**を比較していたことになり、純粋なアドバタイズ間隔の差ではなく LED オフセットを含んだ差分となっていた。
  - 一方、「500 ms vs 1000 ms」の比較は**同一コード内**でLED条件も同じであるため、正しい階段（500 ms > 1000 ms）が確認できていた。
- 対応方針：
  - 条件を跨いだ比較（100/500/1000 ms）を行う際は、**LED/SYNC の扱いを統一した同一コード**のみによるデータを基準とする（旧コードとスイープ版コードの混在比較は行わない）。
  - スイープ版コード側の SYNC 出力は、今後 **「trial中常時HIGH」から「短いパルス（syncPulse相当）」へ揃える**ことを検討中（LED点灯の有無を含め、ベースラインを揃えるため）。

---

# 4. システム構成要素（現時点の「正解」）

現時点で、フェーズ0-0の E2/1 m/100 ms 条件の ON/OFF 実験を再現するための「正解構成（Golden Master）」は以下の通り。

| 役割 | ファイル | 要約 |
| :--- | :--- | :--- |
| **TX (ON用)** | `esp32/TX_BLE_Adv_Meter_blocking.ino` | 100 ms BLE広告、INA219 2 ms サンプリング、整数CSV `mv,uA` 出力、TICK付き |
| **TX (OFF用)** | `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino` | 無線完全停止、INA219 10 ms サンプリング、整数CSV `mv,uA` 出力、TICKなし |
| **PowerLogger** | `esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino` | PASS_THRU版。ON/OFF共通。`ms,mv,uA,p_mW` をSDに記録しつつ E_mJ を積分、TICK入力で `adv_count` カウント |
| **RX Logger** | `esp32/RX_BLE_to_SD_SYNC_B.ino` | SYNC入力で trial を区切り、PDR/TL 評価用の `rx_trial_XXX.csv` を記録 |

この構成と `results/summary_1m_E2_100ms_on_off_05.md` により、当該条件での ΔE/adv ≈ **4.4 mJ/adv** を「代表値」として再現できる。

---

# 5. 将来フェーズへの橋渡し（簡易）

本トピックで行った修正は、単なるバグ修正ではなく、**今後のフェーズ1/2/3に共通で流用できる計測基盤の整備**でもある。

- **PowerLoggerの役割の明確化**：
  - 「電圧・電流・時間」をできるだけ素直に記録する**土管（Pipe）**に徹し、アプリケーションロジック（HAR/MAB/Safe‑MAB）は TX 側に閉じ込める。
  - これにより、TX 側の方策（固定間隔 → MAB → Safe‑MAB）が変わっても、**計測系はそのまま再利用**できる。
- **KPIの互換性**：
  - 本トピックで確立した **ΔE/adv, PDR, TL, Pout(τ)** は、そのままフェーズ1要件定義書で述べている KPI と整合しており、**学習・評価時の報酬／制約指標として直接利用可能**である。
- **データ品質の保証**：
  - `parse_drop ≈ 0`、`rate_hz` の安定、E_total の再現性（±0.5〜1%）を満たすことで、**学習データとしての品質基準（QA）** を満たしている。

---

# 6. 結論

- フェーズ0-0における「広告OFFの方が電力が大きい」という異常は、**PowerLogger側のI/Oボトルネックと単位換算ミス**による計測系の破綻が原因だった。
- TXの整数CSV化、PowerLoggerのPASS_THRU化（塊書き込み＋正しい dt積分）、ON/OFF条件の標準化により、
  - **E_ON > E_OFF**
  - **ΔE/adv ≈ 4.4 mJ/adv**
  を安定して再現できる状態に到達した。
- 現在の計測システムは、**フェーズ1で要求される電力・受信品質評価を実施できる水準**にあり、その上で MAB/Safe‑MAB などの方策を評価していくための基盤として利用可能である。
</file>

<file path="フェーズ0-0/実験ログ_E2_1m_2025-11-09.md">
# フェーズ0-0 実験ログ（E2, 1 m, 100 ms）

- 日付: 2025-11-09
- 現在フェーズ: フェーズ0-0（ベースライン）
- 目的: 100 ms固定のベースラインで電力と受信品質の基準値を取得し、計測系の安定性を確認する。

## 実施条件（要約）
- 距離 1 m / 環境 E2（干渉強）/ 窓 60 s × 6本
- adv_interval=100 ms / TxPower=0 dBm
- 使用コード（ON/OFF非分離の共通版）
  - TX+計測: `esp32/TX_BLE_Adv_Meter_blocking.ino`（旧 `Combined_TX_Meter_UART_B.ino`）
  - 電力ロガ: `esp32/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B.ino`）
  - 受信ロガ: `esp32/RX_BLE_to_SD_SYNC_B.ino`（旧 `RxLogger_BLE_to_SD_SYNC_B.ino`）
- データ: `data/実験データ/研究室/1m_ad/`

## 記録後の状況
- 電力（V×I積分）
  - `E_total_mJ` 平均 1933.47 mJ（±10.06 mJ）
  - `E_per_adv_uJ` 平均 3222.45 μJ（±16.75 μJ）
- 受信品質
  - `PDR` 平均 0.858（±0.009）
  - `RSSI` 中央値 −35 dBm

## 記録からわかったこと
- 電力計測の再現性は良好（±0.6%程度）。
- E2環境でも PDR≈0.86 程度を維持しており、ベースライン品質として妥当。
- `adv_count` は TICK未配線のため t/100ms 近似（=600）。厳密化にはTICK配線を推奨。

## 次アクション（フェーズ移行に向けて）
- 広告OFF（60 s）を同条件で取得し、ΔE = E_on − E_off を算出。
- TICK配線（27→33）＋ `USE_TICK_INPUT=true` で `adv_count` を厳密化。
- TL分布・Pout(τ)の算出スクリプトを当該データに適用し、受入基準（Pout(1 s), TL p95）の確認を開始。

## 追加: OFF取得とΔE（2025-11-09）
- OFFデータ: `data/実験データ/研究室/1m_off/`（広告OFF, 60 s × 6本）
- 集計（OFF）: `E_total_mJ` 平均 5511.02 mJ（±111.55）
- ΔE = ON − OFF = −3577.55 mJ（60 sあたり）
  - 想定外（OFF>ON）のため、配線・レンジ・供給系・無線停止状態の点検を推奨（詳細は `results/フェーズ0-0_E2_1m_100ms_deltaE_2025-11-09.md` 参照）。

### 追記（ON再試行: data/実験データ/研究室/1m_ad_retry/）
- 集計（ON再試行）: `E_total_mJ` 平均 1664.99 mJ（±240.26）, `E_per_adv_uJ` 平均 2775.00 μJ
- 受信（ON再試行）: `PDR` 平均 0.865（±0.000）, `RSSI` 中央値 −28 dBm
- ΔE（ON再試行 − OFF）: −3846.04 mJ（60 sあたり）。OFF>ONは継続。`results/フェーズ0-0_E2_1m_100ms_retry_latest_2025-11-09.md` 参照。

### 追記（OFF再取得: data/実験データ/研究室/1m_off_02/）
- 集計（OFF_02）: `E_total_mJ` 平均 11732.93 mJ（±9.26）。rate_hz ≈ 150.8 Hz, mean_i ≈ 59.18 mA。
- ΔE（ON再試行 − OFF_02）: −10067.94 mJ（60 sあたり）。詳細は `results/フェーズ0-0_E2_1m_100ms_off_02_2025-11-09.md` と `results/summary_1m_E2_100ms_deltaE_retry_off02.md` を参照。

### 追記（OFF再取得: data/実験データ/研究室/1m_off_03/）
- 集計（OFF_03）: `E_total_mJ` 平均 11825.47 mJ（±0.86）。rate_hz ≈ 105.7 Hz, mean_i ≈ 59.34 mA。
- ΔE（ON再試行 − OFF_03）: −10160.48 mJ（60 sあたり）。詳細は `results/フェーズ0-0_E2_1m_100ms_off_03_2025-11-09.md` と `results/summary_1m_E2_100ms_deltaE_retry_off03.md` を参照。

### 追記（OFF再取得: data/実験データ/研究室/1m_off_04/）
- ダイアグ: rate_hz ≈ 339.6 Hz（parse_drop ≈ 0）, dt_mean ≈ 2.94 ms
- オフライン積分: `E_total_mJ` ≈ 11773.60 mJ（±0.57）
- 参考: `results/フェーズ0-0_E2_1m_100ms_off_04_2025-11-09.md`

### 追記（評価指標と結論の更新: 2025-11-09）
- 上記 OFF/ON 系列のうち、**OFF/ OFF_02/ OFF_03** は `parse_drop ≫ 0` かつ `rate_hz` が大きく劣化しており、**PowerLogger の処理遅延による測定系破綻が原因**で ΔE<0（OFF>ON）となっていたことが確定した。
- PowerLogger を **パススルー化（PASS_THRU）** し、OFF_04 系列では `parse_drop ≈ 0` かつ安定したサンプリングが得られている。
- ON 側も同じパイプラインで再取得した結果、代表的な 60 s 窓で
  - E_ON ≈ 14.2 J/60 s
  - E_OFF（OFF_04） ≈ 11.8 J/60 s
 となり、**E_ON > E_OFF** という物理的に妥当な関係に復帰した。
- これにより、本ログ前半で報告している ΔE（ON−OFF）が負となる集計は、**「旧PowerLogger構成による異常値」**として扱い、以後の評価・レポートでは **OFF_04＋ON(PASS_THRU) 系列のみを有効なΔE計測として採用する。**

### 追記（ΔE/adv を主指標とする方針: 2025-11-09）
- 測定系（ESP32 + INA219 + UART/SD）のベース電流が高く、**単純な平均電流[mA]だけではBLE広告の省電力性が見えにくい**ことが分かった。
- フェーズ0-0 の電力評価では、以下の指標を使い分ける。
  - **ΔE（60 sあたり）**: ONとOFFの総エネルギー差の符号・オーダー確認（物理的整合性チェック用）。
  - **ΔE/adv**: `ΔE/adv = (E_ON − E_OFF) / N_adv` を **主指標（KPI）** とし、「無線1回あたりのエネルギー増分」を評価する。
  - **平均電流[mA]**: 補助的な指標としてログに残すが、最適化の主語には用いない。
- 以後のレポートおよびスクリプト（`results/summary_*.md`）では、**電力関連の議論を ΔE/adv（mJ/adv）中心に行う**ことを基本方針とする。

### 再計算手順（スクリプト）
- 依存: Python 3.8+（標準ライブラリのみ）
- 実行:
  - 現セット（ONのみ）の要約
    `python scripts/compute_power_and_pdr.py --data-dir data/実験データ/研究室/1m_ad --expected-adv-per-trial 600 --out results/summary_1m_E2_100ms.md`
  - OFF取得後のΔE計算
    `python scripts/compute_power_and_pdr.py --data-dir data/実験データ/研究室/1m_ad_on --off-dir data/実験データ/研究室/1m_ad_off --expected-adv-per-trial 600 --out results/summary_1m_E2_100ms_deltaE.md`

## メタ情報
- SYNC: GPIO25（100 ms High）→ SYNC_IN=26（立上り開始・固定窓終了）
- 受信: ρ=1の受動スキャン（MFD `MFxxxx` 抽出, 最初に見えたTXにロック）
- チェックサム: `data/実験データ/SHA256.txt` に統合
- 参考: 結果サマリ `results/フェーズ0-0_E2_1m_100ms_2025-11-09.md`
</file>

<file path="フェーズ0-0/実験装置最終仕様書.md">
以下は **ESP32三ノード実験装置 最終仕様書（フェーズ0-0）** です。  
BLE広告の電力と受信品質（Pout, TL, PDR）を測るための **TX / TXSD / RX の3台構成**について、回路・配線・コード挙動を現状仕様として固定します。  
将来のHARやMABなど制御側の設計は別ドキュメントに分離し、本書には記載しません。

---

# 1. 文書メタ

- **文書ID**：ADV-PWR-RIG-PH0-0-v1.0
- **対象フェーズ**：Phase 0-0（ΔEベースライン計測）
- **対象モジュール**：
  - `TX`：送信＋電流測定ノード（esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino）
  - `TXSD`：電力ロガノード（esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino）
  - `RX`：受信ロガノード（esp32_sweep/RX_BLE_to_SD_SYNC_B.ino）
- **スコープ**：
  - 回路・配線・電源条件
  - GPIOピン割り当て
  - 計測シーケンスとログ仕様

---

# 2. システム全体構成

目的：  
BLE広告の電力と品質（Pout, TL, PDR）を測るために、以下の3ノード構成とする。

- **TX**：BLE広告を送信しつつ、INA219で自ノード電流を測定し UART で出力する。
- **TXSD**：TX からの UART を受信し、**電流ログ＋イベント電荷**を SD に記録する。
- **RX**：空間中の BLE広告をパッシブスキャンし、**受信ログ**を SD に記録する。

**共通の重要ポイント**：

- **3台すべての GND を外部電源の GND と共通化する（直結）**。
  - 外部電源GND ↔ TX.GND ↔ INA219.GND ↔ TXSD.GND ↔ RX.GND を1点接続で共有する。

---

# 3. 回路・配線仕様

## 3.1 TX（送信＋電流測定）

- **ファイル**：`esp32_sweep/TX_BLE_Adv_Meter_ON_sweep.ino`
- **役割**：
  - BLE広告を一定間隔（`ADV_INTERVAL_MS`）で送信する。
  - INA219 で TXボード全体の電流/電圧を測定し、UART1 から `"mv,uA"` 形式で出力する。
  - トライアル開始～終了を SYNC信号で示し、TXSD/RX のログ区切りに使う。
  - 各広告イベントごとに TICKパルスを出力し、TXSDで ADV回数をカウントできるようにする。

### 3.1.1 電源

- 外部電源（例：PMM25 等）から **3.3V** を供給する。
- 推奨配線：
  - 外部電源 +3.3V → **INA219 VIN+**
  - INA219 VIN− → **ESP32 TX の 3V3ピン**
  - 外部電源 GND → **ESP32 TX の GNDピン** ＋ **INA219 GND**
  - 上記 GND を TXSD・RX 側の GND と共通化する。
- 注意事項：
  - ESP32 DevKit の **VINピンに3.3Vを入力しない**。オンボードLDOでさらに降圧されるため、**3V3ピンに直接給電**する。
  - INA219 のシャント抵抗は **0.1Ω（`RSHUNT_MILLIOHM = 100`）** を前提とする。

### 3.1.2 GPIOピン割り当て

```cpp
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN      = 2;
static const int I2C_SDA      = 21;
static const int I2C_SCL      = 22;
static const int UART_TX      = 4;
```

- **GPIO25 (`SYNC_OUT_PIN`)**
  - トライアル開始〜終了の間 HIGH を出力する。
  - 接続先：
    - TXSD の **GPIO26 (`SYNC_IN`)**
    - RX の **GPIO26 (`SYNC_IN`)**
- **GPIO27 (`TICK_OUT_PIN`)**
  - 各アドバタイズ更新時に **約200µsの HIGH パルス**を出力する。
  - 接続先：
    - TXSD の **GPIO33 (`TICK_IN`)**
- **GPIO2 (`LED_PIN`)**
  - `syncStart()` 呼び出し時に HIGH（点灯）、`syncEnd()` で LOW（消灯）。
  - トライアル中のインジケータとして使用する。
- **GPIO21 / GPIO22（`I2C_SDA` / `I2C_SCL`）**
  - INA219 との I2C 通信に使用する。
- **GPIO4 (`UART_TX`)**
  - `HardwareSerial uart1(1)` の TX ピン。
  - 接続先：
    - TXSD の **GPIO34 (`RX_PIN`)**

### 3.1.3 主なソフトウェア定数

```cpp
static const uint16_t ADV_INTERVAL_MS   = 100;    // 100 / 500 / 1000 / 2000 ...
static const uint32_t SAMPLE_US         = 10000;  // 10ms ≒ 100Hz（INAサンプル周期）
static const uint16_t N_ADV_PER_TRIAL   = 300;    // 1トライアルあたり広告回数
static const uint8_t  N_TRIALS          = 10;     // トライアル回数
static const uint32_t GAP_BETWEEN_TRIALS_MS = 5000;
static const uint8_t  RUN_GROUP_ID      = 1;      // 条件ID（例: 1=100ms, 2=500ms ...）
static const bool     USE_TICK_OUT      = true;
```

---

## 3.2 TXSD（PowerLogger）

- **ファイル**：`esp32_sweep/TXSD_PowerLogger_PASS_THRU_ON_v2.ino`
- **役割**：
  - TX からの UART (`"mv,uA"`) を受信し、**「ms,mv,uA,p_mW」形式のCSV**として SD に記録する。
  - SYNC信号で trial 開始/終了を検出する。
  - TICK信号で ADV回数を厳密カウントし、エネルギーを **「1広告イベントあたりの平均エネルギー（µJ）」** まで集計する。

### 3.2.1 電源

- ESP32 DevKit を **USB 5V給電**する。
- GNDは **外部電源GND（TX/INA219側）と共通**にする。
  - 外部GNDをブレッドボードなどで引き回し、TXSD.GND と直結する。

### 3.2.2 GPIOピン割り当て

```cpp
static const int RX_PIN   = 34;
static const int SD_CS    = 5;
static const int SYNC_IN  = 26;
static const int TICK_IN  = 33;
```

コメント（コード内）：

```cpp
// UART RX=34 ← ② TX=4（クロス）
// SYNC_IN=26 ← ② SYNC_OUT=25
// TICK_IN=33 ← ② TICK_OUT=27（推奨）
// SD: CS=5, SCK=18, MISO=19, MOSI=23
```

- **GPIO34 (`RX_PIN`)**
  - TX の GPIO4 (`UART_TX`) からの `"mv,uA"` CSV を受信する。
  - UART1 設定：`baud=230400, SERIAL_8N1, RX=34, TX=-1`。
- **GPIO26 (`SYNC_IN`)**
  - TX の GPIO25 (`SYNC_OUT`) から入力する。
  - 立ち上がりエッジで `startTrial()`、立ち下がりエッジで `endTrial()` を呼び出す。
- **GPIO33 (`TICK_IN`)**
  - TX の GPIO27 (`TICK_OUT`) から入力する。
  - 割込みハンドラ `onTick()` で RISINGエッジごとに `advCountISR++` する。
- **SPI / SDカード**
  - `SPI.begin(18,19,23,SD_CS);`（SCK=18, MISO=19, MOSI=23, CS=5）
  - `/logs/trial_XXX_on.csv` として SD 直下に保存する。

---

## 3.3 RX（BLE受信ロガ）

- **ファイル**：`esp32_sweep/RX_BLE_to_SD_SYNC_B.ino`
- **役割**：
  - TX の BLE広告（ManufacturerData `"MFxxxx"`）をパッシブスキャンで受信する。
  - SYNC信号に合わせて、**「時刻、RSSI、アドレス、MFD」** を SD に記録する。
  - trial終端で簡易的な PDR を推定する。

### 3.3.1 電源

- ESP32 DevKit を **USB給電**する。
- GNDは TX / TXSD と同じ外部GNDに合流させる。

### 3.3.2 GPIOピン割り当て

```cpp
static const int SD_CS   = 5;
static const int SYNC_IN = 26;
...
SPI.begin(18,19,23,SD_CS);
```

コメント（コード内）：

```cpp
// SYNC_IN=26 ← ①の SYNC_OUT=25
// SD: CS=5, SCK=18, MISO=19, MOSI=23
```

- **GPIO26 (`SYNC_IN`)**
  - TX の GPIO25 (`SYNC_OUT`) から入力する。
  - TXSD と並列接続とし、同一の SYNC信号で trial を同期する。
- **SPI / SDカード**
  - ピン配置は TXSD と同一（CS=5, SCK=18, MISO=19, MOSI=23）。
  - `/logs/rx_trial_XXX.csv` として SD に保存する。

---

# 4. コード挙動仕様

## 4.1 TX：`TX_BLE_Adv_Meter_ON_sweep.ino`

### 4.1.1 基本挙動

- BLEデバイス名：`"TXM_ESP32"`。
- 送信電力：`TX_PWR = ESP_PWR_LVL_N0`（0 dBm）。
- アドバタイズ間隔：
  - `ADV_INTERVAL_MS` [ms] を **BLE interval単位（0.625ms）** に変換して設定する。
  - `itv = (uint16_t)(ADV_INTERVAL_MS / 0.625f);`

### 4.1.2 トライアル制御

- `setup()`：
  - GPIO（LED/SYNC/TICK）初期化。
  - BLE初期化、初期Advertise開始。
  - INA219 初期化（I2C）。
  - UART1 初期化（TX=GPIO4, 230400bps）。
  - `delay(2000)` 後に `trialIndex=0; startTrial();` を呼ぶ。
- `startTrial()`：
  - `advCountInTrial=0; seq=0; hold0=8; trialRunning=true;` をセットする。
  - `nextSampleUs = micros() + SAMPLE_US;`
  - `nextAdvMs    = nowMs + ADV_INTERVAL_MS;`
  - `syncStart()` を呼び、**LED点灯＋SYNC_OUT=HIGH** とする。
  - `Serial` に開始ログ（グループID、trial番号、adv_interval_ms）を出力する。
- `loop()`（`trialRunning == true` の間）：
  - `SAMPLE_US`（デフォルト10ms）ごとに INA219 をサンプリングし、`"mv,uA\n"` を UART1 に出力する。
  - `nowMs >= nextAdvMs` となったタイミングでアドバタイズ更新を行う。
- アドバタイズ更新時の挙動：
  - `sendSeq = (hold0>0) ? 0 : seq;`
  - ManufacturerData を `"MF%04X"`（seq）に更新する。
  - `hold0` が 0 になるまでは `"MF0000"` を送信し続ける。
  - `USE_TICK_OUT == true` の場合、TICK_OUTに **約200µsのHIGHパルス**を出力する。
  - `advCountInTrial++` し、`advCountInTrial >= N_ADV_PER_TRIAL` で `endTrial()` を呼ぶ。
- `endTrial()`：
  - `trialRunning=false; trialEndMs=millis();` をセットし、`syncEnd()` で SYNC_OUT=LOW・LED消灯とする。
  - `Serial` に trial終了ログ（adv_sent, dur_ms など）を出力する。
- トライアル間の制御：
  - `trialRunning == false` の間は `GAP_BETWEEN_TRIALS_MS` 経過後に `startTrial()` を再実行する（`trialIndex++`）。
  - `trialIndex + 1 >= N_TRIALS` の場合は全トライアル終了状態となり、`vTaskDelay(10)` でアイドル動作を維持する。

---

## 4.2 TXSD：`TXSD_PowerLogger_PASS_THRU_ON_v2.ino`

### 4.2.1 トライアル制御

- SYNC割込み：

```cpp
void IRAM_ATTR onSync(){
  bool s = digitalRead(SYNC_IN);
  if (s != syncLvl){ syncLvl=s; syncEdge=true; }
}
```

- `loop()` 内での処理：
  - `syncEdge == true` のときに SYNCレベルを読み取り、状態遷移を行う。
  - `s == HIGH` かつ `logging == false` の場合 `startTrial()` を呼ぶ。
  - `s == LOW` かつ `logging == true` の場合 `endTrial()` を呼ぶ。

### 4.2.2 startTrial()

- 次のパスを `/logs/trial_XXX_on.csv` 形式で生成し、SD にオープンする。
- 1行目にヘッダを書き出す：

```csv
ms,mv,uA,p_mW
```

- `trialIndex++` と `# meta` 行を出力する。
- 状態を初期化する：
  - `logging=true;`
  - `t0_ms = millis(); tPrev = t0_ms;`
  - `E_mJ=0.0; sampN=0; sum_mv=sum_uA=0;`
  - `sumDt=sumDt2=0.0; dtMin=0xFFFFFFFF; dtMax=0;`
  - `advCountISR=0;`
- UARTバッファを空にしてから計測を開始する。

### 4.2.3 UART受信・SD書き出し・集計

- UART1 から1文字ずつ読み取り、`'\n'` で1行として確定する。
- 行バッファ `lineBuf` を `"mv,uA"` 形式として `parse_mvuA()` でパースする。
- パースに成功した場合：
  - `tNow = millis(); dt = tNow - tPrev; tPrev = tNow;`
  - サンプル数・電圧・電流・時間間隔を集計する。
  - `p_mW = mv * uA / 1e6` として電力[mW]を計算する。
  - `E_mJ += p_mW * (dt / 1000.0);` としてエネルギー[mJ]を積分する。
  - SDには `"ms,mv,uA,p_mW\r\n"` 形式で書き出す（msは `tNow - t0_ms`）。
- SD書き込みは内部バッファ `sdBuf` にため、一定サイズ（`SD_CHUNK_BYTES`）ごとに `sd_flush_chunk()` でまとめて書く。

### 4.2.4 endTrial()

- `logging == true` のときのみ実行する。
- trial全体時間 `t_ms = millis() - t0_ms` を計算する。
- ADV回数の推定：

```cpp
uint32_t Nadv = USE_TICK_INPUT ? advCountISR
                               : (uint32_t)((t_ms / (double)ADV_INTERVAL_MS) + 0.5);
```

- `Eper_uJ = (Nadv>0) ? (E_mJ * 1000.0 / Nadv) : 0.0;` を計算する。
- SDに summary 行を出力する：

```text
# summary, ms_total=..., adv_count=..., E_total_mJ=..., E_per_adv_uJ=...
```

- 併せて diag 行・sys 行を出力する：
  - `# diag`：サンプル数、サンプリングレート、平均電圧/電流/電力、dt統計、パース失敗行数。
  - `# sys`：CPU周波数、WiFiモード、free_heap。
- 最後に `flush()` と `close()` を呼び、`Serial` に trial終了ログを出力する。

---

## 4.3 RX：`RX_BLE_to_SD_SYNC_B.ino`

### 4.3.1 トライアル制御

- SYNC割込み：

```cpp
void IRAM_ATTR onSync(){
  bool s=digitalRead(SYNC_IN);
  if (s!=syncLvl){ syncLvl=s; syncEdge=true; }
}
```

- `loop()` 内での処理：
  - `syncEdge == true` のとき SYNCレベルを読み取り、状態遷移を行う。
  - `s == HIGH` かつ `trial == false` の場合 `startTrial()` を呼ぶ。
  - `s == LOW` かつ `trial == true` の場合 `endTrial()` を呼ぶ。

### 4.3.2 startTrial()

- `/logs/rx_trial_XXX.csv` 形式で次のパスを探索し、SD にオープンする。
- ヘッダを書き出す：

```csv
ms,event,rssi,addr,mfd
```

- `trialIndex++` と `# meta` 行を出力する。
- `t0Ms = millis(); trial = true; txLock = ""; rxCount = 0;` をセットし、`Serial` に開始ログを出力する。

### 4.3.3 BLEスキャンとログ

- NimBLE または Arduino BLEライブラリを用いて、**パッシブスキャン（`activeScan=false`）** を実行する。
- コールバックでは以下の条件でログ記録する：
  - ManufacturerData 文字列を取り出し、`parseMFD()` で `"MFxxxx"` 形式かを確認する。
  - 最初に受信した送信機のアドレスを `txLock` に保存し、それ以外の送信機からの広告は無視する。
  - trial中であれば `ms = millis() - t0Ms;` を計算し、以下の形式で1行を出力する。

```csv
ms,ADV,RSSI,addr,mfd
```

- `rxCount` は trial中に受信した有効広告の行数としてカウントする。

### 4.3.4 endTrial()

- `trial == true` のときのみ実行する。
- `trial = false` とし、ファイルを `flush()` / `close()` する。
- `t_ms = millis() - t0Ms` から以下を計算する：
  - `dur_s = t_ms / 1000.0`
  - `rate_hz = rxCount / dur_s`（受信レート）
  - `expected = t_ms / ADV_INTERVAL_MS`（期待受信回数、ADV_INTERVAL_MS は RX 側定義）
  - `pdr = rxCount / expected`（期待値に対する比としての PDR 推定）
- `Serial` に summary 行（ms_total, rx, rate_hz, est_pdr）と `[RX] end` を出力する。

---

# 5. 計測シーケンス

## 5.1 事前確認

- **GND配線**：
  - 外部電源GND ↔ TX.GND ↔ INA219.GND ↔ TXSD.GND ↔ RX.GND がすべて導通していること。
- **信号配線**：
  - TX.GPIO25 (`SYNC_OUT`) → TXSD.GPIO26 (`SYNC_IN`) および RX.GPIO26 (`SYNC_IN`)。
  - TX.GPIO27 (`TICK_OUT`) → TXSD.GPIO33 (`TICK_IN`)。
  - TX.GPIO4 (`UART_TX`) → TXSD.GPIO34 (`RX_PIN`)。
- **SDカード**：
  - TXSD・RX の両方に適切にフォーマットされた SDカードが挿入されていること。

## 5.2 計測手順

1. **RX と TXSD を USB で PC に接続する。**  
   - 必要に応じてシリアルモニタを開き、ログ開始を確認できる状態にしておく。
2. **外部電源 ON → TX 起動。**  
   - 約2秒後、TX の GPIO2 の LED が点灯し、`startTrial()` 実行と SYNC_OUT=HIGH を示す。
   - これに同期して、RX 側に `[RX] start ...`、TXSD 側に `[PWR] start ...` が出力される。
3. **trial中の動作。**
   - TX は `ADV_INTERVAL_MS` 間隔で BLE広告 `"MFxxxx"` を送信し、各送信ごとに TICK_OUT パルスを出力する。
   - RX は広告を受信し、`/logs/rx_trial_XXX.csv` に RSSI を含むログを記録する。
   - TXSD は UART (`"mv,uA"`) を読み取り、`/logs/trial_XXX_on.csv` に電流ログ＋p_mW を記録しつつ、エネルギーを積分する。
4. **所定の `N_ADV_PER_TRIAL` に到達。**
   - TX は `endTrial()` を呼び出し、`syncEnd()` で SYNC_OUT=LOW・LED消灯とする。
   - RX/TXSD は SYNC下降エッジを検出し、それぞれ `endTrial()` を呼び、CSV をクローズして summary を出力する。
5. **トライアルの繰り返し。**
   - TX は `GAP_BETWEEN_TRIALS_MS` 経過後に次の trial を自動開始する。
   - RX/TXSD も SYNC信号に従って自動的に次の trial を開始し、ログを継続する。

---

本仕様書は、ESP32三ノード構成による BLE広告電力・受信品質計測の **現行実装の固定版** として扱う。  
配線変更やスケッチ差し替えを行った場合は、本書を更新し、計測条件との対応関係を明示すること。
</file>

<file path="フェーズ0-0/要件定義.md">
以下は、**フェーズ0-0（先行デモ）要件定義書**です。フェーズ1で定義されたログ構造とKPIを維持しつつ、HARの完成を待たずにBLE安全バンディット系の評価を開始するための準備段階を示します。

# フェーズ0-0 要件定義書（先行デモ）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH0‑0‑v1.0  
**対象**: 擬似U/S信号によるCCS→広告間隔制御の検証  
**成功見込み**: 95%

## 1. 目的
- HAR（人的活動認識, Human Activity Recognition）非依存の擬似U（不確実度, Uncertainty）・S（安定度, Stability）を生成し、CCS（複合スコア, Composite score）→アドバタイズ間隔の全系を“動かす”。
- BLE安全バンディットに必要な期限超過率（Pout, τ）、初回到達遅延（Time-to-first-Receive, TL）、電力メトリクスの評価線をフェーズ1と同一スキーマで作成する。
- 後続フェーズに向けてログ、閾値、ヒステリシスの実装差分を最小化し、方策差し替えの準備を整える。

## 2. スコープと境界
- **対象機能**: BLEレガシー・アドバタイジング（BLE Legacy Advertising, 3チャネル固定）、アドバタイズ間隔（adv_interval）∈ {100, 500, 1000, 2000} ms、擬似U/Sに基づくCCS写像。
- **擬似信号仕様**:
  - `U_dummy = normalize(|acc|の窓内分散)`（高振幅=高不確実度）
  - `S_dummy = clamp(1 − ΔE_norm, 0, 1)`（エネルギー変化率が低いほど安定）
  - `CCS = 0.6×U_dummy + 0.4×(1 − S_dummy)` をヒステリシス±0.05で段階写像。
- **除外**: HARモデル実装、MAB/Safe‑MAB学習、チャネル可変、Tx電力最適化。

## 3. 成功指標と受入基準
- **期限超過率（Pout, τ=1 s）**: 固定100 ms条件と比較して違反率の増加が±0.5 pt以内。
- **平均電流**: 固定100 ms条件比で**≥5–10%削減**の傾向を確認（参考指標）。
- **イベント電荷**: フェーズ1の測定手順に従い±5%以内で再現。
- **ΔE/adv（イベントあたりのエネルギー増分）**: OFF（無線OFF）とON（無線ON）のエネルギー差を `ΔE/adv = (E_ON − E_OFF) / N_adv` として算出し、**省電力性の評価はこの指標を主語として行う**（測定系のベース電流を相殺し、純粋な「無線1回あたりのコスト」を見る）。
- **ログ完全性**: 欠損率<1%、U/S/CCS∈[0,1]、閾値・ヒステリシスの記録あり。

## 4. 主な作業レーン
1. 擬似U/S算出モジュールのパラメタ確定（窓長1.0 s、50%重畳、重力除去OFF）。
2. フォールバック（1000 ms）・ヒステリシス・最小滞在時間（≥2 s）の実装確認。
3. Runbook（`docs/フェーズ1/Runbook.md`）準拠の実験：環境E1/E2 × 条件5 × 各≥2反復。
4. KPI集計（期限超過率, Pout／初回到達遅延, TL p50/p95／平均電流／イベント電荷）と比較プロット。

## 5. 成果物
- 擬似U/S仕様書（式、パラメタ、正規化係数）。
- 実装時の設定ファイル（CCS閾値、ヒステリシス、最小滞在時間、フォールバック区分）。
- KPIレポート（固定基準との比較、95% CI付き）。
- ログ一式（送信・受信・電力・導出KPI）およびDecisionMeta。

## 6. リスクと緩和
- **擬似指標の過度な振動** → 移動平均（3窓）とヒステリシス強化で抑制。
- **振幅変動が環境依存** → 窓内標準化と環境別スケーリング係数をRunbookに記録。
- **評価遅延の偏り** → TLのCDFと期限超過率（Pout, τ=1/2/3 s）を必ず比較し、逸脱時はパラメタ調整。

## 7. フェーズ1との接続
- ログスキーマ、写像表、閾値定義はフェーズ1（弱い構成）と完全互換。
- 評価レポートはフェーズ1の要件定義に記載されたKPI差分表フォーマットを流用。
- 成果物はフェーズ1のPolicy Engineにそのまま供給でき、後続のHAR更新時は擬似U/Sを実U/Sに差し替えるだけで連続運用可能。
</file>

<file path="フェーズ0-1/要件定義.md">
以下は、**フェーズ0-1（データ整合リファイン）要件定義書**です。フェーズ1のポリシ全体像を維持しつつ、mHealth胸装着データに合わせたHARモデルの再学習と較正を通じて安定したU/S/CCSを提供することを目的とします。

# フェーズ0-1 要件定義書（データ整合リファイン）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH0‑1‑v1.0  
**対象**: mHealth胸装着データへのモデル転移と較正  
**成功見込み**: 70–80%

## 1. 目的
- モデル入力（軸・窓長・前処理）をmHealth胸装着データに合わせ、U（不確実度, Uncertainty）とCCS（複合スコア, Composite score）が素直に機能する状態を再構築する。
- フェーズ1の決め打ち写像とBLE計測を止めずに、HAR推論部のみを差し替え可能な形式で提供する。
- バランス精度（Balanced Accuracy）≥0.80、期待較正誤差（Expected Calibration Error, ECE）≤0.05、未知率（Unknown rate）5–15%を満たし、BLE評価へ合流する。

## 2. スコープと境界
- **対象処理**: 6軸（加速度＋ジャイロ）入力、窓長1.5–2.0 s、50%重畳、被験者別z-score正規化、温度スケーリングによる較正。
- **モデル更新**: 既存DS‑CNN系の最後の畳み込みブロックまでを凍結し、分類ヘッドを再学習。必要に応じて最終ブロックのみ解凍。
- **データ前処理緩和**: 窓純度しきい値0.7–0.8、境界除外±0.25–0.5 s、HPFは0.4 Hzに緩和。
- **除外**: 完全な新規モデル探索、MAB方策の更新、BLEチャネル制御。

## 3. 成功指標と受入基準
- **バランス精度（Balanced Accuracy）**: Validationで≥0.80（12クラス維持）。
- **マクロ平均F1スコア（F1 macro）**: フェーズ1既定モデル比で上昇し、動的クラスの崩落を解消。
- **期待較正誤差（Expected Calibration Error, ECE）**: ≤0.05（温度スケーリング適用後）。
- **未知率（Unknown rate）**: 5–15%（最大確率<τでUnknown、τは適合率-再現率曲線（Precision-Recall, PR）で最適化）。
- **CCS挙動**: 高U時にACTIVE（100 ms）へ、低U/S高時にQUIET（2000 ms）へ遷移する正負例タイムラインを確認。

## 4. 主な作業レーン
1. データ同期・整形: 6軸化、欠損補間、被験者別z-score、窓長2.0 s（比較として1.5 sも評価）。
2. モデル転移: 既存重み読み込み→ヘッド再学習→必要時に最終DWConvも解凍→量子化（QAT optional）。
3. 較正と閾値決定: 温度スケーリングでECEを0.05以下に調整し、{θ_low, θ_high}を受信者操作特性（Receiver Operating Characteristic, ROC）と適合率-再現率曲線（Precision-Recall, PR）で決定。
4. BLE接続評価: フェーズ0-0の評価線を流用し、U/S/CCSを差し替えてPout、TL、電力の変化を測定。

## 5. 成果物
- データ前処理仕様（窓長、重畳、純度、境界、フィルタ、正規化）。
- 再学習レポート（バランス精度, Balanced Accuracy／マクロ平均F1スコア, F1 macro／期待較正誤差, Expected Calibration Error／未知率, Unknown rate／混同行列）。
- 温度スケーリング係数Tと新しきい値{θ_low, θ_high}（Runbook差し替え用）。
- 更新後`.tflite`モデル、Arena/t_inf計測ログ、写像テーブルへの反映手順。

## 6. リスクと緩和
- **分布シフトの過小評価** → 6軸化・窓延長・HPF緩和をセットで適用し、再現データでA/B比較。
- **学習データ不足** → 窓純度しきい値を0.7–0.8に緩和し、被験者分割のfoldを増やす。
- **Unknownしきい値の不一致** → PRカーブでτを決定し、フェーズ1 Runbookにしきい値マッピングを追記。

## 7. フェーズ1との接続
- Policy EngineとBLE Advertiserはフェーズ1設計のまま使用し、HarOutのU/S/CCSのみを差し替える。
- ログスキーマ（model_id, calib_T, window_len, overlap, W_sec）はフェーズ1フォーマットを継続。
- 合格後はフェーズ1要件定義のFR‑2/FR‑3評価に本接続し、MAB導入前の初期方策としてWarm‑startを提供する。

---

# フェーズ0–1 要件定義 v0.1（HAR→BLE接続のための最小決めごと）

## 1) データ仕様（mHealth; chest 前提）

**決めること**

* サンプリング周波数: **50 Hz**
* 単位: **m/s²（加速度）**, **deg/s（ジャイロ）**（異なる場合はスケール変換）
* 軸順序: **Acc[X,Y,Z], Gyro[X,Y,Z]**（右手系; ファイルの列順に合わせて変換）
* 姿勢: 胸センサの**装着方向**（X: 左↔右, Y: 下↔上, Z: 背↔胸）。不明時は**重力ベクトルで補正**（低域通過でg推定）。
* 6軸化: **可**。欠損処理は**線形補間（≤200 ms）/ それ以上は窓ごと除外**。
* データ出所・版管理: `data/MHEALTHDATASET/` 配下に **README.md**, **SHA256.txt**（全ファイルのハッシュ）を置く。

**SHAの作り方（例）**

```bash
find data/MHEALTHDATASET -type f -exec shasum -a 256 {} \; | sort > data/MHEALTHDATASET/SHA256.txt
```

---

## 2) クラス設計（内部12→運用クラス）

**原則**

* 学習は**内部12クラス**（mHealth定義準拠）で実施 → 運用で**後段マッピング**（情報落ちを回避）。
* Unknownは**学習に含めない**（推論時に閾値で排他）。

**マッピング表（例）**
（※語は短縮：Sta=Stationary, Wal=Walking, Jog=Jogging, Run=Running, Bik=Cycling, UpS=Upstairs, DnS=Downstairs, Sit=Sit, Stan=Stand, Lie=Lie, Tras=Transport, Null=Null）

| 内部12 | 運用4        |
| ---- | ---------- |
| Sta  | Locomotion |
| Wal  | Locomotion |
| Jog  | Locomotion |
| Run  | Locomotion |
| Bik  | Locomotion |
| UpS  | Transition |
| DnS  | Transition |
| Sit  | Stationary |
| Stan | Stationary |
| Lie  | Stationary |
| Tras | Ignore     |
| Null | Ignore     |

**併合/除外の基準**

* **Ignore**は評価から除外（train: Hard negativeとして使わない）
* デモ段階は運用4に合算してメトリクスも出す（12も保存）

---

## 3) 分割戦略

* スキーム: **LOSO 5-fold（subject-wise）**
* 例（仮）: `fold-1: train=[S2..S9], val=[S10], test=[S1]` …（全foldでローテーション）
* seed: **42** 固定（NumPy/torch/TF）

**追記ファイル**

* `docs/フェーズ0-1/splits.yaml` に fold ごとの **train/val/test subject_id** を列挙

---

## 4) 前処理パラメータ（デフォルト）

* 入力: **6軸（Acc+Gyro）**
* 窓: **2.0 s**, **50%重畳**
* HPF: **0.4 Hz（一階）**（重力除去は過剰適用せず）
* 正規化: **被験者別 z-score**
* 窓純度: **≥0.75**
* 境界除外: **±0.25 s**
* 安定度Sの窓: **W=10 s**（ラベル遷移/代理指標用）

---

## 5) 学習・較正・評価（最小一式）

**学習**

* Optim: **Adam**, lr=**1e-3**, batch=**256**, max **80** epoch, **early-stop=10**, weight decay **1e-4**
* 損失: **重み付きCE**（クラス頻度逆数で正規化）
* 増強: **±10% 時間伸縮**, **±5° ランダム回転**, **白色ノイズ SNR>20dB**

**較正**

* **ECE**: **等頻度 15-bin**
* **温度スケーリング**: val で **T** を最小化（NLL/ECE両監視）→ **T** を保存

**Unknown判定**

* ルール: **max-softmax < τ** → **Unknown**
* τの決め方: valで **Unknownカバレッジ 5–15%** のレンジで **F1macro** 最大の τ を選ぶ（PRで確認）

**CCSの閾値（θ_low/θ_high）**

* CCS = **0.6·U + 0.4·(1−S)**  
  （注：フェーズ1の統一式〔CCS=0.7×confidence+0.3×stability〕との整合はP1で再較正し、Runbookの置換表に反映）
* val で **ROC/PR**を引き、**低頻度(2000ms)**, **中(500ms)**, **高(100ms)** の3段切替を最適化
* デフォルト初期値: **θ_high=0.70 / θ_low=0.40**, 最小滞在 **2 s**, 切替回数**≤1回/s**

**評価指標**

* **Balanced Accuracy**, **F1(macro)**, **ECE**, **Unknown率**, **推論レイテンシ**
* 運用4クラスに合算した **BAcc/F1** も併記

---

## 6) デプロイ仕様（TinyML）

* 量子化: **PTQ**（per-channel conv）→ 改善余地あれば **QAT 8–15 epoch**
* 校正データ: **2k 窓**（被験者横断）
* TFLM: **Op互換確認**（Conv, DWConv, Add, Mul, Relu/ReLU6, AvgPool, Softmax）
* モデル命名: `model_id=HAR_chest6x_2s_vYYMMDD_NN`
* リソース計測: **Arena ≤ 80 KB, t_inf ≤ 20 ms @240 MHz**（実測値を `docs/フェーズ0-1/deploy_metrics.md` に追記）

---

## 7) ログ拡張（再現用メタ）

**列追加（推奨）**

* `subject_id, activity_id, dataset_version, preproc_hash, split_id, model_id, calib_T, tau_unknown, theta_low, theta_high`

**設定ハッシュ**

* `preproc_hash = SHA256(窓/HPF/zscore/純度/境界/増強のJSON)`
* `run_hash = SHA256(preproc_hash + split_id + model_id + seed)`

---

## 8) ゲート / フォールバック（レーン移行）

* **Go to BLE本接続（レーン1→2）**:
  `BAcc ≥ 0.80` **かつ** `ECE ≤ 0.05` **かつ** `Unknown 5–15%`
* **Fallback（腰寄せ or 擬似U/Sで進行）**:
  `BAcc < 0.80` **または** `ECE > 0.05` を **2 回の微調整**後も満たせない場合、**レーン2**へ移行
  （締切目安：**3実験日 or 2 iteration**）

---

# 付録A：設定ファイルの雛形

**`configs/phase0-1.yaml`**

```yaml
data:
  fs_hz: 50
  axes: [AccX, AccY, AccZ, GyroX, GyroY, GyroZ]
  unit: {acc: "m/s2", gyro: "deg/s"}
  posture: {x: "left->right", y: "down->up", z: "back->chest"}
  missing: {interp_ms_max: 200, drop_window_if_exceeds: true}
  version: "mhealth_v1"
window:
  length_s: 2.0
  hop_s: 1.0
  purity_min: 0.75
  boundary_exclude_s: 0.25
preprocess:
  hpf_hz: 0.4
  zscore_scope: "per_subject"
split:
  scheme: "LOSO_5fold"
  seed: 42
train:
  optim: "adam"
  lr: 1e-3
  batch: 256
  max_epoch: 80
  early_stop_patience: 10
  weight_decay: 1e-4
  loss: "weighted_ce"
  aug: {time_stretch: 0.1, rot_deg: 5, noise_snr_db: 20}
calibration:
  ece_bins: 15
  ece_binning: "equal_frequency"
  temp_scale: true
unknown:
  tau_target_coverage: [0.05, 0.15]
  select_by: "max_F1_macro"
ccs:
  alpha: 0.6  # U weight
  beta: 0.4   # (1-S)
  theta_low: 0.40
  theta_high: 0.70
  min_stay_s: 2.0
  max_switch_per_s: 1
deploy:
  quant: {ptq: true, qat: false, calib_windows: 2000, per_channel: true}
  limits: {arena_kb_max: 80, t_inf_ms_max: 20}
```

---

# 付録B：評価プロトコル（要点だけ）

1. **分割固定** → train で学習 → val で **T, τ, θ** を確定 → test で**一回**評価
2. **指標**：BAcc/F1macro（12 & 運用4）、ECE、Unknown率、t_inf、Arena
3. **ログ**：`*_summary.json` に **seed, split_id, preproc_hash, model_id, calib_T, tau, theta** を必ず保存
4. **BLE接続の準備**：`pred.csv` に `entropy, U, S, CCS` を列追加（BLE側がそのまま読める）

---

# 付録C：小さなFAQ（詰まり回避）

* **GMP(wl=24)で0.43の頭打ち** → **6軸化 & 窓2s**にまず上げる。3軸×短窓は胸では厳しい。
* **Jog/Run/BikがStairs/Staに崩れる** → HPFを弱く、**ジャイロ追加**、**2s窓**で周期特徴を回収。
* **サンプルが少ない**（純度/境界除外で激減）→ **純度0.75/境界0.25s**へ緩和。
* **Uが暴れる** → **温度スケーリング＋移動平均（3–5窓）＋ヒステリシス**。

---

# 次アクション（30分でできること）

1. `configs/phase0-1.yaml` をリポジトリに追加
2. `docs/フェーズ0-1/要件定義.md` に本内容のコピペ＋分割表（splits.yaml）を作成
3. mHealth配下の**SHA256.txt**を作成
4. 既存スクリプトのログ列に**preproc_hash, split_id, model_id, calib_T, tau, theta**を追加
</file>

<file path="フェーズ0-2/要件定義.md">
以下は、**フェーズ0-2（腰装着フォールバック）要件定義書**です。フェーズ1で定義した評価系を維持しつつ、高精度かつ安定した不確実度を短期間で確保するための保険レーンと追加伸びしろを整理します。

# フェーズ0-2 要件定義書（腰装着フォールバック）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH0‑2‑v1.0  
**対象**: 腰装着データの迅速取得・学習および早期出口の評価  
**成功見込み**: 80–90%（腰データ）、60–70%（早期出口）

## 1. 目的
- 腰装着シナリオ向けに正解率（Accuracy）とバランス精度（Balanced Accuracy）≥0.90、期待較正誤差（Expected Calibration Error, ECE）≤0.03のHARモデルを短期間で確立し、BLE評価の母体を確保する。
- BLE安全バンディット評価を止めずに、腰データ版のU/S/CCSを供給し、フェーズ1のKPI算出を継続する。
- 余力がある場合は早期出口（Early-exit）構成を試験し、推論エネルギーとUの一貫性を改善する。

## 2. スコープと境界
- **腰ミニ計測**: 静止/歩行/走行/階段 × 各1分（計≈4分）、必要に応じて追加クラス（上下昇降等）。
- **代替データ**: 公開腰装着データセット（4–6クラス）を利用する場合はセンサ軸を合わせ、Runbookに出典・SHA256を記録。
- **モデル**: 小型1D-CNN（例: DS‑CNN 4–6クラス版）をゼロから学習、量子化（int8）、Arena ≤64 KB、t_inf ≤10 ms。
- **評価**: バランス精度（Balanced Accuracy）/マクロ平均F1スコア（F1 macro）、期待較正誤差（Expected Calibration Error, ECE）、未知率（Unknown rate）、Uの秩序性（易→低U、難→高U）を測定。
- **除外**: BLEチャネル集合変更、MAB導入、長期オンライン学習。

## 3. 成功指標と受入基準
- **正解率/バランス精度（Accuracy/Balanced Accuracy）**: Validationで≥0.90。
- **期待較正誤差（Expected Calibration Error, ECE）**: ≤0.03（温度スケーリング適用後）。
- **未知率（Unknown rate）**: 5–15%、秩序性テストで難クラス時のUが閾値を超過。
- **BLE指標**: フェーズ0-0の擬似U/S比較で期限超過率（Pout, τ=1/2/3 s）が同等以内、平均電流は腰モデルでも削減効果が維持。
- **早期出口（任意）**: 平均t_infを≥10%削減し、マクロ平均F1スコア（F1 macro）低下≤1.0 pt、Pout(1 s)/TL p95に悪化なし。

## 4. 主な作業レーン
1. 計測/データ収集: ミニセッション撮影、姿勢・装着位置の記録、センサ校正ログ取得。
2. 学習: 小型CNNで学習→被験者内/被験者間評価→量子化→Arena/t_inf計測。
3. 較正: 温度スケーリングでECE ≤0.03に合わせ、Unknown閾値τを適合率-再現率曲線（Precision-Recall, PR）から決定。
4. BLE統合: HarOut（腰モデル）をフェーズ1 Policy Engineへ供給し、Pout・TL・電力を評価。
5. 余力（レーン3）: 多出口CNN＋出力ブロック予測器を試験し、推論エネルギー削減とUの階調改善を観測。

## 5. 成果物
- データ取得メモ（環境、姿勢、収録時刻、端末設定）、公開データ利用時は出典・バージョン・SHA256。
- 腰モデル仕様書（アーキテクチャ、パラメタ数、Arena、t_inf、量子化情報）。
- 評価レポート（正解率/バランス精度, Accuracy/Balanced Accuracy／マクロ平均F1スコア, F1 macro／期待較正誤差, Expected Calibration Error／未知挙動／U秩序性／可視化：混同行列・TL/Pout比較）。
- 早期出口検証ノート（ON/OFF比較、エネルギー/レイテンシ差分、閾値設定）。

## 6. リスクと緩和
- **3分計測の品質不足** → 被験者2名以上・各条件≥1分を推奨、足りない場合は公開データで補完。
- **腰と胸のCCS差異** → ウィンドウパラメタとUnknown閾値を独立管理し、Runbookに両者の対照表を追加。
- **早期出口の不安定化** → Exit判定をHAR出力後移動平均で平滑、Uが暴発する場合はExit無効化でフォールバック。

## 7. フェーズ1との接続
- BLE評価系、ログスキーマ、KPI算出はフェーズ1の要件・設計文書をそのまま利用する。
- フェーズ0-2の成果でバランス精度（Balanced Accuracy）≥0.90、期待較正誤差（Expected Calibration Error, ECE）≤0.03を達成した場合、フェーズ1のFR‑2/FR‑5を腰モデルで先行検証できる。
- フェーズ0-1の準備が完了したら、本フェーズで得た腰モデルは比較ベースラインとして保持し、MAB導入時の安全側アーム生成に活用する。
</file>

<file path="フェーズ1/model定義.md">
# フェーズ1 モデル定義（確定版）

本章は Phase‑1 におけるオンデバイス HAR 推論モデルの確定仕様を示す。無線（TL/Pout/電力）が主目的であるため、モデルは軽量・安定・再現可能性を最優先とする。

## 1. 目的と適用範囲
- 目的: Phase‑1 のポリシ評価に必要な U/S/CCS を0.5 s周期で安定供給する。
- 適用: ESP32‑S3/C3 + TFLM int8、IMU 50 Hz／1.0 s窓／50%重畳。

## 2. 実装制約（HW/Runtime）
- TFLM int8、S3 は `esp‑nn` 最適化推奨。
- 制約: Tensor Arena ≤ 80 KB（開始 64 KB 目安）、Flash ≤ 200 KB、FLOPs ≤ 8 M、t_inf ≤ 20 ms（1窓）。

## 3. 標準プロファイル（既定）: DS‑CNN（1.0 s, 6ch）
- 入力: 50×6（1.0 s/50%重畳）。前処理: z‑score、（任意）重力除去。
- 構成（例）:
  - DWConv1D(k=5, s=1) → PWConv(16)
  - DWConv1D(k=5, dilation=2) → PWConv(24)
  - GAP → Dense(K) → Softmax（K=クラス数）
- 目安: ~1k params／~0.03 M FLOPs／~5 ms（S3@240 MHz）。Arena ~48 KB 未満。
- 用途: 省リソース・高安定の既定実装。Phase‑1 の全条件で使用可。

## 4. 拡張プロファイル（任意）: DS‑CNN++（マルチスケール＋早期出口）
- 目的: 遷移 TL への追従と平均遅延・電力の Pareto 改善。
- 入力枝: A=50×6（1.0 s）, B=25×6（0.5 s, 2倍ストライドサンプリング）。
- 各枝: A: DW5→PW16→DW5(d=2)→PW24→GAP／B: DW3→PW12→DW3(d=2)→PW16→GAP。
- 融合: Concat(A_GAP, B_GAP)。
- Exit‑0（任意）: Dense(K)→Softmax（条件: `max_softmax≥0.90` かつ 温度スケーリング後≥0.85 で確定）。
- 最終: 小 Dense（例:16）→ Dense(K)→Softmax。
- 目安: 9–12k params／3–5 M FLOPs／8–12 ms（Exit‑0 命中時 3–5 ms）。Arena 48–64 KB。
- 既定: OFF（A/B 評価で ON 可）。

## 5. 代替プロファイル（任意）: MicroConv‑GRU（DWConv→GRU16）
- 目安: 12–18k params／6–8 M FLOPs／14–20 ms。
- 用途: 連続動作の平滑性を重視する評価に限定。

## 6. 学習・量子化（共通）
- 最適化: Adam, lr=1e‑3（Plateau 0.5×）、Weight Decay 1e‑4、早停=patience 10／max 120 epoch。
- 増強: 小回転、時軸伸縮(±10%)、ノイズ注入、サンプルドロップ(5%)、左右ミラー。
- 不均衡: 重み付き CE または Focal(γ=1–2)。
- 検証: 被験者分離（subject‑wise）K‑fold。
- QAT: FP32 収束後 8–15 epoch。Conv は per‑channel 量子化。
- 信頼度校正: 温度スケーリング（valid で最適 T）→ CCS/Exit 判定に適用。

## 7. エクスポート・デプロイ
- 生成物: 量子化 `.tflite`（int8）＋代表データ。C 配列化して組込み。
- 計測: `esp_timer` で t_inf を 1000 反復測定。Arena 実測／モデルハッシュをログ。
- 推奨設定: Arena=64 KB 開始、S3 は `esp‑nn` 有効化。

## 8. モデルID・命名と記録
- 命名例: `RHT_DSCNN_int8_v{MAJOR.MINOR}`／`RHT_DSCNNpp_int8_v{...}`。
- 記録: `model_id`, `commit_hash`, `q_scheme`, `arena_kb`, `t_inf_ms@S3/C3` を Runbook/レポートへ併記。

## 9. 受入基準（モデル観点）
- 標準（DS‑CNN）: `t_inf ≤ 20 ms`、`Arena ≤ 80 KB`、未サポート Op なし。
- 早期出口 ON（任意）: OFF 比で平均 `t_inf ≥ 20%` 短縮、F1 低下 `≤ 1.0 pt`、Pout(1 s)/TL p95 の劣化は受入基準内。

> 備考: Phase‑1 の主目的は無線（TL/Pout/電力）の評価。モデル比較はポリシ有効性の補助に留める。
</file>

<file path="フェーズ1/Runbook.md">
# フェーズ1 実験運用 Runbook（再現性重視）

## 0. ESP32系スケッチの命名ルール
- 役割別に接頭辞を固定する：受信ロガは `RX_*`, DUT/送信側は `TX_*`, 送信側電力ロガ（PowerLogger/SD書き込み側）は `TXSD_*`。
- 新しいスケッチや派生版を追加する場合は必ずこの接頭辞ルールを守り、既存資料（README, 実験ログ, Runbook）の参照名も同時に更新する。

## 1. 実験前チェック
- NTP同期（ゲートウェイ）／バッテリ残量>80%／電力計校正ログ記録
- 端末・OS・ビルド・スキャン設定（LOW_LATENCY）固定、Doze無効化
- 距離・姿勢を写真で記録（再現用）。E1/E2の時間帯メタを記録

## 2. 条件割付（順序効果の抑制）
- 各セッションの条件順序は Latin 方格で割付
- 固定4条件＋不確実度1条件（計5）を、環境E1/E2で各≥2反復

## 3. 同期・重複除去・評価窓
- 同期: セッション開始時に Sync ADV（seq=0）を1回送信し、LEDを500 ms点灯
- 重複除去: {seq, ts_tx} をキー、判定窓=3×adv_interval。最初の到達を採用
- 評価窓: A/B比較は開始・終了端の0.5 sを除外

## 4. 早期出口（任意、既定OFF）
- 有効化条件（例）: max_softmax≥0.90 かつ 温度スケーリング後≥0.85（Exit‑0）
- 合格基準: 平均t_infがOFF比≥20%短縮、F1低下≤1.0pt、Pout(1 s)/TL p95の劣化が受入基準内
- 速度不足時の縮退: B枝ch数↓ or dilation段削減（C3で顕著な場合）

## 5. P0 校正（推奨）
- 静的/動的3分×2。Arena実測、t_inf（1000反復）、推論のみ/アドバタイズのみ/同時のμC分離
- 取得: Arena_kB, t_inf_ms分布, ベース電流, 校正ログ

## 6. 記録・可視化・受入
- KPI: avg_current, event_charge_uC, PDR, TL（p50/p95）, Pout(τ)
- CI/手元チェック: markdownリンク検査、CSVスキーマ検査（ts単調・値域）
- 併記: 環境ごとに95% CIを併記。P1で{θ_low, θ_high}を確定し、旧{0.40,0.70}を置換
</file>

<file path="フェーズ1/詳細設計定義書_送信ログテンプレート.csv">
t_local_ms,session_id,device_id,adv_interval_ms,ch_mask,tx_dbm,state,U,S,CCS,thresholds_up_active,thresholds_up_uncertain,thresholds_down_active,thresholds_down_uncertain,hysteresis,calib_T_C,window_len_sec,overlap,W_sec
0,PH1_E1_S001,DUT_A01,2000,111,0,QUIET,0.28,0.92,0.2,0.7,0.4,0.65,0.35,0.05,298.15,1.0,0.5,10
500,PH1_E1_S001,DUT_A01,500,111,0,UNCERTAIN,0.58,0.58,0.516,0.7,0.4,0.65,0.35,0.05,298.2,1.0,0.5,10
1000,PH1_E1_S001,DUT_A01,100,111,0,ACTIVE,0.83,0.35,0.758,0.7,0.4,0.65,0.35,0.05,298.26,1.0,0.5,10
1500,PH1_E2_S002,DUT_B02,1000,111,0,FALLBACK,0.42,0.55,0.432,0.7,0.4,0.65,0.35,0.05,293.4,1.0,0.5,10
</file>

<file path="フェーズ1/詳細設計定義書.md">
以下は **ReFormHAR‑Tiny / フェーズ1（弱い構成）_詳細設計定義書** です。
※実装コードは一切含みません。要件定義・設計定義で合意した内容を、**モジュール粒度・状態遷移・データ設計・タイミング設計・誤動作対策・試験観点**まで落とし込んでいます。Phase‑2/3 へそのまま橋渡しできる**拡張フック**も明示しています。

---

## 0. 文書メタ

* **文書ID**：RHT‑DDD‑PH1‑v1.0
* **対象**：Phase‑1（固定ベースライン＋不確実度に基づく決め打ち写像）
* **前提文書**：要件定義書（REQ‑PH1）、詳細要件定義書（RHT‑REQ‑PH1‑D1.0）
* **非対象**：MAB/Safe‑MAB、チャネル集合可変、Tx電力/PHY最適化（Phase‑2/3で扱う）

---

## 1. システム全体像（コンテキスト & 分割）

### 1.1 コンポーネント分割

* **C1. Sensing & HAR**：IMU→前処理（1.0 s窓/50%重畳）→分類（pₖ）→**U**（不確実度）・**S**（安定度）・**CCS**算出
* **C2. Policy Engine（Rule）**：**CCS→adv_interval**の段階写像＋ヒステリシス＋**最小滞在時間**＋**切替レート制限**＋**フォールバック**
* **C3. BLE Advertiser**：**interval適用**、3チャネル（37/38/39）でアドバタイズ、適用成否をイベント化
* **C4. Telemetry & KPI**：送信/受信/電力/決定根拠の**統合ログ**、**KPI生成**（TL、Pout(τ)、PDR、平均電流、イベント電荷）
* **C5. Power Meter I/F**：VBAT直列計測、**イベント境界マーク**、**μC算出**

### 1.2 データフロー（DFD 概念図）

```
IMU --> C1(HAR) --> {U,S,CCS} --> C2(Policy) --> adv_interval --> C3(BLE)
         |                                 |             |
         |                                 +--> C4(Decision Rationale Log)
         v                                               v
      C4(Tx Log)                                  C4(Rx Log) <== Gateway
         ^
         |                              C5(Power Waveform) --> μC --> C4(KPI)
         +----------------------------- 時刻/同期 ----------------------------+
```

---

## 2. 前提・制約（Assumptions & Constraints）

* **Legacy Advertising固定**、**ch_mask=111**（3ch）
* **adv_interval集合**：{100, 500, 1000, 2000} ms（比較用）、写像で用いるのは {100, 500, 2000} ms
* **推論窓**：1.0 s、オーバーラップ50%（**0.5 s周期**でU/S/CCS更新）
* **Sの窓**：W=10 s、遷移カウント正規化
* **ヒステリシス帯**：±0.05（上り閾 0.70/0.40、下り閾 0.65/0.35）
* **最小滞在時間**：2 s、**切替レート上限**：1 Hz
* **フォールバック**：HAR欠落・異常時は **1000 ms**・3ch
* **受信側**：Android **LOW_LATENCY** 固定（端末差の影響を抑える）
* **計測**：Power ≥100 kS/s、イベント境界は**GPIO**でマーキング推奨
* **KPI**：イベント電荷（μC）、平均電流、PDR、TL分布（p50/p95）、**Pout(τ=1/2/3 s)**
* **実装制約（HW/Runtime）**：**TFLM int8**、`Arena ≤ 80 KB`（開始64 KB目安）、`Flash ≤ 200 KB`、`FLOPs ≤ 8 M`、`t_inf ≤ 20 ms/窓`（S3は`esp‑nn`最適化推奨）

---

## 3. 詳細モジュール設計

### 3.1 C1: Sensing & HAR

* **入力**：IMU ≥50 Hz（加速度/ジャイロ）
* **前処理**：固定窓 1.0 s、50%重畳、正規化
* **推論**：pₖ（Kクラス）を出力
* **U（不確実度）**：(U = -\sum_k p_k \log p_k / \log K)（[0,1]）
* **S（安定度）**：直近 W=10 s の**状態遷移回数** n_trans から ( S = 1 - \min(1, n_{\text{trans}}/\tau ))（τは設計値。初期は**5**を推奨）
* **confidence**：`confidence = 1 − U`
* **CCS（統一）**：( \mathrm{CCS} = 0.7\,\mathrm{confidence} + 0.3\,S )。 しきい値{0.40,0.70}はP1で{θ_low, θ_high}に再較正。
* **較正（任意）**：温度スケーリング T（>0）をメタとして保持（**calib_T**）
* **出力周期**：0.5 s
* **早期出口（任意）**：`max_softmax≥0.90` かつ 温度スケーリング後≥0.85 で**Exit‑0**を採用（平均`t_inf`短縮を狙う）。有効/無効をA/Bで比較・ログ化。
* **エラーハンドリング**：pₖが壊れている・欠測 → `HAR_Health=false`（C2へ通知）

**出力イベント（HarOut）**
`{ t_local, label_hat, p_k[], U, S, CCS, calib_T, window_len=1.0, overlap=0.5, W_sec=10 }`

---

### 3.2 C2: Policy Engine（Rule）

* **責務**：HarOutを取り込み、**adv_interval**を段階写像で決定。
* **入力**：`HarOut`、`current_interval`、内部状態（現在STATE、滞在開始時刻）
* **出力**：`Decision{ new_interval, reason, thresholds_used, hysteresis_band, min_dwell_hit, fallback_flag }`

**3.2.1 状態モデル**

* **STATE**：`QUIET (2000ms)`, `UNCERTAIN (500ms)`, `ACTIVE (100ms)`, `FALLBACK (1000ms)`
* **ガード**：

  * **上り判定**：`CCS >= 0.70`（ACTIVE）, `CCS >= 0.40`（UNCERTAIN）
  * **下り判定**：`CCS < 0.65`（ACTIVE→UNCERTAIN）, `CCS < 0.35`（UNCERTAIN→QUIET）
  * **ヒステリシス**：昇降でしきい値が異なる
  * **最小滞在**：前回切替から **≥2 s**
  * **切替レート**：直近 1 s に切替なし
  * **フォールバック**：`HAR_Health=false` or `HarOut timeout > 1.0 s`

**3.2.2 遷移表（再掲・厳密化）**

| 現STATE    | ガード条件                            | 次STATE    | new_interval | reason     |
| --------- | -------------------------------- | --------- | ------------ | ---------- |
| QUIET     | CCS≥0.70 ∧ dwellOK ∧ rateOK      | ACTIVE    | 100          | TH_UP      |
| QUIET     | 0.40≤CCS<0.70 ∧ dwellOK ∧ rateOK | UNCERTAIN | 500          | TH_UP      |
| ANY       | HAR_Health=false ∨ timeout>1.0s  | FALLBACK  | 1000         | FALLBACK   |
| ACTIVE    | CCS<0.65 ∧ dwellOK ∧ rateOK      | UNCERTAIN | 500          | TH_DOWN    |
| UNCERTAIN | CCS<0.35 ∧ dwellOK ∧ rateOK      | QUIET     | 2000         | TH_DOWN    |
| UNCERTAIN | CCS≥0.75 ∧ dwellOK ∧ rateOK      | ACTIVE    | 100          | TH_UP      |
| ANY       | ¬rateOK ∨ ¬dwellOK               | 現STATE    | 現interval    | RATE_LIMIT |

**3.2.3 例外・整合性**

* 連続3回 `FALLBACK` 発動時：**SAFEモード**（500 ms固定）でセッション完走、アラート発報
* `new_interval` が集合外 → 拒否し**SAFEモード**
* 閾値の設定矛盾（上り≤下り）→ 起動時に検出し**SAFEモード**

---

### 3.3 C3: BLE Advertiser

* **責務**：`apply_interval(new_interval)` を**アトミック**に実行
* **制約**：ch_mask=111、Tx dBm固定（地域規制内）
* **副作用**：適用成功/失敗を**Decision Rationale Log**へイベント出力
* **タイミング**：**BLE送信直後**にPolicy評価→次イベントから新interval適用（過渡の二重設定を避ける）

---

### 3.4 C4: Telemetry & KPI

* **サブモジュール**：

  * **TxLogger**：送信側メタ（interval, state, U, S, CCS, thresholds, reason）
  * **RxLogger**（GW側）：`t_gateway, phone_model, scan_mode, rx_uuid, rssi, dedup_flag`
  * **DecisionLog**：切替ごとに1行（根拠追跡用）
  * **PowerLogger**：イベント境界（GPIO）、波形→**μC**化
  * **KPI Builder**：TL分布、Pout(τ)、PDR、平均電流、イベント電荷の集計CSVを出力（任意で`t_inf`分布と`exit_used`率を追加）

**実装ポリシ**

* **非同期書き出し**（バッファリング）／**優先度**：Tx/Rx>Decision>Power（波形は連続ストリーム）
* **落ち穂拾い**：バッファ溢れ時は**最古の通常ログ**から破棄。**DecisionLog**は破棄禁止
* **完全性**：セッション末尾に**インデックス**（件数/欠損/範囲）を付与

---

### 3.5 C5: Power Meter I/F

* **接続**：VBAT直列（シャント内蔵計）、GNDループ回避
* **サンプリング**：≥100 kS/s、**電圧**も併記
* **イベント境界**：GPIOで**アドバタイズイベント開始/終了**をマーキング
* **前後校正**：ゼロ/ゲイン、温度ログ
* **導出**：各イベントの**μC**を算出し、平均/分散をKPIへ

---

## 4. タイミング設計（実時間要件）

| 項目         | 目標/上限             |
| ---------- | ----------------- |
| HAR出力周期    | 0.5 s（窓1.0 s/50%） |
| Policy評価時間 | ≤1 ms/回           |
| 決定→BLE適用   | **次の**アドバタイズイベントから反映   |
| 最小滞在時間     | ≥2 s              |
| 切替レート      | ≤1回/秒             |
| ログフラッシュ    | ≤500 ms           |
| Power波形遅延  | 0（ストリーミング）        |

**優先度**：BLE Tx（高）＞ HAR（中）＞ Logger（低）
**ジッタ**：Policy評価のトリガは**BLE送信直後**に合わせて実行（競合・振動回避）

---

## 5. データ設計（スキーマ & 妥当性）

### 5.1 送信ログ（Tx）

```
t_local(ms), session_id, device_id,
adv_interval_ms{100|500|1000|2000}, ch_mask='111', tx_dbm,
state{ACTIVE|UNCERTAIN|QUIET|FALLBACK}, U[0..1], S[0..1], CCS[0..1],
thresholds{upA,upU,downA,downU}, hysteresis=0.05,
calib_T?, window_len=1.0, overlap=0.5, W_sec=10
```

**検証**：値域、単調時刻、集合外intervalの禁止

### 5.2 受信ログ（Rx, GW）

```
t_gateway(ms), session_id, gateway_id, phone_model, scan_mode='LOW_LATENCY',
adv_addr, rx_uuid, rssi(dBm), dedup_flag{0|1}
```

### 5.3 決定ログ（Decision）

```
t_local(ms), session_id, old_interval, new_interval, reason{TH_UP|TH_DOWN|FALLBACK|RATE_LIMIT},
CCS_at_decision, min_dwell_hit{0|1}, rate_limit_hit{0|1}, har_health{0|1}, apply_success{0|1}
```

### 5.4 電力波形（Power）

```
t_probe(us), current_mA, voltage_V, event_marker{0|1}
```

### 5.5 導出KPI（Aggregated CSV）

```
session_id, condition, env(E1|E2), run_id,
avg_current_mA, energy_mWh_per_day,
event_charge_uC_mean, event_charge_uC_std,
PDR, TL_p50_ms, TL_p95_ms, Pout_1s, Pout_2s, Pout_3s
```

**命名規約**：`RHT_{date}_{session}_{condition}_{env}.csv`
**時刻基準**：DUTは相対（セッション起点0 ms）、GWはNTP（同期マーカーで整合）

---

## 6. シーケンス（代表ケース）

### 6.1 不確実度上昇→ACTIVE遷移

```
HarOut(U,S,CCS=0.74)      -> C2.set_context()
C2.decide_interval()       -> dwellOK & rateOK & CCS>=0.70 → ACTIVE
C3.apply_interval(100ms)   -> success
C4.DecisionLog             -> reason=TH_UP, CCS=0.74, min_dwell=1
C4.TxLog                   -> state=ACTIVE, adv_interval=100
C5.Power                   -> 次イベント区間をevent_markerで取得
```

### 6.2 HAR欠落→FALLBACK

```
HarOut timeout>1.0s        -> C2.fallback()
C3.apply_interval(1000ms)  -> success
C4.DecisionLog             -> reason=FALLBACK, fallback_flag=1
```

---

## 7. エラー/例外設計（FMEA 抜粋）

| 事象        | 原因        | 検出           | 影響        | 緩和/回復                     |
| --------- | --------- | ------------ | --------- | ------------------------- |
| HAR欠落     | センサ/推論停止  | HarOutタイムアウト | CCS無効     | FALLBACK=1000ms、アラート、復帰監視 |
| しきい値設定矛盾  | 設定ミス      | 起動時検証        | 異常遷移      | SAFE=500ms固定、設定拒否         |
| 切替振動      | U/Sノイズ    | 切替頻度監視       | QoS・電力悪化  | ヒステリシス/最小滞在/レート制限         |
| Power波形欠損 | ケーブル/記録停止 | QAスクリプト      | μC不明      | 再試行、セッション無効化              |
| 受信側ドロップ過多 | 干渉/端末不良   | PDR監視        | TL/Pout劣化 | 端末再起動/再試行、E1/E2分離評価       |

---

## 8. 設定管理（Config 仕様）

* **policy.thresholds**：`{ up_active:0.70, up_uncertain:0.40, down_active:0.65, down_uncertain:0.35 }`
* **policy.hysteresis**：0.05
* **policy.min_dwell_sec**：2
* **policy.switch_rate_limit_hz**：1
* **policy.fallback_interval_ms**：1000
* **har.window_sec/overlap/W_sec**：1.0 / 0.5 / 10
* **ble.ch_mask/tx_dbm**：`0b111` / `0`
* **logging.flush_period_ms**：500

**バリデーション**：上り閾 > 下り閾、interval集合の単調増加、数値範囲チェック
**バージョン**：`config_version` と **Gitハッシュ**をDecisionLogへ同時出力

---

## 9. セキュリティ/プライバシ/規格

* 生IMUは**外部送信しない**。アドバタイジング内容は**アクティビティ種別/統計メタ**に限定（フェーズ1は固定ビーコンでも可）
* BLE出力は**地域規制**（Tx/EIRP）を順守
* ログには個人識別子を入れず、**匿名ID**で管理

---

## 10. 検証設計（試験観点と可視化）

* **機能**：状態遷移（すべての枝）、フォールバック、ヒステリシス・最小滞在・レート制限の発火を**DecisionLog**で確認
* **性能**：avg_current・μC・PDR・TL（p50/p95）・Pout(τ) を**環境E1/E2×条件**で比較
* **再現性**：主要KPIが**±5%以内**（同条件3反復）
* **可視化**：

  * TLの**CDF**（条件別）
  * **Pout(τ)**（τ=1/2/3 s）棒グラフ
  * 事件電荷（μC）の**箱ひげ**
  * 状態遷移タイムライン（state/interval over time）

---

## 11. Phase‑2/3 への拡張フック

* **Policy IFは固定**：`decide_interval()` を **MAB / Safe‑MAB** に差し替え
* **DecisionMeta拡張**：`arm_id`, `reward`, `context{U,S,env}` を**列追加**で後方互換
* **Safety Hook**：`is_feasible(arm, τ, θ)` を空実装で先行定義（Phase‑3 で有効化）
* **Rx拡張**：将来の**rx_channel同定**や**scan_mode可変**は**別列**で追加可能
* **電力辞書**：Phase‑1で得た**interval→μC**をMAB報酬の正規化に再利用

---

## 12. チェックリスト（運用/品質）

* 起動時：Config検証OK／時刻同期OK／Power校正OK／ストレージ空き>5 GB
* 走行中：切替頻度≤1 Hz／最小滞在違反なし／DecisionLogに根拠が記録されている
* 終了時：ログ欠損<1%／Power波形のイベント境界が明瞭／KPI CSVが自動出力

---

## 付録A：代表しきい値・区分

* ACTIVE：`CCS ≥ 0.70` → 100 ms
* UNCERTAIN：`0.40 ≤ CCS < 0.70` → 500 ms
* QUIET：`CCS < 0.40` → 2000 ms
* 下り閾：ACTIVE→0.65、UNCERTAIN→0.35（ヒステリシス±0.05）

## 付録B：代表KPI算出フロー（数式のみ）

* **μC**：イベント区間の ( \int I(t),dt )
* **平均電流**：( \bar{I} = \frac{1}{T}\int_0^T I(t),dt )
* **TL**：イベント時刻差（DUTラベル→GW初回受信）
* **Pout(τ)**：( \Pr[TL>\tau] )（TLの経験CDFから）

---

### 結語

本**詳細設計定義書**により、Phase‑1 を **実装なしに運用準備**でき、得られた**写像・ログ・KPI**は **Phase‑2/3** の **初期方策・報酬正規化・制約フック**へ**無改造で継承**できます。設計の**差し替え点**（Policy IF / Safety Hook / DecisionMeta拡張）を明示したため、以降の複雑化に対しても**最小変更**で対応可能です。
</file>

<file path="フェーズ1/詳細要件定義書.md">
以下は、**フェーズ1（弱い構成）_詳細要件定義書**です。
※実装コード・詳細設計は含みません。実験・計測・評価を“そのまま運用できる”粒度で要件化しています。

---

# ReFormHAR‑Tiny / フェーズ1 詳細要件定義書（弱い構成）

**文書ID**: RHT‑REQ‑PH1‑D1.0
**版**: v1.0（起案）
**作成日**: 2025-11-08
**作成/責任**: 研究代表（A）、実験リード（B）、計測リード（C）、解析リード（D）

---

## 1. 目的／達成像

* **最小実行可能な省電力効果**を、**再現可能なKPI**（イベント電荷μC、平均電流mA、Pout(τ)、p50/p95遅延TL、PDR）で**統一手順**により定量化する。
* **HAR不確実度（U）・安定度（S）**から得る**複合スコア（CCS）**に基づき、**決め打ち写像**で**アドバタイズ間隔**を切替え、**固定ベースライン**と比較する。
* フェーズ2以降（MAB/Safe‑MAB）に**そのまま移植**できる**データスキーマ・KPI計算・写像表**を確立する。

---

## 2. スコープ／非スコープ

**２.１ スコープ**

* BLE **Legacy Advertising**（非接続・非指向、Ch 37/38/39）
* **アドバタイズ間隔（adv_interval）**の制御
* **HAR推論（オンデバイス）**から得る U, S, CCS を用いた**段階写像**
* **イベント電荷（μC）**の計測／**Pout(τ)**・**TL分布**の算出／**PDR**の算出
* **再現性の担保**（校正・同期・ログ・QA）

**２.２ 非スコープ**

* MAB/Safe‑MAB の学習・制約導入
* Androidスキャン非理想性のアルゴリズム注入（観測は次フェーズ）

* Tx電力/PHY/アドバタイズ長の最適化、オンライン重み更新、モデル再学習

---

### 2.3 実装制約（HW/Runtime）

* **プラットフォーム**：ESP32‑S3/C3、**TFLM int8**を使用（S3は`esp‑nn`最適化を推奨）
* **推論制約**：`Arena ≤ 80 KB`（開始64 KB目安）、`Flash ≤ 200 KB`、`FLOPs ≤ 8 M`、`t_inf ≤ 20 ms/窓`
* **入力仕様**：IMU 50 Hz、窓1.0 s、重畳50%（SはW=10 s）
* **計測**：`t_inf`は`esp_timer`等で1000反復、バイナリと条件をログ

---

## 3. 成果物（Deliverables）

1. **要件適合レポート**（KPI合否・グラフ・考察）
2. **ログ一式**（送信・受信・電力・導出KPI；統一スキーマ）
3. **決め打ち写像表（CCS→adv_interval）**（CSV、ヒステリシス含む）
4. **イベント電荷リファレンス**（3ch基準、参考：1/2ch測定）
5. **実験Runbook**（配線・手順・チェックリスト・失敗時復旧手順）

---

## 4. 用語・記号（定義）

* **U（不確実度）**: (U=-\sum_k p_k\log p_k / \log K \in [0,1])
* **S（安定度）**: 直近 (W) 秒の状態遷移回数から算出、(S\in[0,1])（大きいほど安定）
* **confidence（確信度）**：`confidence = 1 − U`
* **CCS（統一）**: ( \mathrm{CCS} = 0.7\,\mathrm{confidence} + 0.3\,\mathrm{stability} \in[0,1])

> しきい値の再較正：定義変更に伴い、従来の {0.40, 0.70} はそのまま使用せず、P1（validation）で ROC/PR に基づき新しきい値 {θ_low, θ_high} を決定し、Runbook に置換表として記録する。
* **adv_interval**: アドバタイズイベントの周期（ms）
* **TL**: イベント検知→初回受信までの遅延（ms）
* **Pout(τ)**: 期限 τ 内に初回受信が無い確率
* **イベント電荷（μC）**: アドバタイズ**1イベント**（3ch送信）に要した電流積分値

---

## 5. システム構成とデータフロー（概念）

```
IMU → 前処理(1.0s窓/50%重畳) → HAR推論(p_k)
                          └→ U(不確実度), S(安定度) → CCS → [決め打ち写像] → adv_interval設定
BLE Stack(3ch) → 送信 → 受信(ゲートウェイ/Android) → 重複除去 → PDR/TL/Pout算出
                                       ↑
電力計測(イベント電流波形) → 積分(μC) → 電力KPI
```

---

## 6. 機能要件（FR：Functional Requirements）

**FR‑1 固定ベースライン制御**

* adv_interval ∈ {**100**, **500**, **1000**, **2000**} ms（各独立セッション）
* ch_mask = **111**（3ch固定）、Tx dBm = 既定（例: 0 dBm）

**FR‑2 決め打ち写像（CCS→間隔）**

* 窓長=**1.0 s**、オーバーラップ=**50%**、安定判定窓 (W=10,s)
* **ヒステリシス**: 閾値±**0.05**（昇降で別閾値）
* 既定写像（**変更可**・変更時はログ必須）。以下の閾値は初期値であり、P1で{θ_low, θ_high}に再較正する。

  * **ACTIVE**: CCS ≥ **0.70** → **100 ms**
  * **UNCERTAIN**: **0.40** ≤ CCS < **0.70** → **500 ms**
  * **QUIET**: CCS < **0.40** → **2000 ms**

**FR‑3 Uの較正（推奨）**

* 温度スケーリング等の**単一係数**による較正を1回実施
* 込み／無し両条件を比較、**calib_T**をログ

**FR‑4 受信・重複除去**

* ゲートウェイ（Android/Low‑Latency推奨）がアドバタイズを**重複除去**しユニーク系列化
* 受信時刻・RSSI・端末モデル・スキャンモードをログ

**FR‑5 電力計測**

* **イベント波形**を取得（イベント境界マーキング）
* 各イベントの**電荷（μC）**を算出
* 平均電流・mWh/日も算出（ベースライン比較用）

**FR‑6 同期**

* セッション先頭に**LED 3秒点滅**で**送受ログ**に共通マーカー
* ゲートウェイは**NTP同期**、DUTは相対時刻で補正

**FR‑7 KPI導出**

* **TL分布**（p50/p95）、**Pout(τ=1/2/3s)**、**PDR**、**平均電流**、**イベント電荷**を条件×環境×反復ごとに自動出力

**FR‑8 実験条件**

* **環境**: E1=干渉弱、E2=干渉強（2.4GHz Wi‑Fi 1/6/11稼働）
* **受信端末**: Android 1–2機種（**LOW_LATENCY**固定）
* **セッション**: 各条件×各環境 **≥3反復**（合計≥30セッション）
* **アクティビティ**: 座位5分→歩行5分→座位5分（計15分/セッション）

---

## 7. 非機能要件（NFR）

* **NFR‑1 再現性**: 同条件で**±5%以内**（平均電流、イベント電荷、Pout）
* **NFR‑2 観測可能性**: 状態遷移・閾値超過・間隔変更の**根拠ログ**付与（U,S,CCS,閾値方向）
* **NFR‑3 可搬性**: ログスキーマはPhase2/3でも**列追加のみ**で互換
* **NFR‑4 安全・規格**: BLE規格／地域規制の**Tx・Duty**遵守
* **NFR‑5 プライバシ**: 生IMUを外部送信しない（メタデータのみ）

---

## 8. インタフェース要件（IF）

**IF‑A（HAR→ポリシ）**

* 入力: (p_k)（確率）、窓長=1.0s/50%重畳
* 出力: U（[0,1]）、S（[0,1]）、CCS（[0,1]）
* 周期: 0.5sごと（重畳のため）
* 付帯: **calib_T**（スカラー）・**W**（s）・**遷移カウント**

**IF‑B（ポリシ→BLE制御）**

* 入力: CCS、ヒステリシス状態、現在のadv_interval
* 出力: 新adv_interval（{100,500,2000}ms）
* 付帯: **切替イベントログ**（旧→新、理由：閾値方向/値）

**IF‑C（DUT→ゲートウェイ）**

* 送信: BLEレガシー・アドバタイジング（3チャネル）
* 受信ログ: t_gateway、端末モデル、scan_mode、rx_uuid、RSSI、dup_flag

**IF‑D（電力計測）**

* 入力: DUT VBATライン
* 出力: 電流波形、生電圧、イベントマーク（on/off）
* 分解能: ≥100 kS/s

---

## 9. KPI定義（数式／算出手順）

* **イベント電荷（μC）**: (\textstyle Q=\int_{t_s}^{t_e} I(t),dt)（1イベント=3ch送信期間）
* **平均電流（mA）**: 期間平均（ベースライン比較用）
* **PDR**: ユニーク・アドバタイズ数／期待アドバタイズ数（ウィンドウ基準）
* **TL**: アクティビティ変化（端末内ラベル時刻）→ゲートウェイで**最初に受信**したアドバタイズまで
* **Pout(τ)**: ( \Pr[TL>\tau] = 1 - \hat{F}_{TL}(\tau) )（τ∈{1,2,3}s）
* **統計**: 各KPIは**平均±95%CI**、**p50/p95**、環境別に提示

---

## 10. 受入基準（Acceptance）

* **省電力**: 固定100ms対比で、不確実度駆動が**平均電流 ≥ 5–10% 改善**（E1/E2とも）
* **品質維持**: Pout(1s)の悪化が**+1.0%pt以内**、p95(TL)が**+10%以内**
* **整合性**: 主要KPIの再現性**±5%以内**、ログ欠損<1%
* **表記**: KPIは**95% CI**を併記（E1/E2別）
* **満たない場合**: **閾値±0.05**、ヒステリシス強化、QUIET下限**2000→1000ms**へ一度だけチューニング許容

**補助基準（任意：早期出口ONの場合）**

* **平均`t_inf`がOFF比で**≥20%短縮**し、かつKPIの劣化（Pout(1 s)・TL p95）が**受入基準内**であること
* 学習側の**F1（validation）**低下が**≤1.0 pt**であること（参考指標、ログ化推奨）

---

## 11. 実験プロトコル（運用）

**11.1 セッション前チェック（抜粋）**

* 電力計測器校正OK／気温記録／バッテリ残量>80%
* ゲートウェイ時刻NTP同期／ストレージ空き>5GB
* DUT: 固定条件→不確実度条件の順で**ランダム化**（順序効果抑制）

**11.2 実行**

1. LED同期（3秒）→セッション開始
2. 15分アクティビティ（座位→歩行→座位）
3. 受信・電力波形の**同時取得**
4. 終了後、簡易QA（ドロップ率・電力波形有無）

**11.3 エラー時**

* 受信ドロップ>10%: スキャン再起動→再試行
* 波形欠損: ケーブル再接続→再試行
* 2回失敗で**セッション中止**・原因記録

---

### 同期・重複除去（再現規約）

* **同期**：セッション開始時に Sync ADV（`seq=0`）を1回送信し、同時にLEDを**500 ms**点灯する。評価はSync以降のデータのみを用いる。
* **重複除去**：`{seq, ts_tx}` をキーに、**判定窓=3×adv_interval**で同一イベントを定義し、最初に到達した1件を採用する。
* **評価窓**：A/B比較では開始・終了端の**0.5 s**を評価対象から除外する。

### 再現性担保（運用）

* 条件順序は**Latin方格**で割付。
* 受信端末は機種/OS/ビルド/スキャン設定を固定し、**Doze無効化**。
* **距離・姿勢**の写真エビデンスと、E1/E2の**時間帯メタ**を記録する。
* 各環境で**≥2反復**から**95% CI**を併記する。

---

### 付記：P0 校正（推奨）

* **目的**：推論リソース（Arena/t_inf）と電力計測系の健全性確認
* **内容**：静的/動的3分×2、`Arena`実測、`t_inf`（1000反復）、推論のみ/アドバタイズのみ/同時のμC分離
* **出力**：`Arena_kB`, `t_inf_ms`分布、ベース電流、計測校正ログ

---

## 12. ログ仕様（データ辞書）

**送信ログ（DUT）**

| 項目              | 型         | 単位/範囲                  | 必須 | 備考     |
| --------------- | --------- | ---------------------- | -- | ------ |
| t_local         | float(ms) | 単調増加                   | ●  | 起点0で良い |
| session_id      | string    | —                      | ●  | 一意     |
| device_id       | string    | —                      | ●  | —      |
| adv_interval_ms | int       | {100,500,1000,2000}    | ●  | —      |
| ch_mask         | string    | ‘111’固定                | ●  | —      |
| tx_dbm          | int       | 例 0                    | ●  | —      |
| state           | string    | ACTIVE/UNCERTAIN/QUIET | ●  | —      |
| U               | float     | [0,1]                  | ●  | —      |
| S               | float     | [0,1]                  | ●  | —      |
| CCS             | float     | [0,1]                  | ●  | —      |
| calib_T         | float     | >0                     | ○  | 較正時のみ  |
| window_len      | float     | 秒                      | ●  | 1.0    |
| overlap         | float     | 0–1                    | ●  | 0.5    |
| W_sec           | float     | 秒                      | ●  | 10     |

**受信ログ（GW）**

| 項目          | 型         | 説明                    |
| ----------- | --------- | --------------------- |
| t_gateway   | float(ms) | NTP同期時刻               |
| session_id  | str       | 一致必須                  |
| gateway_id  | str       | —                     |
| phone_model | str       | —                     |
| scan_mode   | str       | LOW_LATENCY固定（Phase1） |
| adv_addr    | str       | —                     |
| rx_uuid     | str       | ユニーク受信ID              |
| rssi        | int       | dBm                   |
| dedup_flag  | bool      | 重複除去後=1               |

**電力ログ（Power）**

| 項目           | 型         | 説明          |
| ------------ | --------- | ----------- |
| t_probe      | float(ms) | —           |
| current_mA   | float     | —           |
| voltage_V    | float     | —           |
| event_marker | int       | 0/1（イベント境界） |

**導出KPI（集計CSV）**

| 項目                                | 型     | 説明 |
| --------------------------------- | ----- | -- |
| session_id/condition/env/run_id   | —     | —  |
| avg_current_mA/energy_mWh_per_day | float | —  |
| event_charge_uC_mean/std          | float | —  |
| PDR                               | float | —  |
| TL_p50_ms/TL_p95_ms               | float | —  |
| Pout_1s/_2s/_3s                   | float | —  |

---

## 13. QA／データ完全性（自動チェック）

* 欠損率<1%、時刻の単調性、範囲外値（U,S,CCS∉[0,1]）、adv_intervalセット外の検出
* イベント電荷の分布外れ（外れ値>±3σ）警告
* 受信ユニーク数が期待値の一定割合未満（例<30%）で**警告**

---

## 14. リスクと緩和

| リスク        | 影響      | 緩和策                          |
| ---------- | ------- | ---------------------------- |
| Uの過信（誤高信頼） | 通信暴発    | 温度スケーリング、ヒステリシス強化、QUIET下限短縮  |
| 受信端末の不安定   | PDR低下   | LOW_LATENCY固定、バックアップ端末、再起動手順 |
| 電力計測誤差     | μC再現性低下 | ゼロ/ゲイン校正、温度記録、イベント境界マーク      |
| 干渉過多       | Pout劣化  | E1/E2分離評価、再試行条件の明確化          |

---

## 15. 変更管理

* **小変更**（閾値±0.05、ヒステリシス±0.02）: 実験継続OK、差分記録
* **中変更**（窓長、W）: 代表条件1セット再計測
* **大変更**（adv_intervalセット/ch_mask）: 要承認・計画更新

---

## 16. Traceability（目的⇔要件⇔検証）

| 目的       | 要件ID        | 検証手段                         |
| -------- | ----------- | ---------------------------- |
| 省電力定量    | FR‑1/2/5    | avg_current、event_charge、比較図 |
| QoS維持    | FR‑4/7      | Pout(τ)、TL p95、PDR           |
| 再現性確保    | NFR‑1       | 再現性±5%テスト                    |
| Phase2移行 | FR‑2/7、ログ仕様 | 写像表CSV、スキーマ互換、KPI自動計算        |

---

## 17. 次フェーズ接続（インタフェース保証）

* **写像表CSV**は**初期方策（warm‑start）**としてMABに投入可能
* **イベント電荷辞書**は**報酬正規化**に直結
* **ログスキーマ**は**arm/reward/context**列を追加するだけで拡張可能
* **KPI関数**に**Pout制約判定**用フック（引数τ, θ）をあけておく

---

## 18. スケジュール／マイルストーン（例）

* **M1**: 計測治具校正・Runbook完成（W1）
* **M2**: E1環境で固定4条件×3反復完了（W2–3）
* **M3**: E2環境で固定4条件×3反復完了（W3–4）
* **M4**: 不確実度写像条件（E1/E2×各3反復）完了（W4–5）
* **M5**: 解析・KPIレポート・要件適合判定（W6）

---

## 19. チェックリスト（抜粋）

**事前**: NTP同期/ストレージ空き/電力計校正/ケーブル固定/LED同期確認
**実行**: 条件順序表の確認/ヒステリシス有効/ラベル付け開始時刻記録
**終了**: ログ欠損確認/イベント電荷の波形確認/TLの粗集計/バックアップ保存

---

### 付録A：既定パラメータ（初期値）

* 窓長=**1.0 s**、重畳=**50%**、W=**10 s**
* 閾値=**0.40/0.70**、ヒステリシス=**±0.05**
  - 注：上記は初期値。P1で{θ_low, θ_high}に再較正し置換する。
* adv_intervalセット=**{100, 500, 1000, 2000}**（比較）、写像は**{100, 500, 2000}**
* ch_mask=**111**、Tx dBm=**既定（0 dBm）**
* スキャンモード=**LOW_LATENCY**
* Pout評価 τ=**1/2/3 s**
</file>

<file path="フェーズ1/設計定義書.md">
以下は **ReFormHAR‑Tiny / フェーズ1（弱い構成） 設計定義書** です。
※実装コードは含みません。要求仕様に対して、**アーキテクチャ／モジュール分割／インタフェース契約／状態機械／データ設計／運用・計測設計／試験設計との整合**を明確にします。フェーズ2（MAB化）、フェーズ3（Safe‑MAB化）への拡張を前提に、**差し替え可能な設計**にしています。

---

# 1. 文書メタ

* **文書ID**：RHT‑DES‑PH1‑v1.0
* **対象フェーズ**：Phase‑1（固定ベースライン＋不確実度に基づく決め打ち写像）
* **前提文書**：要件定義書／詳細要件定義書（前回合意済み）

---

# 2. 設計方針（Design Principles）

1. **分離（Separation of Concerns）**：

   * **Sensing/HAR**（推論）／**Policy Engine**（写像）／**BLE Advertiser**（送信）／**Telemetry & Power**（観測）を疎結合化。
2. **プラグイン化**：

   * **Policy Engine**を**インタフェース化**（Phase‑2でMAB、Phase‑3でSafe‑MABに差し替え）。
3. **観測駆動**：

   * すべての意思決定に**根拠ログ**（U,S,CCS,境界超過, 旧→新interval）を必ず残す。
4. **最小限のリアルタイム制約**：

   * HAR出力周期0.5 sで十分／アドバタイズ間隔は100–2000 msの離散値。スレッド優先度は**無線＞推論＞ログ**。
5. **安全側フォールバック**：

   * U/Sが無効・欠落時は**1000 ms・3ch**へ復帰。切替頻繁化を防ぐ**ヒステリシス＋最小滞在時間**を持たせる。
6. **将来拡張**：

   * **rx_channel同定**や**Pout(τ)制約**用のフックを先に定義しておく（未使用でも空実装）。

---

# 3. システム構成（High‑Level Architecture）

```
+-------------------+        +----------------------+        +------------------+
|   Sensing & HAR   | -----> |  Policy Engine (PH1) | -----> |  BLE Advertiser  |
|  (IMU → model)    |  U,S   |  (Rule-based mapping)|  Adv   | (Interval & 3ch) |
|  p_k → U,S,CCS    |  CCS   |  + Hysteresis        |  set   |  Tx dBm fixed    |
+-------------------+        +----------------------+        +------------------+
         |                               |                              |
         v                               v                              v
+-------------------+        +----------------------+        +------------------+
| Telemetry Logger  | <----- |  Decision Rationale  | <----- | Power Meter I/F  |
| (Tx/Rx/Power/KPI) |        | (Why/When switched)  |        | (Event charge)   |
+-------------------+        +----------------------+        +------------------+
```

---

# 4. モジュール設計

## 4.1 Sensing & HAR モジュール

* **役割**：1.0 s窓・50%重畳で推論、U（不確実度）、S（安定度）を算出。
* **入出力**：

  * 入力：IMUストリーム（≥50 Hz）
  * 出力：`HAR_Output{ t, label_hat, p_k[K], U∈[0,1], S∈[0,1], CCS∈[0,1] }`（0.5 s毎）
* **アルゴリズム仕様**：

  * `U = -Σ p_k log p_k / log K`
  * `S = 1 - min(1, n_transitions(W)/τ)`（W=10 s；τは設計値）
  * `confidence = 1 − U`
  * `CCS = 0.7*confidence + 0.3*(S)`  （定義統一）
  * 注：従来の閾値{0.40,0.70}はP1で再較正し、{θ_low, θ_high}に置換して運用。
* **較正（任意）**：温度スケーリングTを係数として保持（ログに記録）。
* **実装注**：**TFLM int8**を前提、S3は`esp‑nn`最適化推奨。`Arena`は**64 KB開始（上限80 KB）**、`Flash ≤ 200 KB`、`t_inf ≤ 20 ms/窓`を設計目安。

## 4.2 Policy Engine（PH1：決め打ち写像）

* **役割**：CCSに基づきアドバタイズ間隔を離散切替。
* **IF（フェーズ横断）**：

  * `set_context(HAR_Output)`
  * `decide_interval(current_interval) -> NewInterval, DecisionMeta`
* **写像仕様**（既定、変更可）：

  * ACTIVE：CCS ≥ 0.70 → 100 ms
  * UNCERTAIN：0.40 ≤ CCS < 0.70 → 500 ms
  * QUIET：CCS < 0.40 → 2000 ms
* **アンチスラッシング**：

  * **ヒステリシス**：±0.05
  * **最小滞在時間**：各区分**≥2 s**（滞在満了まで再切替禁止）
  * **レート制限**：**1 sあたり最大1回**の切替
* **フォールバック**：U/S/CCSが欠損・NaN・異常域 → `1000 ms`へ、理由をDecisionMetaに記録。

> **将来差し替え点**：`decide_interval()`の実装のみ置換で**MAB**／**Safe‑MAB**へ移行可能。入出力とメタは維持。

## 4.3 BLE Advertiser

* **役割**：与えられたintervalを設定し、3チャネル（37/38/39）で送出。
* **仕様**：

  * `apply_interval(ms)` はアトミックに設定（OS/BLE Stack API準拠）
  * **ch_mask=111固定**（Phase‑1は評価の一貫性重視）
  * **Tx dBm固定**（規格・地域上限内）
* **観測**：切替タイムスタンプ、旧→新interval、適用成否をログ。

## 4.4 Telemetry & Power

* **役割**：送受・電力・決定根拠を統合ログ化し、KPI生成に必要なデータ完全性を担保。
* **サブ構成**：

  * **Tx Logger**：`{t, session_id, adv_interval, ch_mask, tx_dbm, state, U, S, CCS, calib_T}`（任意で`t_inf_ms`, `exit_used`を追加し推論の実測/Exit発火を観測）
  * **Rx Logger（GW側）**：`{t_gateway, session_id, phone_model, scan_mode, rx_uuid, rssi, dedup_flag}`
  * **Power Logger**：イベント境界マーク付き波形（≥100 kS/s）、イベント電荷μCを算出
  * **Decision Rationale**：`{t, old_interval, new_interval, reason(TH_UP/DOWN/FALLBACK), CCS_at_decision, dwell_time_ok}`

---

# 5. インタフェース契約（Contract）

## 5.1 データ型（抽象）

* `HAR_Output`：前述（floatは[0,1]制約、K>1）
* `DecisionMeta`：`{ reason, threshold_used, hysteresis_band, min_dwell_hit(bool), fallback_flag(bool) }`
* `TxLogRecord`／`RxLogRecord`／`PowerEvent`：詳細要件のスキーマに準拠

## 5.2 タイミング契約

* HAR出力周期：0.5 s
* Policy反映：HAR出力から**≤100 ms**以内に`decide_interval`評価、必要なら次のアドバタイズイベントに**即反映**
* 切替最小間隔：1 s
* 最小滞在時間：2 s

## 5.3 エラーハンドリング

* **HAR欠落**（タイムアウト>1.0 s）：`fallback_flag=true`で1000 msへ復帰
* **BLE設定失敗**：直前設定を再適用、連続失敗3回で**安全側（500 ms）**に設定しアラート
* **パラメタ異常**（閾値入替、負のinterval等）：設定を拒否し保守モード（500 ms）

---

# 6. 状態機械（Policy Engine）

**状態**：`QUIET`, `UNCERTAIN`, `ACTIVE`, `FALLBACK`
**入力イベント**：`CCS↑閾値超過`, `CCS↓閾値下回り`, `HAR欠落`, `滞在満了`, `RateLimit超過`

| 現状態       | 入力                    | 遷移先       | 動作                           |
| --------- | --------------------- | --------- | ---------------------------- |
| QUIET     | CCS≥0.70 かつ 滞在満了      | ACTIVE    | interval=100ms, reason=TH_UP |
| QUIET     | 0.40≤CCS<0.70 かつ 滞在満了 | UNCERTAIN | 500ms, TH_UP                 |
| ANY       | HAR欠落                 | FALLBACK  | 1000ms, FALLBACK             |
| ACTIVE    | CCS<0.65 かつ 滞在満了      | UNCERTAIN | 500ms, TH_DOWN               |
| UNCERTAIN | CCS<0.35 かつ 滞在満了      | QUIET     | 2000ms, TH_DOWN              |
| UNCERTAIN | CCS≥0.75 かつ 滞在満了      | ACTIVE    | 100ms, TH_UP                 |
| ANY       | RateLimit超過           | 現状態       | 変更なし（理由=RATE_LIMIT）          |

注：0.70/0.40は上り閾値、0.65/0.35は下り閾値（ヒステリシス=±0.05）。

---

# 7. データ設計（ログ／KPI）

## 7.1 ログスキーマ（再掲＋設計注）

* **送信ログ**の`state`は**状態機械の状態**と一致させる。
* **Decision Rationale**は**切替のたびに1行**必ず出す（監査可能性）。
* **Power**は**イベント境界**のマークを確実に記録（アドバタイズ（3チャネル）の区間に一致させる）。

## 7.2 KPI生成フロー

1. Power波形 → **イベント電荷μC**に積分 → セッション平均・分散
2. Rxログ＋アクティビティラベル → **TL**（初回到達遅延）→ **Pout(τ)**=Pr[TL>τ]
3. Tx/Rx統合 → **PDR**, **平均電流**（Power総和/時間）
4. 条件×環境×反復の**集計CSV**を自動書き出し

---

# 8. タイミング・スケジューリング設計

* **スレッド優先度**：`BLE Tx (High)` > `HAR (Mid)` > `Logger (Low)`
* **実行周期**：HAR＝2 Hz、Policy評価＝2 Hz、BLEイベント＝interval依存
* **競合回避**：Policy評価は**BLE送信直後**のタイミングで行い、**最小滞在時間**と**レート制限**でスラッシング防止。
* **時間予算**（目安）：Policy判定≦1 ms、ログ出力≦5 ms/回（非同期・バッファリング）

---

# 9. 構成・パラメタ管理（Config）

* **config.yml（例）**

  * `intervals: [100, 500, 2000]`
  * `thresholds: { up_active: 0.70, up_uncertain: 0.40, down_active: 0.65, down_uncertain: 0.35 }`
    - 注：上記は初期値。P1で再較正した {θ_high, θ_low} に置換して運用する。
  * `hysteresis: 0.05`
  * `min_dwell_sec: 2`
  * `switch_rate_limit_hz: 1`
  * `fallback_interval_ms: 1000`
  * `har: { window_sec: 1.0, overlap: 0.5, W_sec: 10, temp_scale_T: 1.0 }`
  * `har.early_exit: { enabled: false, conf_thresh: 0.90, post_T_conf_thresh: 0.85 }`
  * `ble: { ch_mask: 0b111, tx_dbm: 0 }`
  * `logging: { level: INFO, flush_period_ms: 500 }`

> Phase‑2 以降は `policy: { type: RULE | MAB | SAFE_MAB, params: ... }` を追加するだけで切替。

---

# 10. 電力計測・受信系設計

## 10.1 電力計測

* **配線**：VBAT直列・シャント内蔵計へ。グラウンドループ防止。
* **サンプリング**：≥100 kS/s、時刻同期は開始時LEDマーク＋ソフトマーク。
* **イベント境界**：アドバタイズイベント開始/終了を**GPIOトグル**で書き出し（観測器で同時取得）推奨。
* **校正**：ゼロ／ゲイン、気温記録、校正ログを別ファイル管理。

## 10.2 受信系

* **スキャンモード**：Phase‑1は**LOW_LATENCY**固定（端末差要因を抑制）
* **重複除去**：`(seq, ts_tx)` をキーに**判定窓=3×adv_interval**でユニーク化（最初の到達を採用）
* **評価窓**：A/B 比較は**端0.5 s**を除外
* **TL算出**：アクティビティ遷移タイムスタンプ（DUT起点）と受信時刻（GW起点）を**同期マーカー**で整合

---

# 11. 品質設計（QA & フェイルセーフ）

* **Self‑Check**：起動時にConfig妥当性検査（閾値順序、interval集合の単調増加、値域）
* **Watchdog**：HAR出力タイムアウト>1 sでFALLBACKへ、復帰時に`fallback_flag=false`で記録
* **ドロップ対策**：ログキューにバックプレッシャ、溢れ時は**最古を間引き**（切替イベントは必ず保持）
* **セッション完了チェック**：ログ欠損率＜1%、イベント電荷の外れ値警告（±3σ）

---

# 12. 試験設計との整合（Traceability）

| 要件ID   | 設計要素                            | 試験観点                       |
| ------ | ------------------------------- | -------------------------- |
| FR‑1/2 | Policy Engine（Rule）・状態機械・ヒステリシス | 切替動作、RateLimit、最小滞在検証      |
| FR‑4   | Rx Logger・重複除去                  | PDR/TLの再現                  |
| FR‑5   | Power Logger・GPIOマーク            | イベント電荷の再現性±5%              |
| FR‑7   | KPIパイプライン                       | Pout(τ), TL p95, 平均電流の自動算出 |
| NFR‑1  | 校正・再現性手順                        | 同条件±5%検証                   |
| NFR‑3  | IF契約・Config                     | Phase‑2/3での差し替え試験          |

---

# 13. リスク & デザイン緩和

* **切替振動**：ヒステリシス＋最小滞在＋レート制限で抑制。
* **HAR誤検知**：温度スケーリング導入・Sの窓W拡大。
* **受信端末差による変動**：Phase‑1はLOW_LATENCY固定、Phase‑2でチャネル同定導入予定。
* **計測ノイズ**：GPIO境界マーク・高サンプル・校正の3点セットで吸収。

---

# 14. フェーズ移行のための“差し替え点”明示

* **Policy Engine**：`decide_interval()`を**MAB**（arm=(interval, ch_mask)）へ差し替え。
* **DecisionMeta**：`arm`, `reward`, `context` を拡張フィールドとして追加（後方互換）。
* **Telemtry**：既存ログに `arm_id`, `reward_est` 列を追加。
* **Safety Hook**（Phase‑3）：`is_feasible(arm, τ, θ)`フックをPolicyに追加（初期は常にtrue）。

---

# 15. 展開・運用（Runbook要点）

1. 設備点検（電力計校正、NTP同期、ストレージ空き）
2. Config配布・起動・自己診断OK確認
3. LED同期→セッション開始
4. 実験終了→自動KPI出力→要件合否判定

---

# 16. 変更管理（設計）

* 閾値・ヒステリシス・滞在時間：**小変更**（ログにバージョン注記）
* interval集合変更・ch_mask可変化：**中〜大変更**（Phase‑2で実施予定）
* IF破壊変更は禁止（後方互換を維持）

---

## 付録A：主要パラメタ一覧（初期値）

| 項目                   | 値                                                                        | 用途                        |
| -------------------- | ------------------------------------------------------------------------ | ------------------------- |
| intervals            | [100, 500, 2000] ms                                                      | 写像用（比較は100/500/1000/2000） |
| thresholds           | up_active=0.70, up_uncertain=0.40, down_active=0.65, down_uncertain=0.35 | ヒステリシス±0.05               |
| min_dwell_sec        | 2                                                                        | 最小滞在時間                    |
| switch_rate_limit_hz | 1                                                                        | 切替頻度制限                    |
| fallback_interval_ms | 1000                                                                     | フォールバック                   |
| har.window_sec       | 1.0                                                                      | 推論窓                       |
| har.overlap          | 0.5                                                                      | 重畳                        |
| har.W_sec            | 10                                                                       | 安定度窓                      |
| ble.ch_mask          | 0b111                                                                    | 3ch固定                     |
| ble.tx_dbm           | 0                                                                        | 固定出力                      |
</file>

<file path="フェーズ1/用語集.md">
# フェーズ1 用語集（Glossary）

本プロジェクトの設計・要件に即した用語の簡潔な定義。日本語優先・初出で英語（英語略）を併記。

## 推論・スコア関連
- HAR（人的活動認識, Human Activity Recognition）: IMUからオンデバイスで活動を分類する処理。
- IMU（慣性計測ユニット, Inertial Measurement Unit）: 加速度・ジャイロを含む6軸センサ。
- 窓長（Window length）: 1.0 s、50%重畳。出力は0.5 s周期。
- U（不確実度, Uncertainty）: 出力確率の正規化エントロピー。0（確信）〜1（不確実）。
- confidence（確信度, Confidence）: 1 − U。CCSの主成分として用いる。
- S（安定度, Stability）: 直近W=10 sの状態遷移回数から算出した安定度（大きいほど安定）。
- CCS（複合スコア, Composite score）: 0.7×confidence + 0.3×stability。しきい値{θ_low, θ_high}はP1で再較正（初期値0.40/0.70）。
- ヒステリシス（Hysteresis）: 昇降でしきい値を±0.05ずらす処理（例: up_active=0.70, down_active=0.65）。
- 最小滞在時間（Min dwell）: 区分滞在の最短時間（≥2 s）。
- 切替レート制限（Switch rate limit）: 切替頻度の上限（≤1 Hz）。
- 早期出口（Early-Exit）: 中間出力の信頼度が条件（例: max_softmax≥0.90 かつ温度スケーリング後≥0.85）を満たす場合に推論を短絡する方式（Exit-0）。
- 温度スケーリング（Temperature scaling, T）: 確信度の較正。較正後のTはログに保存。

## BLE・ポリシ関連
- BLEレガシー・アドバタイジング（BLE Legacy Advertising）: 非接続・非指向のアドバタイジング。評価はCh 37/38/39の3チャネル固定。
- adv_interval（アドバタイズ間隔）: アドバタイズイベント周期。既定の段階は{100, 500, 2000} ms（比較には1000 msも用いる）。
- ch_mask（チャネル集合, Channel mask）: `0b111`=37/38/39の3チャネル送出を意味。
- 状態区分（ACTIVE/UNCERTAIN/QUIET）: CCSとヒステリシスで決まる伝送区分。各区分にadv_intervalを割当。
- FALLBACK/SAFE: HAR欠落・異常時などの安全側設定（例: 1000 ms固定）。
- Sync ADV: セッション開始時に送る同期アドバタイズ（seq=0）。LED 500 ms点灯と併用。
- seq / ts_tx: アドバタイズのシーケンスID / 送信時刻（送信側基準）。
- 重複除去（Deduplication）: {seq, ts_tx}をキーに判定窓=3×adv_intervalで同一イベントを定義し、最初の到達を採用。

## KPI・計測関連
- TL（初回到達遅延, Time-to-first-Receive）: アクティビティ変化→最初の受信までの遅延。
- Pout(τ)（期限超過率, Outage）: TLがτ（1/2/3 s）を超える確率（Pr[TL>τ]）。
- PDR（受信成功率, Packet Delivery Rate）: 重複除去後ユニーク受信数の割合。
- イベント電荷（Event charge, μC）: アドバタイズイベント（3チャネル送信）の電流積分値。
- 平均電流（Average current）: セッション平均の電流値（比較に使用）。
- 95% CI（信頼区間）: KPIに併記する信頼区間（環境E1/E2別）。

## 実装・実行環境
- 推論モデル（Inference model）: ネットワーク構造＋学習済み重み。最終成果物は量子化済み`.tflite`（int8）。
- TFLiteモデル（.tflite）: 推論モデルをTFLite形式に変換したファイル。デバイスへはバイナリ同梱やC配列化で組み込む。
- TFLM（TensorFlow Lite for Microcontrollers）: `.tflite`を実行する推論ランタイム（インタプリタ＋演算カーネル＋メモリ管理）。
- Tensor Arena（アリーナ, Arena）: TFLMの静的ワーク領域。運用目安64 KB（上限80 KB）。
- Flash（フラッシュ）: モデル等の格納領域。目安≤200 KB。
- FLOPs: 1推論あたりの演算量（乗算加算回数の目安）。制約≤8 M。
- t_inf（推論時間）: 1窓の推論遅延（ms）。`esp_timer`で1000反復計測。制約≤20 ms。
- ESP32-S3/C3: 対象SoC。S3では`esp-nn`最適化カーネルの使用を推奨。

## モデル設計（model定義.mdで使用）
- DS‑CNN（Depthwise Separable CNN）: Depthwise畳み込み＋Pointwise（1×1）畳み込みで軽量化したCNN。
- DS‑CNN++: DS‑CNNを基にしたマルチスケール分岐＋早期出口（Exit‑0）を備える強化版。
- DWConv / PWConv: Depthwise畳み込み / Pointwise（1×1）畳み込み。
- GAP（Global Average Pooling）: 特徴マップを空間平均してベクトル化する層。
- GRU（Gated Recurrent Unit）: 軽量な再帰型ユニット。例: GRU(16)は16ユニット。
- 早期出口（Early‑Exit, Exit‑0）: 中間層の確信度が条件（例: max_softmax≥0.90、T適用後≥0.85）を満たせば最終層をスキップ。
- max_softmax: 出力確率ベクトルの最大成分。確信度の近似指標。
- QAT（Quantization‑Aware Training）: 学習時から量子化誤差を模擬して精度劣化を抑える手法（ConvはPer‑channel量子化推奨）。
- Params（パラメータ数）: 学習可能重みの総数。モデル容量の目安。
- dilation / stride: 畳み込みの膨張率 / ストライド（サンプリング間引き）。
- マルチスケール分岐（Multi‑scale branch）: 1.0 s窓と0.5 s窓など異なる時間スケールの特徴を並列抽出。
- F1（macro）: クラスごとのF1を平均した指標。クラス不均衡の影響を抑える。

## 実験運用
- E1/E2: 環境区分。E1=干渉弱、E2=干渉強（Wi‑Fi混雑）。
- Runbook: 再現性重視の運用手順（`docs/フェーズ1/Runbook.md`）。
- Latin方格（Latin square）: 条件順序の割付法。順序効果を抑制。
- Doze無効化: 受信端末で省電力最適化を停止し、スキャンの安定性を確保。
- {θ_low, θ_high}: CCSの再較正後しきい値。P1（validation）で確定し、初期値0.40/0.70を置換。
</file>

<file path="フェーズ1/要件定義.md">
以下は、**フェーズ1（弱い構成）要件定義書**です。コードは一切含まず、**目的／範囲／用語／機能・非機能要件／KPI・受入基準／実験プロトコル／計測・ログ仕様／成果物／リスク／次フェーズ接続**までを“そのまま運用できる粒度”でまとめています。

---

# フェーズ1 要件定義書（弱い構成）

**文書ID**: ReFormHAR‑Tiny/REQ‑PH1‑v1.0
**作成日**: 2025-11-08
**対象**: BLEアドバタイジングの**固定基準**および**不確実度駆動（決め打ち写像）**による省電力評価

---

## 1. 目的（Purpose）

1. **最低限の省電力効果**を、**再現可能なKPI**（イベント電荷μC、平均電流mA、Pout(τ)、遅延TL分布、PDR）で定量化する。
2. **HAR不確実度**（U）と**安定度**（S）に基づく**決め打ち写像**（CCS→adv間隔）を定義し、**ベースライン（固定間隔）**と比較する。
3. フェーズ2（中位構成：MAB導入）以降へ**そのまま移植**できるデータ構造・ログ・計測系・写像表を確立する。

---

## 2. スコープ（Scope）と境界

* **対象機能**

  * BLE **Legacy** Advertising（非接続・非指向、3チャネル 37/38/39）
  * **アドバタイズ間隔（adv_interval）**の制御（**100/500/1000/2000 ms**）
  * **チャネル集合は3ch固定**（111）。※イベント電荷の基礎測定のみ1ch/2chも取得（制御には使わない）
  * HAR推論（端末内）から得る**不確実度U**、**安定度S**、**複合スコアCCS**の算出と**段階写像**
* **除外**

* MAB/バンディット学習、Safe/Constrained Bandit、Androidスキャン非理想性の方策注入、Tx電力/PHY/アドバタイズ長の最適化
  * 個人最適化のオンライン学習（モデルパラメタ更新）
* **適用環境**

  * 屋内（干渉弱／Wi‑Fi干渉強）2条件
  * 受信側は**Android 1–2機種**（**LOW_LATENCY**スキャン推奨）
  * 端末（DUT）1機種（BLE5 SoC搭載デバイス）

---

## 3. 用語・指標定義

* **U（不確実度）**：出力確率 (p_k) のエントロピー正規化 (U = -\sum_k p_k\log p_k / \log K \in [0,1])。
* **S（安定度）**：直近 (W) 秒の状態遷移回数に基づく安定度。例：( S = 1 - \min(1,, n_{\text{trans}}/\tau) \in [0,1])。
* **confidence（確信度）**：`confidence = 1 − U`。
* **CCS（複合スコア）［統一］**： ( \mathrm{CCS} = 0.7\,\mathrm{confidence} + 0.3\,\mathrm{stability} \in [0,1] )。

> しきい値の再較正：定義変更に伴い、従来の {0.40, 0.70} をそのまま使用せず、P1（validation）で ROC/PR に基づき新しきい値 {θ_low, θ_high} を決定し、Runbook に置換表として記録する。
* **TL（初回到達遅延）**：イベント検知→最初のアドバタイズ受信までの遅延。
* **Pout(τ)**：期限 τ（例1/2/3秒）以内に**初回受信できない**確率。
* **イベント電荷（μC/event）**：1 度のアドバタイズイベント（3チャネル送出）の電流積分値。
* **PDR/ASR**：受信成功率（重複除去後のユニーク・アドバタイズ単位）。

---

## 4. 機能要件（Functional Requirements, FR）

**FR‑1 ベースライン制御**

* 固定 adv_interval ∈ {100, 500, 1000, 2000} ms、**ch_mask=111**、Tx電力=既定（例 0 dBm）。
* それぞれ独立セッションで計測（同一環境条件で≥3反復）。

**FR‑2 不確実度駆動（決め打ち写像）**

* CCSに応じて adv_interval を**段階切替**。既定（変更可・ログ化必須）。
  注：以下の閾値は初期値。P1で再較正し、{θ_low, θ_high} に置換して運用する。

  * **ACTIVE（高緊急）**：CCS ≥ 0.70 → **100 ms**
  * **UNCERTAIN（中）**：0.40 ≤ CCS < 0.70 → **500 ms**
  * **QUIET（低緊急）**：CCS < 0.40 → **2000 ms**
* 切替ヒステリシス（抑振動）を**±0.05**付与（昇降で閾値差を設ける）。
* 状態推定は**窓長 1.0 s / 50% オーバーラップ**。(W=10) sでSを更新。

**FR‑3 HAR較正（任意・推奨）**

* 温度スケーリング等でUのキャリブレーションを1回実施し、**較正係数T**をログ（数値のみ保存）。
* 較正有/無の両条件でFR‑2を評価。

**FR‑4 計測・ログ**

* 送信側：adv_interval、ch_mask、state（ACTIVE/UNCERTAIN/QUIET）、U、S、CCS、タイムスタンプ。
* 受信側：受信時刻（ゲートウェイ時刻）、RSSI、重複除去後ユニークID、スキャンモード。
* 電力：**イベント波形**を記録し、**イベント電荷（μC）**を算出。平均電流、mWh/日も保存。
* **同期**：セッション先頭でLED点滅（3秒）等の**同期マーカー**を両ログに記録。

**FR‑5 KPI算出**

* **TL分布**（p50/p95）、**Pout(τ)**（τ=1/2/3 s）、**PDR/ASR**、**イベント電荷**、**平均電流**。
* 条件 × 環境 × 反復ごとに自動出力（CSV/図）。

---

## 5. 非機能要件（NFR）

**NFR‑1 再現性**：同条件で**±5%以内**の再現性（平均電流、イベント電荷、Pout(τ)）。
**NFR‑2 観測可能性**：すべての状態遷移・閾値・間隔変更に**根拠ログ（U,S,CCS,境界超過）**を付与。
**NFR‑3 可搬性**：ログスキーマはPhase2/3でも**列追加のみ**で互換。
**NFR‑4 安全・規格**：BLE規格と地域規制の**送信電力/ Duty**を順守。
**NFR‑5 プライバシ**：生IMUは端末内完結。送信はラベル/メタのみ。

---

## 6. KPIと受入基準（Acceptance Criteria）

**KPI‑1 省電力**

* 固定100 ms（ベースライン）に対し、不確実度駆動（FR‑2）が**平均電流で ≥ 5–10% 改善**（両環境で達成）。

**KPI‑2 品質維持（遅延・到達）**

* **Pout(1 s)** の悪化が**ベースライン比 +1.0%pt 以内**。
* **p95(TL)** が**ベースライン比 +10% 以内**（もしくは同等以下）。

**KPI‑3 計測整合**

* イベント電荷（3ch）・平均電流の**再現性 ±5%以内**。
* ログ欠損・同期ずれ**< 1%**。

**合否**：KPI‑1〜3を**全て**満たすこと。未達の場合はチューニング（閾値、ヒステリシス、窓長）を**1回**まで許容し再試行。

---

## 7. 実験設計（被験・環境・反復）

* **環境**：

  * **E1: 干渉弱**（Wi‑Fi最小）
  * **E2: 干渉強**（2.4GHz Wi‑Fi稼働、1/6/11を高占有）
* **受信端末**：Android **LOW_LATENCY**固定（端末1–2機種）。
* **セッション**：各条件（固定4種類＋不確実度1種類=計5）× **各環境で3反復**。
* **アクティビティ**（例）：座位5分→歩行5分→座位5分（合計15分/セッション）。
* **総本数**：5条件 × 2環境 × 3反復 = **30セッション**（端末2機種なら60）。

**補助評価（追加・任意）**

* **P0 校正（推奨）**：Arena使用量、`t_inf`（1000反復、S3@240 MHz目安）、ベース電流を取得し、運用前に健全性を確認。
* **早期出口のA/B（任意）**：Exit‑0条件（例：`max_softmax≥0.90` かつ 温度スケーリング後≥0.85）をON/OFFで比較し、平均`t_inf`短縮とKPI（Pout(1 s), TL p95）の維持を確認（劣化は受入基準内）。

---

## 8. 計測仕様（電力・受信・同期）

**電力**

* **装置**：PPK‑II / Joulescope / Otii（いずれか）。
* **接続**：VBAT直列、**サンプリング ≥ 100 kS/s**。
* **ブレークダウン**：

  * **アドバタイズのみ**／**推論のみ**／**アイドル**の分離測定を**各1回**実施し背景値を得る。
  * **イベント電荷**：アドバタイズイベント毎（3チャネル一括）の電流積分（μC）。
* **校正**：ゼロ補正・ゲイン補正をセッション前後に実施し**温度・ドリフト**を記録。

**受信**

* **重複除去**：アドバタイズPDUのアドレス＋タイム窓で除重。
* **PDR**：秒あたりユニーク・アドバタイズ数の比率。
* **TL/Pout**：アクティビティ変化（端末側ラベル）起点→最初の受信まで。**τ=1/2/3 s**でPout算出。

**同期**

* **開始マーカー**：端末LED点滅（3秒）、ゲートウェイ側スクリーン録画/ログ印。
* **時刻**：ゲートウェイNTP同期、端末RTCは相対時間で補正。

---

## 9. ログ仕様（スキーマ）

* **送信ログ（DUT）**

  ```
  t_local, session_id, device_id,
  adv_interval_ms, ch_mask, tx_dbm,
  state{ACTIVE|UNCERTAIN|QUIET}, U, S, CCS,
  model_id, calib_T(optional), window_len, overlap, W_sec,
  note
  ```
* **受信ログ（Gateway）**

  ```
  t_gateway, session_id, gateway_id, phone_model, scan_mode,
  adv_addr, rx_uuid, rssi, dedup_flag
  ```
* **計測ログ（Power）**

  ```
  t_probe, session_id, current_mA, voltage_V, event_marker
  ```
* **導出KPI（集計CSV）**

  ```
  session_id, condition(baseline_100|...|uncertainty),
  env(E1|E2), run_id,
  avg_current_mA, energy_mWh_per_day,
  event_charge_uC_mean, event_charge_uC_std,
  PDR, TL_p50_ms, TL_p95_ms,
  Pout_1s, Pout_2s, Pout_3s
  ```

---

## 10. 解析・可視化（最低限）

* **箱ひげ**：avg_current、event_charge（条件×環境）
* **CDF**：TLのCDF（条件別）
* **曲線**：Pout(τ) vs τ（条件別、E1/E2）
* **棒グラフ**：PDR、Pout(1s)の比較
* **テーブル**：KPIまとめ（ベースライン100msとの比較差［%/pt］）

---

## 11. 成果物（Deliverables）

1. **要件適合レポート**（本ドキュメント準拠でKPI合否を記載）
2. **ログ一式**（送信・受信・電力・導出KPI）と**図表（PNG/PDF）**
3. **決め打ち写像表（CCS→adv_interval）**（数値版・ヒステリシス込み）
4. **イベント電荷リファレンス**（3ch基準、参考として1ch/2chの値も掲載）
5. **再現手順書**（環境構築・配線・同期・解析のRunbook、バージョン付き）

---

## 12. リスクと緩和

* **R‑1 IMU/HARノイズで状態遷移が過多** → **ヒステリシス**強化、窓長・Wの調整、Uの温度スケーリング適用。
* **R‑2 Poutが悪化** → QUIETの下限を**2000→1000 ms**へ暫定短縮（再試行は1回まで）。
* **R‑3 電力計測の再現性不足** → 校正頻度増、温度ログ記録、イベント境界のデジタルマーカー導入。
* **R‑4 受信端末の不安定** → **LOW_LATENCY固定**、バックアップ端末準備。
* **R‑5 ログ欠損** → ストレージ監視、セッション前の容量チェック、ローテーション設定。

---

## 13. 移行（Phase‑2/3 への接続要件）

* **写像表**は**初期方策（warm‑start）**としてMABに投入可能な**CSV形式**で出力。
* **イベント電荷辞書**（条件→μC）はMABの**報酬正規化**に流用。
* **ログスキーマ**は**arm/reward/context**列を**列追加**するだけで拡張可能。
* **KPI算出スクリプト**は**Pout(τ)制約判定**の呼び出し口を空けておく（関数インタフェース定義のみ）。

---

## 14. 役割と責任（RACI）

* **実験設計・運用**（R/A）：あなた
* **電力計測治具の校正**（R）：ハード担当
* **受信ログと重複除去**（R）：ゲートウェイ担当
* **KPI集計＆レポート**（R）：解析担当
* **最終承認**（A）：プロジェクト責任者
* **支援/相談**（C/I）：全員

---

## 15. 変更管理

* **小変更**（閾値±0.05、ヒステリシス調整）：再実験**不要**、ログに差分記録
* **中変更**（窓長、W）：主要条件**1セット再計測**
* **大変更**（intervalセット変更、ch_mask変更）：要審査・承認

---

### 付記：既定パラメータ（初期値）

* 窓長=**1.0 s**、オーバーラップ=**50%**、W=**10 s**
* CCS閾値=**0.40/0.70**、ヒステリシス=**±0.05**
  - 注：上記は初期値。P1で{θ_low, θ_high}に再較正し置換する。
* adv_interval（ms）=**100/500/2000**、基準比較に**100/500/1000/2000**
* ch_mask=**111**（3ch固定）
* スキャンモード=**LOW_LATENCY**
* Pout評価 τ=**1/2/3 s**

---

### 付記：HW/Runtime 制約（Phase‑1 実装）

* **SoC**：ESP32‑S3/C3、**TFLM int8**固定（S3は`esp‑nn`最適化を推奨）
* **入力**：IMU 50 Hz／窓1.0 s／重畳50%
* **推論制約**：`Arena ≤ 80 KB`（運用開始は64 KB目安）、`Flash ≤ 200 KB`、`FLOPs ≤ 8 M`、`t_inf ≤ 20 ms/窓`
* **評価**：`t_inf`は`esp_timer`等で1000反復計測し、条件とバイナリのハッシュを記録

---

この要件定義に従えば、**弱い構成の成果物がそのまま中位・強い構成の“部品”**（初期方策・イベント電荷辞書・KPIパイプライン）として流用できます。
実装や数式の詳細設計は不要ですが、**ログ・KPI・閾値の“約束”**だけは厳密に守って運用してください。
</file>

<file path="全体像.md">
以下は、**ReFormHAR‑Tiny** の“引きの目線”から描いた **Vision / World Model** です。
目的は、**他のAIがこのプロジェクトの世界観・用語・約束事を読み取って、そのまま正しく解釈・再構成できる**ように、**用語の正規化・不変条件・境界条件・役者・相互作用・成熟段階**を体系化して提示することです。コードや実装詳細には踏み込みません。

---

## 0) North Star（北極星）

> **人に寄り添う省電力AIを“端末だけで成立させる”。**
> センサ→推論→通信の**3層を同時に最適化**し、**期限内に届くこと（Pout(τ)の保証）**と**電池寿命の最大化（mWh/日、µC/イベント最小）**を**同時達成**する。
> 学習は**軽量・安全**で、**環境とユーザの変化**に**自律追従**する。

北極星を定義しておくと、後述の設計判断（方針・評価・リスク対策）はこのベクトルに**常時整合**させます。

---

## 1) World Model（世界観の骨格）

### 1.1 役者（Actors）

* **Edge Node / DUT**：IMU＋マイコン（MCU）。**HAR**（人間行動認識）を**オンデバイス**で推論し、**不確実度 U** と **安定度 S** を生成、**BLE広告**の振る舞いを決める。
* **Gateway（スマホ/受信機）**：BLE広告を受けるだけの**受信主体**。**スキャンは非理想**（チャネル巡回・隙間・モード差）であることを前提とする。
* **Observer / Orchestrator（任意）**：実験・運用でログを収集し、**KPI**（Pout、遅延TL、PDR、µC、平均電流）を算出する。クラウド常時接続は不要。
* **Safety Oracle（概念）**：**QoS制約**（例：Pout(1s) ≤ θ）を定義し、**方策が常に守るべき境界**を提示する“規格書”的存在。
* **Policy Engine（概念→実体）**：**通信層の意思決定器**。Phase‑1はルール写像、Phase‑2でMAB、Phase‑3でSafe‑MAB（制約つき）へ進化。

### 1.2 能力（Capabilities）— 5つの柱

1. **Perception（知覚）**：IMU→HAR→確率分布 (p_k)、**U**（不確実度）、**S**（安定度）。
2. **Decision（意思決定）**：**CCS=0.6 U+0.4 (1−S)** をコンテキストに**BLE広告の間隔・チャネル集合**を決定。
3. **Communication（通信）**：**イベント電荷（µC）最小**で、**期限内初回受信（Pout(τ)の保証）**を満たす広告。
4. **Safety（安全）**：**常時** Pout(τ) ≤ θ を満たす**制約**の中で最適化。違反兆候で**安全側へ自動退避**。
5. **Observability（可観測性）**：**すべての意思決定に根拠ログ**（U,S,CCS,閾値、切替理由、適用可否）を残す。

### 1.3 不変条件（Invariants）

* **オンデバイス優先**：生センサは外に出さない（プライバシ）。
* **QoS優先の最適化**：**Pout(τ) を常に制約**として扱い、その範囲内で電力最小化。
* **後方互換のIF**：Policyの入出力（Context→Arm/Interval）は**固定契約**。内部実装が変わってもIFは壊さない。
* **単一真実のKPI**：**イベント電荷（µC）・Pout(τ)・TL分布**を“一次指標”。平均電流やmWh/日は従属。

### 1.4 境界条件（Operating Envelope）

* **MCU制約**：RAM≲256 KB / Flash≲1 MB、整数演算（INT8）前提。
* **BLE制約**：Legacy Advertising、3ch（37/38/39）、Tx/EIRPとDutyは地域規制遵守。
* **受信制約**：スマホは**連続スキャンではない**（モードで挙動が変化）。**理想化しない**。

---

## 2) Ontology（用語・データ辞書）

### 2.1 概念・変数

* **(p_k)**：HARのクラス確率。
* **U**：正規化エントロピー。不確実度∈[0,1]。
* **S**：安定度∈[0,1]（遷移が少ないほど1に近い）。
* **CCS**：0.6 U+0.4 (1−S)。
* **Arm**：通信方策の一単位（Phase‑1：adv_interval；Phase‑2以降：interval×ch_mask[×tx_dbm/phy]）。
* **TL**：イベント検知→最初の受信までの遅延。
* **Pout(τ)**：期限τ内に初回受信できない確率。
* **µC/event**：広告イベント1回あたり電流積分。
* **ρ（Duty factor）**：受信側のスキャン占有率。
* **pd**：スキャン窓内での検出同時確率（環境依存）。

### 2.2 ログ主キー（“AIが読める命名”）

* **Tx**：`t, session_id, adv_interval, ch_mask, tx_dbm, state, U, S, CCS, reason`
* **Rx**：`t, session_id, phone_model, scan_mode, rx_uuid, rssi, dedup_flag`
* **Power**：`t, current_mA, voltage_V, event_marker`
* **KPI**：`avg_current, event_charge_uC, TL_p50, TL_p95, Pout_1s/_2s/_3s, PDR`

> すべて**列追加入り**で拡張可能（後方互換）。AIは列名で意味を推定できる。

---

## 3) ビジョンの段階（Maturity Levels）

### **L1：Rule**（Phase‑1の姿）

* **何をするか**：CCSで**adv_interval**を切替（100/500/2000 ms）。**ヒステリシス＋滞在時間**で安定化。
* **なぜ意味があるか**：**イベント電荷**と**平均電流**を即時に落としつつ、**Pout(τ)**・**TL**が**基準と同等**であることを示せる。
* **残る課題**：環境・端末依存性や“受信側の隙間”を考慮できない。最適点は状況で変わる。

### **L2：MAB**（学習化）

* **何をするか**：**腕=（interval, ch_mask）**、**報酬=−µC × 受信成否**、**コンテキスト=（U,S）**。**写像表はWarm‑Start**に。
* **なぜ意味があるか**：**環境ごと**に（干渉、距離、端末差）**最適点に自律収束**。**写像単独**より**+αの省電力**（同QoS）を狙う。
* **残る課題**：**Pout(τ)** は保証されない（平均的に良くても、最悪ケースで欠落が起きうる）。

### **L3：Safe‑MAB**（制約つき最適化）

* **何をするか**：**Pout(τ) ≤ θ** を**制約関数**として腕選択を**常時**制限。**feasible‑arm**集合内で最適化。違反兆候で**安全側デグレード**。
* **なぜ意味があるか**：**QoS保証**と**省電力**を**同時達成**。**解析式の知見（ρ, pd, N＝η等）**を**学習の境界条件**に注入。
* **残る課題**：**先験情報**（端末ごとのスキャン挙動）や**アプリ側の価値**をまだ十分活用していない。

### **L4：Context Fusion**（“世界”を読む）

* **何をするか**：**スマホのスキャン挙動の先験**（37→38→39巡回、モード差の初期オフセットなど）と**アプリの緊急度**（U,S,アラート重要度）を**ポリシに注入**。
* **なぜ意味があるか**：**実環境の非理想**を**事前に知っているポリシ**は、**学習初期の後悔**と**最悪遅延**を減らす。
* **残る課題**：学習の**初期方策**が手作りで、環境やアプリの**多様性**を十分に取り込めない。

### **L5：Knowledge‑Distilled Bandit**（知識蒸留）

* **何をするか**：外部知識（規格・端末挙動・無線環境の一般論・アプリ優先度マップ）を**“圧縮表現”**に蒸留し、**Warm‑Start**と**禁止腕**に変換。
* **なぜ意味があるか**：**現場投入直後**から**安全に**・**そこそこ良い**方策で始められる。**再学習時間**を短縮。
* **残る課題**：知識の鮮度・偏りへの対処（監査・更新ガバナンス）。

> **到達点**：L3（Safe‑MAB）で論文的インパクト、L4/L5で**実運用の堅牢性とTTV（Time‑to‑Value）短縮**。

---

## 4) 価値の地図（Value Map）

### 4.1 定量KPI（“通貨”）

* **一次**：**イベント電荷（µC）**、**Pout(τ)**、**TL（p95）**
* **二次**：平均電流、mWh/日、PDR、F1/Acc
* **複合**：**J/decision**（1検出あたりのエネルギ）／**QoS違反率**（τ毎）

### 4.2 ユースケース枠

* **見守り**（転倒・無動作）：「**偽陰性＜偽陽性**」「Pout(2s)≪θ」
* **労働安全**（急変姿勢の通知）：「**TL p95 ≤ 500 ms** かつ 電池寿命30日↑」
* **スポーツ**（フォーム変化検知）：「**遷移期だけ濃く**、安定期は薄く」
* **PdM×人**（作業者×機械）：「**異常連鎖時**に**バースト広告**で到達率優先」

---

## 5) ガバナンス（Governance Model）

* **規格準拠**：BLE広告・出力規制・Duty規制の**上限**は**Policyが越えない**。
* **安全網**：QoS違反兆候→**安全側へ退避**（短間隔×3ch固定）。
* **説明責任**：各ラウンドの**Decision Rationale**は**不可欠ログ**。
* **データ最小化**：ログは**匿名化**。生波形や生IMUは外に出さない。
* **監査可能性**：実験再現用の**Runbook**と**KPIパイプライン**を常備（環境・端末差まで記録）。

---

## 6) AIのための“読み取りガイド”（他AIが誤解しないために）

### 6.1 契約（IF）— **MUST / SHOULD**

* **MUST**：`decide_interval(context) -> interval` の**IFは固定**（将来MAB/Safe‑MABでも同じIF）。
* **MUST**：`Pout(τ)`は**制約**（L3以降）。違反率の**上限 θ**は**構成情報**として常に明示。
* **MUST**：**Decision Rationale**を**毎切替**で1行出す（理由コード、CCS、ガードの満足可否）。
* **SHOULD**：受信側の**モード/端末挙動**を**先験**として方策に反映（L4以降）。
* **SHOULD**：**イベント電荷辞書**（arm→µC）を**報酬正規化**に使う（学習安定化）。
* **SHOULD**：**フェイルセーフ**（短間隔×3ch）をいつでも呼べる。

### 6.2 推論の取り扱い

* **MUST**：U,Sは**[0,1]正規化**。**CCS**は**0.6/0.4**をデフォルト（変更時はロギング）。
* **SHOULD**：**温度スケーリング**等でUを較正（過信抑制）。
* **MAY**：早期Exitや推論スキップの導入（合算省エネのため）。

### 6.3 受信側の取り扱い

* **MUST**：**受信は非理想**。チャネル巡回・隙間・モード差が存在。
* **SHOULD**：**rx_channel同定**や**scan_mode**をログ化（L2以降）。
* **MAY**：バースト広告＋クールダウン（遷移の見逃し抑止）。

---

## 7) リスク & フェイルセーフ（体系）

| リスク           | 兆候         | フェイルセーフ     | 恒久対策                |
| ------------- | ---------- | ----------- | ------------------- |
| QoS違反（Pout上昇） | TL分布が右シフト  | 短間隔×3ch     | Safe‑MABの制約強化、先験ルール |
| 受信端末差         | PDR低下・端末依存 | 端末切替/再起動    | 端末別事前重み             |
| 切替振動          | 切替頻発ログ     | ヒステリシス/滞在時間 | U/S較正、窓W調整          |
| 学習初期の後悔       | 違反スパイク     | Warm‑Start  | 知識蒸留（禁止腕/初期重み）      |

---

## 8) ロードマップ（Vision → 実装への橋）

* **Phase‑1（L1）**：**写像の価値をKPIで証明**（µC↓、QoS＝基準）。**ログ様式・KPIパイプライン**を固定。
* **Phase‑2（L2）**：**MAB導入**。写像を**初期方策**に採用。**端末挙動の可視化**（rx_channel同定）。
* **Phase‑3（L3）**：**Safe‑MAB**で**Pout(τ) ≤ θ を保証**。**安全側フェイルセーフ**を規範化。
* **Phase‑4（L4）**：**先験（受信側挙動）＋アプリ緊急度**の注入。学習初期の**最悪遅延**を抑制。
* **Phase‑5（L5）**：**知識蒸留（Warm‑Start/禁止腕）**で**TTV短縮**。**大規模複数現場**へ展開。
* **製品化要件**：**MCU実装サイズ/レイテンシ**の提示、**デバイス差異**の先験、**再現パッケージ**（ログ・KPI・Runbook）。

---

## 9) 研究成果の位置づけ（論点の“芯”）

* **通信×推論×安全制約の三層協調**で、**端末内だけ**で**QoS保証**と**電力最小化**を両立。
* **受信側非理想性の知識化**（先験）と**制約最適化**の橋渡し。
* **標準化できるKPI**（µC/イベント、Pout(τ)、TL p95）と**監査可能ログ**で、**再現性**を担保。
* **TinyML実装**を前提とした**現実解**（INT8、RAM/Flash制約内）。

---

## 10) 参考リソース（本ビジョンを支える“根拠集”）

* **プロジェクト資料**：中間発表スライド（不確実度→広告間隔の写像、実測KPI、想定シナリオ）

  * [/mnt/data/中間発表資料_萩原.pdf](/mnt/data/中間発表資料_萩原.pdf)
* **TinyML（実装可能性・スタック）**：総合サーベイ／PdM向けホリスティックレビュー

  * [/mnt/data/A_Comprehensive_Survey_on_TinyML.pdf](/mnt/data/A_Comprehensive_Survey_on_TinyML.pdf)
  * [/mnt/data/A_Holistic_Review_of_the_TinyML_Stack_for_Predictive_Maintenance.pdf](/mnt/data/A_Holistic_Review_of_the_TinyML_Stack_for_Predictive_Maintenance.pdf)
* **BLE受信の非理想性・スキャン挙動**（実機観測・モデル化の背景）

  * [/mnt/data/3661820.pdf](/mnt/data/3661820.pdf)
* **量子化モデルのMCU実装例（RAM/Flash/レイテンシの目安）**

  * [/mnt/data/s41598-025-98571-2.pdf](/mnt/data/s41598-025-98571-2.pdf)
* **HAR省電力・システム最適化の俯瞰**

  * [/mnt/data/1-s2.0-S1574119224001019-main.pdf](/mnt/data/1-s2.0-S1574119224001019-main.pdf)

> これらのリソースは**世界観の“証拠”**としての役割（AIが根拠をたどれる）を持ちます。必要に応じてPhase別に参照箇所を特定し、KPI式・しきい値・境界条件を抽出します。

---

## 11) 要約（AIが誤読しないための短文仕様）

* **Goal**：**Pout(τ)を守りながら**、**µC/event**と**平均電流**を最小化（**端末内完結**）。
* **Signals**：`U∈[0,1]`, `S∈[0,1]`, `CCS=0.6U+0.4(1−S)`。
* **Policy IF**（不変）：`context(U,S,CCS) → interval`（将来MAB/Safe‑MABでも同じ）。
* **KPI**（一次）：`event_charge_uC`, `Pout(τ)`, `TL_p95`。
* **Safety**：`Pout(τ) ≤ θ` を**制約**として常時満たす（L3以降）。
* **Fallback**：いつでも `interval=短/3ch` に退避可。
* **Logs**：**Decision Rationale**を**毎切替**で出力（根拠・閾値・適用成否）。
* **Growth**：L1→L2（学習）→L3（制約）→L4（先験）→L5（知識蒸留）。

---

この **Vision / World Model** を採用すると、**人（現場）にやさしい“端末内AI”**が**段階的に強く**なり、**再現性・可監査性・安全性**を前提に**実装現場へ届く**プロダクトへと育っていきます。
次のステップとして、上記の“**Maturity Level**”を見出しにした**社内標準仕様（Spec 0.x）**と**図表テンプレ**を固めれば、他AI/他チームが**同じ世界観を共有**して**自走**できます。
</file>

</files>
