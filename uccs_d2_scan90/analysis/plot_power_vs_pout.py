#!/usr/bin/env python3
"""
Plot D2/D2b tradeoff: avg_power_mW vs pout_1s with share100 annotation.

Input: summary_by_condition.csv generated by summarize_d2_run.py
Output: PNG/PDF figure for paper-ready quick inspection.
"""

from __future__ import annotations

import argparse
import csv
import os
from pathlib import Path
from typing import Dict, Optional, Tuple


def f_or_none(v: str) -> Optional[float]:
    v = (v or "").strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary_by_condition(path: Path) -> Dict[str, Dict[str, Optional[float]]]:
    out: Dict[str, Dict[str, Optional[float]]] = {}
    with path.open(newline="") as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            cond = (row.get("condition") or "").strip()
            if not cond:
                continue
            out[cond] = {
                "pout_1s_mean": f_or_none(row.get("pout_1s_mean") or ""),
                "pout_1s_std": f_or_none(row.get("pout_1s_std") or ""),
                "avg_power_mW_mean": f_or_none(row.get("avg_power_mW_mean") or ""),
                "avg_power_mW_std": f_or_none(row.get("avg_power_mW_std") or ""),
                "adv_count_mean": f_or_none(row.get("adv_count_mean") or ""),
                "rx_share100_mean": f_or_none(row.get("rx_tag_share100_time_est_mean") or ""),
            }
    return out


def mean_of_present(xs: list[Optional[float]]) -> Optional[float]:
    ys = [x for x in xs if x is not None]
    if not ys:
        return None
    return sum(ys) / len(ys)


def compute_share100_from_adv(
    adv_count_policy: Optional[float],
    adv_count_fixed100: Optional[float],
    adv_count_fixed500: Optional[float],
) -> Optional[float]:
    if (
        adv_count_policy is None
        or adv_count_fixed100 is None
        or adv_count_fixed500 is None
        or adv_count_fixed100 <= adv_count_fixed500
    ):
        return None
    return (adv_count_policy - adv_count_fixed500) / (adv_count_fixed100 - adv_count_fixed500)


def get_point(
    rows: Dict[str, Dict[str, Optional[float]]],
    key: str,
) -> Tuple[float, float, float, float, Optional[float], Optional[float]]:
    r = rows.get(key, {})
    x = r.get("avg_power_mW_mean")
    y = r.get("pout_1s_mean")
    if x is None or y is None:
        raise SystemExit(f"missing required metrics for {key} in summary csv")
    xerr = r.get("avg_power_mW_std") or 0.0
    yerr = r.get("pout_1s_std") or 0.0
    adv = r.get("adv_count_mean")
    rx_share = r.get("rx_share100_mean")
    return float(x), float(y), float(xerr), float(yerr), adv, rx_share


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--summary-csv", type=Path, required=True, help="metrics/*/summary_by_condition.csv")
    ap.add_argument("--out", type=Path, required=True, help="output png path")
    ap.add_argument("--title", type=str, default="", help="optional title")
    args = ap.parse_args()

    # Matplotlib cache/rc write avoidance (for restricted environments).
    repo_root = Path.cwd()
    xdg_cache = repo_root / ".cache"
    xdg_cache.mkdir(exist_ok=True)
    os.environ.setdefault("XDG_CACHE_HOME", str(xdg_cache))
    mpl_dir = repo_root / ".mplconfig"
    mpl_dir.mkdir(exist_ok=True)
    os.environ.setdefault("MPLCONFIGDIR", str(mpl_dir))

    import matplotlib

    matplotlib.use("Agg")
    import matplotlib.pyplot as plt  # type: ignore

    rows = read_summary_by_condition(args.summary_csv)

    # Reference adv_count points (same for S1/S4 in this experiment).
    adv_fixed100 = mean_of_present(
        [
            rows.get("S1_fixed100", {}).get("adv_count_mean"),
            rows.get("S4_fixed100", {}).get("adv_count_mean"),
        ]
    )
    adv_fixed500 = mean_of_present(
        [
            rows.get("S1_fixed500", {}).get("adv_count_mean"),
            rows.get("S4_fixed500", {}).get("adv_count_mean"),
        ]
    )

    fig, ax = plt.subplots(figsize=(7.0, 4.8))

    def plot_group(session: str, color: str) -> None:
        fx100 = f"{session}_fixed100"
        fx500 = f"{session}_fixed500"
        pol = f"{session}_policy"

        x1, y1, x1e, y1e, _, _ = get_point(rows, fx100)
        x5, y5, x5e, y5e, _, _ = get_point(rows, fx500)
        xp, yp, xpe, ype, advp, rx_share = get_point(rows, pol)

        ax.errorbar(
            [x1, x5],
            [y1, y5],
            xerr=[x1e, x5e],
            yerr=[y1e, y5e],
            fmt="s",
            ms=7,
            color=color,
            capsize=3,
            linestyle="none",
            label=f"{session} fixed",
        )
        ax.errorbar(
            [xp],
            [yp],
            xerr=[xpe],
            yerr=[ype],
            fmt="o",
            ms=8,
            color=color,
            capsize=3,
            linestyle="none",
            label=f"{session} policy",
        )

        # Share annotation: prefer TXSD-derived share (adv_count), fall back to RX-tag estimate.
        share_tx = compute_share100_from_adv(advp, adv_fixed100, adv_fixed500)
        share = share_tx if share_tx is not None else rx_share
        if share is not None:
            ax.annotate(
                f"share100â‰ˆ{share:.2f}",
                (xp, yp),
                textcoords="offset points",
                xytext=(8, 8),
                ha="left",
                fontsize=10,
                color=color,
            )

        # Minimal labels for fixed points.
        ax.annotate("100", (x1, y1), textcoords="offset points", xytext=(6, -12), fontsize=9, color=color)
        ax.annotate("500", (x5, y5), textcoords="offset points", xytext=(6, -12), fontsize=9, color=color)

    plot_group("S1", color="#1f77b4")
    plot_group("S4", color="#ff7f0e")

    ax.set_xlabel("avg_power_mW (TXSD)")
    ax.set_ylabel("pout_1s")
    ax.grid(True, alpha=0.3)

    title = args.title.strip()
    if not title:
        title = f"{args.summary_csv.parent.name}: avg_power vs pout_1s (D2/D2b)"
    ax.set_title(title)

    handles, labels = ax.get_legend_handles_labels()
    # de-dup labels while preserving order
    seen = set()
    h2 = []
    l2 = []
    for h, l in zip(handles, labels):
        if l in seen:
            continue
        seen.add(l)
        h2.append(h)
        l2.append(l)
    ax.legend(h2, l2, loc="best", frameon=True, fontsize=9)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    if args.out.suffix.lower() == ".png":
        pdf_out = args.out.with_suffix(".pdf")
        fig.savefig(pdf_out)


if __name__ == "__main__":
    main()
