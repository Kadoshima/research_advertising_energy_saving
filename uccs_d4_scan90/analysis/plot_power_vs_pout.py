#!/usr/bin/env python3
"""
Plot Step D4 (U ablation) tradeoff: avg_power_mW vs pout_1s with share100 annotation.

Input: summary_by_condition.csv generated by summarize_d4_run.py
Output: PNG/PDF figure for quick paper-ready inspection.
"""

from __future__ import annotations

import argparse
import csv
import math
import os
from pathlib import Path
from typing import Dict, Optional, Tuple


def f_or_none(v: str) -> Optional[float]:
    v = (v or "").strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary_by_condition(path: Path) -> Dict[str, Dict[str, Optional[float]]]:
    out: Dict[str, Dict[str, Optional[float]]] = {}
    with path.open(newline="") as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            cond = (row.get("condition") or "").strip()
            if not cond:
                continue
            out[cond] = {
                "pout_1s_mean": f_or_none(row.get("pout_1s_mean") or ""),
                "pout_1s_std": f_or_none(row.get("pout_1s_std") or ""),
                "avg_power_mW_mean": f_or_none(row.get("avg_power_mW_mean") or ""),
                "avg_power_mW_std": f_or_none(row.get("avg_power_mW_std") or ""),
                "adv_count_mean": f_or_none(row.get("adv_count_mean") or ""),
                "rx_share100_mean": f_or_none(row.get("rx_tag_share100_time_est_mean") or ""),
            }
    return out


def compute_share100_from_adv(
    adv_count_policy: Optional[float],
    adv_count_fixed100: Optional[float],
    adv_count_fixed500: Optional[float],
) -> Optional[float]:
    if (
        adv_count_policy is None
        or adv_count_fixed100 is None
        or adv_count_fixed500 is None
        or adv_count_fixed100 <= adv_count_fixed500
    ):
        return None
    return (adv_count_policy - adv_count_fixed500) / (adv_count_fixed100 - adv_count_fixed500)


def get_point(
    rows: Dict[str, Dict[str, Optional[float]]],
    key: str,
) -> Tuple[float, float, float, float, Optional[float], Optional[float]]:
    r = rows.get(key, {})
    x = r.get("avg_power_mW_mean")
    y = r.get("pout_1s_mean")
    if x is None or y is None:
        raise SystemExit(f"missing required metrics for {key} in summary csv")
    xerr = r.get("avg_power_mW_std") or 0.0
    yerr = r.get("pout_1s_std") or 0.0
    adv = r.get("adv_count_mean")
    rx_share = r.get("rx_share100_mean")
    return float(x), float(y), float(xerr), float(yerr), adv, rx_share


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--summary-csv", type=Path, required=True, help="metrics/*/summary_by_condition.csv")
    ap.add_argument("--out", type=Path, required=True, help="output png path")
    ap.add_argument("--title", type=str, default="", help="optional title")
    args = ap.parse_args()

    # Matplotlib cache/rc write avoidance.
    repo_root = Path.cwd()
    xdg_cache = repo_root / ".cache"
    xdg_cache.mkdir(exist_ok=True)
    os.environ.setdefault("XDG_CACHE_HOME", str(xdg_cache))
    mpl_dir = repo_root / ".mplconfig"
    mpl_dir.mkdir(exist_ok=True)
    os.environ.setdefault("MPLCONFIGDIR", str(mpl_dir))

    import matplotlib

    matplotlib.use("Agg")
    import matplotlib.pyplot as plt  # type: ignore

    rows = read_summary_by_condition(args.summary_csv)

    # Required keys (S4 only).
    k100 = "S4_fixed100"
    k500 = "S4_fixed500"
    kpol = "S4_policy"
    kabl = "S4_ablation_u_shuf"

    x100, y100, x100e, y100e, adv100, _ = get_point(rows, k100)
    x500, y500, x500e, y500e, adv500, _ = get_point(rows, k500)
    xpol, ypol, xpole, ypole, advpol, rx_share_pol = get_point(rows, kpol)
    xabl, yabl, xable, yable, advabl, rx_share_abl = get_point(rows, kabl)

    fig, ax = plt.subplots(figsize=(7.0, 4.6))

    # fixed
    ax.errorbar(
        [x100, x500],
        [y100, y500],
        xerr=[x100e, x500e],
        yerr=[y100e, y500e],
        fmt="s",
        ms=7,
        color="#1f77b4",
        capsize=3,
        linestyle="none",
        label="fixed",
    )

    # policy
    ax.errorbar(
        [xpol],
        [ypol],
        xerr=[xpole],
        yerr=[ypole],
        fmt="o",
        ms=8,
        color="#ff7f0e",
        capsize=3,
        linestyle="none",
        label="policy (U+CCS)",
    )

    # ablation
    ax.errorbar(
        [xabl],
        [yabl],
        xerr=[xable],
        yerr=[yable],
        fmt="^",
        ms=8,
        color="#2ca02c",
        capsize=3,
        linestyle="none",
        label="ablation (U-shuffle)",
    )

    def annotate_share(x: float, y: float, adv: Optional[float], rx_share: Optional[float], color: str) -> None:
        share_tx = compute_share100_from_adv(adv, adv100, adv500)
        share = share_tx if share_tx is not None else rx_share
        if share is None:
            return
        ax.annotate(
            f"share100â‰ˆ{share:.2f}",
            (x, y),
            textcoords="offset points",
            xytext=(8, 8),
            ha="left",
            fontsize=10,
            color=color,
        )

    annotate_share(xpol, ypol, advpol, rx_share_pol, "#ff7f0e")
    annotate_share(xabl, yabl, advabl, rx_share_abl, "#2ca02c")

    ax.annotate("100", (x100, y100), textcoords="offset points", xytext=(6, -12), fontsize=9, color="#1f77b4")
    ax.annotate("500", (x500, y500), textcoords="offset points", xytext=(6, -12), fontsize=9, color="#1f77b4")

    # Fix axis bounds/ticks so plot edges align with ticks (A4-friendly).
    xs = [x100, x500, xpol, xabl]
    ys = [y100, y500, ypol, yabl]
    xerrs = [x100e, x500e, xpole, xable]
    yerrs = [y100e, y500e, ypole, yable]
    x_min = min(x - xe for x, xe in zip(xs, xerrs))
    x_max = max(x + xe for x, xe in zip(xs, xerrs))
    y_max = max(y + ye for y, ye in zip(ys, yerrs))
    x_step = 5.0
    y_step = 0.05
    xmin = math.floor((x_min - 0.5) / x_step) * x_step
    xmax = math.ceil((x_max + 0.5) / x_step) * x_step
    ymax = math.ceil((y_max + 0.005) / y_step) * y_step
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(0.0, ymax)
    ax.set_xticks([xmin + i * x_step for i in range(int(round((xmax - xmin) / x_step)) + 1)])
    ax.set_yticks([i * y_step for i in range(int(round(ymax / y_step)) + 1)])
    ax.margins(x=0.0, y=0.0)

    ax.set_xlabel("avg_power_mW (TXSD)")
    ax.set_ylabel("pout_1s")
    ax.set_axisbelow(True)
    ax.grid(True, alpha=0.3)

    title = args.title.strip()
    if not title:
        title = f"{args.summary_csv.parent.name}: avg_power vs pout_1s (D4 ablation, S4)"
    ax.set_title(title)
    ax.legend(loc="upper right", frameon=True, fontsize=9)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    if args.out.suffix.lower() == ".png":
        fig.savefig(args.out.with_suffix(".pdf"))


if __name__ == "__main__":
    main()
