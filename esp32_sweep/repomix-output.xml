This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
RX_BLE_to_SD_SYNC_B.ino
TX_BLE_Adv_Meter_ON_sweep.ino
TXSD_PowerLogger_PASS_THRU_ON_v2.ino
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="RX_BLE_to_SD_SYNC_B.ino">
// === RX_BLE_to_SD_SYNC_B.ino ===
// Board: ESP32 Dev Module (Arduino-ESP32 v3.x)
//
// 機能：パッシブスキャンでTXのMFD("MFxxxx")を受信 → SDへ記録。
//       SYNC(26)で試行ファイルを開始/終了。
// 配線：SYNC_IN=26 ← ①の SYNC_OUT=25
//      SD: CS=5, SCK=18, MISO=19, MOSI=23
//
// 出力：/logs/rx_trial_XXX.csv
//   ms,event,rssi,addr,mfd

#include <Arduino.h>
#include <SPI.h>
#include <SD.h>

#ifndef __has_include
  #define __has_include(x) 0
#endif
#if __has_include(<NimBLEDevice.h>)
  #include <NimBLEDevice.h>
  #define USE_NIMBLE 1
#else
  #include <BLEDevice.h>
  #include <BLEUtils.h>
  #include <BLEScan.h>
  #define USE_NIMBLE 0
#endif

static const int SD_CS                = 5;
static const int SYNC_IN              = 26;
static const uint16_t ADV_INTERVAL_MS = 100;
static const uint32_t TRIAL_MS        = 60000; // 旧固定窓（互換性のため残置・通常はSYNCで区切る）

#ifndef SCAN_MS
  #define SCAN_MS 50
#endif

volatile bool syncLvl=false, syncEdge=false;
File f;
static const char FW_TAG[] = "RX_BLE_to_SD_SYNC_B";
static uint32_t trialIndex = 0;

static inline int nib(char c){
  if(c>='0'&&c<='9')return c-'0';
  if(c>='A'&&c<='F')return c-'A'+10;
  if(c>='a'&&c<='f')return c-'a'+10;
  return -1;
}
static bool parseMFD(const String&s, uint16_t& seq){
  if (s.length()<6) return false;
  if (!(s[0]=='M'&&s[1]=='F')) return false;
  int n0=nib(s[2]),n1=nib(s[3]),n2=nib(s[4]),n3=nib(s[5]);
  if (n0<0||n1<0||n2<0||n3<0) return false;
  seq=(uint16_t)((n0<<12)|(n1<<8)|(n2<<4)|n3);
  return true;
}

String txLock="";             // 最初に見えた送信機にロック
uint32_t t0Ms=0; bool trial=false;
uint32_t rxCount=0;

void IRAM_ATTR onSync(){
  bool s=digitalRead(SYNC_IN);
  if (s!=syncLvl){ syncLvl=s; syncEdge=true; }
}

String nextPath(){
  SD.mkdir("/logs");
  char p[64];
  for(uint32_t id=1;;++id){
    snprintf(p,sizeof(p),"/logs/rx_trial_%03lu.csv",(unsigned long)id);
    if(!SD.exists(p)) return String(p);
  }
}

void startTrial(){
  String path=nextPath();
  f=SD.open(path, FILE_WRITE);
  if (f){
    f.println("ms,event,rssi,addr,mfd");
    trialIndex++;
    f.printf("# meta, firmware=%s, trial_index=%lu\r\n", FW_TAG, (unsigned long)trialIndex);
  }
  t0Ms=millis(); trial=true; txLock=""; rxCount=0;
  Serial.printf("[RX] start %s (trial=%lu)\n", path.c_str(), (unsigned long)trialIndex);
}

void endTrial(){
  if (trial){
    trial=false;
    if (f){ f.flush(); f.close(); }
    uint32_t t_ms = millis() - t0Ms;
    double dur_s = t_ms / 1000.0;
    double rate_hz = (dur_s>0.0)? ((double)rxCount / dur_s) : 0.0;
    double expected = (double)t_ms / (double)ADV_INTERVAL_MS;
    double pdr = (expected>0.0)? ((double)rxCount / expected) : 0.0;
    Serial.printf("[RX] summary trial=%lu ms_total=%lu, rx=%lu, rate_hz=%.2f, est_pdr=%.3f\n",
                  (unsigned long)trialIndex,
                  (unsigned long)t_ms, (unsigned long)rxCount, rate_hz, pdr);
    Serial.println("[RX] end");
  }
}

#if USE_NIMBLE
NimBLEScan* gScan=nullptr;
class CB: public NimBLEAdvertisedDeviceCallbacks{
  void onResult(NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    String mfd = String(d->getManufacturerData().c_str());
    uint16_t seq=0; if(!parseMFD(mfd,seq)) return;
    String addr = String(d->getAddress().toString().c_str());
    if (txLock.length()==0) txLock = addr;
    if (addr != txLock) return;

    uint32_t ms = millis() - t0Ms;
    if (f){
      f.printf("%lu,ADV,%d,%s,%s\r\n",
               (unsigned long)ms, d->getRSSI(), addr.c_str(), mfd.c_str());
      rxCount++;
    }
  }
};
CB cb;
#else
BLEScan* gScan=nullptr;
class CB: public BLEAdvertisedDeviceCallbacks{
  void onResult(BLEAdvertisedDevice d) override {
    if (!trial) return;
    String mfd = String(d.getManufacturerData().c_str());
    uint16_t seq=0; if(!parseMFD(mfd,seq)) return;
    String addr = String(d.getAddress().toString().c_str());
    if (txLock.length()==0) txLock = addr;
    if (addr != txLock) return;

    uint32_t ms = millis() - t0Ms;
    if (f){
      f.printf("%lu,ADV,%d,%s,%s\r\n",
               (unsigned long)ms, d.getRSSI(), addr.c_str(), mfd.c_str());
      rxCount++;
    }
  }
};
CB cb;
#endif

void setup(){
  Serial.begin(115200);

  // SD
  SPI.begin(18,19,23,SD_CS);
  if(!SD.begin(SD_CS)){ Serial.println("[SD] init FAIL"); while(1) delay(1000); }

  // SYNC
  pinMode(SYNC_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(SYNC_IN), onSync, CHANGE);
  syncLvl=digitalRead(SYNC_IN);
  if (syncLvl) startTrial();

  // BLE passive scan (rho=1)
#if USE_NIMBLE
  NimBLEDevice::init("RX_ESP32");
  gScan = NimBLEDevice::getScan();
  gScan->setActiveScan(false);
  gScan->setInterval(SCAN_MS);
  gScan->setWindow(SCAN_MS);
  gScan->setAdvertisedDeviceCallbacks(&cb);
  gScan->start(0, false);
#else
  BLEDevice::init("RX_ESP32");
  gScan = BLEDevice::getScan();
  gScan->setActiveScan(false);
  gScan->setInterval(SCAN_MS);
  gScan->setWindow(SCAN_MS);
  gScan->setAdvertisedDeviceCallbacks(&cb, true);
  gScan->start(0, nullptr, false);
#endif
  Serial.println("[RX] ready");
}

void loop(){
  if (syncEdge){
    noInterrupts(); bool s=syncLvl; syncEdge=false; interrupts();
    if (s && !trial) {
      startTrial();
    } else if (!s && trial) {
      endTrial();
    }
  }
}
</file>

<file path="TX_BLE_Adv_Meter_ON_sweep.ino">
// === TX_BLE_Adv_Meter_ON_sweep.ino ===
// Board: ESP32 Dev Module (Arduino-ESP32 v3.x)
//
// 役割：
//   - BLEアドバタイズを一定間隔（ADV_INTERVAL_MS）で送出（100〜2000 msなど）。
//   - 各トライアルごとに SYNC_OUT を start/high → end/low で出力し、
//     PowerLogger / RX ロガの区切りに使えるようにする。
//   - 各トライアルで N_ADV_PER_TRIAL 回の広告を送ったら終了し、
//     GAP_BETWEEN_TRIALS_MS 待機して次のトライアルを自動実行。
//   - UART1 からは INA219 の整数CSV（mv,uA）を 10ms周期で出力。
//   - Serial にラベル（TX_group_trial）とトライアル開始/終了をログする。
//
// 想定運用：
//   - ADV_INTERVAL_MS を 100, 500, 1000, 2000 ms などに変更してビルド。
//   - RUN_GROUP_ID に条件ID（例: 1=100ms, 2=500ms ...）を設定。
//   - N_ADV_PER_TRIAL=300, N_TRIALS=2 などに設定して、1回セットしたら放置で計測。
//

#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_INA219.h>
#include <BLEDevice.h>

// ===== ユーザ設定 =====
static const uint16_t ADV_INTERVAL_MS   = 100;    // 100 / 500 / 1000 / 2000 などに変更
static const uint32_t SAMPLE_US         = 10000;  // 計測周期 10ms ≒ 100Hz（固定）
static const uint16_t N_ADV_PER_TRIAL   = 300;    // 1トライアルあたりの広告回数
static const uint8_t  N_TRIALS          = 10;      // トライアル回数
static const uint32_t GAP_BETWEEN_TRIALS_MS = 5000; // トライアル間の待機時間
static const uint8_t  RUN_GROUP_ID      = 1;      // 条件ID（例: 1=100ms, 2=500ms ...）

static const bool     USE_TICK_OUT      = true;
static const esp_power_level_t TX_PWR   = ESP_PWR_LVL_N0; // 0 dBm

// ピンアサイン
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN      = 2;
static const int I2C_SDA      = 21;
static const int I2C_SCL      = 22;
static const int UART_TX      = 4;
static const long UART_BAUD   = 230400;

// シャント値（ミリオーム）
#define RSHUNT_MILLIOHM  100   // 実装が 0.1Ω=100 mΩ の場合

HardwareSerial uart1(1);
Adafruit_INA219 ina;
BLEAdvertising* adv = nullptr;

uint16_t seq  = 0;
uint8_t  hold0 = 8;   // SYNC直後は "MF0000" を数フレーム維持

// ランタイム状態
static uint32_t nextSampleUs = 0;
static uint32_t nextAdvMs    = 0;
static uint8_t  trialIndex   = 0;   // 0〜N_TRIALS-1
static bool     trialRunning = false;
static uint16_t advCountInTrial = 0;
static uint32_t trialEndMs   = 0;

static inline String makeMFD(uint16_t s){
  char b[7];
  snprintf(b, sizeof(b), "MF%04X", (unsigned)s);
  return String(b);
}

static void syncStart(){
  digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
}

static void syncEnd(){
  digitalWrite(SYNC_OUT_PIN, LOW);
  digitalWrite(LED_PIN, LOW);
}

static void startTrial(){
  advCountInTrial = 0;
  seq = 0;
  hold0 = 8;
  trialRunning = true;

  uint32_t nowMs = millis();
  nextSampleUs = micros() + SAMPLE_US;
  nextAdvMs    = nowMs + ADV_INTERVAL_MS;

  syncStart();
  Serial.printf("[TX] start trial group=%u, idx=%u, adv_interval_ms=%u\n",
                (unsigned)RUN_GROUP_ID,
                (unsigned)(trialIndex + 1),
                (unsigned)ADV_INTERVAL_MS);
}

static void endTrial(){
  trialRunning = false;
  trialEndMs = millis();
  syncEnd();
  Serial.printf("[TX] end trial group=%u, idx=%u, adv_sent=%u, dur_ms=%lu\n",
                (unsigned)RUN_GROUP_ID,
                (unsigned)(trialIndex + 1),
                (unsigned)advCountInTrial,
                (unsigned long)(trialEndMs)); // 相対時間はログ側で計算
}

void setup(){
  Serial.begin(115200);

  // GPIO
  pinMode(LED_PIN, OUTPUT);       digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_TICK_OUT){
    pinMode(TICK_OUT_PIN, OUTPUT);
    digitalWrite(TICK_OUT_PIN, LOW);
  }

  // BLE
  BLEDevice::init("TXM_ESP32");
  BLEDevice::setPower(TX_PWR);
  BLEAdvertising* a = BLEDevice::getAdvertising();
  a->setScanResponse(false);
  a->setMinPreferred(0);
  uint16_t itv = (uint16_t)(ADV_INTERVAL_MS / 0.625f);
  a->setMinInterval(itv);
  a->setMaxInterval(itv);
  BLEAdvertisementData ad;
  ad.setName("TXM_ESP32");
  ad.setManufacturerData(makeMFD(0));
  a->setAdvertisementData(ad);
  a->start();
  adv = a;

  // INA219
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);               // I2C 400kHz
  ina.begin();
  ina.setCalibration_16V_400mA();      // 代表レンジ（0.1Ω想定）

  // UART1（PowerLogger行き）
  uart1.begin(UART_BAUD, SERIAL_8N1, -1, UART_TX);

  // 起動2秒後に最初のトライアル開始
  delay(2000);
  trialIndex = 0;
  startTrial();
}

void loop(){
  uint32_t nowUs = micros();
  uint32_t nowMs = millis();

  if (trialRunning){
    // ---- 10ms周期で INA219 サンプリング ----
    int guard = 0;
    while ((int32_t)(nowUs - nextSampleUs) >= 0 && guard < 8){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();

      int32_t mv = (int32_t)lroundf(v * 1000.0f);
      int32_t uA = (int32_t)lroundf(i * 1000.0f);
      uart1.printf("%ld,%ld\n", (long)mv, (long)uA);

      guard++;
      nowUs = micros();
    }

    // ---- adv_interval ごとのアドバタイズ更新 ----
    if ((int32_t)(nowMs - nextAdvMs) >= 0){
      nextAdvMs += ADV_INTERVAL_MS;
      uint16_t sendSeq = (hold0>0)? 0 : seq;

      BLEAdvertisementData ad;
      ad.setName("TXM_ESP32");
      ad.setManufacturerData(makeMFD(sendSeq));
      adv->setAdvertisementData(ad);

      if (hold0>0) --hold0;
      else         ++seq;

      if (USE_TICK_OUT){
        digitalWrite(TICK_OUT_PIN, HIGH);
        delayMicroseconds(200);
        digitalWrite(TICK_OUT_PIN, LOW);
      }

      advCountInTrial++;
      if (advCountInTrial >= N_ADV_PER_TRIAL){
        endTrial();
      }
    }
  } else {
    // トライアル間の待機 / 次トライアル開始
    if (trialIndex + 1 < N_TRIALS){
      if (nowMs - trialEndMs >= GAP_BETWEEN_TRIALS_MS){
        trialIndex++;
        startTrial();
      }
    } else {
      // 全トライアル終了後はアイドル（BLE広告はそのまま or 停止してもよい）
      vTaskDelay(10);
    }
  }

  // 他タスクに譲る
  vTaskDelay(1);
}
</file>

<file path="TXSD_PowerLogger_PASS_THRU_ON_v2.ino">
// === TXSD_PowerLogger_PASS_THRU_ON_v2.ino ===
// Board: ESP32 Dev Module (Arduino-ESP32 v3.x)
//
// 役割：TX(②)からの UART を「パススルー＋軽量集計」で SD に保存。
//       SYNCで試行開始/終了。TICKで adv_count を厳密カウント。
//       CSV行は「ms,mv,uA[,p_mW]」形式（整数主体）。末尾に #summary/#diag/#sys を付与。
// ねらい：受信/パース/SD書込みの負荷を最小化し、実効レートと再現性（±5%）を担保。
// 配線：UART RX=34 ← ② TX=4（クロス）
//      SYNC_IN=26 ← ② SYNC_OUT=25
//      TICK_IN=33 ← ② TICK_OUT=27（推奨）
//      SD: CS=5, SCK=18, MISO=19, MOSI=23

#include <Arduino.h>
#include <SPI.h>
#include <SD.h>
#include <WiFi.h>

HardwareSerial uart1(1);

// ---- ピン／定数 ----
static const int RX_PIN   = 34;
static const int SD_CS    = 5;
static const int SYNC_IN  = 26;
static const int TICK_IN  = 33;

// 出力フォーマット：整数CSV（ms,mv,uA[,p_mW]）
#define CSV_APPEND_PM_W   1        // 1: p_mW列を付ける
#define USE_TICK_INPUT    1        // 1: TICKで厳密カウント（ON用）
#define ADV_INTERVAL_MS   100      // 推定用（TICK未配線時のフォールバック計算に使用しうる）
#define SD_CHUNK_BYTES    16384    // SD書込みチャンク（大きいほど良い）
#define UART_RXBUF_BYTES  16384    // UART受信バッファ拡張
#define LINE_MAX_BYTES    64       // "mv,uA" 1行の最大想定

// ---- 変数 ----
File f;
volatile bool syncLvl=false, syncEdge=false;
volatile uint32_t advCountISR=0;

bool     logging=false;
uint32_t t0_ms=0, tPrev=0;
uint32_t lineN=0, badLines=0;

// 軽量集計（整数基準）
double   E_mJ=0.0;
uint32_t dtMin=0xFFFFFFFF, dtMax=0;
double   sumDt=0.0, sumDt2=0.0;  // ms
int64_t  sum_mv=0, sum_uA=0;
uint32_t sampN=0;
static   uint32_t trialIndex=0;

// SDバッファ（非同期っぽく塊で書く）
static uint8_t sdBuf[SD_CHUNK_BYTES];
static size_t  sdLen=0;

// 行バッファ（固定長）
static char    lineBuf[LINE_MAX_BYTES];
static size_t  lbLen=0;

static const char FW_TAG[] = "TXSD_PowerLogger_PASS_THRU_ON_v2";

static inline void sd_flush_chunk(){
  if (sdLen){ f.write(sdBuf, sdLen); sdLen=0; }
}
static inline void sd_puts(const char* s, size_t n){
  if (sdLen + n > SD_CHUNK_BYTES) sd_flush_chunk();
  memcpy(sdBuf + sdLen, s, n); sdLen += n;
}
static inline void sd_putc(char c){
  if (sdLen + 1 > SD_CHUNK_BYTES) sd_flush_chunk();
  sdBuf[sdLen++] = (uint8_t)c;
}

void IRAM_ATTR onSync(){
  bool s = digitalRead(SYNC_IN);
  if (s != syncLvl){ syncLvl=s; syncEdge=true; }
}
void IRAM_ATTR onTick(){ if (logging && USE_TICK_INPUT) advCountISR++; }

String nextPath(){
  SD.mkdir("/logs");
  char p[64];
  for (uint32_t id=1;;++id){
    snprintf(p,sizeof(p),"/logs/trial_%03lu_on.csv",(unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

void startTrial(){
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (!f){ Serial.println("[SD] open FAIL"); return; }

  // ヘッダ
#if CSV_APPEND_PM_W
  f.println("ms,mv,uA,p_mW");
#else
  f.println("ms,mv,uA");
#endif
  trialIndex++;
  f.printf("# meta, firmware=%s, trial_index=%lu\r\n", FW_TAG, (unsigned long)trialIndex);

  logging = true;
  t0_ms = millis(); tPrev = t0_ms; lineN = badLines = 0;
  E_mJ = 0.0; sampN=0; sum_mv=sum_uA=0;
  sumDt=sumDt2=0.0; dtMin=0xFFFFFFFF; dtMax=0;
  advCountISR = 0;

  // UARTバッファを空に
  while (uart1.available()) uart1.read();
  sdLen=0; lbLen=0;

  Serial.printf("[PWR] start %s (ON, trial=%lu)\n", path.c_str(), (unsigned long)trialIndex);
}
void endTrial(){
  if (!logging) return;
  logging = false;

  uint32_t t_ms = millis() - t0_ms;
  uint32_t Nadv = USE_TICK_INPUT ? advCountISR
                                 : (uint32_t)((t_ms / (double)ADV_INTERVAL_MS) + 0.5);
  double Eper_uJ = (Nadv>0) ? (E_mJ * 1000.0 / Nadv) : 0.0;

  // まとめ（#summary / #diag / #sys）
  sd_flush_chunk();
  f.printf("# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, E_per_adv_uJ=%.1f\r\n",
           (unsigned long)t_ms, (unsigned long)Nadv, E_mJ, Eper_uJ);

  double meanDt = (sampN>0)? (sumDt/sampN) : 0.0;
  double varDt  = (sampN>0)? (sumDt2/sampN) - meanDt*meanDt : 0.0;
  double stdDt  = (varDt>0)? sqrt(varDt) : 0.0;
  double rate_hz= (meanDt>0)? (1000.0/meanDt) : 0.0;
  double mean_mv= (sampN>0)? (double)sum_mv / (double)sampN : 0.0;
  double mean_uA= (sampN>0)? (double)sum_uA / (double)sampN : 0.0;
  double mean_mV= mean_mv;                     // 単位名だけ整える
  double mean_mA= mean_uA / 1000.0;
  double meanPmW= (mean_mV * mean_uA) / 1000.0;

  f.printf("# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f\r\n",
           (unsigned long)sampN, rate_hz, mean_mV/1000.0, mean_mA, meanPmW);
  f.printf("# diag, dt_ms_mean=%.3f, dt_ms_std=%.3f, dt_ms_min=%lu, dt_ms_max=%lu, parse_drop=%lu\r\n",
           meanDt, stdDt, (unsigned long)(dtMin==0xFFFFFFFF?0:dtMin), (unsigned long)dtMax, (unsigned long)badLines);
  f.printf("# sys, cpu_mhz=%d, wifi_mode=%s, free_heap=%lu\r\n",
           getCpuFrequencyMhz(), (WiFi.getMode()==WIFI_OFF?"OFF":"ON"), (unsigned long)ESP.getFreeHeap());

  f.flush(); f.close();
  Serial.printf("[PWR] end trial=%lu t=%lums N=%lu E=%.3fmJ (ON)\n",
                (unsigned long)trialIndex, (unsigned long)t_ms, (unsigned long)Nadv, E_mJ);
}

static inline bool parse_mvuA(const char* s, int32_t& mv, int32_t& uA){
  // 期待形式: "1234,567890"
  // 高速・健全系の簡易パーサ（負号なし前提）
  const char* p=s; long a=0,b=0;
  if(!*p) return false;
  while(*p>='0' && *p<='9'){ a = a*10 + (*p-'0'); ++p; }
  if(*p!=',') return false; ++p;
  if(!*p) return false;
  while(*p>='0' && *p<='9'){ b = b*10 + (*p-'0'); ++p; }
  mv=(int32_t)a; uA=(int32_t)b; return true;
}

void setup(){
  Serial.begin(115200);

  // SD
  SPI.begin(18,19,23,SD_CS);
  if (!SD.begin(SD_CS)){ Serial.println("[SD] init FAIL"); while(1) delay(1000); }

  // UART（受信専用）
  uart1.begin(230400, SERIAL_8N1, RX_PIN, -1);
  uart1.setRxBufferSize(UART_RXBUF_BYTES);

  // SYNC/TICK
  pinMode(SYNC_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(SYNC_IN), onSync, CHANGE);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTick, RISING);

  syncLvl = digitalRead(SYNC_IN);
  if (syncLvl) startTrial();
}

void loop(){
  // SYNC立上りで開始、SYNC下降で終了
  if (syncEdge){
    noInterrupts(); bool s=syncLvl; syncEdge=false; interrupts();
    if (s && !logging) {
      startTrial();
    } else if (!s && logging) {
      endTrial();
    }
  }

  // UART受信（パススルー＋軽量集計）
  while (uart1.available()){
    char c = (char)uart1.read();
    if (c == '\n'){
      if (logging && f){
        uint32_t tNow = millis();
        uint32_t dt   = tNow - tPrev; tPrev = tNow;
        if (lbLen>0 && lbLen<LINE_MAX_BYTES){
          // 解析：mv,uA を整数で取得
          int32_t mv=0, uA=0;
          if (parse_mvuA(lineBuf, mv, uA)){
            // 集計
            sampN++;
            sum_mv += mv; sum_uA += uA;
            sumDt += dt; sumDt2 += (double)dt * (double)dt;
            if (dt < dtMin) dtMin = dt;
            if (dt > dtMax) dtMax = dt;
            // エネルギー積分（p_mW = mv*uA/1000）
            double p_mW = ( (double)mv * (double)uA ) / 1000000.0;
            E_mJ += p_mW * (dt / 1000.0);

            // SDへ書き出し "ms,mv,uA[,p_mW]\r\n"
            char hdr[16];
            int hn = snprintf(hdr, sizeof(hdr), "%lu,", (unsigned long)(tNow - t0_ms));
            sd_puts(hdr, hn);
            sd_puts(lineBuf, lbLen);
#if CSV_APPEND_PM_W
            char tail[24];
            int tn = snprintf(tail, sizeof(tail), ",%.1f\r\n", p_mW);
            sd_puts(tail, tn);
#else
            sd_puts("\r\n", 2);
#endif
            lineN++;
          } else {
            badLines++;
          }
        } else {
          badLines++;
        }
      }
      lbLen=0;
    } else if (c != '\r'){
      if (lbLen < LINE_MAX_BYTES-1) lineBuf[lbLen++] = c;
      else badLines++; // オーバーラン
    }
  }

  // SDへ塊書き（受信が一段落したタイミングで）
  if (sdLen >= (SD_CHUNK_BYTES - 128)) sd_flush_chunk();

  // 他タスクに譲る（スリープ誘導）
  vTaskDelay(1);
}
</file>

</files>
