2025-12-14
- [00:17 JST] δ帯を「Fixed500が落ちる帯」に寄せたレター図を作成（解析のみ）: scan90 v5 + power table + context mixing の Pareto（v6）を入力に、δ={0.02,0.03,0.04} のtight帯で `pout_1s vs avg_power_mW` 図を生成。出力: `results/mhealth_policy_eval/letter_v2_scan90_v5_delta_tight/fig_delta_band.png` と選定点 `selected_policies.csv/json`（各δのpower-min点）。生成コマンドは同ディレクトリの `README.md` に記載。
- [00:17 JST] 図生成スクリプトを拡張: `scripts/plot_letter_delta_band.py` に `--select-deltas`/`--select-style` を追加し、δ帯が小さい場合でも図が見切れないよう y軸範囲を自動化（v1互換は維持）。
- [00:17 JST] TODO更新: レター関連の参照を scan90 v5 / Pareto v6 / letter_v2 に更新（`docs/TODO.md`）。
- [00:20 JST] δ tight の要点を1枚に固定: 固定点（Fixed100/500/1000/2000）と、各δのpower-min点（share100/adv_rate/switch_rate付き）を `results/mhealth_policy_eval/letter_v2_scan90_v5_delta_tight/summary.md` に整理。
- [00:22 JST] 地雷チェック（欠損確認）: scan90 v5 固定メトリクス表 `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_agg_enriched_scan90_v5.csv` に S1×{100,500,1000,2000} と S4×{100,500,1000,2000} が揃っていることを確認。δ tight の context mixing（stable→S1 / transition→S4）計算が「欠損で楽観側にズレる」懸念は scan90 v5 では無し。※ scan50 v5 で S1×100 が欠けて見えるのは session名にコメントが混ざっているため（旧/retakeの扱い）で、scan50を本流に使う場合は整理が必要。

- [04:52 JST] power table をrobust版（sleep_on, n=9–10）に差し替えて、Pareto/δ tight/比較表を再生成。
  - power table（主線）: `results/mhealth_policy_eval/power_table_sleep_eval_2025-12-14_interval_sweep_sleep_on_n9_10.csv`（生成元: `sleep_eval_scan90/metrics/on_off_test_100~2000_02/txsd_power_summary.csv`）
    - 100/500/1000/2000ms = 198.56/180.80/178.62/177.47 mW
  - Pareto v7: `results/mhealth_policy_eval/pareto_front_v7_power_table_scan90_v5_sleep_on_n9_10/pareto_sweep.csv`（δ={0.02,0.03,0.04}, context mixing + power最小化）
  - δ tight 図 v3: `results/mhealth_policy_eval/letter_v3_scan90_v5_delta_tight_sleep_on_n9_10/fig_delta_band.png`
    - δ=0.03（Fixed500の境界≈0.0322より厳しい帯）で power-min は avg_power≈195.09mW / pout_1s≈0.0297、Fixed100(198.56mW)より −3.47mW（≈−1.75%）
  - デフォルト方策評価を更新: `results/mhealth_policy_eval/policy_eval_default.json`（avg_power≈187.71mW）
  - 比較表を更新: `results/mhealth_policy_eval/policy_table.md`（avg_power列が新power table反映）

- [05:15 JST] 決定（主線）: v7（robust power table: sleep_on n=9–10）をレター主線として採用し、この条件で実機の動的切替（100↔500）へ進む方針を確定。
  - 採用理由: n=2のpower tableだと電力軸の揺れツッコミが入りやすい一方、sleep_on n=9–10で土台が固い（100→500の主効果 −17.76mW が明確、500→2000は −3.33mWと小さい）。
  - δ tight（v3）: δ=0.03帯（Fixed500が落ちる帯）で「固定100msより低電力でδ達成」が成立（−3.47mW）。
  - 次ステップ（最短ルート）:
    - D0: 実機が100↔500だけになる場合、オフライン側も行動空間を{100,500}に限定したスイープ/代表ポリシー選定を追加（比較の整合性を保つ目的）。
    - D1: 実機は最小セット（Fixed100 / Fixed500 / Policy）で成立確認。動的は同期破綻防止のため TX payload に `tx_elapsed_ms` or `step_idx`（＋`interval_ms_current`）を埋め込み、RX/TXSDと突合できる形にする。
  - 実機候補（現状のδ=0.03 power-min; v7）:
    - params=(u_mid=0.10,u_high=0.35,c_mid=0.15,c_high=0.35,hyst=0.08), share100=0.816, share500=0.121, share2000=0.063
    - 予測: avg_power≈195.09mW / pout_1s≈0.0297（scan90 v5 + context mixing + robust power table）

- [12:46 JST] TODO更新: `docs/TODO.md` を v7（robust power table）主線に合わせて更新。
  - TL;DRの参照先を v7/v3 に差し替え（旧v6/v2は主線から外す）
  - 新規TODO（P0-Letter）として D0（{100,500}限定の代表ポリシー再選定）/D1（実機100↔500最小セット）を追記

- [13:02 JST] D0完了: 実機行動空間を **{100,500}** に揃えた2値版の Pareto/δ tight を再生成し、実機用の代表ポリシーを確定。
  - スクリプト更新: `scripts/sweep_policy_pareto.py` に `--actions` を追加（allowed intervals のクランプ対応）。
  - Pareto v8（actions={100,500}）: `results/mhealth_policy_eval/pareto_front_v8_power_table_scan90_v5_sleep_on_n9_10_actions_100_500/pareto_sweep.csv`
  - δ tight v4（actions={100,500}）: `results/mhealth_policy_eval/letter_v4_scan90_v5_delta_tight_sleep_on_n9_10_actions_100_500/summary.md`
  - 代表（δ=0.03 power-min, actions={100,500}）:
    - params=(u_mid=0.20,u_high=0.35,c_mid=0.20,c_high=0.35,hyst=0.02)
    - share100=0.369 / share500=0.631, 予測 avg_power≈187.36mW / pout_1s≈0.0226（Fixed100比 −11.20mW ≈ −5.6%）

- [13:05 JST] D0完了を確認し、以降の実機比較は actions={100,500} の代表ポリシー（δ=0.03 power-min）を採用する方針で進行。

- [13:30 JST] Step D1（実機：不確実性駆動/ルールベースの動的切替）用の専用ディレクトリとArduinoスケッチ（TX/RX/TXSD）を追加。
  - 追加ディレクトリ: `uccs_d1_scan90/`（index: `uccs_d1_scan90/README.md`）
  - TX: `uccs_d1_scan90/src/tx/TX_UCCS_D1_100_500/TX_UCCS_D1_100_500.ino`
    - 1回の起動で `Fixed100 → Fixed500 → Policy(100↔500)` を自動実行（`N_CYCLES=3`, `TRIAL_DURATION_MS=60s`, `GAP_MS=5s`）
    - TXSD向け cond_id を preamble TICK パルス数で通知（1=fixed100, 2=fixed500, 3=policy）
    - payload: `<tx_elapsed_ms>_<label>`（fixed=F100/F500, policy=P100/P500）
    - 代表ポリシー（actions={100,500}）: u_mid=0.20,u_high=0.35,c_mid=0.20,c_high=0.35,hyst=0.02（D0確定）
    - U/CCS入力は暫定で synthetic（実機HARに差し替える前提）
  - RX: `uccs_d1_scan90/src/rx/RX_UCCS_D1_SCAN90/RX_UCCS_D1_SCAN90.ino`（scan90, SYNC gate, SDへ `/logs/rx_trial_XXX.csv`）
  - TXSD: `uccs_d1_scan90/src/txsd/TXSD_UCCS_D1_SCAN90/TXSD_UCCS_D1_SCAN90.ino`（INA219, SYNC start/stop, preambleでcond_id判別）
  - 配線: TX GPIO25→RX/TXSD GPIO26（SYNC）, TX GPIO27→TXSD GPIO33（TICK）

- [13:31 JST] バグ修正: `TX_UCCS_D1_100_500` で interval が切替わった後も旧intervalで次回更新を待ってしまう可能性があったため、`nextUpdateMs` を切替後の `currentIntervalMs` に基づいて再計算するよう修正（`uccs_d1_scan90/src/tx/TX_UCCS_D1_100_500/TX_UCCS_D1_100_500.ino`）。

- [14:06 JST] Step D1（uccs_d1_scan90）を実機で1回実行して、ログ上の挙動が期待通りであることを確認（ユーザ取得ログの目視チェック）。
  - RX（`RX_UCCS_D1_SCAN90`）: 9セッション（3条件×3回）が連続で取得でき、buf_overflow=0。
    - fixed100相当: rate_hz≈7.8–8.1（scan90の受信率として妥当）
    - fixed500相当: rate_hz≈1.5–1.7（期待2adv/s×受信率）
    - policy: rate_hz≈3.6–3.8（固定より中間＝切替が動いている兆候）
  - TXSD（`TXSD_UCCS_D1_SCAN90`）: preamble pulsesで cond_id=1/2/3 を正しく復号し、各trial ms≈589xx, parse_drop=0。
    - fixed100 mean_p_mW: 203.8 / 208.3 / 203.2
    - fixed500 mean_p_mW: 186.6 / 185.2 / 184.7
    - policy mean_p_mW: 192.8 / 191.9 / 191.8（固定100/500の間に入り、成立確認としてOK）
  - 次: SDの `/logs/` を `uccs_d1_scan90/data/<date>_runXX/{RX,TXSD}/` に吸い上げて、policyの `P100/P500` 比率（share100/share500）と Pout(τ) を解析で確定する。

- [14:18 JST] Step D1 実測ログ（`uccs_d1_scan90/data/01`）を集計して、Power/RX rate/Policyの100ms比率を確定。
  - 集計スクリプト: `uccs_d1_scan90/analysis/summarize_d1_run.py`（出力: `uccs_d1_scan90/metrics/01/`）
  - 採用ログ: ms_total>=50s のみ（SDに旧ログが残っていたため）。run index: `uccs_d1_scan90/data/01/README.md`
  - TXSD（mean_p_mW, n=3）:
    - fixed100: 205.10 ± 2.79 mW
    - fixed500: 185.50 ± 0.98 mW
    - policy: 192.17 ± 0.55 mW
    - 差分: fixed100-fixed500=19.60mW、policy-fixed100=-12.93mW、policy-fixed500=+6.67mW
  - RX（rate_hz, n=3）:
    - F100: 7.94 ± 0.21 Hz、F500: 1.63 ± 0.09 Hz、Policy: 3.71 ± 0.11 Hz
  - Policyの100ms比率（time-weight推定）:
    - power mix由来: share100≈0.340
    - RXラベル由来（P100/P500カウント×interval重み）: share100≈0.294 ± 0.010
  - これで D1 の成立条件（切替/電力/受信率の方向性）が実測ログで確認できた。次は D2（レター図に実測点を重ねる）か、U/CCS入力を実機HARへ置換して同枠組みで再計測する。

- [15:02 JST] Step D2（動的QoS: TL/Pout）用の専用ディレクトリとArduinoスケッチ（TX/RX/TXSD）を追加し、取得準備を完了。
  - 追加ディレクトリ: `uccs_d2_scan90/`（index: `uccs_d2_scan90/README.md`）
  - truth（flash埋め込み, 100msグリッド180s）: `uccs_d2_scan90/src/tx/stress_causal_s1_s4_180s.h`（stress_causal S1/S4 の label/U/CCS を量子化して格納）
  - TX: `uccs_d2_scan90/src/tx/TX_UCCS_D2_SCAN90/TX_UCCS_D2_SCAN90.ino`
    - 1回の起動で S1/S4 × {Fixed100, Fixed500, Policy(100↔500)} を自動実行（`REPEAT=3`, `EFFECTIVE_LEN_STEPS=1800(=180s)`, `GAP_MS=5s`）
    - payload: `<step_idx>_<tag>`（tag例: `P4-09-500`。動的でも time axis を `step_idx*100ms` で復元可能）
    - TXSD向け cond_id: preamble TICKパルス数（1..6）で通知（READMEの表と一致）
    - trial中 tick: payload更新ごとに1発（TXSD側で `adv_count=tick_count` の近似を取得）
  - RX: `uccs_d2_scan90/src/rx/RX_UCCS_D2_SCAN90/RX_UCCS_D2_SCAN90.ino`（scan90, SYNC gate, SDへ `/logs/rx_trial_XXX.csv`）
  - TXSD: `uccs_d2_scan90/src/txsd/TXSD_UCCS_D2_SCAN90/TXSD_UCCS_D2_SCAN90.ino`（INA219, SYNC start/stop, preambleでcond_id判別, summaryにadv_count出力）
  - TODO更新: `docs/TODO.md` に D1完了（集計参照先）と D2準備完了/D2取得TODOを反映。
