<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: AGENTS.md, README.md, 修士論文/**, docs/全体像.md, docs/metrics_definition.md, docs/TODO.md, docs/decision_log_2025-12-13_letter_route.md, logs/worklog_2025-12-17_thesis_setup.txt, logs/worklog_2025-12-17_letter_route.txt, logs/worklog_2025-12-16_letter_route.txt, logs/worklog_2025-12-16_letter_route_continued.txt, logs/worklog_2025-12-15_thesis_setup.txt, logs/worklog_2025-12-15_letter_route.txt, logs/worklog_2025-12-13_stress_fixed_metrics_v5.txt, scripts/bootstrap_effects.py, uccs_d2_scan90/README.md, uccs_d2_scan90/analysis/**, uccs_d2_scan90/metrics/**, uccs_d2_scan90/plots/**, uccs_d2_scan90/src/**, uccs_d2_scan90/truth/**, uccs_d3_scan70/README.md, uccs_d3_scan70/analysis/**, uccs_d3_scan70/metrics/**, uccs_d3_scan70/plots/**, uccs_d3_scan70/src/**, uccs_d4_scan90/README.md, uccs_d4_scan90/analysis/**, uccs_d4_scan90/metrics/**, uccs_d4_scan90/plots/**, uccs_d4_scan90/src/**, uccs_d4b_scan90/README.md, uccs_d4b_scan90/analysis/**, uccs_d4b_scan90/metrics/**, uccs_d4b_scan90/plots/**, uccs_d4b_scan90/src/**, uccs_d4b_scan70/README.md, uccs_d4b_scan70/src/**
- Files matching these patterns are excluded: uccs_d2_scan90/data/**, uccs_d3_scan70/data/**, uccs_d4_scan90/data/**, uccs_d4b_scan90/data/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Files are sorted by Git change count (files with more changes are at the bottom)</notes><additional_info></additional_info></file_summary><directory_structure>docs/
  decision_log_2025-12-13_letter_route.md
  metrics_definition.md
  TODO.md
  全体像.md
scripts/
  bootstrap_effects.py
uccs_d2_scan90/
  analysis/
    merge_metrics_runs.py
    plot_power_vs_pout.py
    summarize_d2_run.py
  metrics/
    01/
      per_trial.csv
      summary_by_condition.csv
      summary.md
    B/
      per_trial.csv
      summary_by_condition.csv
      summary.md
    B_02/
      per_trial.csv
      summary_by_condition.csv
      summary.md
    B_n6/
      per_trial.csv
      summary_by_condition.csv
      summary.md
  src/
    rx/
      RX_UCCS_D2_SCAN90/
        RX_UCCS_D2_SCAN90.ino
      RX_UCCS_D2B_SCAN90/
        RX_UCCS_D2B_SCAN90.ino
    tx/
      TX_UCCS_D2_SCAN90/
        TX_UCCS_D2_SCAN90.ino
      TX_UCCS_D2B_SCAN90/
        TX_UCCS_D2B_SCAN90.ino
      stress_causal_s1_s4_180s.h
    txsd/
      TXSD_UCCS_D2_SCAN90/
        TXSD_UCCS_D2_SCAN90.ino
      TXSD_UCCS_D2B_SCAN90/
        TXSD_UCCS_D2B_SCAN90.ino
  README.md
uccs_d3_scan70/
  analysis/
    plot_power_vs_pout.py
    summarize_d3_run_v2.py
  metrics/
    01/
      effects_ci.csv
      effects_ci.md
      per_trial.csv
      summary_by_condition.csv
      summary.md
  src/
    rx/
      RX_UCCS_D3_SCAN70/
        RX_UCCS_D3_SCAN70.ino
    tx/
      TX_UCCS_D3_SCAN70/
        TX_UCCS_D3_SCAN70.ino
      stress_causal_s1_s4_180s.h
    txsd/
      TXSD_UCCS_D3_SCAN70/
        TXSD_UCCS_D3_SCAN70.ino
  README.md
uccs_d4_scan90/
  analysis/
    plot_power_vs_pout.py
    summarize_d4_run_v2.py
    summarize_d4_run.py
  metrics/
    01/
      effects_ci.csv
      effects_ci.md
      per_trial.csv
      summary_by_condition.csv
      summary.md
  src/
    rx/
      RX_UCCS_D4_SCAN90/
        RX_UCCS_D4_SCAN90.ino
    tx/
      TX_UCCS_D4_SCAN90/
        TX_UCCS_D4_SCAN90.ino
      stress_causal_s1_s4_180s.h
    txsd/
      TXSD_UCCS_D4_SCAN90/
        TXSD_UCCS_D4_SCAN90.ino
  README.md
uccs_d4b_scan70/
  src/
    rx/
      RX_UCCS_D4B_SCAN70/
        RX_UCCS_D4B_SCAN70.ino
    tx/
      TX_UCCS_D4B_SCAN70/
        TX_UCCS_D4B_SCAN70.ino
      stress_causal_s1_s4_180s.h
    txsd/
      TXSD_UCCS_D4B_SCAN70/
        TXSD_UCCS_D4B_SCAN70.ino
  README.md
uccs_d4b_scan90/
  analysis/
    ccs_timing_analysis_conditional.py
    ccs_timing_analysis.py
    outage_story_trace.py
    plot_alpha_vs_pout.py
    plot_power_vs_pout.py
    plot_role_separation_overview.py
    pout_tail_decomposition.py
    summarize_d4b_run_v2.py
  metrics/
    01/
      effects_ci.csv
      effects_ci.md
      extra_analysis.md
      per_trial.csv
      summary_by_condition.csv
      summary.md
  plots/
    ccs_timing_01/
      alloc_efficiency_summary.csv
      event_triggered_p100.csv
      fig_alloc_efficiency.svg
      fig_event_triggered_p100.svg
      fig_hit_cover.svg
      fig_lag_cdf.svg
      hit_cover_lag_summary.csv
      lag_cdf.csv
    ccs_timing_conditional_01/
      fig_event_triggered_p100_conditional.svg
      selected_transitions.csv
    outage_story_01/
      fig_outage_timeline.svg
      outage_ranking.csv
      per_transition.csv
      selected_event.json
    pout_tail_01/
      delta_pout_contrib.csv
      fig_delta_pout_cum.svg
      fig_outage_count_hist.svg
      outage_counts_by_trial.csv
      pout_tail_decomposition.md
    alpha_vs_pout_overview.svg
    d4b_01_power_vs_pout.svg
    role_separation_d3_d4_d4b.svg
  src/
    rx/
      RX_UCCS_D4B_SCAN90/
        RX_UCCS_D4B_SCAN90.ino
    tx/
      TX_UCCS_D4B_SCAN90/
        TX_UCCS_D4B_SCAN90.ino
      stress_causal_s1_s4_180s.h
    txsd/
      TXSD_UCCS_D4B_SCAN90/
        TXSD_UCCS_D4B_SCAN90.ino
  README.md
修士論文/
  chapters/
    acknowledgements.tex
    appx_a_metrics.tex
    appx_b_assets.tex
    appx_c_results.tex
    appx_d_log_schema.tex
    appx_e_runbook.tex
    appx_f_symbols.tex
    appx_g_troubleshooting.tex
    appx_h_ccs_params.tex
    ch0_introduction.tex
    ch1_background.tex
    ch10_implementation.tex
    ch2_background_related.tex
    ch2_proposed.tex
    ch2_related_work.tex
    ch3_oncampus.tex
    ch3_system_and_method.tex
    ch3_system_design.tex
    ch4_measurement_metrics_repro.tex
    ch4_rain.tex
    ch5_evaluation.tex
    ch5_publicroad.tex
    ch6_stress_fixed.tex
    ch7_offline_eval.tex
    ch8_experiment_design.tex
    ch8_measurement_system.tex
    ch9_har_uncertainty.tex
    conclusion.tex
  figures/
    README.md
  frontmatter/
    abstract.tex
  .gitignore
  chubuthesis.sty
  latexmkrc
  main.tex
  meta.tex
  README.md
  references.bib
  WRITING_RULES.md
AGENTS.md
README.md</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="docs/全体像.md"># ReFormHAR-Tiny: Vision / World Model

&gt; **現在地 (2025-11-30)**: Phase 0-0 ベースライン計測中。ON計測（100/500/1000/2000ms自動遷移）実行中、Group 4 (2000ms) 進行中。配線修正・SYNC信号修正完了。次ステップ: 計測完了後のデータ解析 → Phase 1 CCS制御実装へ。

本ドキュメントは、**ReFormHAR-Tiny** プロジェクトの研究ビジョンと世界観を体系的に記述する。
他のAI・研究者がプロジェクトの方向性を正しく理解し、一貫した判断ができるようにすることを目的とする。

---

## 0) 研究ビジョンの階層構造

### Phase 1: 今回のレター（短期目標）

&gt; **「Safe Contextual Banditの前段階として、決め打ちルールの実装と評価指標の確立」**

**位置づけ**:
- Safe-MABの「warm-start用ベースライン」を作る
- 評価指標（Pout(τ), μC）の測定系を確立する
- 単純なルールでも「効果がある」ことを示し、将来の学習ベース手法の土台を作る

**主張**:
&gt; 「HAR不確実度に基づくBLE広告間隔の適応制御において、単純な閾値ルールでも固定間隔と比較して省電力効果が得られることを示した。提案手法は、将来のSafe Contextual Banditによるオンライン最適化の基盤となる。」

**レターに含めるもの**:
1. 問題定式化: Pout(τ)制約下でのエネルギー最小化問題
2. 評価指標: Pout(τ), μC/eventの定義と測定方法
3. 決め打ちルール: CCS→T_adv写像の実装
4. 実験評価: 固定100ms / 固定2000ms / CCS制御の比較
5. Future Work: Safe Contextual Banditへの拡張

**レターに含めないもの（Future Work）**:
- MAB/RLの学習アルゴリズム
- 非理想スキャンのモデリング
- HAR誤認識の統合評価（RoME）

### Phase 2: 研究テーマ（修論〜博士前期）

&gt; **「HAR不確実度を活用したBLE広告のSafe Contextual Bandit最適化」**

**問題定式化**:
- **コンテキスト**: HAR推論の不確実度 U、安定度 S
- **行動（Arm）**: 広告間隔 T_adv ∈ {100, 500, 1000, 2000ms}
- **報酬**: −μC（エネルギー最小化）
- **制約**: Pout(τ) ≤ δ（QoS保証）

**新規性**:
1. HAR不確実度をContextual Banditの「コンテキスト」として初めて使用
2. Pout(τ)を「制約」として扱うSafe Bandit定式化
3. アプリ層（HAR）→通信層（BLE）のクロスレイヤー最適化

### Phase 3: 究極のゴール（5-10年スパン）

&gt; **「アプリ層のセマンティクスが通信層を自律制御する、エッジAIの新しいパラダイム」**

- TinyMLデバイスが「今この瞬間、どれだけ確信を持っているか」を通信スタックに伝える
- 通信層は、そのセマンティクスに応じてリソース配分を動的に変える
- 人間の介入なく、デバイスが自律的に「省電力」と「QoS保証」を両立する

---

## 1) World Model（世界観の骨格）

### 1.1 役者（Actors）

| Actor | 役割 | 備考 |
|-------|------|------|
| **Edge Node / DUT** | IMU＋MCUでHARをオンデバイス推論。U, S, CCSを生成しBLE広告を制御 | ESP32-S3/C3想定 |
| **Gateway（スマホ/受信機）** | BLE広告の受信主体。スキャンは非理想（チャネル巡回・隙間・モード差） | Android LOW_LATENCY |
| **Observer / Orchestrator** | ログ収集、KPI算出。クラウド常時接続は不要 | 実験・運用時 |
| **Safety Oracle（概念）** | QoS制約（Pout(τ) ≤ δ）を定義。方策が守るべき境界 | 規格書的存在 |
| **Policy Engine** | 通信層の意思決定器。Phase 1はルール、Phase 2でSafe-MAB | 段階的進化 |

### 1.2 能力（Capabilities）— 5つの柱

1. **Perception（知覚）**: IMU → HAR → 確率分布 (p_k) → U（不確実度）、S（安定度）
2. **Decision（意思決定）**: CCS をコンテキストに BLE広告間隔を決定
3. **Communication（通信）**: μC/event最小で、Pout(τ)制約を満たす広告
4. **Safety（安全）**: 常時 Pout(τ) ≤ δ を満たす制約の中で最適化。違反兆候で安全側へ退避
5. **Observability（可観測性）**: すべての意思決定に根拠ログ（U, S, CCS, 閾値, 切替理由）を残す

### 1.3 不変条件（Invariants）

- **オンデバイス優先**: 生センサは外に出さない（プライバシ）
- **QoS優先の最適化**: Pout(τ) を常に制約として扱い、その範囲内で電力最小化
- **後方互換のIF**: `decide_interval(context) → interval` のIFは固定（将来MAB/Safe-MABでも同じ）
- **単一真実のKPI**: μC/event、Pout(τ)、TL分布を一次指標。平均電流やmWh/日は従属

### 1.4 境界条件（Operating Envelope）

- **MCU制約**: RAM ≤ 256KB / Flash ≤ 1MB、INT8演算前提
- **BLE制約**: Legacy Advertising、3ch（37/38/39）、Tx/EIRPとDutyは地域規制遵守
- **受信制約**: スマホは連続スキャンではない（モードで挙動が変化）。理想化しない

---

## 2) Ontology（用語・データ辞書）

### 2.1 概念・変数

| 変数 | 定義 | 範囲 |
|------|------|------|
| **(p_k)** | HARのクラス確率 | Σp_k = 1 |
| **U** | 正規化エントロピー（不確実度） | [0, 1] |
| **S** | 安定度（遷移が少ないほど1に近い） | [0, 1] |
| **confidence** | 1 − U | [0, 1] |
| **CCS** | Composite Confidence Score = 0.7×confidence + 0.3×S | [0, 1] |
| **T_adv / Arm** | 広告間隔。Phase 1: {100, 500, 1000, 2000}ms | ms |
| **TL** | Time-to-first-Receive。イベント検知→初回受信までの遅延 | ms |
| **Pout(τ)** | Outage probability。期限τ内に初回受信できない確率 | [0, 1] |
| **μC/event** | 広告イベント1回あたりの電流積分 | μC |

### 2.2 CCS定義の根拠と感度分析

**採用定義**: CCS = 0.7 × (1 − U) + 0.3 × S = 0.7 × confidence + 0.3 × S

**根拠**:
1. **変数名との整合性**: CCS = Composite Confidence Score。高い値が「確信がある」という解釈と一致
2. **Safe Banditとの整合性**: CCS高い → 確信あり → 長い間隔OK → 省電力。単調な写像で直感的
3. **論文での説明容易性**: &quot;Higher CCS indicates the system can safely extend advertising intervals.&quot;
4. **主成分の重視**: 推論の確信度（confidence）を0.7、時間的安定性（S）を0.3で補助的に扱う

**係数の選択**:
- α=0.7, β=0.3 は経験的初期値
- confidence（瞬時の推論品質）を主成分とし、stability（時間的一貫性）を補助とする設計意図

**感度分析（Future Work）**:
- 係数 (α, β) の変動が KPI（μC, Pout(τ), TL_p95）に与える影響を評価
- 候補: (0.8, 0.2), (0.7, 0.3), (0.6, 0.4), (0.5, 0.5)
- 評価方法: 同一実験データに対して係数を変えた場合の省電力効果とQoS劣化のトレードオフを可視化
- 最適係数はアプリケーション依存（QoS重視 vs 省電力重視）であり、ユースケース毎に調整可能とする

### 2.3 ログスキーマ

| ログ種別 | 主キー |
|----------|--------|
| **Tx** | `t, session_id, adv_interval, ch_mask, tx_dbm, state, U, S, CCS, reason` |
| **Rx** | `t, session_id, phone_model, scan_mode, rx_uuid, rssi, dedup_flag` |
| **Power** | `t, current_mA, voltage_V, event_marker` |
| **KPI** | `avg_current, event_charge_uC, TL_p50, TL_p95, Pout_1s/_2s/_3s, PDR` |

&gt; すべて列追加で拡張可能（後方互換）。将来のMAB拡張時に `arm, reward, context` 列を追加。

---

## 3) 研究の段階（Phases）

### Phase 1: Rule-based（今回のレター）

| 項目 | 内容 |
|------|------|
| **何をするか** | CCSで adv_interval を切替（100/500/1000/2000ms）。ヒステリシス＋滞在時間で安定化 |
| **なぜ意味があるか** | μC/eventと平均電流を削減しつつ、Pout(τ)・TLが基準と同等であることを示せる |
| **成果物** | 評価指標の確立、warm-start用ベースライン、KPIパイプライン |
| **残る課題** | 環境・端末依存性を考慮できない。最適点は状況で変わる |

### Phase 2: Safe Contextual Bandit（修論テーマ）

| 項目 | 内容 |
|------|------|
| **何をするか** | コンテキスト=(U,S)、腕=T_adv、報酬=−μC、制約=Pout(τ)≤δ のSafe Bandit |
| **なぜ意味があるか** | 環境ごとに最適点へ自律収束しつつ、QoS保証を維持 |
| **アルゴリズム候補** | Conservative UCB, SafeOpt, Constrained Thompson Sampling |
| **残る課題** | 先験情報（端末スキャン挙動）の活用、学習初期の後悔 |

### Phase 3: Semantic-driven Communication（長期ビジョン）

| 項目 | 内容 |
|------|------|
| **何をするか** | アプリ層のセマンティクス（確信度、緊急度、価値）が通信層を自律制御 |
| **なぜ意味があるか** | 人間介入なしで省電力とQoS保証を両立。エッジAIの新パラダイム |
| **発展方向** | 知識蒸留によるwarm-start、マルチデバイス協調、アプリ横断の優先度制御 |

---

## 4) 価値の地図（Value Map）

### 4.1 定量KPI

| 区分 | KPI |
|------|-----|
| **一次（Primary）** | μC/event, Pout(τ), TL_p95 |
| **二次（Secondary）** | 平均電流, mWh/日, PDR, F1/Acc |
| **複合（Composite）** | J/decision（1検出あたりエネルギ）, QoS違反率 |

### 4.2 ユースケース枠

| ユースケース | 要件 |
|--------------|------|
| **見守り**（転倒・無動作） | 偽陰性 &lt; 偽陽性、Pout(2s) ≪ δ |
| **労働安全**（急変姿勢通知） | TL_p95 ≤ 500ms、電池寿命30日↑ |
| **スポーツ**（フォーム変化検知） | 遷移期だけ濃く、安定期は薄く |

---

## 5) ガバナンス（Governance Model）

- **規格準拠**: BLE広告・出力規制・Duty規制の上限はPolicyが越えない
- **安全網**: QoS違反兆候 → 安全側へ退避（短間隔×3ch固定）
- **説明責任**: 各ラウンドの Decision Rationale は不可欠ログ
- **データ最小化**: ログは匿名化。生IMUは外に出さない
- **監査可能性**: 実験再現用の Runbook と KPIパイプラインを常備

---

## 6) リスク &amp; フェイルセーフ

| リスク | 兆候 | フェイルセーフ | 恒久対策 |
|--------|------|----------------|----------|
| QoS違反（Pout上昇） | TL分布が右シフト | 短間隔×3ch | Safe-MABの制約強化 |
| 受信端末差 | PDR低下・端末依存 | 端末切替/再起動 | 端末別事前重み |
| 切替振動 | 切替頻発ログ | ヒステリシス/滞在時間 | U/S較正、窓W調整 |
| 学習初期の後悔 | 違反スパイク | Warm-Start | 知識蒸留（禁止腕/初期重み） |

---

## 7) ロードマップ

```
Phase 1 (レター)          Phase 2 (修論)           Phase 3 (長期)
─────────────────────────────────────────────────────────────────
決め打ちルール実装    →   Safe Contextual Bandit  →  Semantic-driven
評価指標確立              Pout(τ)制約保証             Communication
warm-startベースライン    環境適応学習                 マルチデバイス協調
```

---

## 8) 要約（AIが誤読しないための短文仕様）

- **Goal**: Pout(τ)を守りながら、μC/eventを最小化（端末内完結）
- **Signals**: U ∈ [0,1], S ∈ [0,1], CCS = 0.7×(1−U) + 0.3×S
- **Policy IF（不変）**: `context(U, S, CCS) → interval`（将来Safe-MABでも同じ）
- **KPI（一次）**: μC/event, Pout(τ), TL_p95
- **Safety**: Pout(τ) ≤ δ を制約として常時満たす（Phase 2以降）
- **Fallback**: いつでも `interval=短/3ch` に退避可
- **Logs**: Decision Rationale を毎切替で出力
- **Growth**: Phase 1（ルール）→ Phase 2（Safe Bandit）→ Phase 3（セマンティック制御）

---

## 9) 参考リソース

- **TinyML**: A Comprehensive Survey on TinyML
- **BLE受信の非理想性**: スキャン挙動の実機観測・モデル化
- **HAR省電力**: システム最適化の俯瞰

&gt; これらは世界観の根拠としての役割を持つ。必要に応じてKPI式・閾値・境界条件を抽出。

---

*Last updated: 2025-11-30*</file><file path="修士論文/chapters/acknowledgements.tex">% chapters/acknowledgements.tex --- 謝辞（番号なし、目次には載せる）
\chapterwithtoc{謝辞}

本研究を進めるにあたり，ご指導・ご助言を賜った指導教員の先生方に深く感謝申し上げる．また，実験環境の整備や議論にご協力いただいた研究室の皆様に感謝する．最後に，研究活動を支えてくれた家族に感謝する．</file><file path="修士論文/chapters/appx_a_metrics.tex">% chapters/appx_a_metrics.tex --- 付録A 指標定義（詳細）
\section{指標定義（詳細）}
\label{sec:metrics_detail}

本節では，本研究で用いる主要指標を，実装と集計の観点で最小限に定義する．本文の図表は本節の定義に従い，同一の処理パイプラインで端末内比較を行う．

\subsection{PDR（到達率）}
PDRは，広告イベント数に対して受信できた割合である．重複受信がある場合，受信行数に基づくPDRは1を超え得るため，seq等でユニーク化した指標も併記する．

本研究では，広告イベント数（分母）を$N_{\mathrm{adv}}$，受信ログ行数（重複含む）を$N_{\mathrm{rx}}$，seqでユニーク化した受信数を$N_{\mathrm{rx,uniq}}$とする．
\begin{equation}
  \mathrm{PDR}_{\mathrm{raw}} = \frac{N_{\mathrm{rx}}}{N_{\mathrm{adv}}},\qquad
  \mathrm{PDR}_{\mathrm{unique}} = \frac{N_{\mathrm{rx,uniq}}}{N_{\mathrm{adv}}}
\end{equation}
$\mathrm{PDR}_{\mathrm{raw}}$は重複受信により1を超え得るため，到達性の比較（QoS用途）では$\mathrm{PDR}_{\mathrm{unique}}$を優先する．分母$N_{\mathrm{adv}}$は，可能な場合はTICKにより物理カウントした値を正とし，利用できない場合は試行時間と広告間隔から推定する（動的切替では誤差が入り得る）．

\subsection{TLとPout(τ)}
TLは，イベント後に最初に受信されるまでの遅延である．Pout(τ)は，TLが期限$\tau$を超える確率として定義する．TL/Poutの算出では，受信ログの時間軸と真値（truth）の時間軸の一致が必要であり，開始位相ずれがある場合は定数オフセットで補正する（\secref{sec:stress_fixed_metrics}）．

真値（truth）における状態遷移（イベント）時刻を$t_{\mathrm{event},j}$，その後に初めて正しいラベル（または該当イベントに対応する識別子）が受信される時刻を$t_{\mathrm{rx},j}$とすると，
\begin{equation}
  \mathrm{TL}_j = t_{\mathrm{rx},j} - t_{\mathrm{event},j}
\end{equation}
である．期限$\tau$に対する期限超過率は，
\begin{equation}
  P_{\mathrm{out}}(\tau)=\frac{1}{N_{\mathrm{event}}}\sum_{j=1}^{N_{\mathrm{event}}}\mathbb{I}[\mathrm{TL}_j&gt;\tau]
\end{equation}
で定義する．
\noindent
また，試行時間がtruthの全長より短い場合は末端遷移が試行区間外に出るため，truth側も有効長（EFFECTIVE\_LEN）でクリップし，$N_{\mathrm{event}}$の分母を揃える．

\subsection{電荷と$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$）}
本研究の一次KPIである$q_{\mathrm{event}}$は，セッション中の電荷消費をイベント数で正規化した指標である．電力やエネルギーは電圧に依存するため，バッテリ消費の観点では電荷（Coulomb count）で整理すると解釈が容易である．

電流を$I(t)$とすると，総電荷$Q$は
\begin{equation}
  Q=\int I(t)\,dt
\end{equation}
で定義できる．TXSDログでは電流が$\mu$A，時刻がmsで記録されるため，離散近似として
\begin{equation}
  Q_{\si{\micro\coulomb}} \approx \sum_{i} I_{\si{\micro\ampere},i}\cdot \frac{\Delta t_{\si{\milli\second},i}}{1000}
\end{equation}
により$\si{\micro\coulomb}$単位の電荷を算出できる．

計測系の定常負荷（ロギング，LED等）が大きい場合，広告間隔による差分が総電荷に埋もれる．このため，広告ONとOFFの差分
\begin{equation}
  \Delta Q = Q_{\mathrm{on}}-Q_{\mathrm{off}}
\end{equation}
を用いて，広告による増分を評価する．OFF計測では，sleep状態や無線スタック状態がONと一致するよう，同一コード系列で条件を固定する必要がある（\secref{sec:runbook}）．

TL/Poutの評価起点となるイベント数を$N_{\mathrm{event}}$とすると，
\begin{equation}
  q_{\mathrm{event}}=\frac{\Delta Q}{N_{\mathrm{event}}}
\end{equation}
で定義する．$\Delta Q$の代わりに$Q_{\mathrm{on}}$を用いる場合は，基準補正が入らないため，条件間比較の解釈に注意する．
\noindent
なお，平均電力$\overline{P}$や$\Delta E/N_{\mathrm{adv}}$等は従属指標として併用し，単位監査や原因切り分けに用いる．</file><file path="修士論文/chapters/appx_b_assets.tex">% chapters/appx_b_assets.tex --- 付録B 実験資産一覧（ファイル・ディレクトリ）
\section{実験資産一覧}
\label{sec:assets}

\subsection{図の管理}
図は原則として\texttt{\detokenize{修士論文/figures/}}に集約し，本文から拡張子なしで参照する．本リポジトリでは，既存の解析結果図を相対パスで参照している箇所もあるため，提出用に固める際は\texttt{\detokenize{figures/}}へコピーしてパスを固定する．

\subsection{主要な出力先（例）}
\begin{itemize}
  \item 固定間隔の電力テーブル：\texttt{\detokenize{results/mhealth_policy_eval/power_table_sleep_eval_2025-12-14_interval_sweep_sleep_on_n9_10.csv}}
  \item オフライン評価（δ帯）：\texttt{\detokenize{results/mhealth_policy_eval/letter_v4_scan90_v5_delta_tight_sleep_on_n9_10_actions_100_500/}}
  \item ストレス固定（v5図）：\texttt{\detokenize{results/stress_fixed/figures_v5/}}
  \item 追加検証（ブートストラップCI）：\path{scripts/bootstrap_effects.py}
\end{itemize}

\subsection{実機評価（例：D2）}
実機の動的切替の例として，D2（scan90）では次のディレクトリ構成でログと指標を管理する．
\begin{itemize}
  \item 実験ルート：\path{uccs_d2_scan90/}
  \item 入力（run B/01, RX）：\path{uccs_d2_scan90/data/B/01/RX/}
  \item 入力（run B/01, TXSD）：\path{uccs_d2_scan90/data/B/01/TX/}
  \item 入力（追加 run B/02, RX）：\path{uccs_d2_scan90/data/B/02/RX/}
  \item 入力（追加 run B/02, TXSD）：\path{uccs_d2_scan90/data/B/02/TX/}
  \item 出力（指標，主結果・統合n=6）：\path{uccs_d2_scan90/metrics/B_n6/summary.md}
  \item 出力（集計CSV）：\path{uccs_d2_scan90/metrics/B_n6/summary_by_condition.csv}
  \item 出力（主張図）：\path{uccs_d2_scan90/plots/d2b_B_n6_power_vs_pout.pdf} / \path{uccs_d2_scan90/plots/d2b_B_n6_power_vs_pout.png}
  \item 参考（run別n=3）：\path{uccs_d2_scan90/metrics/B/summary.md} / \path{uccs_d2_scan90/metrics/B_02/summary.md}
\end{itemize}

\subsection{実機評価（例：D4）}
U-shuffleアブレーション（D4, scan90）では，次のディレクトリ構成でログと指標を管理する．
\begin{itemize}
  \item 実験ルート：\path{uccs_d4_scan90/}
  \item 入力（01, RX）：\path{uccs_d4_scan90/data/01/RX/}
  \item 入力（01, TXSD）：\path{uccs_d4_scan90/data/01/TX/}
  \item 出力（指標, n=3×4条件）：\path{uccs_d4_scan90/metrics/01/summary.md}
  \item 出力（集計CSV）：\path{uccs_d4_scan90/metrics/01/summary_by_condition.csv}
  \item 出力（主張図）：\path{uccs_d4_scan90/plots/d4_01_power_vs_pout.pdf} / \path{uccs_d4_scan90/plots/d4_01_power_vs_pout.png}
\end{itemize}

\subsection{実機評価（例：D4B）}
CCS-offアブレーション（D4B, scan90）では，次のディレクトリ構成でログと指標を管理する．
\begin{itemize}
  \item 実験ルート：\path{uccs_d4b_scan90/}
  \item 入力（01, RX）：\path{uccs_d4b_scan90/data/01/RX/}
  \item 入力（01, TXSD）：\path{uccs_d4b_scan90/data/01/TX/}
  \item 出力（指標, n=3×4条件）：\path{uccs_d4b_scan90/metrics/01/summary.md}
  \item 出力（集計CSV）：\path{uccs_d4b_scan90/metrics/01/summary_by_condition.csv}
  \item 出力（効果量CI）：\path{uccs_d4b_scan90/metrics/01/effects_ci.md} / \path{uccs_d4b_scan90/metrics/01/effects_ci.csv}
  \item 出力（主張図）：\path{uccs_d4b_scan90/plots/d4b_01_power_vs_pout.pdf} / \path{uccs_d4b_scan90/plots/d4b_01_power_vs_pout.svg}
  \item 出力（統合図）：\path{uccs_d4b_scan90/plots/role_separation_d3_d4_d4b.pdf} / \path{uccs_d4b_scan90/plots/role_separation_d3_d4_d4b.svg}
  \item 出力（$\alpha$--$P_{\mathrm{out}}$俯瞰図）：\path{uccs_d4b_scan90/plots/alpha_vs_pout_overview.pdf} / \path{uccs_d4b_scan90/plots/alpha_vs_pout_overview.svg}
  \item 出力（outage事例の追跡）：\path{uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline.pdf} / \path{uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline.svg}
  \item 出力（outage内訳CSV）：\path{uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv} / \path{uccs_d4b_scan90/plots/outage_story_01/per_transition.csv}
  \item 出力（尾の寄与分解）：\path{uccs_d4b_scan90/plots/pout_tail_01/fig_outage_count_hist.pdf} / \path{uccs_d4b_scan90/plots/pout_tail_01/fig_delta_pout_cum.pdf} / \path{uccs_d4b_scan90/plots/pout_tail_01/pout_tail_decomposition.md}
  \item 出力（条件付きタイミング）：\path{uccs_d4b_scan90/plots/ccs_timing_conditional_01/fig_event_triggered_p100_conditional.pdf}
  \item 再現メモ（追加解析）：\path{uccs_d4b_scan90/metrics/01/extra_analysis.md}
\end{itemize}

\subsection{実機評価（準備：D4B scan70）}
scan70条件でCCS-offアブレーション（D4B）の追試を行うための実験ディレクトリを用意した．
\begin{itemize}
  \item 実験ルート：\path{uccs_d4b_scan70/}
  \item TX：\path{uccs_d4b_scan70/src/tx/TX_UCCS_D4B_SCAN70/TX_UCCS_D4B_SCAN70.ino}
  \item RX：\path{uccs_d4b_scan70/src/rx/RX_UCCS_D4B_SCAN70/RX_UCCS_D4B_SCAN70.ino}
  \item TXSD：\path{uccs_d4b_scan70/src/txsd/TXSD_UCCS_D4B_SCAN70/TXSD_UCCS_D4B_SCAN70.ino}
  \item truthヘッダ：\path{uccs_d4b_scan70/src/tx/stress_causal_s1_s4_180s.h}
\end{itemize}

\subsection{解析スクリプト（例）}
解析は，1回で完結する巨大スクリプトではなく，「trial集計」「集約」「図表化」に分割して再現可能にする．代表例を以下に示す．
\begin{itemize}
  \item ストレス固定（trial集計）：\path{scripts/analyze_stress_causal_real.py}
  \item ストレス固定（集約）：\path{scripts/aggregate_stress_causal_real_summary.py}
  \item ストレス固定（v5図生成）：\path{scripts/plot_stress_fixed_figures_v5.py}
  \item D2集計（run単体）：\path{uccs_d2_scan90/analysis/summarize_d2_run.py}
  \item D2集約（run統合）：\path{uccs_d2_scan90/analysis/merge_metrics_runs.py}
  \item D2図生成：\path{uccs_d2_scan90/analysis/plot_power_vs_pout.py}
  \item D4集計（アブレーション）：\path{uccs_d4_scan90/analysis/summarize_d4_run_v2.py}
  \item D4図生成：\path{uccs_d4_scan90/analysis/plot_power_vs_pout.py}
  \item D4B集計（CCS-offアブレーション）：\path{uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py}
  \item D4B図生成：\path{uccs_d4b_scan90/analysis/plot_power_vs_pout.py}
  \item 統合図生成：\path{uccs_d4b_scan90/analysis/plot_role_separation_overview.py}
  \item $\alpha$--$P_{\mathrm{out}}$俯瞰図生成：\path{uccs_d4b_scan90/analysis/plot_alpha_vs_pout.py}
  \item outage事例追跡（D4B run01）：\path{uccs_d4b_scan90/analysis/outage_story_trace.py}
  \item 尾の寄与分解（D4B run01）：\path{uccs_d4b_scan90/analysis/pout_tail_decomposition.py}
  \item 条件付きタイミング（D4B run01）：\path{uccs_d4b_scan90/analysis/ccs_timing_analysis_conditional.py}
  \item ブートストラップCI：\path{scripts/bootstrap_effects.py}
\end{itemize}</file><file path="修士論文/chapters/appx_c_results.tex">% chapters/appx_c_results.tex --- 付録C 追加結果（図表）
\section{追加結果}
\label{sec:extra_results}

\subsection{オフライン評価の比較表}
図\ref{fig:policy_table}に，固定とルールベース方策の比較表（例）を示す．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../results/mhealth_policy_eval/policy_table.png}
  \caption{方策の比較表（例）}
  \label{fig:policy_table}
\end{figure}

\subsection{備考}
本節の図表は，本文の主張に直接必要でないが，読者が条件や比較対象を追跡できるように掲載する．</file><file path="修士論文/chapters/appx_d_log_schema.tex">% chapters/appx_d_log_schema.tex --- 付録D ログスキーマ（詳細）
\section{ログスキーマ（詳細）}
\label{sec:log_schema}

本節では，本研究で扱うログ（TXSD/RX/TX）の列定義をまとめる．解析スクリプトは列追加に対して後方互換で拡張可能であるが，指標計算に必須な列は固定する．

\subsection{TXSD（電力）ログ}
TXSDログは，電流・電圧系列と，末尾のsummaryから構成される．生系列は後処理で再積分できるように保持し，summaryはquick checkとして利用する．

\begin{longtable}{p{0.22\linewidth}p{0.18\linewidth}p{0.52\linewidth}}
  \caption{TXSDログ（例）の列定義}\label{tab:txsd_schema}\\
  \toprule
  列 &amp; 単位 &amp; 意味 \\
  \midrule
  \endfirsthead
  \toprule
  列 &amp; 単位 &amp; 意味 \\
  \midrule
  \endhead
  ms &amp; ms &amp; 試行開始からの相対時刻 \\
  mv &amp; mV &amp; 計測電圧（整数） \\
  uA &amp; $\mu$A &amp; 計測電流（整数） \\
  p\_mW &amp; mW &amp; 瞬時電力（派生列，後処理で再計算可能） \\
  \midrule
  \multicolumn{3}{l}{summary（末尾に出力する集約値の例）} \\
  \midrule
  ms\_total &amp; ms &amp; 試行時間 \\
  adv\_count &amp; 回 &amp; 広告イベント数（TICK物理カウント等） \\
  E\_total\_mJ &amp; mJ &amp; 総エネルギー（積分値） \\
  avg\_power\_mW &amp; mW &amp; 平均電力（$E/T$） \\
  \bottomrule
\end{longtable}

\subsection{RX（受信）ログ}
RXログは，受信時刻とペイロード識別子（seq等）を保持する．PDR\_unique，TL，$P_{\mathrm{out}}(\tau)$の算出に必須である．

\begin{longtable}{p{0.22\linewidth}p{0.18\linewidth}p{0.52\linewidth}}
  \caption{RXログ（例）の列定義}\label{tab:rx_schema}\\
  \toprule
  列 &amp; 単位 &amp; 意味 \\
  \midrule
  \endfirsthead
  \toprule
  列 &amp; 単位 &amp; 意味 \\
  \midrule
  \endhead
  t\_ms &amp; ms &amp; 受信時刻（試行開始からの相対，または端末時刻） \\
  seq &amp; --- &amp; ペイロードに埋め込んだ識別子（広告イベント由来） \\
  rssi &amp; dBm &amp; 受信RSSI \\
  dedup\_flag &amp; --- &amp; 重複除外のためのフラグ（ある場合） \\
  \bottomrule
\end{longtable}

\subsection{TX（送信）ログ}
TXログは，方策の状態（$U,S,\mathrm{CCS},a$等）を保持する．オフライン評価と実機評価を接続するため，方策の根拠（切替理由）を残すことが望ましい．

\begin{longtable}{p{0.22\linewidth}p{0.18\linewidth}p{0.52\linewidth}}
  \caption{TXログ（例）の列定義}\label{tab:tx_schema}\\
  \toprule
  列 &amp; 単位 &amp; 意味 \\
  \midrule
  \endfirsthead
  \toprule
  列 &amp; 単位 &amp; 意味 \\
  \midrule
  \endhead
  t\_ms &amp; ms &amp; 時刻 \\
  U &amp; --- &amp; 不確実度 \\
  S &amp; --- &amp; 安定度 \\
  CCS &amp; --- &amp; 複合スコア \\
  adv\_interval\_ms &amp; ms &amp; 選択した広告間隔 \\
  reason &amp; --- &amp; 切替理由（閾値越え等） \\
  \bottomrule
\end{longtable}

\subsection{ファイル命名と配置}
ログは，試行（trial）単位でファイルを分割し，\texttt{\detokenize{trial_XXX.csv}}等の連番で管理する．このとき，条件IDや実験日付をパスまたはファイル名に含め，作業ログに生成コマンドと出力先を残す（\secref{sec:runbook}）．</file><file path="修士論文/chapters/appx_e_runbook.tex">% chapters/appx_e_runbook.tex --- 付録E 実験Runbook（チェックリスト）
\section{実験Runbook（チェックリスト）}
\label{sec:runbook}

本節では，実験の再現性を担保するための最小チェックリストを示す．運用中に発見された落とし穴（条件混在，欠損，単位不整合など）を避けることを目的とする．

\subsection{実験前チェック}
\begin{itemize}
  \item 役割の確認：TX/RX/TXSDでスケッチが正しい（接頭辞，設定値）．
  \item 配線の確認：GND共通，SYNC入力，必要ならTICK入力（GPIO番号）．
  \item 受信端末の状態：スキャンモード，画面状態，省電力設定を固定し，端末内比較の前提を守る．
  \item SD空き容量：試行本数に対して十分な空きがある．
  \item ログ命名：\texttt{\detokenize{trial_XXX.csv}}の連番と，条件IDの対応が追跡できる．
\end{itemize}

\subsection{試行（trial）実行}
\begin{enumerate}
  \item SYNCで試行開始が一致していることを目視（LED等）で確認する．
  \item 試行中は条件（広告間隔，スキャン設定）を変更しない．
  \item 試行終了後，TXSDログ末尾のsummary（ms\_total, adv\_count, E\_total等）を確認する．
  \item 明らかな異常（rate低下，欠損，桁ズレ）があれば，その場で再試行し，除外理由を作業ログに残す．
\end{enumerate}

\subsection{データ整理}
\begin{itemize}
  \item 生データの退避：\texttt{\detokenize{data/}}へコピーし，取得条件と紐付ける．
  \item 解析対象の選別：含めるtrialと除外trialを明示し，理由（欠損，条件混在等）を記録する．
  \item ハッシュ記録：重要データセットはSHA256を記録し，後から同一入力で再現できるようにする．
  \item 作業ログ追記：生成物のパスと実行コマンドを\texttt{\detokenize{logs/worklog_YYYY-MM-DD_*.txt}}へ追記する．
\end{itemize}

\subsection{解析と図表生成}
\begin{itemize}
  \item trial集計：ログを読み込み，欠損と単位を監査し，指標（PDR, TL, Pout, 平均電力）を算出する．
  \item 集約：条件ごとに平均と分散を計算し，図表（固定点，δ帯，Pareto等）を生成する．
  \item 再現確認：同一入力・同一コマンドで同じ図表が出ることを確認する（乱数がある場合はseed固定）．
  \item 図の固定：提出用には\texttt{\detokenize{修士論文/figures/}}へコピーし，相対パス参照を解消する．
\end{itemize}

\subsection{既知の注意点}
\begin{itemize}
  \item 文字列中の\texttt{\detokenize{_}}（アンダースコア）は，LaTeX本文では\texttt{\detokenize{\texttt{\detokenize{...}}}}等で扱う．
  \item TL/Poutは開始位相ずれで歪むため，定数オフセット補正を適用した定義（v5）を基準にする（\secref{sec:stress_fixed_metrics}）．
  \item 条件混在（LED/SYNCの扱いの違い等）は定常オフセットとなるため，比較は同一コード系列に限定する（\secref{sec:measurement_system}）．
\end{itemize}</file><file path="修士論文/chapters/appx_f_symbols.tex">% chapters/appx_f_symbols.tex --- 付録F 記号表・略語
\section{記号表・略語}
\label{sec:symbols}

本節では，本論文で用いる記号と略語をまとめる．

\subsection{記号表}
\begin{longtable}{p{0.28\linewidth}p{0.16\linewidth}p{0.50\linewidth}}
  \caption{記号表}\label{tab:symbols}\\
  \toprule
  記号 &amp; 単位 &amp; 意味 \\
  \midrule
  \endfirsthead
  \toprule
  記号 &amp; 単位 &amp; 意味 \\
  \midrule
  \endhead
  $a,\;a(t)$ &amp; ms &amp; 広告間隔（方策が選択する行動） \\
  $T_{\mathrm{adv}}$ &amp; ms &amp; 広告間隔（説明用の表記） \\
  $T_{\mathrm{scan}}$ &amp; ms &amp; スキャン周期 \\
  $d_{\mathrm{scan}}$ &amp; ms &amp; スキャンウィンドウ \\
  $\delta$ &amp; --- &amp; スキャンデューティ比（$d_{\mathrm{scan}}/T_{\mathrm{scan}}$） \\
  $\mathbf{p}(t)$ &amp; --- &amp; HAR出力のクラス確率分布 \\
  $U(t)$ &amp; --- &amp; 不確実度（正規化エントロピー） \\
  $S(t)$ &amp; --- &amp; 安定度（時間的一貫性） \\
  $\mathrm{CCS}(t)$ &amp; --- &amp; 複合スコア（$U$と$S$の結合） \\
  $\alpha$ &amp; --- &amp; CCSの重み係数 \\
  $W$ &amp; --- &amp; 安定度の窓長（サンプル数等） \\
  $\theta_{\mathrm{low}},\theta_{\mathrm{high}}$ &amp; --- &amp; CCSの閾値（ヒステリシス） \\
  $t_{\mathrm{event},j}$ &amp; ms &amp; イベント$j$の真値（truth）時刻 \\
  $t_{\mathrm{rx},j}$ &amp; ms &amp; イベント$j$に対応する初回受信時刻 \\
  $\mathrm{TL}_j$ &amp; s &amp; イベント$j$の遅延（Time-to-first-Receive） \\
  $\mathrm{TL}_{p95}$ &amp; s &amp; TL分布の95パーセンタイル \\
  $P_{\mathrm{out}}(\tau)$ &amp; --- &amp; 期限$\tau$に対する期限超過率 \\
  $\tau$ &amp; s &amp; 遅延期限（outage判定の基準） \\
  $N_{\mathrm{event}}$ &amp; 回 &amp; 評価対象のイベント数 \\
  $N_{\mathrm{adv}}$ &amp; 回 &amp; 広告イベント数（adv\_count等） \\
  $\mathrm{PDR}_{\mathrm{raw}}$ &amp; --- &amp; 受信行数に基づくPDR（重複含む） \\
  $\mathrm{PDR}_{\mathrm{unique}}$ &amp; --- &amp; seqでユニーク化したPDR（重複除外） \\
  $Q$ &amp; $\si{\micro\coulomb}$ &amp; 試行区間の総電荷（電流積分） \\
  $\Delta Q$ &amp; $\si{\micro\coulomb}$ &amp; 電荷差分（ON$-$OFF） \\
  $q_{\mathrm{event}}$ &amp; $\si{\micro\coulomb}/\text{event}$ &amp; イベント当たり電荷（$\Delta Q/N_{\mathrm{event}}$） \\
  $E$ &amp; mJ &amp; 試行区間の総エネルギー \\
  $\Delta E$ &amp; mJ &amp; エネルギー差分（ON$-$OFF） \\
  $\overline{P}$ &amp; mW &amp; 平均電力（$E/T$） \\
  $p_d$ &amp; --- &amp; 1広告の受信成功確率（近似モデル） \\
  RSSI &amp; dBm &amp; 受信強度（Received Signal Strength Indicator） \\
  $t_{\mathrm{inf}}$ &amp; ms &amp; 推論時間（TinyML実機計測） \\
  \bottomrule
\end{longtable}

\subsection{略語}
\begin{longtable}{p{0.26\linewidth}p{0.68\linewidth}}
  \caption{略語}\label{tab:acronyms}\\
  \toprule
  略語 &amp; 意味 \\
  \midrule
  \endfirsthead
  \toprule
  略語 &amp; 意味 \\
  \midrule
  \endhead
  BLE &amp; Bluetooth Low Energy \\
  HAR &amp; Human Activity Recognition（人間活動認識） \\
  MCU &amp; Microcontroller Unit（マイコン） \\
  QoS &amp; Quality of Service（サービス品質） \\
  PDR &amp; Packet Delivery Ratio \\
  RSSI &amp; Received Signal Strength Indicator \\
  TL &amp; Time-to-first-Receive（発見遅延） \\
  outage &amp; 期限超過（$P_{\mathrm{out}}(\tau)$） \\
  PTQ &amp; Post-Training Quantization \\
  TFLite &amp; TensorFlow Lite \\
  SD &amp; Secure Digital（SDカード） \\
  UART &amp; Universal Asynchronous Receiver-Transmitter \\
  SPI &amp; Serial Peripheral Interface \\
  I\textsuperscript{2}C &amp; Inter-Integrated Circuit \\
  DUT &amp; Device Under Test（被測定対象） \\
  TX &amp; 送信側（DUT） \\
  RX &amp; 受信側（ロガ） \\
  TXSD &amp; 電力ロガ（送信側の電力計測） \\
  SYNC/TICK &amp; 試行境界・広告回数の同期信号 \\
  \bottomrule
\end{longtable}</file><file path="修士論文/chapters/appx_g_troubleshooting.tex">% chapters/appx_g_troubleshooting.tex --- 付録G トラブルシューティング集
\section{トラブルシューティング集}
\label{sec:troubleshooting}

本節では，実験運用で経験した代表的なトラブルを整理し，原因の切り分けと対策をまとめる．目的は，欠損や時間軸不整合によって結論が崩壊することを避け，再現性を高めることである．

\subsection{症状からの切り分け}
\begin{longtable}{p{0.28\linewidth}p{0.32\linewidth}p{0.34\linewidth}}
  \caption{症状からの切り分け（例）}\label{tab:troubleshooting_by_symptom}\\
  \toprule
  症状 &amp; 疑う箇所 &amp; まず確認すること \\
  \midrule
  \endfirsthead
  \toprule
  症状 &amp; 疑う箇所 &amp; まず確認すること \\
  \midrule
  \endhead
  OFFがONより大きい（$\Delta E&lt;0$） &amp; 欠損，単位換算，条件混在 &amp; 生ログ再積分とsummaryの一致，コード系列の統一 \\
  TL/Poutが不自然に小さい &amp; RXとtruthの時間軸ずれ &amp; 定数オフセット補正（v5）を適用したか \\
  PDRが1を超える &amp; 重複受信の混入 &amp; seqユニーク化（PDR\_unique）を優先 \\
  adv\_countが期待値と乖離 &amp; TICK未接続，推定の誤差 &amp; TICK物理カウントの有無，推定式の前提 \\
  SDログが途中で途切れる &amp; SD I/O，電源，ファイルopen &amp; 末尾summaryの有無，open/initエラー \\
  数値列に文字が混入する &amp; UART品質，ボーレート過大 &amp; ボーレート低下，厳密パース，配線見直し \\
  \bottomrule
\end{longtable}

\subsection{代表的トラブル}
\subsubsection{広告OFFの方が消費が大きい（$\Delta E&lt;0$）}
広告OFFが広告ONより大きい結果は，物理的に矛盾して見えるため，最優先で切り分ける必要がある．本研究では，無線スタックの影響を議論する前に，計測・解析起因の破綻を疑う．
\begin{itemize}
  \item 主要因候補：I/Oボトルネックによる欠損，単位換算ミス，条件混在（コード系列の違い）．
  \item 対策：生ログ（mV/µA）から再積分し，summaryと一致することを監査する．比較は同一コード系列で統一し，sleepの有無も条件として明示する．
  \item 判断：監査を通過した上で$\Delta E&lt;0$が再現する場合，電源ドメインや無線状態遷移など物理要因を再検討する．
\end{itemize}

\subsubsection{TL/Poutの過小評価（開始位相ずれ）}
RXログの開始がtruthより遅れる等の理由で，RXの時間軸とtruthの時間軸が一致しない場合がある．このずれを補正しないと，TLや$P_{\mathrm{out}}(\tau)$が過小評価される．本研究ではv5として，seqから定数オフセットを推定して補正する手順を採用する（\secref{sec:stress_fixed_metrics}）．

\subsubsection{UARTデータ化け（数値列への文字混入）}
UARTログが壊れると，欠損や桁ズレが連鎖し，積分と分母（試行時間・広告回数）が不整合になる．
\begin{itemize}
  \item 兆候：パーサの例外，行数不足，msが単調増加しない，0埋め行の増加．
  \item 対策：ボーレートを下げる，出力列を最小化する，パース失敗は試行ごと除外し理由を記録する．
  \item 再発防止：末尾summaryの生成を必須とし，欠損率が閾値を超えた試行は自動で失格にする．
\end{itemize}

\subsubsection{SYNC検出失敗（短パルス）}
SYNCが短パルスとして出力されると，受信側で取りこぼす可能性がある．境界が崩れると，TL/Poutの定義（イベント時刻）と電力積分区間が一致しなくなる．
\begin{itemize}
  \item 対策：SYNCをHIGH保持する，受信側でラッチする，開始と終了の両方を同期する．
  \item 監査：TXSD summaryのms\_totalが想定長と一致すること，RXの試行数が一致することを確認する．
\end{itemize}

\subsubsection{SD I/O失敗（open/init）}
SDカード初期化やファイルopenに失敗した状態で試行を継続すると，欠損が増え，評価が不能になる．
\begin{itemize}
  \item 対策：SPIクロック調整，塊書き込み，open/init失敗時の即時停止と再試行．
  \item 監査：各trialファイルの末尾summaryの存在と整合を確認する．
\end{itemize}

\subsection{解析前の最終監査}
解析を自動化しても，入力が壊れていると結論が壊れる．したがって，解析前に以下を最低限チェックする．
\begin{itemize}
  \item 末尾summary（ms\_total, adv\_count, E\_total等）が存在し，桁が妥当である．
  \item 生ログの再積分がsummaryと整合し，単位換算が一貫している．
  \item RXの試行数・条件IDがTXSDと一致し，条件混在がない．
  \item 重要データはSHA256を記録し，同一入力で再現できる．
\end{itemize}</file><file path="修士論文/chapters/appx_h_ccs_params.tex">% chapters/appx_h_ccs_params.tex --- 付録H CCS写像とパラメータ（版管理）
\section{CCS写像とパラメータ（版管理）}
\label{sec:ccs_params}

本節では，Phase 1（ルールベース）で用いるCCS写像と主要パラメータを一覧化し，モデル更新時の再キャリブレーション対象を明確化する．評価の再現性のため，パラメータは実験ログ（TX）に保存し，作業ログに変更履歴を残す．

\subsection{主要パラメータ（Phase 1既定値）}
表\ref{tab:ccs_params_phase1}に，Phase 1で用いる代表的パラメータを示す．これらはモデルの出力分布や量子化誤差に依存するため，モデル更新時には再キャリブレーションが必要となる．

\begin{table}[tb]
  \centering
  \caption{CCS写像と安定化の主要パラメータ（例）}
  \label{tab:ccs_params_phase1}
  \begin{tabular}{p{0.28\linewidth}p{0.18\linewidth}p{0.44\linewidth}}
    \toprule
    パラメータ &amp; 値（例） &amp; 説明 \\
    \midrule
    $\alpha$ &amp; 0.7 &amp; $\mathrm{CCS}=\alpha(1-U)+(1-\alpha)S$ の重み \\
    $W$ &amp; 5 &amp; 安定度$S$の窓長（遷移回数の正規化） \\
    $\theta_{\mathrm{low}}$ &amp; 0.80 &amp; ACTIVE$\leftrightarrow$UNCERTAINの閾値（上り） \\
    $\theta_{\mathrm{high}}$ &amp; 0.90 &amp; UNCERTAIN$\leftrightarrow$QUIETの閾値（上り） \\
    $h$ &amp; 0.05 &amp; ヒステリシス幅（下りは$\theta-h$） \\
    $t_{\min}$ &amp; \SI{2}{\second} &amp; 最小滞在時間（切替の振動抑制） \\
    行動集合 &amp; $\{100,500,2000\}$ ms &amp; Phase 1の最小構成（拡張候補は$\{100,500,1000,2000\}$） \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{ログへの記録項目}
方策の説明可能性と再現性のため，少なくとも以下をTXログに記録する．
\begin{itemize}
  \item $U,S,\mathrm{CCS}$と，選択した広告間隔$a$
  \item $\theta_{\mathrm{low/high}}$，ヒステリシス幅$h$，最小滞在時間$t_{\min}$
  \item 切替理由（\texttt{\detokenize{reason}}）
\end{itemize}
これにより，結果図表の背後にある意思決定とパラメータを監査できる．</file><file path="修士論文/chapters/ch0_introduction.tex">% chapters/ch0_introduction.tex --- 第1章 序論
\chapter{序論}
\clearpage

\section{研究背景と社会的文脈}
ウェアラブル端末やエッジデバイスにおいて，推論結果を近傍のスマートフォンへ低遅延に通知する仕組みは，見守りや労働安全など多くの応用で重要である．一方で，常時高頻度に通信を行うと電力消費が増大し，小型バッテリでの長時間運用が困難となる．Bluetooth Low Energy（BLE）の広告（Advertising）は接続を前提としない軽量な近傍通信手段として広く利用されているが，受信側（スマートフォン）のスキャン動作はOSや端末状態に依存し，連続スキャンが保証されない．

\section{課題設定と狙い}
本研究は，アプリケーション層（HAR）で得られる推論不確実度を通信層の制御に利用し，QoS制約（一定時間以内に受信されること）を満たしながら省電力化する枠組みを扱う．推論不確実度と時間的安定度から複合スコアCCSを構成し，その値に応じて広告間隔を段階的に切り替えるルールベース方策を定義する．さらに，送信・受信・電力計測を統合した計測基盤を整備し，電力指標とQoS指標を同一試行で評価できる形に整理する．

\section{問題意識：エッジHARの「推論」と「通信」のねじれ}
ウェアラブル端末やエッジデバイスは，慣性センサ等から人の状態を推定し，異常や重要な変化を近傍のスマートフォンへ通知する用途で用いられる．このとき，アプリケーション層では「推論ができた瞬間に，できるだけ早く届けたい」という要求がある一方，通信層では「常に高頻度に送ると電力が増える」というトレードオフがある．

さらに，BLE広告は送信側の制御が容易である反面，受信側（スマートフォン）のスキャン挙動はOSや端末状態に依存し，連続スキャンが保証されない．したがって，広告間隔を固定して設計した場合，環境変化により「必要なときに届かない」か「届くが電力を使いすぎる」状況が生じ得る．

本研究は，このねじれを緩和するために，アプリケーション層（HAR）で得られる推論不確実度を通信制御に利用し，「いま確信が高いか低いか」に応じて送信頻度を調整する枠組みを扱う．

\section{本研究の核となる主張}
本研究の核となる主張は，次のとおりである．
\begin{quote}
HAR不確実度に基づくBLE広告間隔の適応制御において，単純な閾値ルールでも固定間隔より省電力になりうることを示し，将来のSafe Contextual Bandit最適化の基盤を与える．
\end{quote}

\section{研究課題：QoS制約下での省電力化}
本研究の目的は，受信遅延に基づくQoS制約を満たしつつ，電力消費を抑制することである．代表的なQoSとして，イベント発生後に最初に受信されるまでの遅延（TL）を用い，期限$\tau$を超える確率を
\begin{equation}
  P_{\mathrm{out}}(\tau)=P(\mathrm{TL}&gt;\tau)
\end{equation}
として定義する（詳細は\secref{sec:metrics_detail}）．このとき，広告間隔$a$の選択（固定または動的切替）を含む方策$\pi$に対して，以下の形で整理できる．
\begin{equation}
  \text{minimize}\quad \mathbb{E}[q_{\mathrm{event}}(\pi)]
  \quad \text{subject to}\quad P_{\mathrm{out}}(\tau;\pi)\le \delta
\end{equation}
ここで$q_{\mathrm{event}}$（単位：$\si{\micro\coulomb}/\text{event}$）は，セッション中の電荷消費をイベント数で正規化した指標である．平均電力$\overline{P}$や$\Delta E/N_{\mathrm{adv}}$等は従属指標として併用し，単位監査や原因切り分けに用いる（\secref{sec:metrics_detail}）．

\section{本研究の貢献}
本研究の貢献を以下にまとめる．
\begin{enumerate}
  \item 推論不確実度$U$と安定度$S$から複合スコアCCSを構成し，広告間隔を段階的に切り替えるルールベース方策として定義した．
  \item 送信（TX）・電力（TXSD）・受信（RX）の三ノード構成と同期信号（SYNC/TICK）により，同一試行で電力とQoS（TL，$P_{\mathrm{out}}(\tau)$）を評価できる計測基盤を整備した．
  \item TL/Poutの算出において開始位相ずれが結果を歪め得ることを示し，定数オフセット補正（v5）として指標定義を固定した．
  \item オフライン評価（mHealth合成）により，固定間隔点と候補方策点のトレードオフ（δ帯・Pareto）を可視化し，実機実験の探索空間を縮小する枠組みを示した．
  \item Phase 2の拡張として，$U,S$をコンテキスト，広告間隔を行動，$P_{\mathrm{out}}(\tau)$を制約とするSafe Contextual Banditへ接続できる形で問題設定を整理した．
\end{enumerate}

\section{スコープと前提（Phase 1 / Phase 2）}
本研究は，Phase 2でのSafe Contextual Bandit最適化を見据えつつ，Phase 1として「決め打ちルールで評価指標と計測系を確立する」段階に焦点を当てる．したがって，本論文のスコープは次のとおりである．

\subsection{IN（本論文で扱うこと）}
\begin{itemize}
  \item $U,S,\mathrm{CCS}$の定義とログ化（推論不確実度を通信制御へ接続するための最小要素）．
  \item ルールベース方策（閾値，ヒステリシス，最小滞在時間）と，実機での動作確認．
  \item 一次KPI（$\si{\micro\coulomb}/\text{event}$，$P_{\mathrm{out}}(\tau)$，TL\_p95）の測定方法と再現性の確立．
\end{itemize}

\subsection{OUT（本論文では深掘りしないこと）}
\begin{itemize}
  \item Safe Banditの学習アルゴリズムそのものの実装・オンライン学習（将来課題として定式化までを示す）．
  \item スキャン窓の推定など，受信側OS挙動の同定（非理想スキャン前提で端末内比較を行う）．
  \item HARモデルの最終性能の到達（TinyMLの未完タスクは明示し，評価系の枠組みを主張する）．
\end{itemize}

\section{本論文の構成}
本論文は，章数を抑えつつ各章を厚くし，特に再現性確保（ログ設計・指標定義・運用手順・破綻モード）を本文内で明示する構成を採用する．第2章では背景と関連研究を統合し，BLE広告・非理想スキャン・sleepの位置づけと関連アプローチを整理する．第3章ではシステム設計と提案手法をまとめ，World Model，一次KPI，HAR不確実度，CCS写像とパラメータを整理する．第4章では計測系・ログ設計・指標定義・Runbook・トラブルシューティングを統合し，再現性のための前提を固定する．第5章ではストレス固定，オフライン評価，実機評価結果をまとめ，固定点と提案方策の比較を示す．第6章では考察として，非理想スキャン下での解釈，sleepの扱い，失敗・未完タスクの位置づけ，およびPhase 2（Safe Contextual Bandit）への展望を述べる．最後におわりにで全体をまとめる．</file><file path="修士論文/chapters/ch1_background.tex">% chapters/ch1_background.tex --- 第2章 背景
\section{背景}

\subsection{BLEアドバタイズとスキャンの基礎}
Bluetooth Low Energy（BLE）の広告は，接続を確立せずに情報をブロードキャストでき，端末側の実装が容易である\scite{bluetooth_core_spec}．一方で，広告は受信側のスキャン窓に依存して観測されるため，送信側がどれだけ制御しても「確実に届く」とは限らない．本節では，広告とスキャンの基本要素を整理する．

\subsubsection{広告イベントと3チャネル}
広告は，規格上の広告チャネル（37/38/39）を用いて送信される．送信側は，広告間隔を$T_{\mathrm{adv}}$として，概ね$T_{\mathrm{adv}}$ごとに広告イベントを発生させる．広告イベントは複数チャネルに送信されるが，周波数ホッピングや干渉により，受信側で観測される成否は確率的になる．

\subsubsection{スキャン間隔・ウィンドウとデューティ比}
受信側は，スキャン間隔$T_{\mathrm{scan}}$ごとに，スキャンウィンドウ$d_{\mathrm{scan}}$の間だけ受信機を有効化する．スキャンのデューティ比$\delta$は
\begin{equation}
  \delta=\frac{d_{\mathrm{scan}}}{T_{\mathrm{scan}}}
\end{equation}
で定義できる．$\delta$が小さいほど受信側は省電力になるが，広告イベントとの重なりが起きにくくなり，発見遅延が増える．

\subsubsection{発見遅延（TL）の概念}
イベント発生後，最初に広告が受信されるまでの遅延をTL（Time-to-first-Receive）とする．TLは，広告間隔とスキャン窓の相互作用（位相差）で分布が決まるため，平均受信率だけではQoSを十分に表現できない．本研究では，一次KPIとして省電力指標$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$），TL分布の裾（TL\_p95），および期限超過率$P_{\mathrm{out}}(\tau)$を採用する．

\subsection{``非理想スキャン&apos;&apos;という現実}
スマートフォンのスキャン挙動は，端末機種，OSバージョン，画面状態，省電力機構，および他アプリの利用状況に依存して変化する．Androidでは，アプリケーションがスキャンを要求しても，OSが内部的にスキャンの間欠化やスロットリングを行う可能性がある\scite{android_ble_scanner}．このため，本研究ではスキャンを理想的な一定窓として仮定せず，「非理想で観測できない内部状態がある」前提で送信側の制御を議論する．

\subsubsection{Valley Area（ブラインドスポット）}
広告間隔とスキャン周期が高調波関係に近い場合，広告イベントが系統的にスキャン窓の外側へ入り続け，発見遅延が極端に悪化する領域が生じ得る．このような領域は，平均的な受信率が同程度でもTLの裾を悪化させるため，$P_{\mathrm{out}}(\tau)$により議論する必要がある．

\subsubsection{Androidのスキャンモードと前提条件}
AndroidのBLEスキャンは，アプリケーションが要求するスキャンモード（例：LOW\_LATENCY）だけで挙動が一意に定まるとは限らない\scite{android_ble_scanner}．画面状態や電源管理の影響により，アプリケーションが意図したとおりに連続スキャンできない場合がある．したがって，本研究は「受信側スキャンは非理想である」前提で，送信側が取り得る適応制御の範囲を議論する．

\subsubsection{OS側のスロットリングとオポチュニスティック・スキャン}
スマートフォン側では，複数アプリのスキャン要求を統合するような挙動や，バックグラウンド制約に起因するスロットリングが生じ得る．これらはアプリケーション側から直接観測・制御できないため，評価では端末内比較と運用条件の固定（スキャンモード，画面状態等）が重要となる．

\subsubsection{端末内比較という評価姿勢}
スキャン挙動が端末・OS状態に依存する以上，異なる端末間の比較は外的要因が支配的になりやすい．本研究は，固定条件と提案条件を同一端末・同一設定で取得し，同一パイプラインで集計する端末内比較を基本とする．

\subsection{sleepをどう捉えるか}
本研究の評価は，送信側の電力と受信側のQoSを同時に扱う．このとき，sleep（間欠動作）の扱いは，受信側と送信側で意味が異なるため，整理が必要である．

\subsubsection{スキャナ側のsleep（scan dutyの縮退）}
受信側のsleepは，スキャンデューティ比$\delta$の低下として観測される．これはOSの省電力機構に起因し，アプリケーション側から直接制御できない場合が多い．スキャナ側のsleepは，TL分布の右裾を伸ばし，$P_{\mathrm{out}}(\tau)$を悪化させる方向に作用する．

\subsubsection{アドバタイザ側のsleep（平均電力の低下）}
送信側（DUT）のsleepは，CPUや無線を低消費電力状態に移行させることで平均電力を下げる．広告間隔を長くすると無線イベント回数が減るだけでなく，sleepに入れる時間が増えるため，平均電力が低下しやすい．本研究の予備計測（sleep\_eval\_scan90）では，固定\SI{100}{\milli\second}から固定\SI{500}{\milli\second}への変更で平均電力が大きく低下する一方，\SI{500}{\milli\second}以上では改善幅が小さくなる傾向が確認されている（詳細は\secref{sec:evaluation_results}）．

\subsubsection{広告が支配的コストになりやすい理由}
広告イベントは，無線送信に加えてスタック処理や割り込み等を伴うため，完全なスタンバイsleepより高コストになりやすい．そのため，広告間隔の制御は「通信頻度そのものの削減」と「sleep時間の増加」という2つの経路で省電力に寄与する．

\subsection{不確実度$U$・安定度$S$・CCSの基礎}
端末内推論（HAR）は，クラス確率分布として出力を持つことが多い．この確率分布から不確実度$U$を導出すると，「いまの推論がどの程度信頼できるか」を定量化できる．一方で，確率は瞬間的に揺らぐため，時間的一貫性を表す安定度$S$も併用する設計が有効である．

\subsubsection{CCSの直感}
複合スコアCCSは，確信度$(1-U)$と安定度$S$を組み合わせた指標であり，「確信が高く，かつ安定しているほど長間隔を選びやすい」という単調な解釈を与える．この単調性は，ルールベース方策の説明容易性に寄与する．

\subsubsection{感度分析の必要性}
CCSは係数（例：$\alpha$）や窓長$W$に依存するため，分布が変わると閾値の意味が変化する．本研究では，Phase 1では説明容易性を優先し，固定の係数でルールベース評価を行う．係数感度や較正は，今後の課題として整理する（関連研究・TinyML章を参照）．

\subsection{まとめ}
本節では，BLE広告とスキャンの基本要素，非理想スキャン，sleepの二面性，および不確実度指標の位置づけを整理した．次節では，これらを踏まえて関連研究を整理し，本研究の新規性と立脚点を明確化する．</file><file path="修士論文/chapters/ch10_implementation.tex">% chapters/ch10_implementation.tex --- 第10章 実装（ファームウェア・解析パイプライン）
\section{実装：ファームウェアと解析パイプライン}

\subsection{目的}
本研究では，方策の比較を可能にするため，計測系と解析パイプラインを共通化した．本節では，実装の要点（ログ設計，同期，解析フロー）を整理する．

\subsection{ファームウェア構成}
ファームウェアは役割ごとに送信（TX），受信（RX），電力ロガ（TXSD）に分割する．各スケッチは，役割がファイル名から判別できるよう命名し，試行境界の同期とログ出力形式を統一する．

\subsubsection{命名規約}
実験の再現性を担保するため，スケッチ名は役割別に接頭辞を付与する．
\begin{itemize}
  \item RX\_*：受信ロガ（RX）
  \item TX\_*：送信・被測定対象（TX）
  \item TXSD\_*：送信側の電力ロガ（TXSD）
\end{itemize}
この規約により，ファイル名だけで役割が判別でき，Runbookや作業ログから参照しやすくなる．

\subsection{ログ形式}
本研究の解析は，TXSDログ（電力）とRXログ（受信）を中心に行う．特に，広告回数（adv\_count）や試行時間（ms\_total）の扱いは，指標の分母・分子に直結するため，ログ末尾のsummaryを正として扱う．

\subsubsection{解析で重要な列}
TXSDログでは，時刻（ms）と計測値（mV，$\mu$A）が一次情報であり，平均電力や総エネルギーはここから再計算できる．RXログでは，受信時刻とseqがTL/PoutおよびPDR\_uniqueの計算に必須である．したがって，ログ設計では「後から復元できる列」を優先し，表示用の派生列は監査可能な形で保持する．

\subsection{解析パイプラインの流れ}
解析は，概ね以下の段階で行う．
\begin{enumerate}
  \item trialごとのログを読み込み，欠損や単位の整合をチェックする．
  \item TXSDから平均電力・総エネルギー等を算出する．
  \item RXからPDR，TL，Pout(τ)を算出する（必要に応じて時間同期を行う）．
  \item 条件ごとに集約し，図表を生成する．
\end{enumerate}

\subsubsection{代表的なスクリプト}
解析は，試行ごとの集計，条件ごとの集約，図表生成に分割することで，再実行と検証を容易にする．例えばストレス固定の解析では，時間同期を含む集計と，集約・図表化を分離して実行できるように整備した．

\subsection{再現性のための運用}
解析対象の選別（除外理由），生成コマンド，入力データの出典・ハッシュ等を記録し，再現可能な形で結果を残す．作業ログとインデックスを併用して，後から辿れる状態を維持する．

\subsection{まとめ}
本節では，ファームウェアと解析パイプラインの要点を整理した．これにより，固定間隔と動的制御を同一基盤で比較できる．</file><file path="修士論文/chapters/ch2_background_related.tex">% chapters/ch2_background_related.tex --- 第2章 背景・関連研究（統合）
\chapter{背景・関連研究}
\clearpage

本章では，本研究の前提となるBLE近隣発見の基礎，非理想スキャン，sleepの二面性，不確実度指標の位置づけを整理する．続いて関連研究を概観し，本研究の立脚点と新規性を明確化する．

\input{chapters/ch1_background}
\input{chapters/ch2_related_work}</file><file path="修士論文/chapters/ch2_proposed.tex">% chapters/ch2_proposed.tex --- 第6章 提案手法（CCS→広告間隔制御）
\section{提案手法：CCSに基づくBLE広告間隔制御}
\label{sec:proposed_method}

\subsection{問題設定}
本研究は，広告間隔$a$を選択する方策$\pi$に対して，電荷指標$q_{\mathrm{event}}$を小さくしつつ，受信遅延に基づく期限超過率$P_{\mathrm{out}}(\tau)$を制約する問題として整理する（問題設定は\secref{sec:measurement_setup}と\secref{sec:metrics_detail}に従う）．

\subsection{不確実度と安定度}
HARモデルの出力確率分布から不確実度$U\in[0,1]$を導出し，過去一定窓におけるラベル遷移回数から安定度$S\in[0,1]$を導出する（算出方法と前提は\secref{sec:har_uncertainty}）．

\subsection{複合スコアに基づく広告間隔制御}
不確実度と安定度から複合スコア（Composite Confidence Score：CCS）を構成し，その値に応じて広告間隔を段階的に切り替える．本研究では，実装の単純性と説明容易性のためにルールベース方策を採用し，閾値とヒステリシス，最小滞在時間により切替の振動を抑制する．

\subsubsection{複合スコアCCS}
CCSは，不確実度$U$と安定度$S$の線形結合として定義し（\secref{sec:har_uncertainty}），閾値写像により広告間隔へ変換する．

\subsubsection{閾値写像}
CCSを3段階に分け，広告間隔$a\in\{100,500,2000\}\,\si{\milli\second}$へ写像する．閾値を$\theta_{\mathrm{low}}$，$\theta_{\mathrm{high}}$（$\theta_{\mathrm{low}}&lt;\theta_{\mathrm{high}}$）とすると，
\begin{equation}
  a(\mathrm{CCS}) =
  \begin{cases}
    2000\,\si{\milli\second} &amp; (\mathrm{CCS}\ge\theta_{\mathrm{high}})\\
    500\,\si{\milli\second}  &amp; (\theta_{\mathrm{low}}\le\mathrm{CCS}&lt;\theta_{\mathrm{high}})\\
    100\,\si{\milli\second}  &amp; (\mathrm{CCS}&lt;\theta_{\mathrm{low}})
  \end{cases}
\end{equation}
と定義する．

\subsubsection{ヒステリシスと最小滞在時間}
CCSは推論誤差やセンサノイズにより揺らぐため，単純な閾値写像では切替が過度に発生しうる．そこで，閾値にヒステリシス（上下で異なる閾値）を持たせる．また，最小滞在時間を設け，滞在時間が一定値未満の間は切替を抑制する．

なお，Phase 1で用いる代表的なパラメータ（$\alpha,W,\theta_{\mathrm{low/high}}$，ヒステリシス幅，最小滞在時間）は\secref{sec:ccs_params}に一覧化する．

\subsubsection{切替規則（実装上の要点）}
実装は，現在の間隔$a_t$とCCSの観測値$\mathrm{CCS}_t$から次の間隔$a_{t+1}$を決定する有限状態機械として表せる．本研究では以下を満たす設計とする．
\begin{itemize}
  \item \textbf{単調性}：CCSが高いほど長間隔側を選びやすい．
  \item \textbf{安全側への退避}：QoS悪化の兆候がある場合は短間隔へ戻す余地を残す．
  \item \textbf{振動抑制}：ヒステリシスと最小滞在時間で切替頻度を抑える．
\end{itemize}
切替規則の例は，実験装置・計測方式（\secref{sec:measurement_setup}）および実験設計（\secref{sec:experiment_design}）で示す条件（閾値，滞在時間）と併せて具体化する．

\subsection{ログと説明可能性（Observability）}
動的制御の評価では，「なぜその間隔を選んだか」を後から説明できることが重要である．特に，本研究は非理想スキャンを前提とするため，受信品質の変動をすべて送信側のせいにできない．したがって，方策の意思決定（$U,S,\mathrm{CCS}$）と，使用したパラメータ（閾値，ヒステリシス，最小滞在時間等）をログとして残し，観測可能性を担保する．

\subsubsection{切替理由（reason）を毎回残す}
切替のたびに，閾値越え，ヒステリシス判定，最小滞在時間による抑制，フェイルセーフ退避などの理由を\texttt{\detokenize{reason}}として記録する．これにより，結果図表の背後にある「切替の根拠」を監査できる．

\subsubsection{Tx/Rx/Powerのスキーマ}
TXログは方策の内側（$U,S,\mathrm{CCS}$と選択した$a$），RXログは受信時刻とseq，TXSDログは電流・電圧系列とsummaryを保持する．ログ列の詳細は\secref{sec:log_schema}に示し，\secref{sec:runbook}に従って運用条件（端末，スキャン設定，sleepの有無）を固定する．

\subsection{動的切替の最小構成（2値制御）}
実機実験の初期段階では，電力低下の主効果が短間隔滞在の削減にあることを踏まえ，広告間隔を\SI{100}{\milli\second}と\SI{500}{\milli\second}の2値に限定した動的切替を用いる．この最小構成により，計測系の同期とログ整合を保ちつつ，動的切替が期待通りに動作することを確認する．

\subsubsection{2値制御の目的}
2値制御は，行動空間を小さくすることで，実装・解析の複雑性を抑える目的がある．また，\SI{100}{\milli\second}と\SI{500}{\milli\second}の差は平均電力の主効果になりやすく，省電力化の寄与を説明しやすい．</file><file path="修士論文/chapters/ch2_related_work.tex">% chapters/ch2_related_work.tex --- 第3章 関連研究
\section{関連研究}

\subsection{BLE広告・近隣発見の最適化}
BLE広告における主要設計パラメータは，広告間隔，送信チャネル数，送信電力等である．これらは到達性（受信率・遅延）と電力のトレードオフに直結するため，固定値の最適化や，状況に応じた動的制御が検討されてきた．

\subsubsection{MABでintervalを選ぶ考え方}
広告間隔の動的制御は，混雑度推定や直近の受信状況に基づくルールとして実装されることが多い．一方で，未知・非定常な環境では，有限個の行動集合からオンラインで運用点を学習する枠組み（マルチアーム・バンディット）も候補となる\scite{lattimore2020bandit}．本研究はPhase 2での拡張可能性を残しつつ，Phase 1では学習以前の前提（指標・計測）を確立する立場を採る．

\subsubsection{3チャネル送信と電力}
BLE広告は広告チャネル（37/38/39）で送信されるため，チャネル数や送信回数は到達性と電力に影響する．本研究はPhase 1ではチャネルマスク等を固定し，広告間隔の効果と不確実度駆動制御の枠組みに焦点を当てる．

\subsubsection{学習しない設計（多重化等）}
学習を用いないアプローチとしては，複数の間隔や送信パターンを組み合わせ，Valley Areaの影響を平均化する設計も考えられる．ただし，受信側スキャンが非理想である場合，無線側のパラメータだけで性能が決まらないため，アプリケーション層の状態（遷移期／安定期）を併用した説明が必要となる．

\subsection{遅延制約・Outage解析}
近隣発見では，平均遅延だけでなく，期限超過率$P_{\mathrm{out}}(\tau)$や遅延分布の裾（例：TL\_p95）が重要である．スキャン窓のデューティ比が低い場合，平均受信率が一定でも遅延分布が右に伸び，$P_{\mathrm{out}}(\tau)$が支配的な評価軸になる．

理想化した周期モデルでは，広告イベントとスキャン窓の相互作用から遅延分布を解析できるが，実際のスマートフォンはOSの省電力機構によりスキャンが間欠化し，観測できない内部状態が存在する．したがって，本研究では解析モデルによる厳密導出ではなく，実測ログに基づき$P_{\mathrm{out}}(\tau)$と電力のトレードオフを描き，方策比較を端末内比較として解釈する．

\subsubsection{scan duty・sleepとoutageの関係}
受信側のsleepは，スキャンデューティ比の縮退として現れ，TL分布の裾を悪化させる方向に作用する．一方で送信側のsleepは，広告間隔の延伸と組み合わせることで平均電力を下げる．この二面性を踏まえ，sleepは背景・装置・考察に分散して扱う必要がある．

\subsection{不確実度駆動の通信制御（クロスレイヤー）}
推論モデルが出力する確率分布は，不確実度として定量化できる．不確実度に基づいて「重要なときだけ通信する」「確信が低いときだけサンプリングや送信を増やす」といった制御は，エッジAIにおける省電力化の代表的な戦略である．

ただし，不確実度の定義や較正が不適切であると，確信が過大評価されて長間隔に偏り，QoS違反が増える危険がある．本研究では，確率較正の必要性を踏まえつつ（将来課題），まずは確率分布から導出した$U$と時間的一貫性$S$を組み合わせ，説明可能な複合スコアCCSとして通信制御へ接続する．

\subsection{TinyML環境での制約付き学習・実装論}
MCU上で学習・制御を実装する場合，RAMや演算資源の制約により，実装可能なアルゴリズムが制限される．現実的には，学習器そのものは単純な最適化に徹し，その外側にSafety Filter（Action Masking等）を置いてハード制約を担保する構造が採られることが多い．

本研究の行動集合（広告間隔）は小さいため，Phase 2での拡張としては，低次元のコンテキストに対する軽量なContextual Banditが候補となる．一方，Phase 1の段階では，実験計測と指標定義がボトルネックになるため，まずはルールベース方策で再現性の高いデータを取得することが重要である．

\subsection{オンライン最適化（バンディット）と安全制約}
医療・見守り等の用途ではQoS違反が許容されにくく，探索の過程で制約を破るリスクが課題となる．このため，本研究は，Phase 1として安全側のルールベース方策と評価指標を確立した上で，将来課題として安全制約付きのContextual Bandit（Safe Contextual Bandit）へ接続する方針を採る．

\subsection{本研究の位置づけ}
表\ref{tab:related_work_positioning}に，本研究と関連アプローチの整理を示す．本研究は，「不確実度を用いた動的制御」と「電力＋QoSの同時実測」を同一の評価系で統合し，Phase 2の安全制約付きオンライン最適化へ接続できる形に整理する点に特徴がある．

\begin{table}[tb]
  \centering
  \caption{関連アプローチと本研究の位置づけ（概念整理）}
  \label{tab:related_work_positioning}
  \begin{tabular}{p{0.22\linewidth}p{0.22\linewidth}p{0.22\linewidth}p{0.22\linewidth}}
    \toprule
    区分 &amp; 主な入力 &amp; 制御の形式 &amp; 評価の主軸 \\
    \midrule
    固定設計 &amp; 規格・経験値 &amp; 固定$a$ &amp; 平均電流，PDR \\
    ルールベース &amp; 混雑度・直近受信 &amp; 閾値で切替 &amp; 平均電力，遅延 \\
    バンディット &amp; 観測（報酬） &amp; 探索＋活用 &amp; 報酬最大化 \\
    本研究 &amp; $U,S,\mathrm{CCS}$ &amp; ルール（Phase 1） &amp; $\overline{P}$，$P_{\mathrm{out}}(\tau)$，TL\_p95 \\
    \bottomrule
  \end{tabular}
\end{table}</file><file path="修士論文/chapters/ch3_oncampus.tex">% chapters/ch3_oncampus.tex --- 第7章 実験装置・計測方式
\section{実験装置・計測方式}
\label{sec:measurement_setup}

\subsection{概要}
本研究の一次KPIは，省電力指標$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$）とQoS（TL，$P_{\mathrm{out}}(\tau)$）である．これらを同一試行で評価するため，送信（TX），電力（TXSD），受信（RX）の三ノード構成を採用し，同期信号で試行区間を揃える．本節では，計測方式とログ設計を「再現できる手順」として整理する．

\subsection{三ノード構成（TX/TXSD/RX）}
各ノードの役割を表\ref{tab:nodes}に示す．

\begin{table}[tb]
  \centering
  \caption{評価系のノード構成}
  \label{tab:nodes}
  \begin{tabular}{lll}
    \toprule
    ノード &amp; 役割 &amp; 主なログ \\
    \midrule
    TX &amp; BLE広告送信・間隔制御 &amp; ペイロード（時刻/タグ），制御状態 \\
    TXSD &amp; 電力計測（INA219） &amp; 電圧・電流系列，集約指標 \\
    RX &amp; 受信ログ取得 &amp; 受信時刻，RSSI，ペイロード \\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{機材と計測パラメータ}
本研究の計測は，汎用マイコン（ESP32系）と電流センサ（INA219）を中心に構成する．表\ref{tab:hw}に，主要な構成要素と役割を示す．

\begin{table}[tb]
  \centering
  \caption{計測システムの主要構成}
  \label{tab:hw}
  \begin{tabular}{ll}
    \toprule
    要素 &amp; 役割 \\
    \midrule
    ESP32（TX） &amp; BLE広告送信，広告間隔制御，ペイロード生成 \\
    ESP32（TXSD） &amp; INA219計測データの収集，SD保存，エネルギー集約 \\
    ESP32（RX）/スマートフォン &amp; 受信ログの取得（時刻，RSSI，seq） \\
    INA219 &amp; 電流・電圧の計測（サンプリング周期は試行条件に依存） \\
    SYNC/TICK &amp; 試行区間の同期，広告回数の物理カウント \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{同期設計（SYNC/TICK）}
\subsubsection{SYNC（試行区間の整列）}
試行（trial）の開始・終了を揃えるために，同期信号（SYNC）を用いる．TXは試行区間の境界でSYNC信号を出力し，TXSDおよびRXはこの信号に同期してログ取得区間を区切る．SYNCにより，「どの区間の電力・受信ログを比較するか」を明確化できる．

\subsubsection{TICK（広告回数の物理カウント）}
広告イベント数$N_{\mathrm{adv}}$は，到達性指標の分母として重要である．可能であれば，TXがTICK信号を出力し，TXSD側で割り込みにより広告回数を物理カウントする．TICKが利用できない場合は，試行時間と広告間隔から期待回数を推定するが，動的切替では誤差が入り得るため解釈に注意する．

\subsubsection{配線例（UCCS評価）}
本研究で用いた配線例を表\ref{tab:wiring_example}に示す（実験ディレクトリのREADMEに準拠）．ピン番号は実装に依存するため，運用時はRunbookに記録して固定する（\secref{sec:runbook}）．

\begin{table}[tb]
  \centering
  \caption{配線例（UCCS評価）}
  \label{tab:wiring_example}
  \begin{tabular}{lll}
    \toprule
    信号 &amp; TX（GPIO） &amp; 受け側（GPIO） \\
    \midrule
    SYNC &amp; 25 &amp; RX:26, TXSD:26 \\
    TICK &amp; 27 &amp; TXSD:33 \\
    \bottomrule
  \end{tabular}
\end{table}

\figref{fig:measurement_architecture_esp32_three_node}に，外部電源およびINA219を含む三ノード計測系（TX/TXSD/RX）の配線・信号構成を示す．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.98\linewidth]{figures/measurement_architecture_esp32_three_node}
  \caption{三ノード計測系のシステムアーキテクチャ（外部電源・INA219・TX/TXSD/RXの配線と信号）}
  \label{fig:measurement_architecture_esp32_three_node}
\end{figure}

\subsection{ログ設計とスキーマ}
解析の再現性を担保するため，ログの列（カラム）を固定する．本研究では，TXSDログ末尾のsummary（例：$N_{\mathrm{adv}}$，$E$，$\overline{P}$）を一次情報として扱い，RXログはPDR/TL評価の基礎とする．ログスキーマの詳細は\secref{sec:log_schema}に示す．

\subsubsection{TXSD（電力）ログ}
TXSDログは，時刻と計測値（電圧・電流）を行ごとに保持し，末尾に集約値を出力する．積分は$\Delta t$を用いた逐次積分とし，後処理でも再積分して監査する（計測系の健全化は\secref{sec:measurement_system}で述べる）．

\subsubsection{RX（受信）ログ}
RXログは，受信時刻，RSSI，ペイロード（seq等）を保持する．重複受信があるため，seqでユニーク化した件数を併記する（\secref{sec:metrics_detail}）．また，TL/Pout算出にはRXログとtruthの時間軸整合が必要であり，定数オフセット補正を用いる（定義と実装は\secref{sec:stress_fixed_metrics}で述べる）．

\subsubsection{ファイル命名}
ログは試行単位で分割し，\texttt{\detokenize{trial_XXX.csv}}等の連番で管理する．条件IDやスキャン設定の違いは，preambleの条件ID（TICKパルス等）と作業ログにより追跡する．

\subsection{計測方針（電力とQoSの同時評価）}
本研究では，電力とQoSを同一試行で同時に評価する．電力はTXSD，QoSはRXを主に用いる．ただし，動的切替では「イベント時刻の定義」と「時間同期」が結果を左右するため，指標定義（特にTL/Pout）は\secref{sec:stress_fixed_metrics}で固定する．

\subsubsection{ON/OFF差分とsleep}
省電力指標$q_{\mathrm{event}}$は，電荷積分に基づくため，ログ欠損や単位不整合の影響を強く受ける．そのため，広告ON/OFF差分による基準補正や，生ログからの再積分監査が重要となる．また，送信側がlight sleep等に入れる条件では，広告間隔を伸ばすことが平均電力低下に直結する．sleepの有無は条件として明示し，同一コード系列で比較する（運用手順は\secref{sec:runbook}）．

\subsection{受信端末の運用（スマートフォン側）}
受信側のスキャン挙動は端末・OS状態に依存するため，実験では運用手順を固定する必要がある．特に，スキャンモード，画面状態，電源状態等を統一し，端末内比較の前提を守る．実験前のチェックリストは\secref{sec:runbook}に示す．

\subsubsection{スキャンアプリと設定例}
受信ログは，BLEスキャナアプリ（例：nRF Connect）等を用いて取得する．再現性の観点から，以下を固定する．
\begin{itemize}
  \item スキャンモード：LOW\_LATENCY相当（可能な範囲で最も積極的なスキャン）
  \item フィルタ：対象UUID等でフィルタする場合は条件として明記し，条件間で統一する
  \item 画面：試行中は画面ONを維持し，アプリを前面に置く
\end{itemize}

\subsubsection{端末状態の固定（端末内比較の前提）}
OSの省電力機構によりバックグラウンド制約やスロットリングが生じ得るため，試行間で端末状態を揃えることが重要である．具体的には，省電力設定の固定，機内モード・Wi-Fi状態の固定，バックグラウンド制限の解除等をRunbookに従って統一する．

\subsection{データ処理の概要}
本研究の解析は，ログを読み込んで指標を算出し，条件ごとに集約して図表を生成する流れである．最小構成として，以下を満たすことを解析の合格条件とする．
\begin{itemize}
  \item 試行区間がSYNCで正しく切れている（期間$T$が想定と一致する）．
  \item TXSDの集約値と後処理の再積分が同程度である（単位・欠損が健全）．
  \item RXのPDR\_uniqueが0付近にならない（受信系が動作している）．
  \item TL/Poutの算出に時間同期（定数オフセット補正）を適用できる．
\end{itemize}

\subsection{まとめ}
本節では，実験装置の構成，同期設計，ログ設計，および運用上の前提を整理した．以降の節では，計測系の破綻モードと修正履歴を\secref{sec:measurement_system}にまとめ，評価の前提を固定する．</file><file path="修士論文/chapters/ch3_system_and_method.tex">% chapters/ch3_system_and_method.tex --- 第3章 システム設計と提案手法（統合）
\chapter{システム設計と提案手法}
\clearpage

本章では，問題設定（World Model，一次KPI，制約）と，HAR推論部から得る不確実度・安定度を用いた広告間隔制御（CCS）を統合して述べる．さらに，CCS写像・パラメータを版管理の観点で整理し，Phase 2（Safe Contextual Bandit）へ接続できる形で前提を固定する．

\input{chapters/ch3_system_design}
\input{chapters/ch9_har_uncertainty}
\input{chapters/ch2_proposed}
\input{chapters/appx_h_ccs_params}</file><file path="修士論文/chapters/ch3_system_design.tex">% chapters/ch3_system_design.tex --- 第4章 問題設定とシステム設計
\section{問題設定とシステム設計}

\subsection{World Model}
本研究は，アプリケーション層（HAR）と通信層（BLE広告）を跨ぐクロスレイヤー制御である．このため，単に広告間隔を調整するだけでなく，「どの情報がどこで生成され，どこで観測されるか」を明確にする必要がある．本節では，役者（Actors）と能力（Capabilities）を整理し，議論の前提を固定する．

\subsubsection{Actors}
表\ref{tab:actors}に，本研究で扱う役者を示す．

\begin{table}[tb]
  \centering
  \caption{Actors（役者）}
  \label{tab:actors}
  \begin{tabular}{p{0.28\linewidth}p{0.62\linewidth}}
    \toprule
    Actor &amp; 役割 \\
    \midrule
    Edge Node / DUT &amp; IMU等からHARを推論し，不確実度$U$・安定度$S$・CCSを生成して広告間隔を制御する（送信側） \\
    Gateway（スマートフォン） &amp; BLE広告を受信する主体．スキャン挙動はOS依存で非理想とみなす（受信側） \\
    Observer（計測系） &amp; 電力（TXSD）と受信（RX）を収集し，一次KPIを算出する（実験時の観測者） \\
    Safety Oracle（概念） &amp; QoS制約$P_{\mathrm{out}}(\tau)\le\delta$を規定する境界（設計上の規格） \\
    Policy Engine &amp; コンテキストから広告間隔を決定する意思決定器（Phase 1はルール，Phase 2でSafe Bandit） \\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Capabilities（5つの柱）}
本研究の設計で重要となる能力を以下にまとめる．
\begin{enumerate}
  \item Perception：HAR推論から確率分布を得て，不確実度$U$と安定度$S$を計算する．
  \item Decision：$U,S$からCCSを構成し，広告間隔$a$を決定する．
  \item Communication：BLE広告として送信し，受信側の非理想スキャン下で到達する．
  \item Safety：QoS制約を守るため，危険兆候では短間隔へ退避できる．
  \item Observability：意思決定の根拠（$U,S,\mathrm{CCS}$，閾値，切替理由）をログに残す．
\end{enumerate}

\subsection{一次KPIと不変条件}
本研究では，議論がぶれないように一次KPIを固定する．表\ref{tab:kpi}に一次・二次KPIを示す．一次KPIは「省電力」と「期限超過」の同時評価を担い，二次KPIは補助指標として扱う．

\begin{table}[tb]
  \centering
  \caption{KPIの整理}
  \label{tab:kpi}
  \begin{tabular}{p{0.22\linewidth}p{0.68\linewidth}}
    \toprule
    区分 &amp; 指標 \\
    \midrule
    一次（Primary） &amp; $\si{\micro\coulomb}/\text{event}$，$P_{\mathrm{out}}(\tau)$，TL\_p95 \\
    二次（Secondary） &amp; 平均電力$\overline{P}$，PDR（unique），RSSI，切替頻度（switch\_rate），平均広告レート（adv\_rate） \\
    \bottomrule
  \end{tabular}
\end{table}

また，設計上の不変条件として以下を採用する．
\begin{itemize}
  \item 後方互換のIF：\texttt{decide\_interval(context) -&gt; interval} の構造を保ち，ルールから学習へ差し替え可能にする．
  \item 端末内比較：受信端末・設定を固定し，OS依存の影響は端末内で相殺して解釈する．
  \item ログ優先：KPI算出に必要な列を必ず残し，派生値は後処理で再計算できる形にする．
\end{itemize}

\subsection{目的関数と制約}
本研究の問題設定は，広告間隔制御により電力（電荷消費）を下げつつ，期限超過率を制約することである．動的制御の方策$\pi$に対し，
\begin{equation}
  \text{minimize}\quad \mathbb{E}[q_{\mathrm{event}}(\pi)]
  \quad \text{subject to}\quad P_{\mathrm{out}}(\tau;\pi)\le \delta
\end{equation}
として表せる．ここで$q_{\mathrm{event}}$（単位：$\si{\micro\coulomb}/\text{event}$）は，セッション中の電荷消費をイベント数で正規化した指標である（定義は\secref{sec:metrics_detail}）．コンテキストとしては$U,S$（またはCCS）を用い，Phase 1ではルール$\pi_{\mathrm{rule}}$，Phase 2では学習$\pi_{\mathrm{safe\_mab}}$を想定する．

\subsection{フェイルセーフと運用設計}
非理想スキャン環境では，受信品質が瞬間的に悪化する可能性がある．このため，実装では安全側への退避（短間隔）を設けることが望ましい．本研究では，切替規則の設計とログ化により，安全側に寄せた挙動を説明可能にする．
具体的には，通常はCCSに応じて広告間隔を選択し，QoS悪化の兆候がある場合は短間隔へ退避できる余地を残す．また，退避の根拠（切替理由）をログに残し，監査可能にする．

\subsection{フェーズ設計（Phase 1 → Phase 2）}
Phase 1では，ルールベース方策で「計測・指標・実機実装」を成立させることを優先する．特に，TL/Poutの定義と時間同期，電力計測の健全化は，学習以前に必須である．Phase 2では，コンテキスト（$U,S$）と行動（広告間隔）の選択をSafe Contextual Banditとして定式化し，環境差に適応しつつQoS制約を守る枠組みを検証する．</file><file path="修士論文/chapters/ch4_measurement_metrics_repro.tex">% chapters/ch4_measurement_metrics_repro.tex --- 第4章 計測系・ログ設計・指標定義（再現性）（統合）
\chapter{計測系と再現性}
\clearpage

本研究は，非理想スキャン環境と実機ログに依存するため，条件混在や欠損により結論が逆転し得る．そのため，本章では再現性確保（計測系，ログ設計，指標定義，運用手順，破綻モード）を本文に統合して明示し，評価の前提を固定する．

\input{chapters/ch3_oncampus}
\input{chapters/ch8_measurement_system}

\section{評価準備（実験設計と実装）}
\label{sec:eval_preparation}
\begingroup
  \let\section\subsection
  \let\subsection\subsubsection
  \input{chapters/ch8_experiment_design}
  \input{chapters/ch10_implementation}
\endgroup

\section{再現性のための詳細資料}
\label{sec:repro_details}
\begingroup
  \let\section\subsection
  \let\subsection\subsubsection
  \input{chapters/appx_d_log_schema}
  \input{chapters/appx_a_metrics}
  \input{chapters/appx_e_runbook}
\endgroup</file><file path="修士論文/chapters/ch4_rain.tex">% chapters/ch4_rain.tex --- 第4章 評価結果
\section{評価結果}
\label{sec:evaluation_results}

\subsection{固定間隔の基準特性}
固定間隔における$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$）と受信品質を基準として整理する．ただし，本節では説明の都合上，電力の従属指標として平均電力の例も併記する．特に，\SI{100}{\milli\second}から\SI{500}{\milli\second}への変更により電力が低下する一方で，受信率や遅延分布が変化するため，制約$\delta$に対する可行性が境界条件として現れる．

\subsubsection{固定間隔の平均電力（例）}
本研究では，固定間隔の平均電力を実測し，オフライン評価で用いる電力テーブルとして利用する．表\ref{tab:power_table_example}に，\SI{100}{\milli\second}から\SI{2000}{\milli\second}までの固定間隔における平均電力の一例を示す．

\begin{table}[tb]
  \centering
  \caption{固定間隔の平均電力（例）}
  \label{tab:power_table_example}
  \begin{tabular}{lll}
    \toprule
    広告間隔 [ms] &amp; 平均電力 [mW] &amp; 備考 \\
    \midrule
    100  &amp; 198.56 &amp; n=10（sleep\_on） \\
    500  &amp; 180.80 &amp; n=9（sleep\_on） \\
    1000 &amp; 178.62 &amp; n=9（sleep\_on） \\
    2000 &amp; 177.47 &amp; n=9（sleep\_on） \\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{主効果の観察}
表\ref{tab:power_table_example}の例では，\SI{100}{\milli\second}から\SI{500}{\milli\second}への変更で平均電力が大きく低下する．一方で，\SI{500}{\milli\second}以上では改善幅が小さくなる．この傾向は，動的制御において短間隔の滞在時間を抑制する設計が有効であることを示唆する．

\subsection{動的切替（2値制御）の実機確認}
動的制御の最小構成として，\SI{100}{\milli\second}と\SI{500}{\milli\second}の切替を実装し，固定\SI{100}{\milli\second}および固定\SI{500}{\milli\second}と比較する．平均電力が両固定条件の中間に位置し，受信率も中間的になることを確認することで，切替が成立していることを検証する．

切替成立の確認としては，平均電力が両固定条件の中間に位置し，かつログ上でinterval切替が発生することを確認すれば十分である．以降では，TLと$P_{\mathrm{out}}(\tau)$を用いて，QoS制約下での省電力効果を定量評価する．

\subsection{実測のQoS指標（TLとPout）}
本研究では，受信品質をPDRだけでなく，遅延分布と期限超過率$P_{\mathrm{out}}(\tau)$で評価する．特に，非理想スキャン環境では平均受信率が同程度でも，遅延の裾が悪化する場合があるため，$P_{\mathrm{out}}(\tau)$が重要となる（\secref{sec:metrics_detail}）．

\subsubsection{実測例（D2b，scan90）}
表\ref{tab:d2_summary}に，D2b（scan90）における実測例を示す．本表は，S1/S4の2条件について，固定\SI{100}{\milli\second}，固定\SI{500}{\milli\second}，および方策（2値切替）の比較をまとめたものである．ここでは run B（n=3）と追加取得 B/02（n=3）を統合し，各条件n=6として集計した．

\begin{table}[tb]
  \centering
  \caption{D2b（scan90）の実測例（mean$\pm$std, 各n=6）}
  \label{tab:d2_summary}
  {\small
  \setlength{\tabcolsep}{4pt}
  \begin{tabular}{lrrrrr}
    \toprule
    条件 &amp; Pout(1s) &amp; TL\_mean[s] &amp; PDR\_u &amp; P[mW] &amp; share100 \\
    \midrule
    S1-100   &amp; 0.075$\pm$0.027 &amp; 3.76$\pm$1.46 &amp; 0.789$\pm$0.016 &amp; 204.1$\pm$1.4 &amp; 1.000$\pm$0.000 \\
    S1-500   &amp; 0.142$\pm$0.049 &amp; 5.29$\pm$0.02 &amp; 0.816$\pm$0.018 &amp; 184.7$\pm$1.5 &amp; 0.000$\pm$0.000 \\
    S1-policy &amp; 0.125$\pm$0.027 &amp; 5.24$\pm$0.05 &amp; 0.803$\pm$0.022 &amp; 191.5$\pm$1.9 &amp; 0.331$\pm$0.004 \\
    \midrule
    S4-100   &amp; 0.053$\pm$0.010 &amp; 1.25$\pm$0.01 &amp; 0.792$\pm$0.009 &amp; 204.4$\pm$2.1 &amp; 0.998$\pm$0.002 \\
    S4-500   &amp; 0.146$\pm$0.031 &amp; 2.48$\pm$1.11 &amp; 0.817$\pm$0.020 &amp; 184.5$\pm$1.5 &amp; 0.000$\pm$0.000 \\
    S4-policy &amp; 0.069$\pm$0.029 &amp; 1.58$\pm$0.50 &amp; 0.793$\pm$0.021 &amp; 196.6$\pm$1.6 &amp; 0.595$\pm$0.008 \\
    \bottomrule
  \end{tabular}
  }
\end{table}

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.90\linewidth]{../uccs_d2_scan90/plots/d2b_B_n6_power_vs_pout}
  \caption{D2b（run B + B/02, n=6）における平均電力と$P_{\mathrm{out}}(1\mathrm{s})$の関係（share100を注釈）}
  \label{fig:d2b_power_vs_pout}
\end{figure}

\subsubsection{解釈}
表\ref{tab:d2_summary}および図\ref{fig:d2b_power_vs_pout}より，方策（2値切替）はFixed100より低電力であり，Fixed500より低い期限超過率（QoS改善）を示す運用点になり得る．さらに，遷移が多い側（S4）ほどshare100が増加しており，「必要時だけ\SI{100}{\milli\second}に寄せ，それ以外は\SI{500}{\milli\second}に寄せる」挙動が定量で確認できる．

また，平均電力はFixed100/Fixed500の滞在比率（share100）による線形混合で概ね説明できるため，方策の省電力効果はinterval滞在比率に支配されることが示唆される．これにより，「sleep差分が効いた/効かなかった」といった実装依存の議論から切り離し，制御則（どの状態で短間隔へ戻すか）の議論へ接続しやすくなる．

\subsubsection{条件悪化時の頑健性（D3，scan70）}
\label{sec:d3_scan70}
表\ref{tab:d3_summary}に，scan dutyを低下させたD3（scan70, S4, 各n=3）の結果を示す．scan70ではFixed500の期限超過率が0.285まで悪化する一方で，方策は0.089まで改善し，Fixed100（0.065）と同様に制約$\delta$（例：$\delta=0.1$）を満たす．このとき方策はFixed100より平均電力を\SI{7.8}{\milli\watt}（約3.7\%）低減するが，Fixed500よりは\SI{12.6}{\milli\watt}高い．

なお，scan70では受信欠落によりRXタグ由来のshare100（約0.42）が過小評価されやすいため，D3では平均電力の線形混合によりshare100\_mixを推定した．固定\SI{100}{\milli\second}/\SI{500}{\milli\second}の平均電力をそれぞれ$P_{100}, P_{500}$とし，方策の平均電力を$P_{\mathrm{policy}}$とすると，$share100_{\mathrm{mix}}=(P_{\mathrm{policy}}-P_{500})/(P_{100}-P_{500})$で与えられる．また，SDコピーでmtimeが信頼できないため，TXSDログはadv\_count（tick\_count）でクラスタリングしてRXと対応付けた．

\begin{table}[tb]
  \centering
  \caption{D3（scan70, S4）の実測例（mean$\pm$std, 各n=3）}
  \label{tab:d3_summary}
  {\small
  \setlength{\tabcolsep}{4pt}
  \begin{tabular}{lrrrr}
    \toprule
    条件 &amp; Pout(1s) &amp; TL\_mean[s] &amp; P[mW] &amp; share100\_mix \\
    \midrule
    S4-100   &amp; 0.065$\pm$0.028 &amp; 1.34$\pm$0.02 &amp; 209.9$\pm$0.5 &amp; 1.000 \\
    S4-500   &amp; 0.285$\pm$0.061 &amp; 2.93$\pm$1.07 &amp; 189.5$\pm$0.5 &amp; 0.000 \\
    S4-policy &amp; 0.089$\pm$0.037 &amp; 1.40$\pm$0.07 &amp; 202.1$\pm$0.1 &amp; 0.618 \\
    \bottomrule
  \end{tabular}
  }
\end{table}

\subsubsection{U-shuffleアブレーション（D4，scan90）}
\label{sec:d4_ablation}
D2bの主結果に対して，「不確実度$U$は本当に効いているか（単なる閾値遊びではないか）」という疑問に答えるため，D4としてアブレーション実験を行った．ここでは制御器の構造と閾値は固定し，不確実度系列$U$の時間整合だけを破壊する（shuffleする）ことで，制御がどのように崩れるかを観察する．

表\ref{tab:d4_summary}に，S4（遷移が多い条件）における結果（各n=3）を示す．方策（U+CCS）はFixed100より低電力であり，Fixed500より低い期限超過率を示す運用点になり得る．一方で，$U$をshuffleするとshare100が0.593から0.943へ増加し，adv\_countも1227から1715へ増加してFixed100に近い挙動へ崩れる．その結果，平均電力も200.5\,mWから208.1\,mWへ増加し，省電力効果が失われる（図\ref{fig:role_separation_overview}）．

\begin{table}[tb]
  \centering
  \caption{D4（scan90, S4）のアブレーション結果（mean$\pm$std, 各n=3）}
  \label{tab:d4_summary}
  {\small
  \setlength{\tabcolsep}{4pt}
  \begin{tabular}{lrrrrr}
    \toprule
    条件 &amp; Pout(1s) &amp; TL\_mean[s] &amp; P[mW] &amp; adv\_count &amp; share100 \\
    \midrule
    Fixed100 &amp; 0.049$\pm$0.000 &amp; 1.24$\pm$0.01 &amp; 208.2$\pm$1.3 &amp; 1796$\pm$0 &amp; 1.000$\pm$0.000 \\
    Fixed500 &amp; 0.130$\pm$0.014 &amp; 1.59$\pm$0.06 &amp; 187.9$\pm$0.8 &amp; 359$\pm$0 &amp; 0.000$\pm$0.000 \\
    Policy（U+CCS） &amp; 0.098$\pm$0.024 &amp; 1.28$\pm$0.01 &amp; 200.5$\pm$0.8 &amp; 1227$\pm$0 &amp; 0.593$\pm$0.009 \\
    Ablation（U-shuf） &amp; 0.049$\pm$0.000 &amp; 1.23$\pm$0.01 &amp; 208.1$\pm$0.3 &amp; 1715$\pm$0 &amp; 0.943$\pm$0.000 \\
    \bottomrule
  \end{tabular}
  }
\end{table}

\subsubsection{CCS-offアブレーション（D4B，scan90）}
\label{sec:d4b_ccs_off}
CCSの寄与を切り分けるため，制御則の構造は固定したままCCSを無効化し，不確実度$U$のみで切替を行う（U-only）実験（D4B）を追加した．
表\ref{tab:d4b_summary}にS4の結果（各n=3）を示す．Policy（U+CCS）とU-only（CCS-off）は平均電力がほぼ同一（ともに約200.6\,mW）で，adv\_countおよびshare100\_mixも同等であるにも関わらず，Policy（U+CCS）の方が$P_{\mathrm{out}}(1\mathrm{s})$とTL\_meanが改善する．したがって，CCSは「\SI{100}{\milli\second}を増やす」ことでなく，同じ短間隔予算の範囲で「短間隔を使うタイミング」を調整することでQoSを改善していると解釈できる（図\ref{fig:role_separation_overview}）．

\begin{table}[tb]
  \centering
  \caption{D4B（scan90, S4）のCCS-offアブレーション結果（mean$\pm$std, 各n=3）}
  \label{tab:d4b_summary}
  {\small
  \setlength{\tabcolsep}{4pt}
  \begin{tabular}{lrrrrr}
    \toprule
    条件 &amp; Pout(1s) &amp; TL\_mean[s] &amp; P[mW] &amp; adv\_count &amp; share100\_mix \\
    \midrule
    Fixed100 &amp; 0.081$\pm$0.014 &amp; 1.49$\pm$0.11 &amp; 208.3$\pm$0.5 &amp; 1796$\pm$0 &amp; 1.000 \\
    Fixed500 &amp; 0.130$\pm$0.028 &amp; 1.21$\pm$0.26 &amp; 188.1$\pm$0.3 &amp; 359$\pm$0 &amp; 0.000 \\
    U-only（CCS-off） &amp; 0.065$\pm$0.014 &amp; 1.41$\pm$0.15 &amp; 200.6$\pm$0.2 &amp; 1227$\pm$0 &amp; 0.621 \\
    Policy（U+CCS） &amp; 0.049$\pm$0.000 &amp; 1.32$\pm$0.03 &amp; 200.6$\pm$0.1 &amp; 1215$\pm$0 &amp; 0.620 \\
    \bottomrule
  \end{tabular}
  }
\end{table}

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../uccs_d4b_scan90/plots/role_separation_d3_d4_d4b}
  \caption{U/CCSの役割分離と頑健性のまとめ（S4）: 平均電力と$P_{\mathrm{out}}(1\mathrm{s})$の関係（D3/D4/D4B）。図中の矢印は，Uの寄与（U-shuffleから方策へ），CCSの寄与（CCS-offから方策へ），および受信条件悪化（scan90からscan70）に対する挙動を示す．}
  \label{fig:role_separation_overview}
\end{figure}

\subsubsection{解釈（D4/D4B）}
D4の結果は，制御器の構造と閾値を固定したまま入力$U$の時間整合だけを破壊すると，制御が短間隔（\SI{100}{\milli\second}）に張り付く方向へ崩れることを示している．一方でD4Bの結果は，平均電力（=短間隔滞在量）をほぼ同一に保ったまま，CCSの有効化によって$P_{\mathrm{out}}(1\mathrm{s})$とTL\_meanが改善することを示している．したがって，本研究の2値制御では，$U$が「どれだけ短間隔を使うか（電力）」を決め，CCSが「いつ短間隔を使うか（QoS）」を改善する，という役割分担が示唆される．

\subsubsection{効果量のブートストラップCI（追加検証）}
各条件$n=3$のため，trial単位の差分に対してpercentile bootstrap（$n_{\mathrm{boot}}=20000$）で効果量の不確かさを確認した．D4Bでは，$\Delta P_{\mathrm{out}}(1\mathrm{s})$（U+CCS $-$ U-only）$=-0.0163$で95\%CIは$[-0.0244, 0.0000]$となり，$\Delta power$は$-0.0235$\,mWで95\%CIが$[-0.2332, 0.1886]$となった．また，D4では$\Delta power$（policy $-$ U-shuf）$=-7.58$\,mW（95\%CI $[-8.39,-6.93]$），$\Delta P_{\mathrm{out}}(1\mathrm{s})=+0.0488$（95\%CI $[0.0244,0.0732]$）であり，U-shuffleが短間隔寄りに崩れることが定量で確認できる．さらに，D3では$\Delta P_{\mathrm{out}}(1\mathrm{s})$（policy $-$ fixed500）$=-0.195$（95\%CI $[-0.260,-0.130]$），$\Delta power$（policy $-$ fixed100）$=-7.76$\,mW（95\%CI $[-8.24,-7.22]$）であり，受信条件悪化時でも方策がFixed500より低い期限超過率を示しつつFixed100より低電力であることが裏付けられる．

\subsubsection{$\alpha$--$P_{\mathrm{out}}$プロット（追加検証）}
滞在比率の推定を直感的に扱うため，固定\SI{100}{\milli\second}/\SI{500}{\milli\second}の平均電力を$P_{100},P_{500}$とし，各条件の平均電力$P$から
\begin{equation}
  \alpha = \frac{P-P_{500}}{P_{100}-P_{500}}
\end{equation}
を定義する（$\alpha\approx share100_{\mathrm{mix}}$）．図\ref{fig:alpha_vs_pout_overview}は，$x=\alpha$，$y=P_{\mathrm{out}}(1\mathrm{s})$としてD3/D4/D4Bを同一平面に配置したものである．D4Bでは，Policy（U+CCS）とU-only（CCS-off）が同程度の$\alpha$であるにも関わらず$P_{\mathrm{out}}$が改善し，同電力でQoSが改善する傾向が可視化できる．また，D4（U-shuffle）では$\alpha$が1に近づき，短間隔へ張り付く崩れ方が確認できる．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../uccs_d4b_scan90/plots/alpha_vs_pout_overview}
  \caption{$\alpha$（\SI{100}{\milli\second}滞在比率の推定値）と$P_{\mathrm{out}}(1\mathrm{s})$の関係（D3/D4/D4B）．図中の$\delta=0.1$は制約の例として示す．}
  \label{fig:alpha_vs_pout_overview}
\end{figure}

\subsubsection{事例解析：同電力でQoS差を生んだ少数イベント（D4B run01）}
D4B（run01）では，Policy（U+CCS）とU-only（CCS-off）が同程度の平均電力でありながら$P_{\mathrm{out}}(1\mathrm{s})$が異なる．この差の内訳を確認するため，trial$\times$遷移ごとのTLを集計し，outage（TL$&gt;\SI{1}{\second}$）に寄与した遷移をランキングした（出力：\texttt{\detokenize{uccs_d4b_scan90/plots/outage_story_01/}}）．代表例として\texttt{\detokenize{transition_step=1128}}（2$\rightarrow$9）では，U-onlyでTL$\approx\SI{9.889}{\second}$（outage）だがPolicyではTL$\approx\SI{0.212}{\second}$であり，少数の失敗イベントが$P_{\mathrm{out}}$差を生み得ることが確認できる．さらに，遷移単位の集計から復元したoutage率（\texttt{\detokenize{pout_est}}）がsummaryと一致することを確認した（Policy=0.04878, U-only=0.06504）．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.98\linewidth]{../uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline}
  \caption{D4B（run01）における失敗イベント中心のタイムライン図（例：\texttt{\detokenize{transition_step=1128}}, 2$\rightarrow$9）．U-onlyではTLが長くoutageとなる一方で，Policy（U+CCS）では短時間で受信されoutageが回避される．}
  \label{fig:outage_story_timeline}
\end{figure}

\subsubsection{尾（TL$&gt;\SI{1}{\second}$）への寄与分解（D4B run01）}
$P_{\mathrm{out}}(1\mathrm{s})$は「TL$&gt;\SI{1}{\second}$となるoutageの発生有無」で決まりやすい．そこで，trialごとのoutage回数分布と，$\Delta P_{\mathrm{out}}$（U-onlyが悪化する差分）が「どの遷移に集中しているか」を可視化した（出力：\texttt{\detokenize{uccs_d4b_scan90/plots/pout_tail_01/}}）．図\ref{fig:d4b_pout_tail_decomposition}より，本run01では正の$\Delta P_{\mathrm{out}}$を持つ遷移は41遷移中2遷移であり，上位1遷移で差分の50\%を説明するなど，尾の差が少数遷移へ強く集中していることが確認できる．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.92\linewidth]{../uccs_d4b_scan90/plots/pout_tail_01/fig_outage_count_hist}
  \vspace{2mm}
  \includegraphics[width=0.92\linewidth]{../uccs_d4b_scan90/plots/pout_tail_01/fig_delta_pout_cum}
  \caption{D4B（run01）における尾（TL$&gt;\SI{1}{\second}$）の寄与分解．（上）trialごとのoutage回数分布，（下）上位K遷移が$\Delta P_{\mathrm{out}}(1\mathrm{s})$をどれだけ説明するか（累積寄与）．}
  \label{fig:d4b_pout_tail_decomposition}
\end{figure}

\subsubsection{条件付きタイミング：失敗遷移近傍の短間隔割当て（D4B run01）}
同電力で$P_{\mathrm{out}}$差が生じる要因として，平均的な$\alpha$（滞在比率）ではなく「どのタイミングで短間隔を割り当てたか」が効いている可能性がある．そこで，U-onlyのoutage率が高い遷移（差分上位）に限定し，遷移近傍における$P(\text{interval}=\SI{100}{\milli\second})$を再集計した（出力：\texttt{\detokenize{uccs_d4b_scan90/plots/ccs_timing_conditional_01/}}）．図\ref{fig:d4b_ccs_timing_conditional}は，失敗しやすい遷移近傍では短間隔割当ての差が現れやすいことを示しており，CCSが「同じ短間隔予算の使い方（タイミング）」を通じてQoSを改善する可能性を支持する．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../uccs_d4b_scan90/plots/ccs_timing_conditional_01/fig_event_triggered_p100_conditional}
  \caption{D4B（run01）における条件付きタイミング分析：U-onlyが悪化する遷移（差分上位）に限定し，遷移近傍の$P(\text{interval}=\SI{100}{\milli\second})$を可視化した．}
  \label{fig:d4b_ccs_timing_conditional}
\end{figure}
\clearpage

\subsection{オフライン評価との整合}
オフライン評価で予測される運用点と，実機で得られる平均電力・受信品質の差分を比較し，推定モデルの妥当性と限界を整理する．

\subsubsection{予測と実測の差分}
オフライン評価は，固定間隔の電力テーブルと受信品質推定を合成するため，実環境の非理想性を完全には表現しない．したがって，予測値は「候補探索と説明のための近似」として用い，実測との差分を評価しながらモデルの限界を記述することが重要である．

\subsubsection{δ帯プロット（参考）}
δ帯プロットは，\secref{sec:offline_eval}の図\ref{fig:letter_delta_band}に示した通り，固定間隔点と候補方策点の位置関係を俯瞰し，実機評価で探索すべき領域を絞り込むための近似として有効である．

\subsection{まとめ}
本節の結果を，次章の考察に接続するために要点を整理する．
\begin{itemize}
  \item D2b（scan90, n=6）では，方策（2値切替）がFixed100より低電力で，Fixed500より低い期限超過率を示す運用点になり得ることを確認した．
  \item D3（scan70, S4, n=3）では，scan duty低下でFixed500が崩れる条件でも，方策が期限超過率を抑えつつFixed100より低電力を維持できることを確認した．
  \item D4（U-shuffleアブレーション, S4, n=3）では，$U$の時間整合を破壊すると短間隔へ張り付く方向へ崩れ，省電力効果が失われることを確認した．
  \item D4B（CCS-offアブレーション, S4, n=3）では，平均電力をほぼ同一に保ったままCCSの有効化で期限超過率と遅延が改善し，同じ短間隔予算の範囲でQoSを改善できることを確認した．
  \item オフライン評価（δ帯）は，固定間隔点と候補方策点の位置関係を可視化し，実機評価で探索すべき領域を絞り込むための近似として有効である．
\end{itemize}</file><file path="修士論文/chapters/ch5_evaluation.tex">% chapters/ch5_evaluation.tex --- 第5章 評価（統合）
\chapter{評価}
\clearpage

本章では，ストレス固定実験に基づくTL/Pout指標の確立，オフライン評価による候補探索，および実機評価結果をまとめる．固定間隔と提案方策を同一の評価指標で比較し，省電力とQoSのトレードオフを示す．

\input{chapters/ch6_stress_fixed}
\input{chapters/ch7_offline_eval}
\input{chapters/ch4_rain}

% 付録だった追加結果は評価章に吸収
\input{chapters/appx_c_results}</file><file path="修士論文/chapters/ch5_publicroad.tex">% chapters/ch5_publicroad.tex --- 第5章 考察
\chapter{考察}
\clearpage

\section{非理想スキャン環境における解釈}
受信側スキャンの非理想性は，平均的な受信率だけでなく，遅延の裾や期限超過に影響する．端末・OS状態に依存する要素を前提として，評価は端末内のA/B比較として解釈する必要がある．

\subsection{評価の前提}
本研究では，端末内比較の前提を守るため，固定条件と提案条件を同一実験系で取得し，同じ処理パイプラインで集計する．また，ログ欠損や同期ずれが評価結果に直結するため，解析対象の選別や単位整合の監査を行う．

\section{制御設計の妥当性と限界}
ルールベース方策は実装が単純であり，安全側のフォールバックを設計しやすい．一方で，環境ごとに最適な運用点は変化するため，固定閾値では追従できない場合がある．また，切替頻度の増加はログ整合や同期の難易度を上げるため，実装面での制約もある．

\subsection{2値制御の位置づけ}
2値制御は，実機検証を最小構成で成立させる上で有効である．一方で，\SI{1000}{\milli\second}や\SI{2000}{\milli\second}など長間隔を含めた最適化は，より大きな省電力の可能性を持つ．今後は，計測・同期の堅牢性を維持した上で行動空間を拡張し，QoS制約の境界をより広い範囲で評価する必要がある．

\subsection{閾値設計と感度}
CCS閾値は，入力データ（活動種別やモデルの確信度分布）に依存する．閾値を厳しくしすぎると短間隔に偏って省電力効果が薄れ，緩くしすぎると長間隔に偏ってQoS違反が増える．したがって，オフライン評価で候補を絞り込んだ上で，実機の端末内比較で境界付近を詰めるアプローチが実務上有効である．

\subsection{UとCCSの役割分離（実機アブレーション）}
\label{sec:discussion_role_separation}
本研究では，2値制御の実機成立（D2b）に加え，受信条件悪化時の頑健性（D3）と，U/CCSの役割分離（D4/D4B）を追加検証した．D4（U-shuffle）では，制御器の構造を固定したまま$U$の時間整合のみを破壊すると短間隔へ張り付く方向へ崩れ，省電力効果が失われることを示した（\secref{sec:d4_ablation}）．一方でD4B（CCS-off）では，平均電力（=短間隔滞在量）をほぼ同一に保ったまま，CCS有効化により$P_{\mathrm{out}}(1\mathrm{s})$とTLが改善することを示した（\secref{sec:d4b_ccs_off}）．これらより，$U$が「どれだけ短間隔を使うか（電力）」を，CCSが「いつ短間隔を使うか（QoS）」を改善する，という役割分担が実機データで支持される（\figref{fig:role_separation_overview}）．

\section{sleepの扱いと計測公平性}
本研究は，広告間隔を制御することで無線イベント回数を減らし，さらに送信側がsleepに入れる時間を増やすことで平均電力を下げることを狙う．一方で，sleepは計測条件そのものでもあるため，条件が混ざると比較が成立しない．本節では，sleepを議論に入れるための前提を整理する．

\subsection{送信側sleep（平均電力への寄与）}
送信側（DUT）がlight sleep等に入る構成では，広告間隔を延ばすほどsleep時間が増え，平均電力が低下しやすい．ただし，周辺回路やロギングの定常負荷が支配的な場合，改善は飽和する．したがって，sleepの有無（ON/OFFを含む）を条件として明示し，同一コード系列・同一設定の端末内比較として評価することが必要である．

\subsection{受信側sleep（scan dutyの縮退）}
受信側（スマートフォン）のスキャンは，OSの省電力機構や端末状態により間欠化し得る．この受信側sleepは，TL分布の裾を伸ばし，$P_{\mathrm{out}}(\tau)$を悪化させる方向に作用する．したがって，本研究の主張は「理想スキャン下の最適性」ではなく，「非理想スキャン下でも端末内比較として省電力な運用点が存在し得る」ことに置く．

\subsection{OFF計測と差分評価}
計測系の定常負荷が大きい場合，平均電力だけでは広告間隔の差が埋もれる．この場合，広告ON/OFF差分$\Delta E$を広告回数で正規化した$\Delta E/N_{\mathrm{adv}}$を併用することで，「無線1回当たりの増分」として議論できる．ただし，OFFのsleep状態やスタック状態がONと異なると差分の解釈が難しくなるため，Runbookに従って条件を固定する必要がある．

\section{Safe Contextual Banditへの拡張}
将来的には，コンテキスト（不確実度，安定度）に応じて行動（広告間隔）を選択し，報酬（省電力）を最大化しながら制約（$P_{\mathrm{out}}(\tau)\le\delta$）を満たすSafe Contextual Banditとして定式化する．ルールベース方策と固定間隔の基準データは，Warm-Startの事前情報として活用できる．

\subsection{Warm-Startの意義}
オンライン学習では，学習初期の探索によってQoS制約を破るリスクがある．ルールベース方策は，安全側の初期方策として利用でき，探索の範囲を制約内に保つ設計に接続しやすい．したがって，Phase 1に相当するルールベース評価は，オンライン最適化の前提条件として重要である．

\section{失敗・未完タスクの位置づけ}
修士論文では，うまくいかなかった点や未完タスクを隠すのではなく，「何が揃っていて，何が揃っていないか」を明示することが再現性に直結する．本研究は，Phase 1として評価系を確立することを目的に置くため，未完点を将来課題として整理し，Phase 2へ接続する材料とする．

\subsection{HARモデル（A\_tiny）の未完点}
A\_tinyは，4クラス性能の未達やTFLite生成・実機計測が未完である．この状態で閾値制御を議論すると，確率出力の較正や量子化誤差により，CCS分布と閾値の意味が変化する危険がある．したがって，本論文では参照モデルA0を土台として不確実度定義を固定し，A\_tinyの改善は今後の課題として明確化する．

\subsection{計測系トラブルの位置づけ}
計測系のトラブル（SYNC取りこぼし，UART欠損，SD失敗など）は，研究の本質ではないが，無視すると結論を逆転させ得る．そのため，本研究では計測系の破綻モードと対策を\secref{sec:measurement_system}で整理し，評価の前提として本文に明示した．

\section{脅威と限界（Threats to Validity）}
本研究の評価は，実機の端末内比較と，オフライン合成評価を組み合わせている．したがって，以下の脅威と限界を明示する必要がある．
\begin{itemize}
  \item 外的妥当性：受信端末やOSバージョンが変わると，スキャンの非理想性が変化し，同一方策でもQoSが変化し得る．
  \item 内的妥当性：ログ欠損や単位換算の誤りは結論を逆転させ得るため，計測健全化と監査を必須とする（\secref{sec:measurement_system}）．
  \item 統計的妥当性：実機評価は各条件$n=3$のものが含まれる．効果量はブートストラップCIで補助的に確認したが，さらなる反復による不確かさ低減が望ましい（\secref{sec:d3_scan70}）．
  \item モデル近似：オフライン評価は滞在比率に基づく合成であり，切替直後の非定常性や相関は近似に含まれない．
  \item 不確実度較正：確率値が過信されると閾値の意味が崩れるため，較正（温度スケーリング等）の導入が今後の課題となる（\secref{sec:har_uncertainty}）．
\end{itemize}

\section{今後の課題}
本研究で未解決の課題として，スキャン挙動の端末差の系統的整理，動的制御におけるQoS指標（TL分布・$P_{\mathrm{out}}$）の高精度評価，およびオンライン学習導入時の安全側設計が挙げられる．

\subsection{QoS評価の高精度化}
動的制御では，イベント時刻の定義と時間同期が結果を左右する．特に長間隔では，開始位相のずれや受信の間欠性により，TL分布と$P_{\mathrm{out}}(\tau)$が不自然に見える場合がある．今後は，ペイロードにインデックス等を埋め込み，時間軸を確実に復元できるログ設計と解析を統一する．

\subsection{行動集合の拡張}
2値制御は最小構成として有効であるが，運用点の探索範囲を狭める．今後は，$\{100,500,1000,2000\}$のように行動集合を拡張し，制約$\delta$の境界に沿ってより良いトレードオフ点が存在するかを検証する．その際，切替頻度が増えるため，ログ整合と時間同期の堅牢化が前提条件となる．</file><file path="修士論文/chapters/ch6_stress_fixed.tex">% chapters/ch6_stress_fixed.tex --- 第6章 ストレス固定実験と指標定義（scan50/scan90, v5）
\section{ストレス固定実験と指標定義の確立}
\label{sec:stress_fixed_metrics}

\subsection{目的}
本節では，ストレス固定（stress\_fixed）実験を用いて，QoS指標（TLおよびPout(τ)）の定義を「論文で説明できる形」に固定し，実測結果を再現可能に整理する．特に，受信ログの時間軸と真値（truth）の開始位相ずれがTL/Poutに与える影響を明確化し，補正手順を定式化する．

\subsection{実験条件の概要}
ストレス固定実験では，既知のラベル系列（truth）をTX側で再生し，受信側（RX）がそれをどの程度の遅延で観測できるかを測定する．主な比較軸は以下である．
\begin{itemize}
  \item 受信設定：scan50（duty 50\% 相当）とscan90（duty 90\% 相当）
  \item 固定広告間隔：\SI{100}{\milli\second}，\SI{500}{\milli\second}，\SI{1000}{\milli\second}，\SI{2000}{\milli\second}
  \item ストレス列：代表的な2条件（例：S1，S4）を中心に評価
\end{itemize}
各trialについて，TXSDログとRXログを対応付け，PDR，TL，Pout(τ)，平均電力などを出力する．

\subsection{v4で観察された問題}
scan90のv4集計では，固定\SI{2000}{\milli\second}においてPout(1s)が理論下限より小さく見える等，直感に反する挙動が観察された．原因は，RXログの`ms`とtruthの時間軸が一致している前提でTL/Poutを計算していた点にある．実機では試行開始のタイミングがずれ得るため，このずれを補正しないとTL/Poutが過小評価される．

\subsection{v5での時間同期（定数オフセット補正）}
v5では，TL/Pout算出前に定数オフセットを推定し，RXログの時刻を補正する．広告間隔を$\Delta t$（ms），受信ログから得られるseqの初回観測時刻を$\mathrm{first\_ms}(\mathrm{seq})$とすると，seqに対応する期待時刻は$\mathrm{seq}\cdot\Delta t$である．複数のseqに対し，
\begin{equation}
  \mathrm{offset\_ms} = \mathrm{median}_{\mathrm{seq}&gt;0}\left(\mathrm{seq}\cdot\Delta t - \mathrm{first\_ms}(\mathrm{seq})\right)
\end{equation}
としてオフセットを推定し，補正後の時刻を$\mathrm{ms\_aligned}=\mathrm{ms}+\mathrm{offset\_ms}$とする．TL/Poutは$\mathrm{ms\_aligned}$に基づいて算出する．この補正により，開始位相ずれに起因する過小評価を抑制できる．

\subsection{生成物と再現性}
v5では，per-trialの集計に加え，modes/agg/enrichedの集約表を再現可能に生成するパイプラインを整備した．また，scan50とscan90の比較結果も同一の定義で出力し，受信設定の違いがPDRやTL/Poutに与える影響を整理できるようにした．

\subsubsection{PDRの扱い}
PDRは受信ログの行数に基づく指標（重複含む）と，seqでユニーク化した指標（重複除外）の2種類を区別する．QoS比較では，広告イベントの「何割を一度でも拾えたか」を表すPDR\_uniqueを優先する（\secref{sec:metrics_detail}）．

\subsubsection{EFFECTIVE\_LENと末端遷移}
真値（truth）は有限長のラベル系列であり，試行時間のクランプにより末端の遷移が試行区間外に出る場合がある．その場合，末端遷移を含めた評価は不安定になるため，truth側も同じ長さにクリップし，イベント数$N_{\mathrm{event}}$の分母を揃える．この処理は，試行間比較と再現性の観点で重要である．

\subsection{結果（図表）}
\subsubsection{scan90の指標サマリ}
図\ref{fig:stress_fixed_scan90_metrics}に，scan90における主要指標の例を示す．この図は，v5の時間同期を反映したものであり，長間隔側でTL/Poutが不自然に小さくなる問題が緩和される．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../results/stress_fixed/figures_v5/fig1_scan90_metrics.png}
  \caption{ストレス固定（scan90）の主要指標（v5）}
  \label{fig:stress_fixed_scan90_metrics}
\end{figure}

\subsubsection{実測と簡易モデルの比較}
図\ref{fig:stress_fixed_real_vs_sim}に，ストレス固定における実測と簡易モデル（比較用）の例を示す．簡易モデルは，スキャンの非理想性や開始位相ずれの影響を完全には表現できないため，実測との差分が残る．一方で，固定間隔の相対関係（短間隔ほど遅延が改善しやすい等）のトレンドを説明する補助として利用できる．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../results/stress_fixed/compare/stress_causal_real_vs_sim.png}
  \caption{ストレス固定における実測と簡易モデルの比較（例）}
  \label{fig:stress_fixed_real_vs_sim}
\end{figure}

\subsubsection{scan50とscan90の比較}
図\ref{fig:stress_fixed_scan50_vs_scan90_pdr}に，scan50とscan90の比較（例：PDR\_unique）を示す．duty比を上げることで短間隔側の受信品質が改善することが確認できる．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.85\linewidth]{../results/stress_fixed/figures_v5/fig3_scan50_vs_scan90_pdr_unique.png}
  \caption{ストレス固定におけるscan50とscan90の比較（例：PDR\_unique，v5）}
  \label{fig:stress_fixed_scan50_vs_scan90_pdr}
\end{figure}

\subsection{指標の変化例（v4→v5）}
時間同期の導入により，TL/Poutが大きく変化する条件が存在する．例えば，固定\SI{2000}{\milli\second}のPout(1s)や，固定\SI{100}{\milli\second}のTL平均値が大きく更新される場合がある．本研究では，v5を正式な定義として扱い，下流のオフライン評価や図表はv5へ差し替える．

\subsection{まとめ}
本節では，ストレス固定実験を用いてTL/Poutの定義と実装を固定し，開始位相ずれを補正するv5の時間同期手順を示した．以降では，この指標定義を前提として，固定間隔および動的制御の評価を行う．</file><file path="修士論文/chapters/ch7_offline_eval.tex">% chapters/ch7_offline_eval.tex --- 第7章 オフライン評価（mHealth合成 + ルールベース方策）
\section{オフライン評価：mHealth合成とルールベース方策探索}
\label{sec:offline_eval}

\subsection{目的}
実機実験の探索空間を縮小し，説明可能な代表方策を選定するために，オフライン評価を行う．本節では，mHealth由来の時系列（不確実度・安定度・複合スコア）に対してルールベース方策を適用し，固定間隔の電力テーブルと組み合わせて，QoS制約下の省電力運用点を探索する．

\subsection{入力データ（mHealth合成）}
オフライン評価では，実機上でのHAR推論を直接用いる代わりに，既存データセット由来の時系列（mHealth）から$U,S,\mathrm{CCS}$を合成し，方策を適用する\scite{uci_ml_repo}．これにより，実機で高価な全探索を行う前に，閾値やヒステリシスの候補を絞り込める．

\subsection{方策のパラメータ化}
ルールベース方策は，次のパラメータで表せる．
\begin{itemize}
  \item 閾値：$\theta_{\mathrm{low}},\theta_{\mathrm{high}}$
  \item ヒステリシス幅：$\Delta\theta$（上り・下りの閾値差）
  \item 最小滞在時間：$t_{\mathrm{dwell}}$
  \item 行動集合：$A=\{100,500\}$ または $\{100,500,1000,2000\}$
\end{itemize}
オフライン評価では，これらの組合せをスイープし，平均電力とQoS制約の観点からParetoフロントを抽出する．

\subsection{電力テーブル（固定間隔の実測）}
固定間隔ごとの平均電力は，実機計測から得られる．オフライン評価では，この電力テーブルに基づき，「ある方策が各広告間隔にどの程度滞在するか」を合成して平均電力を推定する．

\subsubsection{平均電力の合成}
方策$\pi$が間隔$a\in A$に滞在する比率を$\rho_\pi(a)$とし，固定間隔の平均電力を$P(a)$とすると，方策の平均電力は
\begin{equation}
  \overline{P}_\pi=\sum_{a\in A}\rho_\pi(a)\,P(a)
\end{equation}
で近似できる．ここで$\rho_\pi(a)$は，mHealth時系列に方策を適用した結果の滞在時間比率として求める．

\subsection{QoS制約と境界条件}
オフライン評価では，代表的な期限$\tau$に対するPout(τ)を制約として扱い，$\delta$を満たす運用点を可行集合として抽出する．$\delta$は厳しすぎると可行集合が空になり，緩すぎると省電力とQoSの議論が弱くなるため，境界付近を主張点として設計することが重要である．

\subsubsection{QoSの推定}
オフライン評価におけるQoS推定は，固定間隔の実測から得られる$P_{\mathrm{out}}(\tau\mid a)$等の指標を参照し，方策の滞在比率に基づき合成する（詳細は\secref{sec:metrics_detail}）．動的切替時の非定常性（切替直後の遅延分布など）は近似に含まれないため，実機評価で差分を検証する必要がある．

\subsection{Paretoフロントとδ帯プロット}
図\ref{fig:letter_delta_band}に，オフライン評価の代表例として，Pout(1s)と平均電力のトレードオフを示す．固定間隔点と候補方策点を同一平面で可視化することで，制約$\delta$付近における省電力運用点の存在を示す．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../results/mhealth_policy_eval/letter_v4_scan90_v5_delta_tight_sleep_on_n9_10_actions_100_500/fig_delta_band.png}
  \caption{δ帯（例）におけるPout(1s)と平均電力のトレードオフ（オフライン評価）}
  \label{fig:letter_delta_band}
\end{figure}

\subsubsection{Paretoプロット（全体像）}
図\ref{fig:pareto_plots}に，スイープ結果の全体像としてParetoプロットの例を示す．ここでは，行動集合を$\{100,500\}$に縮退した評価（実装の単純性を優先）を例とする．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.95\linewidth]{../results/mhealth_policy_eval/pareto_front_v8_power_table_scan90_v5_sleep_on_n9_10_actions_100_500/pareto_plots.png}
  \caption{Paretoプロット（例）：行動集合$\{100,500\}$に縮退したオフライン評価}
  \label{fig:pareto_plots}
\end{figure}

\subsection{行動空間の縮退（\{100,500\}）}
実機の動的制御を最小構成で成立させるため，行動空間を\{100,500\}に限定して代表方策を再選定する．この縮退により，実機側の実装・解析の複雑性を抑えつつ，電力低下の主効果（短間隔滞在の削減）に整合した比較が可能となる．

\subsection{選定方策の例}
オフライン評価の出力は，単一の最良方策ではなく，「制約$\delta$付近で成立する候補集合」として整理する．その上で，実機実験の本数制約や説明容易性を踏まえて代表点を選定する．代表点の一覧は\secref{sec:extra_results}に示す．

\subsection{まとめ}
本節では，mHealth合成と固定間隔の実測電力テーブルを組み合わせたオフライン評価により，QoS制約下での省電力運用点を探索する枠組みを示した．次節では，実機評価結果（\secref{sec:evaluation_results}）を示す．</file><file path="修士論文/chapters/ch8_experiment_design.tex">% chapters/ch8_experiment_design.tex --- 第9章 実験設計
\section{実験設計}
\label{sec:experiment_design}

\subsection{実験の目的}
Phase 1の実験目的は，ルールベース方策（CCS→広告間隔切替）が，固定間隔に対して省電力とQoSのトレードオフ上で優位な運用点になり得ることを示すことである．具体的には，以下を検証する．
\begin{enumerate}
  \item 省電力：固定\SI{100}{\milli\second}よりも$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$）が低い運用点が存在する．
  \item QoS維持：代表的な期限$\tau$に対して$P_{\mathrm{out}}(\tau)$が過度に悪化しない．
  \item トレードオフ：固定点と動的点を同一平面（$P_{\mathrm{out}}(\tau)$--$q_{\mathrm{event}}$）で比較し，Pareto的な位置づけを示す．
\end{enumerate}

\subsection{実験条件}
\subsubsection{環境条件}
実験は，距離，受信端末，スキャン設定等を固定し，端末内比較として実施する．干渉状況の違い（例：E1/E2）は外的要因として扱い，必要に応じて環境を分けて評価する．

\begin{table}[tb]
  \centering
  \caption{環境条件（例）}
  \label{tab:env_conditions}
  \begin{tabular}{ll}
    \toprule
    項目 &amp; 値（例） \\
    \midrule
    距離 &amp; \SI{1}{\meter} \\
    TxPower &amp; \SI{0}{\decibelmilliwatt} \\
    受信端末 &amp; Android（同一端末で統一） \\
    スキャンモード &amp; LOW\_LATENCY（前提条件を固定） \\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{制御条件}
制御条件は，固定間隔（ベースライン）と動的制御（提案）を含む．Phase 1の基本方針は，行動集合を$\{100,500,1000,2000\}\,\si{\milli\second}$とし，短間隔（QoS重視）と長間隔（省電力重視）の間を段階的に探索できる形にすることである．

一方で，実機実験の初期段階では，計測系の同期とログ整合を優先し，行動集合を$\{100,500\}\,\si{\milli\second}$に縮退した2値切替で動作成立を確認する．以降，計測の堅牢性が担保できた段階で，$\{100,500,1000,2000\}\,\si{\milli\second}$へ拡張する．

\begin{table}[tb]
  \centering
  \caption{制御条件（例）}
  \label{tab:control_conditions}
  \begin{tabular}{lll}
    \toprule
    条件ID &amp; 条件名 &amp; 広告間隔 \\
    \midrule
    C1 &amp; FIXED-100 &amp; \SI{100}{\milli\second} \\
    C2 &amp; FIXED-500 &amp; \SI{500}{\milli\second} \\
    C3 &amp; FIXED-2000 &amp; \SI{2000}{\milli\second} \\
    C4 &amp; POLICY（2値） &amp; \SI{100}{\milli\second}/\SI{500}{\milli\second} \\
    C5 &amp; POLICY（3値） &amp; \SI{100}{\milli\second}/\SI{500}{\milli\second}/\SI{2000}{\milli\second} \\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{反復設計}
統計的な揺らぎと端末状態のばらつきを抑えるため，各条件は複数回反復する．最小の成立確認としては各条件$n\ge3$とし，差が小さい場合に反復数を増やす．

また，運用シナリオに近い評価としては，環境（例：E1/E2）を分け，3条件（例：FIXED-100/FIXED-2000/POLICY）$\times$ 2環境 $\times$ 10セッション＝60セッション程度を計画し，端末内比較の前提を維持しながら分散（端末状態の非定常）を平均化する．

\subsection{セッション構成とイベント定義}
\subsubsection{セッション}
セッションは一定時間の試行（trial）の集合として構成する．実機の動的切替では，短い試行（例：\SI{60}{\second}）を連続して取り，条件間比較を端末内で完結させる設計が有効である．一方，運用シナリオに近い評価として，\SI{10}{\minute}程度の長いセッションを用い，活動遷移イベントでTL/Poutを評価する設計も重要である．

\subsubsection{イベント}
イベントは，状態遷移（活動の切替）など「QoS評価の基準点」となる時刻である．固定間隔では広告イベントの列から遅延分布を評価できるが，動的切替では開始位相ずれや切替タイミングが影響するため，truthに基づくイベント定義と時間同期が必要となる（次章）．

\subsection{指標算出}
\subsubsection{電力指標}
一次KPIの省電力指標は$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$）である．$q_{\mathrm{event}}$は，TXSDログの電流系列を積分して得た総電荷を，イベント数$N_{\mathrm{event}}$で正規化して算出する（定義は\secref{sec:metrics_detail}）．必要に応じて広告OFFの基準を差し引き，広告による増分を評価する．

平均電力$\overline{P}$や総エネルギー$E$，および広告回数で正規化した$\Delta E/N_{\mathrm{adv}}$等は従属指標として併用し，計測健全性の監査（単位・欠損）と原因切り分けに用いる．

\subsubsection{TLと$P_{\mathrm{out}}(\tau)$}
イベント$j$の遅延を$\mathrm{TL}_j$とすると，
\begin{equation}
  P_{\mathrm{out}}(\tau)=\frac{1}{N_{\mathrm{event}}}\sum_{j=1}^{N_{\mathrm{event}}}\mathbb{I}[\mathrm{TL}_j&gt;\tau]
\end{equation}
である．実装では，RXログの時刻とtruthの時刻の定数オフセットを補正し，$\mathrm{TL}_j$を計算する（次章）．

\subsubsection{理論モデル（参考）}
固定間隔における$P_{\mathrm{out}}(\tau)$は，1広告の受信成功確率$p_d$を仮定すると，
\begin{equation}
  P_{\mathrm{out}}(\tau\mid a)\approx(1-p_d)^{\lfloor \tau/a \rfloor}
\end{equation}
のように近似できる．ただし，非理想スキャンや開始位相の影響を含むため，本研究では理論値は補助的に用い，主張は実測に基づく．

\subsection{リスクと対策}
実験の主要リスクと対策を以下にまとめる．
\begin{itemize}
  \item 同期ずれ：SYNC/TICKの取りこぼしにより試行区間が崩れる．対策として，preambleで条件IDを通知し，ログ末尾のsummaryで監査する．
  \item 条件混在：LED/SYNCの扱い等が異なるコードを跨いで比較すると定常オフセットが入る．比較は同一コード系列で統一する．
  \item 欠損・単位不整合：UART/SDボトルネックや単位換算ミスは結論を逆転させ得る．パススルー化と再積分監査を行う．
  \item 端末状態の変動：受信端末のOS状態は非定常である．端末内比較を徹底し，実験前チェックリスト（\secref{sec:runbook}）を運用する．
\end{itemize}

\subsection{まとめ}
本節では，Phase 1における実験目的と条件，セッション構成，指標算出，およびリスク対策を整理した．次章では，TL/Poutの定義を実測に基づいて固定し，時間同期の手順（v5）を示す．</file><file path="修士論文/chapters/ch8_measurement_system.tex">% chapters/ch8_measurement_system.tex --- 第8章 計測系の健全化と再現性
\section{計測系の健全化と再現性確保}
\label{sec:measurement_system}

\subsection{目的}
本研究の主張は，電力とQoSを同時に評価した上で，固定間隔より良い運用点が存在することを示す点にある．したがって，計測系が不健全であれば，結論そのものが崩れる．本節では，計測系の構成と，過去に発生した代表的な不具合（異常値）の原因と対策を整理し，再現性確保のための運用ルールを述べる．

\subsection{三ノード構成（TX/TXSD/RX）}
電力計測はTX（被測定対象）の消費電流・電圧を計測し，受信品質はRXログから算出する．両者を同一試行で取得するために，同期信号で区間を揃える．この三ノード構成により，方策（固定/動的/学習）を差し替えても，同一の評価パイプラインで比較できる．

\subsection{計測装置の外観}
\figref{fig:measurement_setup_overview}に計測系の全体構成を，\figref{fig:measurement_nodes}に各ノードの外観を示す．以降の評価では，この三ノード構成（TX/TXSD/RX）を前提として，同一試行で電力と受信品質を取得する．

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.85\linewidth]{figures/measurement_setup_overview_02}
  \caption{計測系の外観（TX/TXSD/RXの三ノード構成，2025-12-16撮影）}
  \label{fig:measurement_setup_overview}
\end{figure}

\begin{figure}[tb]
  \centering
  \begin{minipage}{0.48\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/measurement_rx}
    \vspace{1mm}
    {\small (a) RXロガ（受信ログ）}
  \end{minipage}
  \hfill
  \begin{minipage}{0.48\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/measurement_tx_txsd}
    \vspace{1mm}
    {\small (b) TX + TXSD（DUT + 電力ログ）}
  \end{minipage}
  \caption{計測ノードの外観（2025-12-16撮影）}
  \label{fig:measurement_nodes}
\end{figure}

\subsection{計測系の破綻モードと対策}
計測系の問題は，「値が揺れる」だけではなく，結論を逆転させる（例：OFFがONより大きい）形で顕在化し得る．表\ref{tab:measurement_failures}に，代表的な破綻モードと対策をまとめる．

\begin{table}[tb]
  \centering
  \caption{計測系の代表的な破綻モードと対策}
  \label{tab:measurement_failures}
  \begin{tabular}{p{0.30\linewidth}p{0.30\linewidth}p{0.30\linewidth}}
    \toprule
    破綻モード &amp; 兆候 &amp; 代表的対策 \\
    \midrule
    I/Oボトルネック（UART/SD） &amp; 欠損増加，rate低下，dtの歪み &amp; パススルー化，塊書き込み，整数CSV化 \\
    単位換算の誤り &amp; 桁ズレ，ON/OFFの逆転 &amp; 生ログから再積分し監査，式とラベルを固定 \\
    条件混在（LED/SYNCの違い等） &amp; 条件間に定常オフセット &amp; 比較は同一コード系列に限定，条件を明文化 \\
    時間軸不整合（RXとtruth） &amp; TL/Poutが不自然に小さい &amp; 定数オフセットで時間同期（\secref{sec:stress_fixed_metrics}） \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{代表的な異常：OFFがONより大きい問題}
初期の計測では，「広告OFFの方が広告ONより消費が大きい」という物理的に矛盾した結果が観察された．この問題は，無線スタックそのものではなく，PowerLogger側の処理能力不足（I/Oボトルネック）や，単位換算の不整合，UART通信エラーによる欠損が原因となり得る．

\noindent
本研究では，代表的要因と対策を表\ref{tab:measurement_failures}に要点化し，運用上は以下をチェックポイントとして監査した．
\begin{itemize}
  \item I/Oボトルネック：欠損増加$\rightarrow$dtの歪み$\rightarrow$積分破綻を引き起こすため，塊書き込み等で追従性を確保する．
  \item 単位換算：mV/$\mu$A/ms等の桁ずれは結論を逆転させ得るため，生ログ再積分とsummary整合で監査する．
  \item UART通信：文字混入や欠損を厳密パースで検出し，異常trialはその場で再試行して混在を避ける．
\end{itemize}

\subsection{実装トラブルと修正履歴}
本節では，実験の再現性を担保するため，実装上の問題と対策を「問題→症状→対策→再発防止」の観点で整理する．ここで扱う内容は，結果の水増しではなく，欠損や時間軸ずれによる結論の崩壊を避けるための前提条件である．

\begin{table}[tb]
  \centering
  \caption{代表的な実装トラブルと対策（要点）}
  \label{tab:implementation_troubles_summary}
  \begin{tabularx}{\linewidth}{p{0.26\linewidth}X p{0.28\linewidth}}
    \toprule
    問題 &amp; 対策（要点） &amp; 再発防止（監査） \\
    \midrule
    UARTデータ化け &amp; ボーレート低下，厳密パース，欠損を許さないsummary設計 &amp; 行数・欠損率・単位監査 \\
    SYNC検出失敗（短パルス） &amp; HIGH保持やラッチで確実に検出できる信号設計へ変更 &amp; TX/RX/TXSDの境界一致を確認 \\
    試行境界の不一致 &amp; SYNC\_END等で試行区間を一致させる &amp; ms\_totalとadv\_countの整合 \\
    SD I/O失敗 &amp; SPIクロック調整，塊書き込み，open失敗時の即時停止 &amp; 末尾summaryの有無を監査 \\
    \bottomrule
  \end{tabularx}
\end{table}
\noindent
これらは研究の主張そのものではないが，欠損や試行区間のずれによる結論の崩壊を避けるために不可欠である．対策はRunbook（\secref{sec:runbook}）に固定し，試行ごとにms\_total/adv\_count/欠損率等を監査して再現性を担保した．

\subsection{Golden Master（最小再現構成）}
比較実験では，ON/OFFや条件間でコード系列が混在すると，LEDや同期信号の扱いの差が定常オフセットとなり，純粋な広告間隔の差分を評価できない．したがって，代表的な再現構成（Golden Master）を定め，これを基準としてデータを蓄積する．本研究では，役割ごとにスケッチを分割し，ファイル名の接頭辞（RX\_/TX\_/TXSD\_）で役割を明確化する．

\subsection{運用ルール}
再現性確保のため，以下を原則とする．
\begin{itemize}
  \item 解析対象の選別はマニフェストで明示し，除外理由を記録する．
  \item 単位監査（再積分とsummaryの一致）を定期的に実行し，桁ずれや欠損を早期に検知する．
  \item 重要な作業は作業ログに追記し，生成物のパスとコマンドを残す．
\end{itemize}

\subsection{まとめ}
本節では，計測系の健全化と再現性確保のための要点を整理した．これにより，固定間隔と動的制御の比較が「同一の評価系で再現可能」であることを担保し，次段階（オンライン最適化）へ接続する基盤とする．</file><file path="修士論文/chapters/ch9_har_uncertainty.tex">% chapters/ch9_har_uncertainty.tex --- 第5章 HAR推論部（TinyML）と不確実度の構成
\section{HAR推論部（TinyML）と不確実度の構成}
\label{sec:har_uncertainty}

\subsection{目的}
本研究の制御は，HARの推論結果そのものではなく，「推論がどの程度信頼できるか」を表す不確実度と，「状態がどの程度安定しているか」を表す安定度に基づいて動作する．本節では，TinyML環境を想定したHAR推論部の位置づけと現状を整理し，端末内推論から不確実度$U$と安定度$S$を得て複合スコアCCSを構成する流れ，および実装上の制約と未完タスクをまとめる．

\subsection{HARモデルと現状}
HARは，加速度等の時系列入力を一定窓で切り出し，クラス確率分布を出力する．本研究では参照モデル（A0）と小型モデル（A\_tiny）を区別し，Phase 1では評価指標・計測系・制御の成立を優先するため，最終的なTinyML最適化（A\_tinyの性能到達やTFLite整合の監査）はPhase 2に跨る将来課題として位置づける．

\subsection{不確実度U}
HARモデルは，各時刻$t$においてクラス確率分布$\mathbf{p}(t)=(p_1(t),\dots,p_K(t))$を出力する．本研究では，この確率分布から不確実度$U(t)$を導出し，通信制御のコンテキストとする．不確実度$U$は，正規化エントロピーとして定義できる\scite{shannon1948}．
\begin{equation}
  U(t) = -\frac{\sum_{k=1}^{K} p_k(t)\log p_k(t)}{\log K}
\end{equation}
ここで$U=0$は確信度が高い状態，$U=1$は不確実な状態に対応する．$U$は1回の推論出力から計算できるため，多回推論を必要とする不確実度推定（例：MC-Dropout）と比較して計算コストが小さい．

\subsubsection{較正（Calibration）の位置づけ}
ソフトマックス確率は，ニューラルネットの過信（overconfidence）により，確率値が実際の正解率を過大評価する場合がある．不確実度$U$を通信制御に用いる場合，この過信は「本来短間隔にすべき局面で長間隔を選ぶ」リスクに直結する．そのため，推論結果の確率較正（例：温度スケーリング）により，$U$と実際の誤り確率の対応を改善することが望ましい\scite{guo2017calibration}．

\subsection{安定度S}
安定度$S$は，直近窓におけるラベル遷移回数や，状態滞在時間に基づいて構成する．例えば，ラベル遷移が少ないほど安定であるという設計意図のもと，$S$を1に近づける．

\subsubsection{窓長と応答性}
安定度は窓長$W$に依存する．$W$が短いと遷移への応答が速い一方でノイズに敏感になり，$W$が長いと安定する一方で過渡期に追従しにくい．本研究では，実装の単純性を優先し，スライディング窓に基づく遷移回数の正規化という形で$S$を構成する（第2章）．

\subsection{複合スコアCCS}
複合スコアCCSは，確信度$(1-U)$と安定度$S$の線形結合として定義する．
\begin{equation}
  \mathrm{CCS}(t)=\alpha\,(1-U(t))+(1-\alpha)\,S(t)
\end{equation}
係数$\alpha$は設計パラメータであり，Phase 1では説明容易性を優先して固定値（例：$\alpha=0.7$）を採用する．ただし，$\alpha$や窓長$W$が変わるとCCS分布が変化し，閾値の意味が変わるため，モデル更新時には閾値再キャリブレーションが必要となる．

\subsubsection{係数設計と解釈}
係数$\alpha$を大きくすると，瞬時の確信度（$1-U$）を重視し，「いま確信があるなら長間隔」という単調な解釈に近づく．一方で$\alpha$を小さくすると，時間的一貫性（安定度$S$）を重視し，短時間の確信度の揺らぎで切替が発生しにくくなる．本研究では，Phase 1の主張（説明容易性）を優先し，確信度を主成分として扱う．

\subsection{時系列生成とログ}
制御に用いる$U(t)$，$S(t)$，$\mathrm{CCS}(t)$は，スライディング窓で逐次計算し，TXログとして保存する．このログは，オフライン評価および実機評価で共通に利用するため，ログ形式と時間軸の整合が重要である．

本研究の想定はバッテリ駆動の小型端末であり，推論・制御・ログの計算コストは制約となる．不確実度$U$は推論出力から1回で計算できるため，多回推論を要する不確実度推定より計算コストが小さい．一方で，量子化や確率較正により$U$と閾値の意味づけが変化し得るため，モデル更新時は閾値再キャリブレーションが必要となる．

\subsection{まとめ}
本節では，TinyML環境を想定したHAR推論部の現状と，不確実度$U$・安定度$S$・CCSの構成を整理した．また，量子化とTFLite整合の重要性，および未完タスクを明示した．以降の章では，このコンテキストに基づく広告間隔制御と，計測・指標に基づく評価を述べる．</file><file path="修士論文/chapters/conclusion.tex">% chapters/conclusion.tex --- おわりに（番号なし、目次には載せる）
\chapterwithtoc{おわりに}

本研究では，HARの推論不確実度に基づくBLE広告間隔の適応制御を対象とし，ルールベース方策の定義と評価指標の確立，および動的切替の実機検証に取り組んだ．特に，送信・受信・電力計測を統合した計測基盤を整備し，$\si{\micro\coulomb}/\text{event}$と受信遅延に基づく期限超過率を同時に評価できる形に整理した．この結果，単純な閾値ルールでも固定間隔より省電力になりうる運用点が存在し得ることを示し，将来のSafe Contextual Bandit最適化に接続する基盤を与えた．

\section*{本研究のまとめ}
本研究で得られた知見を以下にまとめる．
\begin{itemize}
  \item 不確実度と安定度から複合スコアCCSを構成し，閾値・ヒステリシス・最小滞在時間を用いたルールベース方策として定義した．
  \item 送信（TX），電力（TXSD），受信（RX）の三ノード構成により，同一試行で電力とQoS（TL，$P_{\mathrm{out}}(\tau)$）を評価できる基盤を整備した．
  \item TL/Poutの算出において，開始位相ずれが結果を歪め得ることを示し，定数オフセット補正（v5）として指標定義を固定した．
  \item オフライン評価により，固定間隔点と候補方策点のトレードオフを可視化し，実機実験の探索空間を縮小する枠組みを示した．
  \item 実機実験（D2b/D3）とアブレーション（D4/D4B）により，方策が固定間隔の間の運用点として成立し得ることを示し，さらに$U$が電力（短間隔滞在量）を，CCSが同電力でQoSを改善する役割分担を示唆した．
\end{itemize}

\section*{今後の課題}
今後は，動的制御に対してTL分布と$P_{\mathrm{out}}(\tau)$を高精度に算出し，オフライン評価の予測と実測の差分を体系的に説明できる形にまとめる．また，行動集合を拡張し，制約$\delta$の境界に沿ってより良い運用点を探索する必要がある．さらに，Safe Contextual Banditによるオンライン最適化へ拡張し，環境変化に対してもQoS制約を維持しながら省電力化できる枠組みを検証する．</file><file path="修士論文/figures/README.md"># figures/

図（PDF/PNG）を置くディレクトリ。

- `\includegraphics{figures/&lt;name&gt;}` のように拡張子なしで参照する。
- 生成物の元（スクリプトや入力データ）は本文側に明記する。

## 写真（計測装置）

- `measurement_setup_overview_02.jpg`: 実験構成（全体）写真（元: `image/実験構成02.JPG`）
- `measurement_rx.jpg`: RXロガ外観（元: `image/RX.JPG`）
- `measurement_tx_txsd.jpg`: TX + TXSD外観（元: `image/TX&amp;TXSD.JPG`）

注: 上記は向き補正・メタデータ除去・リサイズを行った派生物（提出用）であり，原本は `image/` に保存する。

## 図（システム構成）

- `measurement_architecture_esp32_three_node.jpg`: ESP32三ノード実験装置（TX/TXSD/RX + 外部電源 + INA219）の配線・信号構成図（元: `image/ESP32三ノード実験装置.jpg`）</file><file path="修士論文/frontmatter/abstract.tex">% frontmatter/abstract.tex --- 要旨本文
% ここには通常，背景→課題→提案→方法→結果→結論→今後の課題，の順に1ページ程度で書く．

本研究では，Human Activity Recognition（HAR）の推論不確実度に基づいてBluetooth Low Energy（BLE）の広告間隔を適応制御し，省電力化とQuality of Service（QoS）維持を両立する手法を検討する．ウェアラブル端末やエッジデバイスでは，常時通信による電力消費がボトルネックとなる一方，スマートフォン側のスキャンは非理想的であり，広告間隔を単純に長くすると受信遅延や期限超過が増える．

提案手法は，HARの出力確率から得られる不確実度と，時間的安定度から複合スコアCCSを構成し，その値に応じて広告間隔を段階的に切り替えるルールベース方策である．実装・評価のために，送信（TX）・電力ロガ（TXSD）・受信（RX）の三ノード構成を用い，省電力指標$q_{\mathrm{event}}$（$\si{\micro\coulomb}/\text{event}$）と，受信遅延に基づく期限超過率$P_{\mathrm{out}}(\tau)$を同一試行で評価できる計測基盤を整備する．

オフライン評価と実機実験により，単純な閾値ルールでも固定間隔より省電力になりうる運用点が存在することを確認する．さらに，\SI{100}{\milli\second}と\SI{500}{\milli\second}の2値切替を用いた最小構成の動的制御を実装し，固定間隔と比較して中間的な挙動を示すことを確認する．最後に，非理想スキャン環境における限界と，Safe Contextual Banditによるオンライン最適化への拡張方針を議論する．

加えて，$U$の時間整合を破壊するU-shuffleと，CCSを無効化するCCS-offのアブレーションにより，$U$が短間隔滞在量（電力）を，CCSが同電力でQoS（期限超過率・遅延）を改善する役割を切り分けて示す．</file><file path="修士論文/.gitignore">build/
*.aux
*.bbl
*.bcf
*.blg
*.fdb_latexmk
*.fls
*.log
*.out
*.run.xml
*.synctex.gz</file><file path="修士論文/chubuthesis.sty">% chubuthesis.sty --- 修士論文テンプレート（LuaLaTeX）
% 例の Word→PDF 修論の体裁を参考に、表紙/要旨/目次/図表キャプション等を整えています。

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{chubuthesis}[2025/12/15 Thesis style]

% --- 日本語（LuaLaTeX） ---
\RequirePackage{luatexja}
\RequirePackage[haranoaji]{luatexja-preset}

% --- レイアウト ---
% Word由来PDFの厳密な余白は推定が難しいため、一般的な学位論文の安全域で設定。
% 研究室/学科で指定があればここを調整してください。
\RequirePackage[a4paper,top=25mm,bottom=25mm,left=30mm,right=25mm]{geometry}

% 段落字下げ（1全角）
% LuaLaTeXでは「zw」単位ではなく \zw を使う（luatexja）
\setlength{\parindent}{1\zw}
\setlength{\parskip}{0pt}

% 目次は section まで（先輩修論の見え方に寄せる）
\setcounter{tocdepth}{1}
\setcounter{secnumdepth}{2}

% --- ページ番号（下右に統一） ---
\RequirePackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% chapter開始ページなど plain も同じにする
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyfoot[R]{\thepage}%
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0pt}%
}

% ltjsreport は章開始などで plainhead/plainfoot を使うため、こちらも同じにする
\fancypagestyle{plainhead}{%
  \fancyhf{}%
  \fancyfoot[R]{\thepage}%
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0pt}%
}
\fancypagestyle{plainfoot}{%
  \fancyhf{}%
  \fancyfoot[R]{\thepage}%
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0pt}%
}

% --- 章見出し（中央寄せ・太字にしない） ---
\RequirePackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\Large\centering}
  {第\thechapter\relax 章}
  {2em}
  {\Large}
\titleformat{name=\chapter,numberless}[display]
  {\normalfont\Large\centering}
  {}
  {0pt}
  {\Large}
\titlespacing*{\chapter}{0pt}{0.33\textheight}{0pt}
\titlespacing*{name=\chapter,numberless}{0pt}{0.33\textheight}{0pt}

% --- 図表 ---
\RequirePackage{graphicx}
\RequirePackage{booktabs}
\RequirePackage{tabularx}
\RequirePackage{longtable}
\RequirePackage{array}

% --- 数式 ---
\RequirePackage{amsmath,amssymb}
\numberwithin{equation}{chapter}

% --- 単位 ---
\RequirePackage{siunitx}
\sisetup{detect-all}
\DeclareSIUnit{\decibelmilliwatt}{dBm}

% --- キャプション：図 4-1 タイトル / 表 4-1 タイトル ---
\RequirePackage{caption}
\renewcommand{\thefigure}{\thechapter-\arabic{figure}}
\renewcommand{\thetable}{\thechapter-\arabic{table}}
\captionsetup{labelsep=space}
\captionsetup[figure]{name=図,justification=centering}
\captionsetup[table]{name=表,justification=centering}

% --- 参照（図/表/式） ---
\newcommand{\figref}[1]{図~\ref{#1}}
\newcommand{\tabref}[1]{表~\ref{#1}}
\newcommand{\eqrefj}[1]{式~(\ref{#1})}
\newcommand{\secref}[1]{\ref{#1}節}

% --- 章（番号なし）でも目次に載せる：はじめに / おわりに / 謝辞 ---
\newcommand{\chapterwithtoc}[1]{%
  \chapter*{#1}%
  \addcontentsline{toc}{chapter}{#1}%
  \clearpage
}

% --- 参考文献（biblatex） ---
\RequirePackage[backend=biber,style=numeric,sorting=none]{biblatex}

% \scite{a,b} で [1][2] 形式を作る（普通の \cite は [1,2]）
\DeclareCiteCommand{\scite}
  {}
  {\mkbibbrackets{\usebibmacro{citeindex}\usebibmacro{cite}}}
  {}
  {}

% URL 表記を簡素化（&quot;url:&quot; / &quot;visited on&quot; を出さない）
\DeclareFieldFormat{url}{\url{#1}}
\renewbibmacro*{url+urldate}{\printfield{url}}

% --- ハイパーリンク（最後の方で読み込み） ---
\RequirePackage[hidelinks]{hyperref}
\RequirePackage{bookmark}

% --- 目次 ---
% numberless \chapter の「章扉（縦中央）」体裁を避け、目次の先頭余白を詰めて表示する
\makeatletter
\newcommand{\thesistableofcontents}{%
  \clearpage
  \thispagestyle{plain}%
  \pdfbookmark[0]{\contentsname}{toc}%
  \begin{center}
    {\Large \contentsname\par}
  \end{center}
  \vspace{1em}
  \@starttoc{toc}%
  \clearpage
}
\makeatother

% --- 表紙・要旨ページ ---
% meta.tex で定義するコマンドを使う想定

\newcommand{\makethesistitle}{%
\begin{titlepage}
  \thispagestyle{empty}
  \centering
  \vspace*{20mm}
  {\Large \ThesisYearLabel\par}
  \vspace{25mm}

  \fbox{%
    \parbox{0.85\textwidth}{\centering
      \vspace{6mm}
      {\Large \ThesisTitle\par}
      \vspace{6mm}
    }%
  }

  \vfill
  {\Large \University\ \GraduateSchool\par}
  {\Large \Department\ \Course\par}
  \vspace{10mm}
  {\Large 氏名\hspace{2em}\AuthorFamily\ \AuthorGiven\par}
  \vspace{5mm}
  {\Large 指導教授\hspace{2em}\AdvisorFamily\ \AdvisorGiven\par}
\end{titlepage}
}

\newcommand{\makeabstractpage}{%
\clearpage
\thispagestyle{empty}
\noindent 修士論文題目

\vspace{6mm}
\begin{center}
  {\Large \ThesisTitle\par}
  \vspace{-2mm}
  \rule{0.9\textwidth}{0.4pt}
\end{center}

\vspace{4mm}
\noindent \AbstractDepartment\hspace{2em}氏名\hspace{2em}\AuthorFamily\ \AuthorGiven

\vspace{8mm}
\begin{center}
  論\quad 文\quad 要\quad 旨
\end{center}

\vspace{6mm}
\input{frontmatter/abstract}
\clearpage
}</file><file path="修士論文/latexmkrc">$out_dir = &apos;build&apos;;
$aux_dir = &apos;build&apos;;

# luaotfload/luatexja のキャッシュを書き込み可能な場所に固定する（sandbox対策）
$ENV{TEXMFCACHE}  = &apos;build/texmf-cache&apos;;
$ENV{TEXMFVAR}    = &apos;build/texmf-var&apos;;
$ENV{TEXMFCONFIG} = &apos;build/texmf-config&apos;;
$ENV{LUATEXCACHE} = &apos;build/luatex-cache&apos;;

# LuaLaTeX + biber (biblatex)
$pdf_mode = 4;
$lualatex = &apos;lualatex -interaction=nonstopmode -file-line-error %O %S&apos;;
$bibtex_use = 2;

# Keep going for draft builds; errors still surface in exit code.
$interaction = &apos;nonstopmode&apos;;</file><file path="修士論文/main.tex">% main.tex --- 修士論文テンプレート（LuaLaTeX）
\documentclass[a4paper,12pt,oneside]{ltjsreport}

% 体裁（図表キャプション、目次深さ、表紙/要旨ページ等）
\usepackage{chubuthesis}

% メタ情報（タイトル等）
\input{meta}

% 参考文献ファイル
\addbibresource{references.bib}

\begin{document}

% page anchor の重複警告を避ける（表紙・要旨はページ番号なし）
\hypersetup{pageanchor=false}

% --- 表紙（ページ番号なし） ---
\makethesistitle

% --- 要旨ページ（ページ番号なし） ---
\makeabstractpage

% --- 目次（ローマ数字 i） ---
\pagenumbering{roman}
\setcounter{tocdepth}{1}
\thesistableofcontents

% --- 本文（アラビア数字 1 から） ---
\hypersetup{pageanchor=true}
\pagenumbering{arabic}
\setcounter{page}{1}

\input{chapters/ch0_introduction}
\input{chapters/ch2_background_related}
\input{chapters/ch3_system_and_method}
\input{chapters/ch4_measurement_metrics_repro}
\input{chapters/ch5_evaluation}
\input{chapters/ch5_publicroad}

\input{chapters/conclusion}
\input{chapters/acknowledgements}

% --- 参考文献・参考URL ---
\printbibliography[heading=bibintoc,title={参考文献・参考 URL}]

\end{document}</file><file path="修士論文/meta.tex">% meta.tex --- 論文メタ情報（ここだけ編集すればOK）
% 全角数字にしたい場合は「２０２５」のように入力してください。

% ===== 表紙に出る情報 =====
\newcommand{\ThesisYearLabel}{２０２５年度修士論文}
\newcommand{\ThesisTitle}{HAR不確実度に基づくBLE広告間隔の適応制御に関する研究}

\newcommand{\University}{中部大学大学院}
\newcommand{\GraduateSchool}{工学研究科}
\newcommand{\Department}{情報工学専攻}
\newcommand{\Course}{博士前期課程}

\newcommand{\AuthorFamily}{萩原}
\newcommand{\AuthorGiven}{圭島}

\newcommand{\AdvisorFamily}{木村}
\newcommand{\AdvisorGiven}{秀明}

% ===== PDFの「修士論文題目」ページ（要旨ページ）に出る情報 =====
\newcommand{\AbstractDepartment}{情報工学専攻}</file><file path="修士論文/README.md"># 修士論文 LaTeX テンプレート（LuaLaTeX）

Word→PDF の修論の体裁を参考に、表紙・要旨・目次・本文・図表キャプション・参考文献を一式で用意したテンプレートです。

---

## 1) まず編集するファイル

- `meta.tex`（タイトル・氏名など）
- `frontmatter/abstract.tex`（要旨）
- `chapters/*.tex`（本文）
- `references.bib`（参考文献）

---

## 2) コンパイル方法（LuaLaTeX推奨）

### ローカル（TeX Live）
```bash
latexmk main.tex
```

生成物は `build/main.pdf` に出力されます（ビルド用の一時ファイル/キャッシュも `build/` 配下）。
ページ数は `build/main.log` の `Output written on main.pdf (XX pages, ...)` で確認できます。

### Overleaf
- Compiler: **LuaLaTeX**
- Bibliography: **Biber**（biblatex使用）

---

## 3) 図の置き場

- `figures/` に入れて、拡張子なしで呼ぶのが楽です（PDF/PNG両対応）
```tex
\includegraphics[width=0.9\linewidth]{figures/fig_system_overview}
```

- 写真も提出用には `figures/` に置く（元データはリポジトリ直下の `image/` に保存し、提出用は向き補正・メタデータ除去・リサイズした派生物を `figures/` へ置く）。

---

## 4) 引用の書き方

このテンプレートは biblatex です。

- 普通の引用（カンマ区切り）：`\cite{ref1,ref2}` → `[1,2]`
- 括弧を分けたい場合：`\scite{ref1,ref2}` → `[1][2]`

---

## 5) 大学体裁に寄せる追加ルール（固定）

このテンプレートは「先輩修論（大学方針の体裁）」に寄せるため、以下を**ルールとして固定**する。

- ページ番号：目次はローマ数字（i〜）、本文（第1章）からアラビア数字（1〜）
- ページ番号の位置：全ページ下右（章扉など `plain` も同じ）
- 章扉：各章は `\chapter{...}\clearpage` で「章タイトルだけのページ」を挟む（`chapters/*.tex` 側で徹底）
- 章見出し：中央寄せ・太字にしない（日本語太字のゴシック化を避ける）
- 目次：`section` まで（`tocdepth=1`）
- 図表キャプション：`図 4-1 タイトル` / `表 4-1 タイトル`（章-連番、区切りはスペース）
- 参照：章番号・節番号を手で書かない（`\secref{...}` / `\figref{...}` / `\tabref{...}` を使う）
- 参考文献：URLは載せるが `url:` / `visited on` は出さない（体裁側で抑制）

---

## 6) 体裁を変えたいとき

- 余白：`chubuthesis.sty` の `geometry` を編集
- 図表キャプション：`chubuthesis.sty` の `caption` 設定を編集
- 表紙/要旨ページ：`meta.tex`（値）と `chubuthesis.sty`（配置）を編集
- ページ番号（下右統一）：`chubuthesis.sty` の `fancyhdr` 設定を編集
- 章見出し（章扉の中央寄せ等）：`chubuthesis.sty` の `titlesec` 設定を編集
- 参考文献のURL表示：`chubuthesis.sty` の `biblatex` まわりを編集</file><file path="修士論文/references.bib">% references.bib --- 参考文献・参考URL
% biblatex/biber 用。まずは「本文中で引用できる最小セット」を置く。

@online{bluetooth_core_spec,
  title        = {Bluetooth Core Specification},
  organization = {Bluetooth SIG},
  url          = {https://www.bluetooth.com/specifications/bluetooth-core-specification/},
  urldate      = {2025-12-15},
}

@online{android_ble_scanner,
  title        = {BluetoothLeScanner},
  organization = {Android Developers},
  url          = {https://developer.android.com/reference/android/bluetooth/le/BluetoothLeScanner},
  urldate      = {2025-12-15},
}

@online{uci_ml_repo,
  title        = {UCI Machine Learning Repository},
  organization = {University of California, Irvine},
  url          = {https://archive.ics.uci.edu/},
  urldate      = {2025-12-15},
}

@book{lattimore2020bandit,
  title     = {Bandit Algorithms},
  author    = {Lattimore, Tor and Szepesv{\&apos;a}ri, Csaba},
  year      = {2020},
  publisher = {Cambridge University Press},
}

@article{shannon1948,
  author  = {Shannon, Claude E.},
  title   = {A Mathematical Theory of Communication},
  journal = {Bell System Technical Journal},
  year    = {1948},
  volume  = {27},
  pages   = {379--423, 623--656},
}

@inproceedings{guo2017calibration,
  title     = {On Calibration of Modern Neural Networks},
  author    = {Guo, Chuan and Pleiss, Geoff and Sun, Yu and Weinberger, Kilian Q.},
  booktitle = {Proceedings of the 34th International Conference on Machine Learning},
  year      = {2017},
}</file><file path="修士論文/WRITING_RULES.md"># 記述ルール（提案）

Word→PDF の修論（例）を踏まえつつ、LaTeX化で破綻しやすい部分を先に規格化したルールです。

---

## 0. 体裁ルール（守るべき型）

この修論テンプレートは、先輩修論（大学方針の体裁）に寄せる。以下は**ルールとして固定**し、本文側で勝手に崩さない。

1. **表紙**：年度ラベル → 題目（枠で囲う） → 所属（2行） → 氏名（1行） → 指導教授（1行）
2. **要旨ページ**：上部に「修士論文題目」→題目（下線）→「専攻　氏名　〇〇〇〇」（1行）→「論 文 要 旨」→要旨本文
3. **ページ番号**：目次はローマ数字（i から），本文はアラビア数字（1 から）で開始する
4. **ページ番号の位置**：全ページを下右に統一する（章開始ページの `plain` も含む）
5. **章扉**：各章は「章タイトルだけのページ」を挟み、本文は次ページから開始する（`\chapter{...}\clearpage`）
6. **図表キャプション**：図は `図 4-1 タイトル`，表は `表 4-1 タイトル`（章-連番、区切りはスペース）
7. **引用の見た目**：本文中は基本 `[1][2]` 形式（`\scite{a,b}`）を優先する（参考文献では `url:` や `visited on` を表示しない）

テンプレ側で設定済みのため、基本は本文の書き方だけ守ればよい。

---

## A. 文体・表記

1. **文体は「である調」で統一**
2. **句読点は「，」「．」を基本**（※研究室の慣例があればそちら優先）
3. **略語は初出で定義**（例：Bluetooth Low Energy（BLE））
4. **用語の揺れを禁止**（「端末/デバイス」「推定/推測」など）

---

## B. 章立て・見出し

1. **章は `\chapter`、節は `\section`、項は `\subsection`**
2. **各章は章扉を入れる**：`\chapter{...}` の直後に `\clearpage` を置き、本文は次ページから書く
3. **番号なし章（おわりに / 謝辞）は `\chapterwithtoc{...}` を使う**（目次に載せる）
4. **章番号・節番号は手で書かない**：`第X章で述べた` の代わりに `\secref{sec:...}` を使う

---

## C. 図・表

1. **図は `figure`、表は `table` 環境で管理**（手貼り禁止）
2. **本文中で必ず参照してから出す**（例：`…（\figref{fig:hoge}）…`）
3. **他資料から転載する場合はキャプションに明記**（例：`（[1]より引用）`）
4. **`caption` の形式はテンプレート通り**（図：`図 4-1 タイトル`、表：`表 4-1 タイトル`）

---

## D. 引用・参考文献

1. **引用は本文中に番号で示す**（`biblatex`）
2. **複数引用は**
   - `[1,2]`（`\cite{a,b}`）でも一般にはOK
   - 例に合わせたいなら `[1][2]`（`\scite{a,b}`）

3. **Webページは参照日（urldate）を入れる**

---

## E. 数式・単位・記号

1. **単位は SI に寄せる**（`siunitx` を使用）
2. **記号は定義してから使う**（記号表があると強い）

---

## F. AIを併用する前提の運用ルール（重要）

1. **章ごとにファイル分割**（テンプレート通り）
2. **AIに依頼するときのプロンプトを固定化**
   - 「である調」
   - 「句読点は，．」
   - 「図表は必ず `\label` と `\ref`」
   - 「引用は `\cite`/`\scite`」
3. **ビルドエラーをゼロに保つ**
   - 変更したら必ずコンパイル
   - 参照未解決（??）や重複ラベルを放置しない

---

## G. ビルド（ローカル）

このリポジトリでは `latexmk` を使い，生成物は `修士論文/build/` に出力する。

```bash
cd 修士論文
latexmk main.tex
```</file><file path="scripts/bootstrap_effects.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Bootstrap effect sizes (difference of means) with percentile CI from per-trial CSVs.

Designed for this repo&apos;s uccs_* metrics outputs:
  - uccs_d4b_scan90/metrics/&lt;run&gt;/per_trial.csv
  - uccs_d4_scan90/metrics/&lt;run&gt;/per_trial.csv
  - uccs_d3_scan70/metrics/&lt;run&gt;/per_trial.csv

No external dependencies (no pandas/numpy).

Example:
  python3 scripts/bootstrap_effects.py \
    --in uccs_d4b_scan90/metrics/01/per_trial.csv \
    --out-dir uccs_d4b_scan90/metrics/01 \
    --title &quot;D4B scan90 S4 (run01)&quot; \
    --compare &quot;pout_1s,S4_policy,S4_ablation_ccs_off,Δpout (U+CCS − U-only)&quot; \
    --compare &quot;avg_power_mW,S4_policy,S4_ablation_ccs_off,Δpower (U+CCS − U-only)&quot; \
    --n-boot 20000 --seed 20251217
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
import random
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple


@dataclass(frozen=True)
class EffectResult:
    metric: str
    cond_a: str
    cond_b: str
    label: str
    n_a: int
    n_b: int
    mean_a: float
    mean_b: float
    delta: float
    ci_low: float
    ci_high: float
    p_two_sided: float


def _mean(xs: Iterable[float]) -&gt; float:
    xs = list(xs)
    if not xs:
        return float(&quot;nan&quot;)
    return sum(xs) / len(xs)


def _parse_float(v: str) -&gt; Optional[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return None
    try:
        x = float(v)
    except Exception:
        return None
    if math.isnan(x) or math.isinf(x):
        return None
    return x


def _percentile(sorted_xs: List[float], p: float) -&gt; float:
    if not sorted_xs:
        return float(&quot;nan&quot;)
    if p &lt;= 0:
        return sorted_xs[0]
    if p &gt;= 1:
        return sorted_xs[-1]
    k = (len(sorted_xs) - 1) * p
    f = math.floor(k)
    c = math.ceil(k)
    if f == c:
        return sorted_xs[int(k)]
    d0 = sorted_xs[f] * (c - k)
    d1 = sorted_xs[c] * (k - f)
    return d0 + d1


def _bootstrap_delta(
    a: List[float],
    b: List[float],
    n_boot: int,
    seed: int,
) -&gt; List[float]:
    rnd = random.Random(seed)
    na, nb = len(a), len(b)
    if na &lt;= 0 or nb &lt;= 0:
        return []
    out: List[float] = []
    for _ in range(n_boot):
        sa = [a[rnd.randrange(na)] for _ in range(na)]
        sb = [b[rnd.randrange(nb)] for _ in range(nb)]
        out.append(_mean(sa) - _mean(sb))
    return out


def _two_sided_p_from_bootstrap(deltas: List[float], obs: float) -&gt; float:
    if not deltas:
        return float(&quot;nan&quot;)
    # percentile bootstrap p-value: 2*min(P(delta&gt;=0), P(delta&lt;=0)) around the null 0.
    ge0 = sum(1 for d in deltas if d &gt;= 0.0) / len(deltas)
    le0 = sum(1 for d in deltas if d &lt;= 0.0) / len(deltas)
    p = 2.0 * min(ge0, le0)
    return min(1.0, max(0.0, p))


def _read_values_by_condition(per_trial_csv: Path, metric: str) -&gt; Dict[str, List[float]]:
    out: Dict[str, List[float]] = {}
    with per_trial_csv.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        if not rdr.fieldnames:
            raise SystemExit(f&quot;empty header: {per_trial_csv}&quot;)
        if &quot;condition&quot; not in rdr.fieldnames:
            raise SystemExit(f&quot;missing column &apos;condition&apos; in {per_trial_csv}&quot;)
        if metric not in rdr.fieldnames:
            raise SystemExit(f&quot;missing metric &apos;{metric}&apos; in {per_trial_csv} (available: {rdr.fieldnames})&quot;)
        for row in rdr:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            v = _parse_float(row.get(metric) or &quot;&quot;)
            if v is None:
                continue
            out.setdefault(cond, []).append(v)
    return out


def _parse_compare(spec: str) -&gt; Tuple[str, str, str, str]:
    # &quot;metric,condA,condB,label&quot;
    parts = [p.strip() for p in (spec or &quot;&quot;).split(&quot;,&quot;)]
    if len(parts) &lt; 3:
        raise SystemExit(f&quot;invalid --compare: {spec!r}&quot;)
    metric = parts[0]
    cond_a = parts[1]
    cond_b = parts[2]
    label = parts[3] if len(parts) &gt;= 4 else f&quot;{metric}: {cond_a} - {cond_b}&quot;
    return metric, cond_a, cond_b, label


def _fmt(v: float, digits: int = 4) -&gt; str:
    if math.isnan(v) or math.isinf(v):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--in&quot;, dest=&quot;in_csv&quot;, type=Path, required=True, help=&quot;per_trial.csv&quot;)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;&quot;)
    ap.add_argument(&quot;--compare&quot;, action=&quot;append&quot;, default=[], help=&quot;metric,condA,condB[,label]&quot;)
    ap.add_argument(&quot;--n-boot&quot;, type=int, default=20000)
    ap.add_argument(&quot;--alpha&quot;, type=float, default=0.05)
    ap.add_argument(&quot;--seed&quot;, type=int, default=0)
    args = ap.parse_args()

    if not args.compare:
        raise SystemExit(&quot;at least one --compare is required&quot;)
    if args.n_boot &lt; 1000:
        raise SystemExit(&quot;--n-boot should be &gt;= 1000&quot;)
    if not (0.0 &lt; args.alpha &lt; 1.0):
        raise SystemExit(&quot;--alpha must be in (0,1)&quot;)

    args.out_dir.mkdir(parents=True, exist_ok=True)
    out_csv = args.out_dir / &quot;effects_ci.csv&quot;
    out_md = args.out_dir / &quot;effects_ci.md&quot;

    results: List[EffectResult] = []
    now = datetime.now().strftime(&quot;%Y-%m-%d %H:%M&quot;)

    # cache by metric
    values_cache: Dict[str, Dict[str, List[float]]] = {}

    for i, spec in enumerate(args.compare):
        metric, cond_a, cond_b, label = _parse_compare(spec)
        if metric not in values_cache:
            values_cache[metric] = _read_values_by_condition(args.in_csv, metric)
        values = values_cache[metric]
        a = values.get(cond_a, [])
        b = values.get(cond_b, [])
        if len(a) &lt; 2 or len(b) &lt; 2:
            raise SystemExit(f&quot;not enough samples for {metric}: {cond_a} n={len(a)}, {cond_b} n={len(b)}&quot;)
        mean_a = _mean(a)
        mean_b = _mean(b)
        obs = mean_a - mean_b
        # Use a per-compare seed so multiple compares are stable.
        deltas = _bootstrap_delta(a, b, n_boot=args.n_boot, seed=args.seed + 10007 * (i + 1))
        deltas.sort()
        ci_low = _percentile(deltas, args.alpha / 2.0)
        ci_high = _percentile(deltas, 1.0 - args.alpha / 2.0)
        p_two = _two_sided_p_from_bootstrap(deltas, obs)
        results.append(
            EffectResult(
                metric=metric,
                cond_a=cond_a,
                cond_b=cond_b,
                label=label,
                n_a=len(a),
                n_b=len(b),
                mean_a=mean_a,
                mean_b=mean_b,
                delta=obs,
                ci_low=ci_low,
                ci_high=ci_high,
                p_two_sided=p_two,
            )
        )

    # Write CSV
    with out_csv.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.writer(f)
        w.writerow(
            [
                &quot;metric&quot;,
                &quot;cond_a&quot;,
                &quot;cond_b&quot;,
                &quot;label&quot;,
                &quot;n_a&quot;,
                &quot;n_b&quot;,
                &quot;mean_a&quot;,
                &quot;mean_b&quot;,
                &quot;delta_mean&quot;,
                &quot;ci_low&quot;,
                &quot;ci_high&quot;,
                &quot;p_two_sided&quot;,
                &quot;n_boot&quot;,
                &quot;alpha&quot;,
                &quot;seed&quot;,
                &quot;generated_local&quot;,
                &quot;source_csv&quot;,
            ]
        )
        for r in results:
            w.writerow(
                [
                    r.metric,
                    r.cond_a,
                    r.cond_b,
                    r.label,
                    r.n_a,
                    r.n_b,
                    r.mean_a,
                    r.mean_b,
                    r.delta,
                    r.ci_low,
                    r.ci_high,
                    r.p_two_sided,
                    args.n_boot,
                    args.alpha,
                    args.seed,
                    now,
                    str(args.in_csv),
                ]
            )

    # Write MD (compact, letter-friendly)
    lines: List[str] = []
    if args.title:
        lines.append(f&quot;# effects_ci: {args.title}\n&quot;)
    else:
        lines.append(&quot;# effects_ci\n&quot;)
    lines.append(f&quot;- source: `{args.in_csv}`&quot;)
    lines.append(f&quot;- generated: {now} (local)&quot;)
    lines.append(f&quot;- bootstrap: percentile CI, n_boot={args.n_boot}, alpha={args.alpha}, seed={args.seed}\n&quot;)
    lines.append(&quot;| label | delta(mean) | 95% CI | p(two-sided) |&quot;)
    lines.append(&quot;|---|---:|---:|---:|&quot;)
    for r in results:
        lines.append(
            f&quot;| {r.label} | {_fmt(r.delta)} | [{_fmt(r.ci_low)}, {_fmt(r.ci_high)}] | {_fmt(r.p_two_sided, 4)} |&quot;
        )
    out_md.write_text(&quot;\n&quot;.join(lines) + &quot;\n&quot;, encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d2_scan90/analysis/merge_metrics_runs.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Merge summarized runs (per_trial.csv) and regenerate summary_by_condition.csv / summary.md.

Purpose
  - Increase n (repeats) without re-parsing raw RX/TXSD logs.
  - Keep the exact metric definitions used by summarize_d2_run.py.

Inputs
  - One or more directories that contain per_trial.csv (and optionally summary.md).

Outputs (out_dir)
  - per_trial.csv (concatenated, sorted by rx_trial_id)
  - summary_by_condition.csv (mean/std by condition)
  - summary.md (human-readable summary + provenance)
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import statistics
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple


SUMMARY_FIELDS = [
    &quot;condition&quot;,
    &quot;n_trials&quot;,
    &quot;pout_1s_mean&quot;,
    &quot;pout_1s_std&quot;,
    &quot;tl_mean_s_mean&quot;,
    &quot;tl_mean_s_std&quot;,
    &quot;pdr_unique_mean&quot;,
    &quot;pdr_unique_std&quot;,
    &quot;rx_tag_share100_time_est_mean&quot;,
    &quot;rx_tag_share100_time_est_std&quot;,
    &quot;avg_power_mW_mean&quot;,
    &quot;avg_power_mW_std&quot;,
    &quot;adv_count_mean&quot;,
    &quot;adv_count_std&quot;,
]


def mean_std(xs: List[float]) -&gt; Tuple[float, float]:
    if not xs:
        return 0.0, 0.0
    if len(xs) == 1:
        return xs[0], 0.0
    return statistics.mean(xs), statistics.stdev(xs)


def read_per_trial(path: Path) -&gt; Tuple[List[str], List[Dict[str, str]]]:
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        if not rdr.fieldnames:
            raise SystemExit(f&quot;empty header: {path}&quot;)
        rows = [dict(r) for r in rdr]
        return list(rdr.fieldnames), rows


def f_or_empty(v: str) -&gt; List[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return []
    return [float(v)]


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(
        &quot;--input-dir&quot;,
        type=Path,
        action=&quot;append&quot;,
        required=True,
        help=&quot;metrics/* directory that contains per_trial.csv (repeatable)&quot;,
    )
    args = ap.parse_args()

    input_dirs: List[Path] = args.input_dir
    per_paths = [d / &quot;per_trial.csv&quot; for d in input_dirs]
    for p in per_paths:
        if not p.exists():
            raise SystemExit(f&quot;missing per_trial.csv: {p}&quot;)

    header_ref: List[str] = []
    all_rows: List[Dict[str, str]] = []
    for p in per_paths:
        header, rows = read_per_trial(p)
        if not header_ref:
            header_ref = header
        elif header != header_ref:
            raise SystemExit(f&quot;header mismatch: {p}&quot;)
        all_rows.extend(rows)

    # Sort by rx_trial_id if present.
    if &quot;rx_trial_id&quot; in header_ref:
        all_rows.sort(key=lambda r: int((r.get(&quot;rx_trial_id&quot;) or &quot;0&quot;).strip() or &quot;0&quot;))

    args.out_dir.mkdir(parents=True, exist_ok=True)

    per_out = args.out_dir / &quot;per_trial.csv&quot;
    with per_out.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=header_ref)
        w.writeheader()
        w.writerows(all_rows)

    # Summary by condition (compatible with plot_power_vs_pout.py / thesis tables).
    by_cond: Dict[str, List[Dict[str, str]]] = {}
    for r in all_rows:
        cond = (r.get(&quot;condition&quot;) or &quot;&quot;).strip()
        if not cond:
            continue
        by_cond.setdefault(cond, []).append(r)

    summary_rows: List[Dict[str, object]] = []
    for cond, rows in sorted(by_cond.items()):
        pout_1s_list: List[float] = []
        tl_list: List[float] = []
        pdr_list: List[float] = []
        share100_list: List[float] = []
        pwr_list: List[float] = []
        adv_list: List[float] = []

        for r in rows:
            pout_1s_list.extend(f_or_empty(r.get(&quot;pout_1s&quot;) or &quot;&quot;))
            tl_list.extend(f_or_empty(r.get(&quot;tl_mean_s&quot;) or &quot;&quot;))
            pdr_list.extend(f_or_empty(r.get(&quot;pdr_unique&quot;) or &quot;&quot;))
            share100_list.extend(f_or_empty(r.get(&quot;rx_tag_share100_time_est&quot;) or &quot;&quot;))
            pwr_list.extend(f_or_empty(r.get(&quot;avg_power_mW&quot;) or &quot;&quot;))
            adv_list.extend(f_or_empty(r.get(&quot;adv_count&quot;) or &quot;&quot;))

        pout_m, pout_s = mean_std(pout_1s_list)
        tl_m, tl_s = mean_std(tl_list)
        pdr_m, pdr_s = mean_std(pdr_list)
        sh_m, sh_s = mean_std(share100_list)
        pwr_m, pwr_s = mean_std(pwr_list)
        adv_m, adv_s = mean_std(adv_list)

        summary_rows.append(
            {
                &quot;condition&quot;: cond,
                &quot;n_trials&quot;: len(rows),
                &quot;pout_1s_mean&quot;: round(pout_m, 6),
                &quot;pout_1s_std&quot;: round(pout_s, 6),
                &quot;tl_mean_s_mean&quot;: round(tl_m, 6),
                &quot;tl_mean_s_std&quot;: round(tl_s, 6),
                &quot;pdr_unique_mean&quot;: round(pdr_m, 6) if pdr_list else &quot;&quot;,
                &quot;pdr_unique_std&quot;: round(pdr_s, 6) if pdr_list else &quot;&quot;,
                &quot;rx_tag_share100_time_est_mean&quot;: round(sh_m, 6) if share100_list else &quot;&quot;,
                &quot;rx_tag_share100_time_est_std&quot;: round(sh_s, 6) if share100_list else &quot;&quot;,
                &quot;avg_power_mW_mean&quot;: round(pwr_m, 3) if pwr_list else &quot;&quot;,
                &quot;avg_power_mW_std&quot;: round(pwr_s, 3) if pwr_list else &quot;&quot;,
                &quot;adv_count_mean&quot;: round(adv_m, 3) if adv_list else &quot;&quot;,
                &quot;adv_count_std&quot;: round(adv_s, 3) if adv_list else &quot;&quot;,
            }
        )

    sum_out = args.out_dir / &quot;summary_by_condition.csv&quot;
    with sum_out.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=SUMMARY_FIELDS)
        w.writeheader()
        w.writerows(summary_rows)

    md_out = args.out_dir / &quot;summary.md&quot;
    lines: List[str] = []
    lines.append(&quot;# uccs_d2_scan90 merged metrics summary\n\n&quot;)
    lines.append(&quot;- purpose: merge summarized runs (per_trial.csv) and increase n without re-parsing raw logs.\n&quot;)
    for d in input_dirs:
        lines.append(f&quot;- source: `{d}`\n&quot;)
    lines.append(f&quot;- generated: {datetime.now().strftime(&apos;%Y-%m-%d %H:%M&apos;)} (local)\n&quot;)
    lines.append(
        &quot;- command: &quot;
        f&quot;`python3 uccs_d2_scan90/analysis/merge_metrics_runs.py --out-dir {args.out_dir} &quot;
        + &quot; &quot;.join([f&apos;--input-dir {d}&apos; for d in input_dirs])
        + &quot;`\n&quot;
    )

    lines.append(&quot;\n## Summary (mean ± std)\n&quot;)
    lines.append(&quot;| condition | n | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |\n&quot;)
    lines.append(&quot;|---|---:|---:|---:|---:|---:|---:|---:|\n&quot;)
    for r in summary_rows:
        cond = str(r[&quot;condition&quot;])
        n = int(r[&quot;n_trials&quot;])
        pout = f&quot;{r[&apos;pout_1s_mean&apos;]:.4f}±{r[&apos;pout_1s_std&apos;]:.4f}&quot;
        tl = f&quot;{r[&apos;tl_mean_s_mean&apos;]:.3f}±{r[&apos;tl_mean_s_std&apos;]:.3f}&quot;
        pdr = (
            f&quot;{r[&apos;pdr_unique_mean&apos;]:.3f}±{r[&apos;pdr_unique_std&apos;]:.3f}&quot;
            if r[&quot;pdr_unique_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        pwr = (
            f&quot;{r[&apos;avg_power_mW_mean&apos;]:.1f}±{r[&apos;avg_power_mW_std&apos;]:.1f}&quot;
            if r[&quot;avg_power_mW_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        adv = (
            f&quot;{r[&apos;adv_count_mean&apos;]:.1f}±{r[&apos;adv_count_std&apos;]:.1f}&quot;
            if r[&quot;adv_count_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        sh = (
            f&quot;{r[&apos;rx_tag_share100_time_est_mean&apos;]:.3f}±{r[&apos;rx_tag_share100_time_est_std&apos;]:.3f}&quot;
            if r[&quot;rx_tag_share100_time_est_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        lines.append(f&quot;| {cond} | {n} | {pout} | {tl} | {pdr} | {pwr} | {adv} | {sh} |\n&quot;)

    lines.append(&quot;\n## Notes\n&quot;)
    lines.append(&quot;- This script does not recompute TL/Pout; it re-aggregates existing per-trial metrics.\n&quot;)
    lines.append(&quot;- Rounding follows summarize_d2_run.py (pout/TL/PDR/share: 6 decimals, power/adv: 3 decimals).\n&quot;)
    md_out.write_text(&quot;&quot;.join(lines), encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d2_scan90/analysis/plot_power_vs_pout.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Plot D2/D2b tradeoff: avg_power_mW vs pout_1s with share100 annotation.

Input: summary_by_condition.csv generated by summarize_d2_run.py
Output: PNG/PDF figure for paper-ready quick inspection.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import os
from pathlib import Path
from typing import Dict, Optional, Tuple


def f_or_none(v: str) -&gt; Optional[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary_by_condition(path: Path) -&gt; Dict[str, Dict[str, Optional[float]]]:
    out: Dict[str, Dict[str, Optional[float]]] = {}
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            out[cond] = {
                &quot;pout_1s_mean&quot;: f_or_none(row.get(&quot;pout_1s_mean&quot;) or &quot;&quot;),
                &quot;pout_1s_std&quot;: f_or_none(row.get(&quot;pout_1s_std&quot;) or &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: f_or_none(row.get(&quot;avg_power_mW_mean&quot;) or &quot;&quot;),
                &quot;avg_power_mW_std&quot;: f_or_none(row.get(&quot;avg_power_mW_std&quot;) or &quot;&quot;),
                &quot;adv_count_mean&quot;: f_or_none(row.get(&quot;adv_count_mean&quot;) or &quot;&quot;),
                &quot;rx_share100_mean&quot;: f_or_none(row.get(&quot;rx_tag_share100_time_est_mean&quot;) or &quot;&quot;),
            }
    return out


def mean_of_present(xs: list[Optional[float]]) -&gt; Optional[float]:
    ys = [x for x in xs if x is not None]
    if not ys:
        return None
    return sum(ys) / len(ys)


def compute_share100_from_adv(
    adv_count_policy: Optional[float],
    adv_count_fixed100: Optional[float],
    adv_count_fixed500: Optional[float],
) -&gt; Optional[float]:
    if (
        adv_count_policy is None
        or adv_count_fixed100 is None
        or adv_count_fixed500 is None
        or adv_count_fixed100 &lt;= adv_count_fixed500
    ):
        return None
    return (adv_count_policy - adv_count_fixed500) / (adv_count_fixed100 - adv_count_fixed500)


def get_point(
    rows: Dict[str, Dict[str, Optional[float]]],
    key: str,
) -&gt; Tuple[float, float, float, float, Optional[float], Optional[float]]:
    r = rows.get(key, {})
    x = r.get(&quot;avg_power_mW_mean&quot;)
    y = r.get(&quot;pout_1s_mean&quot;)
    if x is None or y is None:
        raise SystemExit(f&quot;missing required metrics for {key} in summary csv&quot;)
    xerr = r.get(&quot;avg_power_mW_std&quot;) or 0.0
    yerr = r.get(&quot;pout_1s_std&quot;) or 0.0
    adv = r.get(&quot;adv_count_mean&quot;)
    rx_share = r.get(&quot;rx_share100_mean&quot;)
    return float(x), float(y), float(xerr), float(yerr), adv, rx_share


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--summary-csv&quot;, type=Path, required=True, help=&quot;metrics/*/summary_by_condition.csv&quot;)
    ap.add_argument(&quot;--out&quot;, type=Path, required=True, help=&quot;output png path&quot;)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;&quot;, help=&quot;optional title&quot;)
    args = ap.parse_args()

    # Matplotlib cache/rc write avoidance (for restricted environments).
    repo_root = Path.cwd()
    xdg_cache = repo_root / &quot;.cache&quot;
    xdg_cache.mkdir(exist_ok=True)
    os.environ.setdefault(&quot;XDG_CACHE_HOME&quot;, str(xdg_cache))
    mpl_dir = repo_root / &quot;.mplconfig&quot;
    mpl_dir.mkdir(exist_ok=True)
    os.environ.setdefault(&quot;MPLCONFIGDIR&quot;, str(mpl_dir))

    import matplotlib

    matplotlib.use(&quot;Agg&quot;)
    import matplotlib.pyplot as plt  # type: ignore

    rows = read_summary_by_condition(args.summary_csv)

    # Reference adv_count points (same for S1/S4 in this experiment).
    adv_fixed100 = mean_of_present(
        [
            rows.get(&quot;S1_fixed100&quot;, {}).get(&quot;adv_count_mean&quot;),
            rows.get(&quot;S4_fixed100&quot;, {}).get(&quot;adv_count_mean&quot;),
        ]
    )
    adv_fixed500 = mean_of_present(
        [
            rows.get(&quot;S1_fixed500&quot;, {}).get(&quot;adv_count_mean&quot;),
            rows.get(&quot;S4_fixed500&quot;, {}).get(&quot;adv_count_mean&quot;),
        ]
    )

    fig, ax = plt.subplots(figsize=(7.0, 4.8))

    def plot_group(session: str, color: str) -&gt; None:
        fx100 = f&quot;{session}_fixed100&quot;
        fx500 = f&quot;{session}_fixed500&quot;
        pol = f&quot;{session}_policy&quot;

        x1, y1, x1e, y1e, _, _ = get_point(rows, fx100)
        x5, y5, x5e, y5e, _, _ = get_point(rows, fx500)
        xp, yp, xpe, ype, advp, rx_share = get_point(rows, pol)

        ax.errorbar(
            [x1, x5],
            [y1, y5],
            xerr=[x1e, x5e],
            yerr=[y1e, y5e],
            fmt=&quot;s&quot;,
            ms=7,
            color=color,
            capsize=3,
            linestyle=&quot;none&quot;,
            label=f&quot;{session} fixed&quot;,
        )
        ax.errorbar(
            [xp],
            [yp],
            xerr=[xpe],
            yerr=[ype],
            fmt=&quot;o&quot;,
            ms=8,
            color=color,
            capsize=3,
            linestyle=&quot;none&quot;,
            label=f&quot;{session} policy&quot;,
        )

        # Share annotation: prefer TXSD-derived share (adv_count), fall back to RX-tag estimate.
        share_tx = compute_share100_from_adv(advp, adv_fixed100, adv_fixed500)
        share = share_tx if share_tx is not None else rx_share
        if share is not None:
            ax.annotate(
                f&quot;share100≈{share:.2f}&quot;,
                (xp, yp),
                textcoords=&quot;offset points&quot;,
                xytext=(8, 8),
                ha=&quot;left&quot;,
                fontsize=10,
                color=color,
            )

        # Minimal labels for fixed points.
        ax.annotate(&quot;100&quot;, (x1, y1), textcoords=&quot;offset points&quot;, xytext=(6, -12), fontsize=9, color=color)
        ax.annotate(&quot;500&quot;, (x5, y5), textcoords=&quot;offset points&quot;, xytext=(6, -12), fontsize=9, color=color)

    plot_group(&quot;S1&quot;, color=&quot;#1f77b4&quot;)
    plot_group(&quot;S4&quot;, color=&quot;#ff7f0e&quot;)

    ax.set_xlabel(&quot;avg_power_mW (TXSD)&quot;)
    ax.set_ylabel(&quot;pout_1s&quot;)
    ax.grid(True, alpha=0.3)

    title = args.title.strip()
    if not title:
        title = f&quot;{args.summary_csv.parent.name}: avg_power vs pout_1s (D2/D2b)&quot;
    ax.set_title(title)

    handles, labels = ax.get_legend_handles_labels()
    # de-dup labels while preserving order
    seen = set()
    h2 = []
    l2 = []
    for h, l in zip(handles, labels):
        if l in seen:
            continue
        seen.add(l)
        h2.append(h)
        l2.append(l)
    ax.legend(h2, l2, loc=&quot;best&quot;, frameon=True, fontsize=9)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    if args.out.suffix.lower() == &quot;.png&quot;:
        pdf_out = args.out.with_suffix(&quot;.pdf&quot;)
        fig.savefig(pdf_out)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d2_scan90/metrics/01/per_trial.csv">rx_trial_id,condition,repeat_idx,session,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_n100,rx_tag_n500,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_path,rx_path
9,S1_fixed100,1,1,FIXED_100,1429,1427,1796,0.794543,1427,0,1.0,2.40725,42.64345,0.05,0.05,0.05,-1191.0,1427,181469.0,36990.437,203.83887606147607,uccs_d2_scan90/data/TX/trial_001_c1_s1_fixed100.csv,uccs_d2_scan90/data/RX/rx_trial_009.csv
10,S1_fixed500,1,1,FIXED_500,295,295,359,0.821727,1,294,0.00068,5.2275,53.3662,0.1,0.1,0.1,-655.0,295,179635.0,33033.823,183.89413532997466,uccs_d2_scan90/data/TX/trial_002_c2_s1_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_010.csv
11,S1_policy,1,1,POLICY,1431,1430,1787,0.800224,1427,3,0.989598,2.413,42.67525,0.05,0.05,0.05,-1134.0,1430,181462.0,36921.888,203.46897973129362,uccs_d2_scan90/data/TX/trial_001_c3_s1_policy.csv,uccs_d2_scan90/data/RX/rx_trial_011.csv
12,S4_fixed100,1,4,FIXED_100,1463,1463,1796,0.814588,1463,0,1.0,1.244488,13.6686,0.04878,0.04878,0.04878,-1131.0,1463,181480.0,36910.963,203.38859929468816,uccs_d2_scan90/data/TX/trial_001_c4_s4_fixed100.csv,uccs_d2_scan90/data/RX/rx_trial_012.csv
13,S4_fixed500,1,4,FIXED_500,299,299,359,0.832869,1,298,0.000671,2.096122,20.6021,0.097561,0.097561,0.097561,-606.0,299,179638.0,33062.323,184.04971665237863,uccs_d2_scan90/data/TX/trial_001_c5_s4_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_013.csv
14,S4_policy,1,4,POLICY,1462,1461,1787,0.817571,1458,3,0.989817,1.237122,13.6496,0.04878,0.04878,0.04878,-1108.0,1461,181465.0,37035.693,204.092761689582,uccs_d2_scan90/data/TX/trial_001_c6_s4_policy.csv,uccs_d2_scan90/data/RX/rx_trial_014.csv
15,S1_fixed100,2,1,FIXED_100,1466,1464,1796,0.815145,1464,0,1.0,5.091125,53.355625,0.1,0.1,0.1,-1098.5,1464,181460.0,36991.493,203.85480546676953,uccs_d2_scan90/data/TX/trial_002_c1_s1_fixed100.csv,uccs_d2_scan90/data/RX/rx_trial_015.csv
16,S1_fixed500,2,1,FIXED_500,304,304,359,0.846797,0,304,0.0,5.334375,53.372025,0.1,0.1,0.1,-570.5,304,179621.0,33031.832,183.89738393617674,uccs_d2_scan90/data/TX/trial_003_c2_s1_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_016.csv
17,S1_policy,2,1,POLICY,1444,1442,1787,0.806939,1439,3,0.989684,5.0909,53.36095,0.1,0.1,0.1,-1068.0,1442,181451.0,36931.233,203.53281602195634,uccs_d2_scan90/data/TX/trial_002_c3_s1_policy.csv,uccs_d2_scan90/data/RX/rx_trial_017.csv
18,S4_fixed100,2,4,FIXED_100,1454,1454,1796,0.809577,1454,0,1.0,1.233951,13.7389,0.04878,0.04878,0.04878,-1065.0,1453,181464.0,37017.088,203.99135916765863,uccs_d2_scan90/data/TX/trial_002_c4_s4_fixed100.csv,uccs_d2_scan90/data/RX/rx_trial_018.csv
19,S4_fixed500,2,4,FIXED_500,303,303,359,0.844011,0,303,0.0,1.474805,15.0007,0.097561,0.073171,0.073171,-518.0,303,179625.0,33110.978,184.33390675017398,uccs_d2_scan90/data/TX/trial_002_c5_s4_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_019.csv
20,S4_policy,2,4,POLICY,1451,1450,1787,0.811416,1447,3,0.98974,1.227305,13.656,0.04878,0.04878,0.04878,-1034.5,1450,181451.0,36983.375,203.8201773481546,uccs_d2_scan90/data/TX/trial_002_c6_s4_policy.csv,uccs_d2_scan90/data/RX/rx_trial_020.csv
21,S1_fixed100,3,1,FIXED_100,1444,1444,1796,0.804009,1444,0,1.0,5.10125,53.35315,0.1,0.1,0.1,-1025.0,1444,181458.0,36958.209,203.67362695499787,uccs_d2_scan90/data/TX/trial_004_c0_unk.csv,uccs_d2_scan90/data/RX/rx_trial_021.csv
22,S1_fixed500,3,1,FIXED_500,296,296,359,0.824513,0,296,0.0,5.26515,53.37025,0.1,0.1,0.1,-465.0,296,179606.0,32974.619,183.59419507143414,uccs_d2_scan90/data/TX/trial_004_c2_s1_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_022.csv
23,S1_policy,3,1,POLICY,1438,1435,1787,0.803022,1432,3,0.989634,2.44125,42.73345,0.05,0.05,0.05,-981.0,1435,181437.0,37024.787,204.06414898835405,uccs_d2_scan90/data/TX/trial_003_c3_s1_policy.csv,uccs_d2_scan90/data/RX/rx_trial_023.csv
24,S4_fixed100,3,4,FIXED_100,1421,1421,1796,0.791203,1421,0,1.0,1.23478,13.6117,0.04878,0.04878,0.04878,-979.0,1421,181438.0,36961.461,203.71400147708863,uccs_d2_scan90/data/TX/trial_003_c4_s4_fixed100.csv,uccs_d2_scan90/data/RX/rx_trial_024.csv
25,S4_fixed500,3,4,FIXED_500,300,300,359,0.835655,1,299,0.000668,2.267902,21.0551,0.195122,0.121951,0.121951,-427.0,300,179606.0,33125.286,184.43307016469385,uccs_d2_scan90/data/TX/trial_003_c5_s4_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_025.csv
26,S4_policy,3,4,POLICY,1436,1434,1787,0.802462,1432,2,0.993065,1.483634,14.5786,0.073171,0.073171,0.073171,-936.0,1434,181416.0,37165.78,204.86495127221414,uccs_d2_scan90/data/TX/trial_004_c5_s4_fixed500.csv,uccs_d2_scan90/data/RX/rx_trial_026.csv</file><file path="uccs_d2_scan90/metrics/01/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std
S1_fixed100,3,0.083333,0.028868,4.199875,1.552467,0.804566,0.010312,1.0,0.0,203.789,0.1,1796.0,0.0
S1_fixed500,3,0.1,0.0,5.275675,0.054209,0.831012,0.013741,0.000227,0.000393,183.795,0.174,359.0,0.0
S1_policy,3,0.066667,0.028868,3.31505,1.537996,0.803395,0.003373,0.989639,4.3e-05,203.689,0.327,1787.0,0.0
S4_fixed100,3,0.04878,0.0,1.23774,0.005859,0.805123,0.012312,1.0,0.0,203.698,0.302,1796.0,0.0
S4_fixed500,3,0.130081,0.056327,1.946276,0.417242,0.837512,0.005798,0.000446,0.000387,184.272,0.199,359.0,0.0
S4_policy,3,0.05691,0.014082,1.31602,0.145241,0.810483,0.007598,0.990874,0.001898,204.259,0.542,1787.0,0.0</file><file path="uccs_d2_scan90/metrics/01/summary.md"># uccs_d2_scan90 metrics summary

- source RX: `uccs_d2_scan90/data/RX`
- source TXSD: `uccs_d2_scan90/data/TX`
- truth: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S1.csv`, `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv` (n_steps=1800, dt=100ms)
- selected RX trials: 009..026 (n=18)
- generated: 2025-12-15 14:31 (local)
- command: `python3 uccs_d2_scan90/analysis/summarize_d2_run.py --rx-dir uccs_d2_scan90/data/RX --txsd-dir uccs_d2_scan90/data/TX --out-dir uccs_d2_scan90/metrics/01`

## Summary (mean ± std, n=3 each)
| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |
|---|---:|---:|---:|---:|---:|---:|
| S1_fixed100 | 0.0833±0.0289 | 4.200±1.552 | 0.805±0.010 | 203.8±0.1 | 1796.0±0.0 | 1.000±0.000 |
| S1_fixed500 | 0.1000±0.0000 | 5.276±0.054 | 0.831±0.014 | 183.8±0.2 | 359.0±0.0 | 0.000±0.000 |
| S1_policy | 0.0667±0.0289 | 3.315±1.538 | 0.803±0.003 | 203.7±0.3 | 1787.0±0.0 | 0.990±0.000 |
| S4_fixed100 | 0.0488±0.0000 | 1.238±0.006 | 0.805±0.012 | 203.7±0.3 | 1796.0±0.0 | 1.000±0.000 |
| S4_fixed500 | 0.1301±0.0563 | 1.946±0.417 | 0.838±0.006 | 184.3±0.2 | 359.0±0.0 | 0.000±0.000 |
| S4_policy | 0.0569±0.0141 | 1.316±0.145 | 0.810±0.008 | 204.3±0.5 | 1787.0±0.0 | 0.991±0.002 |

## Notes
- RX trial selection: latest 18 trials that form 6 conditions × 3 repeats (duration&gt;=160s).
- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).
- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique when available.
- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).</file><file path="uccs_d2_scan90/metrics/B/per_trial.csv">rx_trial_id,condition,repeat_idx,session,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_n100,rx_tag_n500,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_path,rx_path
2,S1_fixed100,1,1,FIXED_100,1421,1420,1796,0.790646,1420,0,1.0,5.10375,53.35615,0.1,0.1,0.1,-1220.0,1419,181484.0,36847.544,203.03466972295078,uccs_d2_scan90/data/B/TX/trial_001_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_002.csv
3,S1_fixed500,1,1,FIXED_500,300,300,359,0.835655,1,299,0.000668,5.300375,53.368925,0.2,0.1,0.1,-699.5,300,179653.0,32881.102,183.02562161500225,uccs_d2_scan90/data/B/TX/trial_001_c3_s1_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_003.csv
4,S1_policy,1,1,POLICY,700,700,855,0.818713,498,202,0.330239,5.1951,53.3738,0.1,0.1,0.1,-757.0,700,180540.0,34303.246,190.0035781544256,uccs_d2_scan90/data/B/TX/trial_001_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_004.csv
5,S4_fixed100,1,4,FIXED_100,1429,1429,1796,0.795657,1428,1,0.996511,1.249634,13.6667,0.073171,0.04878,0.04878,-1198.0,1429,181482.0,36739.403,202.44102996440418,uccs_d2_scan90/data/B/TX/trial_001_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/RX/rx_trial_005.csv
6,S4_fixed500,1,4,FIXED_500,286,286,359,0.796657,1,285,0.000701,1.620049,14.9768,0.195122,0.097561,0.097561,-678.0,286,179637.0,32909.928,183.20239148950384,uccs_d2_scan90/data/B/TX/trial_001_c6_s4_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_006.csv
7,S4_policy,1,4,POLICY,958,957,1227,0.779951,844,113,0.599006,1.245537,13.9336,0.073171,0.04878,0.04878,-900.0,957,180906.0,35244.03,194.81957480680572,uccs_d2_scan90/data/B/TX/trial_001_c7_unk.csv,uccs_d2_scan90/data/B/RX/rx_trial_007.csv
8,S1_fixed100,2,1,FIXED_100,1393,1392,1796,0.775056,1392,0,1.0,5.09495,53.35685,0.1,0.1,0.1,-1171.0,1392,181477.0,36886.619,203.25781779509248,uccs_d2_scan90/data/B/TX/trial_001_c2_s1_fixed500.csv,uccs_d2_scan90/data/B/RX/rx_trial_008.csv
9,S1_fixed500,2,1,FIXED_500,294,294,359,0.818942,0,294,0.0,5.3122,53.36635,0.15,0.1,0.1,-646.0,294,179619.0,32949.043,183.43851708338204,uccs_d2_scan90/data/B/TX/trial_002_c3_s1_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_009.csv
10,S1_policy,2,1,POLICY,700,700,855,0.818713,496,204,0.327177,5.24535,53.37365,0.1,0.1,0.1,-710.0,700,180526.0,34177.069,189.31937227878532,uccs_d2_scan90/data/B/TX/trial_002_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_010.csv
11,S4_fixed100,2,4,FIXED_100,1393,1393,1796,0.775612,1392,1,0.996421,1.236171,13.6357,0.04878,0.04878,0.04878,-1157.0,1393,181466.0,36685.926,202.16418502639613,uccs_d2_scan90/data/B/TX/trial_002_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/RX/rx_trial_011.csv
12,S4_fixed500,2,4,FIXED_500,291,291,359,0.810585,1,290,0.000689,1.708902,15.007,0.146341,0.097561,0.097561,-620.0,291,179626.0,32848.146,182.8696625210159,uccs_d2_scan90/data/B/TX/trial_002_c6_s4_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_012.csv
13,S4_policy,2,4,POLICY,953,952,1227,0.775876,836,116,0.590395,2.26,23.7535,0.121951,0.073171,0.073171,-823.5,952,180894.0,35375.844,195.56117947527278,uccs_d2_scan90/data/B/TX/trial_002_c7_unk.csv,uccs_d2_scan90/data/B/RX/rx_trial_013.csv
14,S1_fixed100,3,1,FIXED_100,1419,1419,1796,0.790089,1419,0,1.0,2.43275,42.6563,0.05,0.05,0.05,-1115.0,1419,181465.0,36716.754,202.33518309315846,uccs_d2_scan90/data/B/TX/trial_002_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_014.csv
15,S1_fixed500,3,1,FIXED_500,285,285,359,0.793872,1,284,0.000704,5.2747,53.36795,0.1,0.1,0.1,-589.0,285,179616.0,32948.453,183.4382961428826,uccs_d2_scan90/data/B/TX/trial_003_c3_s1_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_015.csv
16,S1_policy,3,1,POLICY,677,677,855,0.791813,487,190,0.3389,5.30085,53.37445,0.15,0.1,0.1,-609.0,677,180512.0,34285.471,189.93458052650237,uccs_d2_scan90/data/B/TX/trial_003_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_016.csv
17,S4_fixed100,3,4,FIXED_100,1426,1424,1796,0.792873,1423,1,0.996499,1.256073,13.6019,0.04878,0.04878,0.04878,-1089.0,1424,181445.0,36841.047,203.04250323789577,uccs_d2_scan90/data/B/TX/trial_004_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_017.csv
18,S4_fixed500,3,4,FIXED_500,303,303,359,0.844011,0,303,0.0,3.169268,20.1689,0.121951,0.097561,0.097561,-564.0,303,179607.0,32970.008,183.5675001531121,uccs_d2_scan90/data/B/TX/trial_003_c6_s4_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_018.csv
19,S4_policy,3,4,POLICY,959,957,1227,0.779951,839,118,0.587124,1.258951,13.8866,0.04878,0.04878,0.04878,-771.0,957,180880.0,35327.718,195.31024988942946,uccs_d2_scan90/data/B/TX/trial_003_c7_unk.csv,uccs_d2_scan90/data/B/RX/rx_trial_019.csv</file><file path="uccs_d2_scan90/metrics/B/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std
S1_fixed100,3,0.083333,0.028868,4.210483,1.539569,0.785264,0.008844,1.0,0.0,202.876,0.481,1796.0,0.0
S1_fixed500,3,0.15,0.05,5.295758,0.019172,0.816156,0.02103,0.000457,0.000396,183.301,0.238,359.0,0.0
S1_policy,3,0.116667,0.028868,5.2471,0.052897,0.809746,0.015531,0.332105,0.00608,189.753,0.377,855.0,0.0
S4_fixed100,3,0.05691,0.014082,1.247293,0.010155,0.788047,0.010859,0.996477,4.9e-05,202.549,0.449,1796.0,0.0
S4_fixed500,3,0.154471,0.037257,2.166073,0.869928,0.817084,0.024337,0.000463,0.000401,183.213,0.349,359.0,0.0
S4_policy,3,0.081301,0.037257,1.588163,0.581867,0.778593,0.002353,0.592175,0.006138,195.23,0.377,1227.0,0.0</file><file path="uccs_d2_scan90/metrics/B/summary.md"># uccs_d2_scan90 metrics summary

- source RX: `uccs_d2_scan90/data/B/RX`
- source TXSD: `uccs_d2_scan90/data/B/TX`
- truth: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S1.csv`, `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv` (n_steps=1800, dt=100ms)
- selected RX trials: 002..019 (n=18)
- generated: 2025-12-15 18:43 (local)
- command: `python3 uccs_d2_scan90/analysis/summarize_d2_run.py --rx-dir uccs_d2_scan90/data/B/RX --txsd-dir uccs_d2_scan90/data/B/TX --out-dir uccs_d2_scan90/metrics/B`

## Summary (mean ± std, n=3 each)
| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |
|---|---:|---:|---:|---:|---:|---:|
| S1_fixed100 | 0.0833±0.0289 | 4.210±1.540 | 0.785±0.009 | 202.9±0.5 | 1796.0±0.0 | 1.000±0.000 |
| S1_fixed500 | 0.1500±0.0500 | 5.296±0.019 | 0.816±0.021 | 183.3±0.2 | 359.0±0.0 | 0.000±0.000 |
| S1_policy | 0.1167±0.0289 | 5.247±0.053 | 0.810±0.016 | 189.8±0.4 | 855.0±0.0 | 0.332±0.006 |
| S4_fixed100 | 0.0569±0.0141 | 1.247±0.010 | 0.788±0.011 | 202.5±0.4 | 1796.0±0.0 | 0.996±0.000 |
| S4_fixed500 | 0.1545±0.0373 | 2.166±0.870 | 0.817±0.024 | 183.2±0.3 | 359.0±0.0 | 0.000±0.000 |
| S4_policy | 0.0813±0.0373 | 1.588±0.582 | 0.779±0.002 | 195.2±0.4 | 1227.0±0.0 | 0.592±0.006 |

## Notes
- RX trial selection: latest 18 trials that form 6 conditions × 3 repeats (duration&gt;=160s).
- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).
- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique when available.
- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).</file><file path="uccs_d2_scan90/metrics/B_02/per_trial.csv">rx_trial_id,condition,repeat_idx,session,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_n100,rx_tag_n500,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_path,rx_path
84,S4_policy,1,4,POLICY,1009,1008,1227,0.821516,893,115,0.608311,2.180732,23.6714,0.073171,0.073171,0.073171,1226.5,1008,180905.0,35958.479,198.76995660705896,uccs_d2_scan90/data/B/02/TX/trial_001_c7_unk.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_084.csv
85,S1_fixed100,1,1,FIXED_100,1468,1466,1793,0.817624,1466,0,1.0,2.4398,42.7262,0.05,0.05,0.05,977.0,1466,181134.0,37155.962,205.1296940386675,uccs_d2_scan90/data/B/02/TX/trial_001_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_085.csv
86,S1_fixed500,1,1,FIXED_500,300,300,359,0.835655,0,300,0.0,5.30245,53.36735,0.2,0.1,0.1,1560.0,300,179653.0,33355.851,185.66821038335016,uccs_d2_scan90/data/B/02/TX/trial_001_c2_s1_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_086.csv
87,S1_policy,1,1,POLICY,698,697,855,0.815205,496,201,0.330446,5.28585,53.3993,0.15,0.1,0.1,1531.0,697,180538.0,34904.265,193.33472731502508,uccs_d2_scan90/data/B/02/TX/trial_001_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_087.csv
88,S4_fixed100,1,4,FIXED_100,1444,1443,1796,0.803452,1443,0,1.0,1.250439,13.6383,0.04878,0.04878,0.04878,1116.0,1443,181477.0,37489.878,206.58198008563068,uccs_d2_scan90/data/B/02/TX/trial_001_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_088.csv
89,S4_fixed500,1,4,FIXED_500,298,298,359,0.830084,0,298,0.0,2.929366,15.0313,0.121951,0.097561,0.097561,1700.0,298,179638.0,33424.385,186.0652256204144,uccs_d2_scan90/data/B/02/TX/trial_001_c6_s4_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_089.csv
90,S4_policy,2,4,POLICY,1003,1003,1227,0.817441,882,121,0.593141,1.23739,14.2797,0.04878,0.04878,0.04878,1509.0,1003,180891.0,35788.503,197.8456805479543,uccs_d2_scan90/data/B/02/TX/trial_002_c7_unk.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_090.csv
91,S1_fixed100,2,1,FIXED_100,1387,1387,1796,0.772272,1387,0,1.0,2.41465,42.71505,0.05,0.05,0.05,2612.0,1387,181460.0,37222.167,205.12601675300343,uccs_d2_scan90/data/B/02/TX/trial_002_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_091.csv
92,S1_fixed500,2,1,FIXED_500,292,292,359,0.81337,0,292,0.0,5.266075,53.369075,0.1,0.1,0.1,1837.5,292,179634.0,33486.651,186.4159958582451,uccs_d2_scan90/data/B/02/TX/trial_001_c3_s1_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_092.csv
93,S1_policy,2,1,POLICY,653,652,855,0.762573,464,188,0.330484,5.2295,53.37455,0.15,0.1,0.1,1825.0,652,180518.0,34900.067,193.33289201076903,uccs_d2_scan90/data/B/02/TX/trial_002_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_093.csv
94,S4_fixed100,2,4,FIXED_100,1417,1417,1796,0.788976,1417,0,1.0,1.253561,13.5936,0.04878,0.04878,0.04878,1417.0,1417,181462.0,37505.15,206.68321742293153,uccs_d2_scan90/data/B/02/TX/trial_002_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_094.csv
95,S4_fixed500,2,4,FIXED_500,297,297,359,0.827298,0,297,0.0,1.325268,10.2239,0.121951,0.097561,0.097561,2004.0,297,179623.0,33422.906,186.07252968717816,uccs_d2_scan90/data/B/02/TX/trial_002_c6_s4_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_095.csv
96,S4_policy,3,4,POLICY,960,959,1227,0.781581,842,117,0.590049,1.269244,13.9147,0.04878,0.04878,0.04878,1817.0,959,180873.0,35677.639,197.25243126392553,uccs_d2_scan90/data/B/02/TX/trial_003_c7_unk.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_096.csv
97,S1_fixed100,3,1,FIXED_100,1412,1411,1796,0.785635,1411,0,1.0,5.08815,53.3578,0.1,0.1,0.1,1571.0,1411,181469.0,37361.659,205.88452573166768,uccs_d2_scan90/data/B/02/TX/trial_002_c2_s1_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_097.csv
98,S1_fixed500,3,1,FIXED_500,286,286,359,0.796657,0,286,0.0,5.299125,53.368425,0.1,0.1,0.1,2148.5,286,179621.0,33399.636,185.94505096842795,uccs_d2_scan90/data/B/02/TX/trial_002_c3_s1_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_098.csv
99,S1_policy,3,1,POLICY,693,693,855,0.810526,491,202,0.327115,5.17525,53.3739,0.1,0.1,0.1,2148.0,693,180508.0,34850.709,193.0701630952645,uccs_d2_scan90/data/B/02/TX/trial_003_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_099.csv
100,S4_fixed100,3,4,FIXED_100,1428,1428,1796,0.7951,1428,0,1.0,1.240537,13.5884,0.04878,0.04878,0.04878,1719.0,1428,181450.0,37333.104,205.74871314411683,uccs_d2_scan90/data/B/02/TX/trial_003_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_100.csv
101,S4_fixed500,3,4,FIXED_500,285,285,359,0.793872,0,285,0.0,4.150585,37.7058,0.170732,0.121951,0.121951,2337.0,285,179609.0,33318.131,185.50368300029507,uccs_d2_scan90/data/B/02/TX/trial_003_c6_s4_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_101.csv</file><file path="uccs_d2_scan90/metrics/B_02/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std
S1_fixed100,3,0.066667,0.028868,3.3142,1.536337,0.791844,0.023305,1.0,0.0,205.38,0.437,1795.0,1.732
S1_fixed500,3,0.133333,0.057735,5.289217,0.02011,0.815227,0.019565,0.0,0.0,186.01,0.378,359.0,0.0
S1_policy,3,0.133333,0.028868,5.2302,0.055303,0.796101,0.02913,0.329348,0.001934,193.246,0.152,855.0,0.0
S4_fixed100,3,0.04878,0.0,1.248179,0.0068,0.795843,0.007267,1.0,0.0,206.338,0.513,1796.0,0.0
S4_fixed500,3,0.138211,0.028164,2.80174,1.416976,0.817085,0.020151,0.0,0.0,185.88,0.326,359.0,0.0
S4_policy,3,0.05691,0.014082,1.562455,0.53568,0.806846,0.021975,0.597167,0.009774,197.956,0.765,1227.0,0.0</file><file path="uccs_d2_scan90/metrics/B_02/summary.md"># uccs_d2_scan90 metrics summary

- source RX: `uccs_d2_scan90/data/B/02/RX`
- source TXSD: `uccs_d2_scan90/data/B/02/TX`
- truth: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S1.csv`, `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv` (n_steps=1800, dt=100ms)
- selected RX trials: 084..101 (n=18)
- generated: 2025-12-16 14:38 (local)
- command: `python3 uccs_d2_scan90/analysis/summarize_d2_run.py --rx-dir uccs_d2_scan90/data/B/02/RX --txsd-dir uccs_d2_scan90/data/B/02/TX --out-dir uccs_d2_scan90/metrics/B_02`

## Summary (mean ± std, n=3 each)
| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |
|---|---:|---:|---:|---:|---:|---:|
| S1_fixed100 | 0.0667±0.0289 | 3.314±1.536 | 0.792±0.023 | 205.4±0.4 | 1795.0±1.7 | 1.000±0.000 |
| S1_fixed500 | 0.1333±0.0577 | 5.289±0.020 | 0.815±0.020 | 186.0±0.4 | 359.0±0.0 | 0.000±0.000 |
| S1_policy | 0.1333±0.0289 | 5.230±0.055 | 0.796±0.029 | 193.2±0.2 | 855.0±0.0 | 0.329±0.002 |
| S4_fixed100 | 0.0488±0.0000 | 1.248±0.007 | 0.796±0.007 | 206.3±0.5 | 1796.0±0.0 | 1.000±0.000 |
| S4_fixed500 | 0.1382±0.0282 | 2.802±1.417 | 0.817±0.020 | 185.9±0.3 | 359.0±0.0 | 0.000±0.000 |
| S4_policy | 0.0569±0.0141 | 1.562±0.536 | 0.807±0.022 | 198.0±0.8 | 1227.0±0.0 | 0.597±0.010 |

## Notes
- RX trial selection: latest 18 trials that form 6 conditions × 3 repeats (duration&gt;=160s).
- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).
- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique when available.
- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).</file><file path="uccs_d2_scan90/metrics/B_n6/per_trial.csv">rx_trial_id,condition,repeat_idx,session,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_n100,rx_tag_n500,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_path,rx_path
2,S1_fixed100,1,1,FIXED_100,1421,1420,1796,0.790646,1420,0,1.0,5.10375,53.35615,0.1,0.1,0.1,-1220.0,1419,181484.0,36847.544,203.03466972295078,uccs_d2_scan90/data/B/TX/trial_001_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_002.csv
3,S1_fixed500,1,1,FIXED_500,300,300,359,0.835655,1,299,0.000668,5.300375,53.368925,0.2,0.1,0.1,-699.5,300,179653.0,32881.102,183.02562161500225,uccs_d2_scan90/data/B/TX/trial_001_c3_s1_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_003.csv
4,S1_policy,1,1,POLICY,700,700,855,0.818713,498,202,0.330239,5.1951,53.3738,0.1,0.1,0.1,-757.0,700,180540.0,34303.246,190.0035781544256,uccs_d2_scan90/data/B/TX/trial_001_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_004.csv
5,S4_fixed100,1,4,FIXED_100,1429,1429,1796,0.795657,1428,1,0.996511,1.249634,13.6667,0.073171,0.04878,0.04878,-1198.0,1429,181482.0,36739.403,202.44102996440418,uccs_d2_scan90/data/B/TX/trial_001_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/RX/rx_trial_005.csv
6,S4_fixed500,1,4,FIXED_500,286,286,359,0.796657,1,285,0.000701,1.620049,14.9768,0.195122,0.097561,0.097561,-678.0,286,179637.0,32909.928,183.20239148950384,uccs_d2_scan90/data/B/TX/trial_001_c6_s4_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_006.csv
7,S4_policy,1,4,POLICY,958,957,1227,0.779951,844,113,0.599006,1.245537,13.9336,0.073171,0.04878,0.04878,-900.0,957,180906.0,35244.03,194.81957480680572,uccs_d2_scan90/data/B/TX/trial_001_c7_unk.csv,uccs_d2_scan90/data/B/RX/rx_trial_007.csv
8,S1_fixed100,2,1,FIXED_100,1393,1392,1796,0.775056,1392,0,1.0,5.09495,53.35685,0.1,0.1,0.1,-1171.0,1392,181477.0,36886.619,203.25781779509248,uccs_d2_scan90/data/B/TX/trial_001_c2_s1_fixed500.csv,uccs_d2_scan90/data/B/RX/rx_trial_008.csv
9,S1_fixed500,2,1,FIXED_500,294,294,359,0.818942,0,294,0.0,5.3122,53.36635,0.15,0.1,0.1,-646.0,294,179619.0,32949.043,183.43851708338204,uccs_d2_scan90/data/B/TX/trial_002_c3_s1_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_009.csv
10,S1_policy,2,1,POLICY,700,700,855,0.818713,496,204,0.327177,5.24535,53.37365,0.1,0.1,0.1,-710.0,700,180526.0,34177.069,189.31937227878532,uccs_d2_scan90/data/B/TX/trial_002_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_010.csv
11,S4_fixed100,2,4,FIXED_100,1393,1393,1796,0.775612,1392,1,0.996421,1.236171,13.6357,0.04878,0.04878,0.04878,-1157.0,1393,181466.0,36685.926,202.16418502639613,uccs_d2_scan90/data/B/TX/trial_002_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/RX/rx_trial_011.csv
12,S4_fixed500,2,4,FIXED_500,291,291,359,0.810585,1,290,0.000689,1.708902,15.007,0.146341,0.097561,0.097561,-620.0,291,179626.0,32848.146,182.8696625210159,uccs_d2_scan90/data/B/TX/trial_002_c6_s4_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_012.csv
13,S4_policy,2,4,POLICY,953,952,1227,0.775876,836,116,0.590395,2.26,23.7535,0.121951,0.073171,0.073171,-823.5,952,180894.0,35375.844,195.56117947527278,uccs_d2_scan90/data/B/TX/trial_002_c7_unk.csv,uccs_d2_scan90/data/B/RX/rx_trial_013.csv
14,S1_fixed100,3,1,FIXED_100,1419,1419,1796,0.790089,1419,0,1.0,2.43275,42.6563,0.05,0.05,0.05,-1115.0,1419,181465.0,36716.754,202.33518309315846,uccs_d2_scan90/data/B/TX/trial_002_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_014.csv
15,S1_fixed500,3,1,FIXED_500,285,285,359,0.793872,1,284,0.000704,5.2747,53.36795,0.1,0.1,0.1,-589.0,285,179616.0,32948.453,183.4382961428826,uccs_d2_scan90/data/B/TX/trial_003_c3_s1_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_015.csv
16,S1_policy,3,1,POLICY,677,677,855,0.791813,487,190,0.3389,5.30085,53.37445,0.15,0.1,0.1,-609.0,677,180512.0,34285.471,189.93458052650237,uccs_d2_scan90/data/B/TX/trial_003_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_016.csv
17,S4_fixed100,3,4,FIXED_100,1426,1424,1796,0.792873,1423,1,0.996499,1.256073,13.6019,0.04878,0.04878,0.04878,-1089.0,1424,181445.0,36841.047,203.04250323789577,uccs_d2_scan90/data/B/TX/trial_004_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/RX/rx_trial_017.csv
18,S4_fixed500,3,4,FIXED_500,303,303,359,0.844011,0,303,0.0,3.169268,20.1689,0.121951,0.097561,0.097561,-564.0,303,179607.0,32970.008,183.5675001531121,uccs_d2_scan90/data/B/TX/trial_003_c6_s4_policy.csv,uccs_d2_scan90/data/B/RX/rx_trial_018.csv
19,S4_policy,3,4,POLICY,959,957,1227,0.779951,839,118,0.587124,1.258951,13.8866,0.04878,0.04878,0.04878,-771.0,957,180880.0,35327.718,195.31024988942946,uccs_d2_scan90/data/B/TX/trial_003_c7_unk.csv,uccs_d2_scan90/data/B/RX/rx_trial_019.csv
84,S4_policy,1,4,POLICY,1009,1008,1227,0.821516,893,115,0.608311,2.180732,23.6714,0.073171,0.073171,0.073171,1226.5,1008,180905.0,35958.479,198.76995660705896,uccs_d2_scan90/data/B/02/TX/trial_001_c7_unk.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_084.csv
85,S1_fixed100,1,1,FIXED_100,1468,1466,1793,0.817624,1466,0,1.0,2.4398,42.7262,0.05,0.05,0.05,977.0,1466,181134.0,37155.962,205.1296940386675,uccs_d2_scan90/data/B/02/TX/trial_001_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_085.csv
86,S1_fixed500,1,1,FIXED_500,300,300,359,0.835655,0,300,0.0,5.30245,53.36735,0.2,0.1,0.1,1560.0,300,179653.0,33355.851,185.66821038335016,uccs_d2_scan90/data/B/02/TX/trial_001_c2_s1_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_086.csv
87,S1_policy,1,1,POLICY,698,697,855,0.815205,496,201,0.330446,5.28585,53.3993,0.15,0.1,0.1,1531.0,697,180538.0,34904.265,193.33472731502508,uccs_d2_scan90/data/B/02/TX/trial_001_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_087.csv
88,S4_fixed100,1,4,FIXED_100,1444,1443,1796,0.803452,1443,0,1.0,1.250439,13.6383,0.04878,0.04878,0.04878,1116.0,1443,181477.0,37489.878,206.58198008563068,uccs_d2_scan90/data/B/02/TX/trial_001_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_088.csv
89,S4_fixed500,1,4,FIXED_500,298,298,359,0.830084,0,298,0.0,2.929366,15.0313,0.121951,0.097561,0.097561,1700.0,298,179638.0,33424.385,186.0652256204144,uccs_d2_scan90/data/B/02/TX/trial_001_c6_s4_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_089.csv
90,S4_policy,2,4,POLICY,1003,1003,1227,0.817441,882,121,0.593141,1.23739,14.2797,0.04878,0.04878,0.04878,1509.0,1003,180891.0,35788.503,197.8456805479543,uccs_d2_scan90/data/B/02/TX/trial_002_c7_unk.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_090.csv
91,S1_fixed100,2,1,FIXED_100,1387,1387,1796,0.772272,1387,0,1.0,2.41465,42.71505,0.05,0.05,0.05,2612.0,1387,181460.0,37222.167,205.12601675300343,uccs_d2_scan90/data/B/02/TX/trial_002_c1_s1_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_091.csv
92,S1_fixed500,2,1,FIXED_500,292,292,359,0.81337,0,292,0.0,5.266075,53.369075,0.1,0.1,0.1,1837.5,292,179634.0,33486.651,186.4159958582451,uccs_d2_scan90/data/B/02/TX/trial_001_c3_s1_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_092.csv
93,S1_policy,2,1,POLICY,653,652,855,0.762573,464,188,0.330484,5.2295,53.37455,0.15,0.1,0.1,1825.0,652,180518.0,34900.067,193.33289201076903,uccs_d2_scan90/data/B/02/TX/trial_002_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_093.csv
94,S4_fixed100,2,4,FIXED_100,1417,1417,1796,0.788976,1417,0,1.0,1.253561,13.5936,0.04878,0.04878,0.04878,1417.0,1417,181462.0,37505.15,206.68321742293153,uccs_d2_scan90/data/B/02/TX/trial_002_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_094.csv
95,S4_fixed500,2,4,FIXED_500,297,297,359,0.827298,0,297,0.0,1.325268,10.2239,0.121951,0.097561,0.097561,2004.0,297,179623.0,33422.906,186.07252968717816,uccs_d2_scan90/data/B/02/TX/trial_002_c6_s4_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_095.csv
96,S4_policy,3,4,POLICY,960,959,1227,0.781581,842,117,0.590049,1.269244,13.9147,0.04878,0.04878,0.04878,1817.0,959,180873.0,35677.639,197.25243126392553,uccs_d2_scan90/data/B/02/TX/trial_003_c7_unk.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_096.csv
97,S1_fixed100,3,1,FIXED_100,1412,1411,1796,0.785635,1411,0,1.0,5.08815,53.3578,0.1,0.1,0.1,1571.0,1411,181469.0,37361.659,205.88452573166768,uccs_d2_scan90/data/B/02/TX/trial_002_c2_s1_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_097.csv
98,S1_fixed500,3,1,FIXED_500,286,286,359,0.796657,0,286,0.0,5.299125,53.368425,0.1,0.1,0.1,2148.5,286,179621.0,33399.636,185.94505096842795,uccs_d2_scan90/data/B/02/TX/trial_002_c3_s1_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_098.csv
99,S1_policy,3,1,POLICY,693,693,855,0.810526,491,202,0.327115,5.17525,53.3739,0.1,0.1,0.1,2148.0,693,180508.0,34850.709,193.0701630952645,uccs_d2_scan90/data/B/02/TX/trial_003_c4_s4_fixed100.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_099.csv
100,S4_fixed100,3,4,FIXED_100,1428,1428,1796,0.7951,1428,0,1.0,1.240537,13.5884,0.04878,0.04878,0.04878,1719.0,1428,181450.0,37333.104,205.74871314411683,uccs_d2_scan90/data/B/02/TX/trial_003_c5_s4_fixed500.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_100.csv
101,S4_fixed500,3,4,FIXED_500,285,285,359,0.793872,0,285,0.0,4.150585,37.7058,0.170732,0.121951,0.121951,2337.0,285,179609.0,33318.131,185.50368300029507,uccs_d2_scan90/data/B/02/TX/trial_003_c6_s4_policy.csv,uccs_d2_scan90/data/B/02/RX/rx_trial_101.csv</file><file path="uccs_d2_scan90/metrics/B_n6/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std
S1_fixed100,6,0.075,0.027386,3.762342,1.460561,0.788554,0.016172,1.0,0.0,204.128,1.432,1795.5,1.225
S1_fixed500,6,0.141667,0.04916,5.292488,0.017934,0.815692,0.018174,0.000229,0.000354,184.655,1.51,359.0,0.0
S1_policy,6,0.125,0.027386,5.23865,0.049278,0.802924,0.022176,0.330727,0.004309,191.499,1.931,855.0,0.0
S4_fixed100,6,0.052845,0.009958,1.247736,0.007745,0.791945,0.009301,0.998239,0.00193,204.444,2.119,1796.0,0.0
S4_fixed500,6,0.146341,0.030852,2.483906,1.107727,0.817084,0.019983,0.000232,0.000359,184.547,1.492,359.0,0.0
S4_policy,6,0.069106,0.028513,1.575309,0.500407,0.792719,0.020853,0.594671,0.007795,196.593,1.587,1227.0,0.0</file><file path="uccs_d2_scan90/metrics/B_n6/summary.md"># uccs_d2_scan90 merged metrics summary

- purpose: merge summarized runs (per_trial.csv) and increase n without re-parsing raw logs.
- source: `uccs_d2_scan90/metrics/B`
- source: `uccs_d2_scan90/metrics/B_02`
- generated: 2025-12-16 14:52 (local)
- command: `python3 uccs_d2_scan90/analysis/merge_metrics_runs.py --out-dir uccs_d2_scan90/metrics/B_n6 --input-dir uccs_d2_scan90/metrics/B --input-dir uccs_d2_scan90/metrics/B_02`

## Summary (mean ± std)
| condition | n | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |
|---|---:|---:|---:|---:|---:|---:|---:|
| S1_fixed100 | 6 | 0.0750±0.0274 | 3.762±1.461 | 0.789±0.016 | 204.1±1.4 | 1795.5±1.2 | 1.000±0.000 |
| S1_fixed500 | 6 | 0.1417±0.0492 | 5.292±0.018 | 0.816±0.018 | 184.7±1.5 | 359.0±0.0 | 0.000±0.000 |
| S1_policy | 6 | 0.1250±0.0274 | 5.239±0.049 | 0.803±0.022 | 191.5±1.9 | 855.0±0.0 | 0.331±0.004 |
| S4_fixed100 | 6 | 0.0528±0.0100 | 1.248±0.008 | 0.792±0.009 | 204.4±2.1 | 1796.0±0.0 | 0.998±0.002 |
| S4_fixed500 | 6 | 0.1463±0.0309 | 2.484±1.108 | 0.817±0.020 | 184.5±1.5 | 359.0±0.0 | 0.000±0.000 |
| S4_policy | 6 | 0.0691±0.0285 | 1.575±0.500 | 0.793±0.021 | 196.6±1.6 | 1227.0±0.0 | 0.595±0.008 |

## Notes
- This script does not recompute TL/Pout; it re-aggregates existing per-trial metrics.
- Rounding follows summarize_d2_run.py (pout/TL/PDR/share: 6 decimals, power/adv: 3 decimals).</file><file path="uccs_d2_scan90/src/rx/RX_UCCS_D2_SCAN90/RX_UCCS_D2_SCAN90.ino">// RX_UCCS_D2_SCAN90.ino (uccs_d2_scan90)
// Receive TX_UCCS_D2 packets (MFD &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;) and log to SD.
// - SYNC gate: TX GPIO25 -&gt; RX GPIO26.
// - NimBLE passive scan with scan90% (interval=100ms, window=90ms).

#include &lt;Arduino.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NimBLEDevice.h&gt;
#include &lt;math.h&gt;

static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26; // TX GPIO25 -&gt; RX GPIO26

// scan90
static const float SCAN_INTERVAL_MS = 100.0f;
static const float SCAN_WINDOW_MS   = 90.0f;

static const uint32_t SESSION_TIMEOUT_MS = 1200000; // safety timeout (~20 min)
static const uint32_t SYNC_LOW_DEBOUNCE_MS = 100;   // end session if SYNC LOW for &gt;=100ms
static const uint32_t START_LEVEL_HOLD_MS = 200;    // start session if SYNC HIGH held for &gt;=200ms

static inline uint16_t ms_to_0p625(float ms){ return (uint16_t)lroundf(ms / 0.625f); }

static const uint16_t RX_BUF_SIZE = 512;
static const uint32_t FLUSH_INTERVAL_MS = 500;

struct RxEntry {
  uint32_t ms;
  int8_t   rssi;
  uint16_t seq;        // step_idx (0..)
  char     label[16];  // tag (e.g., P4-09-500)
  char     addr[18];
  char     mfd[40];
};

static RxEntry rxBuf[RX_BUF_SIZE];
static volatile uint16_t rxHead = 0;
static uint16_t rxTail = 0;
static uint32_t bufOverflow = 0;
static uint32_t lastFlushMs = 0;

static bool trial = false;
static bool syncState = false;
static uint32_t t0Ms = 0;
static uint32_t rxCount = 0;
static uint32_t syncLowSince = 0;
static uint32_t syncHighSince = 0;

static File f;
static const char FW_TAG[] = &quot;RX_UCCS_D2_SCAN90&quot;;
static bool condSeen = false;
static bool condWritten = false;
static char condLabel[16] = {0};

// MFD parser: &quot;&lt;seq&gt;_&lt;label&gt;&quot;
static bool parseMFD(const std::string&amp; s, uint16_t&amp; seq, std::string&amp; label) {
  size_t usPos = s.find(&apos;_&apos;);
  if (usPos == std::string::npos || usPos &lt; 1) return false;
  std::string seqStr = s.substr(0, usPos);
  label = s.substr(usPos + 1);
  if (label.empty()) return false;
  char* endp = nullptr;
  unsigned long v = strtoul(seqStr.c_str(), &amp;endp, 10);
  if (endp == seqStr.c_str() || v &gt; 65535UL) return false;
  seq = static_cast&lt;uint16_t&gt;(v);
  return true;
}

static String nextPath() {
  SD.mkdir(&quot;/logs&quot;);
  char p[64];
  for (uint32_t id = 1;; ++id) {
    snprintf(p, sizeof(p), &quot;/logs/rx_trial_%03lu.csv&quot;, (unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

static void flushBuffer() {
  if (!f) return;
  if (!condWritten &amp;&amp; condSeen) {
    f.printf(&quot;# condition_label=%s\r\n&quot;, condLabel);
    condWritten = true;
  }
  uint16_t head = rxHead;
  bool wrote = false;
  while (rxTail != head) {
    RxEntry&amp; e = rxBuf[rxTail];
    f.printf(&quot;%lu,ADV,%d,%u,%s,%s,%s\r\n&quot;,
             (unsigned long)e.ms,
             (int)e.rssi,
             (unsigned)e.seq,
             e.label,
             e.addr,
             e.mfd);
    rxTail = (rxTail + 1) % RX_BUF_SIZE;
    wrote = true;
  }
  if (wrote) f.flush();
}

static void startSession() {
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (f) {
    f.println(&quot;ms,event,rssi,seq,label,addr,mfd&quot;);
    f.printf(&quot;# meta, firmware=%s, buf_size=%u\r\n&quot;, FW_TAG, (unsigned)RX_BUF_SIZE);
    f.flush();
  }
  t0Ms = millis();
  rxCount = 0;
  rxHead = rxTail = 0;
  bufOverflow = 0;
  lastFlushMs = t0Ms;
  condSeen = false;
  condWritten = false;
  condLabel[0] = &apos;\0&apos;;
  Serial.printf(&quot;[RX] start %s\n&quot;, path.c_str());
  trial = true;
}

static void endSession() {
  if (!trial) return;
  flushBuffer();
  if (f) { f.flush(); f.close(); }
  uint32_t t_ms = millis() - t0Ms;
  double dur_s = t_ms / 1000.0;
  double rate_hz = dur_s &gt; 0 ? (double)rxCount / dur_s : 0.0;
  Serial.printf(&quot;[RX] end ms_total=%lu rx=%lu buf_overflow=%lu rate_hz=%.2f\n&quot;,
                (unsigned long)t_ms,
                (unsigned long)rxCount,
                (unsigned long)bufOverflow,
                rate_hz);
  trial = false;
}

class AdvCB : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    const std::string&amp; mfd = d-&gt;getManufacturerData();
    uint16_t seq;
    std::string label;
    if (!parseMFD(mfd, seq, label)) return;
    if (!condSeen) {
      strncpy(condLabel, label.c_str(), sizeof(condLabel) - 1);
      condLabel[sizeof(condLabel) - 1] = &apos;\0&apos;;
      condSeen = true;
    }
    const std::string addr = d-&gt;getAddress().toString();

    uint16_t nextH = (rxHead + 1) % RX_BUF_SIZE;
    if (nextH == rxTail) { bufOverflow++; return; }
    RxEntry&amp; e = rxBuf[rxHead];
    e.ms = millis() - t0Ms;
    e.rssi = (int8_t)d-&gt;getRSSI();
    e.seq = seq;
    strncpy(e.label, label.c_str(), sizeof(e.label) - 1); e.label[sizeof(e.label) - 1] = &apos;\0&apos;;
    strncpy(e.addr, addr.c_str(), sizeof(e.addr) - 1); e.addr[sizeof(e.addr) - 1] = &apos;\0&apos;;
    strncpy(e.mfd, mfd.c_str(), sizeof(e.mfd) - 1); e.mfd[sizeof(e.mfd) - 1] = &apos;\0&apos;;
    rxHead = nextH; rxCount++;
  }
};

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;[RX] FW=RX_UCCS_D2_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) { Serial.println(&quot;[SD] init FAIL&quot;); while (1) delay(1000); }
  pinMode(SYNC_IN, INPUT_PULLDOWN);

  NimBLEDevice::init(&quot;RX_ESP32&quot;);
  NimBLEScan* scan = NimBLEDevice::getScan();
  scan-&gt;setActiveScan(false);
  scan-&gt;setInterval(ms_to_0p625(SCAN_INTERVAL_MS));
  scan-&gt;setWindow(ms_to_0p625(SCAN_WINDOW_MS));
  scan-&gt;setDuplicateFilter(0);
  scan-&gt;setScanCallbacks(new AdvCB(), true);
  scan-&gt;start(0, false);

  Serial.printf(&quot;[RX] ready (buf=%u, flush=%lums, wait SYNC pin=%d)\n&quot;,
                (unsigned)RX_BUF_SIZE, (unsigned long)FLUSH_INTERVAL_MS, SYNC_IN);
}

void loop() {
  bool syncHigh = (digitalRead(SYNC_IN) == HIGH);

  if (!trial) {
    if (syncHigh) {
      if (syncHighSince == 0) syncHighSince = millis();
      if ((millis() - syncHighSince) &gt;= START_LEVEL_HOLD_MS) {
        startSession();
        syncState = true;
        syncLowSince = 0;
      }
    } else {
      syncHighSince = 0;
    }
  } else {
    if (!syncHigh &amp;&amp; syncState) {
      if (syncLowSince == 0) syncLowSince = millis();
      if ((millis() - syncLowSince) &gt;= SYNC_LOW_DEBOUNCE_MS) {
        endSession();
        syncState = false;
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
    }
    if (trial &amp;&amp; (millis() - t0Ms) &gt;= SESSION_TIMEOUT_MS) {
      Serial.println(&quot;[RX] force end by timeout&quot;);
      endSession();
      syncState = false;
      syncLowSince = 0;
    }
  }

  uint32_t now = millis();
  if (now - lastFlushMs &gt;= FLUSH_INTERVAL_MS) {
    flushBuffer();
    lastFlushMs = now;
  }
  vTaskDelay(1);
}</file><file path="uccs_d2_scan90/src/rx/RX_UCCS_D2B_SCAN90/RX_UCCS_D2B_SCAN90.ino">// RX_UCCS_D2B_SCAN90.ino (uccs_d2_scan90)
// Receive TX_UCCS_D2 packets (MFD &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;) and log to SD.
// - SYNC gate: TX GPIO25 -&gt; RX GPIO26.
// - NimBLE passive scan with scan90% (interval=100ms, window=90ms).

#include &lt;Arduino.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NimBLEDevice.h&gt;
#include &lt;math.h&gt;

static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26; // TX GPIO25 -&gt; RX GPIO26

// scan90
static const float SCAN_INTERVAL_MS = 100.0f;
static const float SCAN_WINDOW_MS   = 90.0f;

static const uint32_t SESSION_TIMEOUT_MS = 1200000; // safety timeout (~20 min)
static const uint32_t SYNC_LOW_DEBOUNCE_MS = 100;   // end session if SYNC LOW for &gt;=100ms
static const uint32_t START_LEVEL_HOLD_MS = 200;    // start session if SYNC HIGH held for &gt;=200ms

static inline uint16_t ms_to_0p625(float ms){ return (uint16_t)lroundf(ms / 0.625f); }

static const uint16_t RX_BUF_SIZE = 512;
static const uint32_t FLUSH_INTERVAL_MS = 500;

struct RxEntry {
  uint32_t ms;
  int8_t   rssi;
  uint16_t seq;        // step_idx (0..)
  char     label[16];  // tag (e.g., P4-09-500)
  char     addr[18];
  char     mfd[40];
};

static RxEntry rxBuf[RX_BUF_SIZE];
static volatile uint16_t rxHead = 0;
static uint16_t rxTail = 0;
static uint32_t bufOverflow = 0;
static uint32_t lastFlushMs = 0;

static bool trial = false;
static bool syncState = false;
static uint32_t t0Ms = 0;
static uint32_t rxCount = 0;
static uint32_t syncLowSince = 0;
static uint32_t syncHighSince = 0;

static File f;
static const char FW_TAG[] = &quot;RX_UCCS_D2B_SCAN90&quot;;
static bool condSeen = false;
static bool condWritten = false;
static char condLabel[16] = {0};

// MFD parser: &quot;&lt;seq&gt;_&lt;label&gt;&quot;
static bool parseMFD(const std::string&amp; s, uint16_t&amp; seq, std::string&amp; label) {
  size_t usPos = s.find(&apos;_&apos;);
  if (usPos == std::string::npos || usPos &lt; 1) return false;
  std::string seqStr = s.substr(0, usPos);
  label = s.substr(usPos + 1);
  if (label.empty()) return false;
  char* endp = nullptr;
  unsigned long v = strtoul(seqStr.c_str(), &amp;endp, 10);
  if (endp == seqStr.c_str() || v &gt; 65535UL) return false;
  seq = static_cast&lt;uint16_t&gt;(v);
  return true;
}

static String nextPath() {
  SD.mkdir(&quot;/logs&quot;);
  char p[64];
  for (uint32_t id = 1;; ++id) {
    snprintf(p, sizeof(p), &quot;/logs/rx_trial_%03lu.csv&quot;, (unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

static void flushBuffer() {
  if (!f) return;
  if (!condWritten &amp;&amp; condSeen) {
    f.printf(&quot;# condition_label=%s\r\n&quot;, condLabel);
    condWritten = true;
  }
  uint16_t head = rxHead;
  bool wrote = false;
  while (rxTail != head) {
    RxEntry&amp; e = rxBuf[rxTail];
    f.printf(&quot;%lu,ADV,%d,%u,%s,%s,%s\r\n&quot;,
             (unsigned long)e.ms,
             (int)e.rssi,
             (unsigned)e.seq,
             e.label,
             e.addr,
             e.mfd);
    rxTail = (rxTail + 1) % RX_BUF_SIZE;
    wrote = true;
  }
  if (wrote) f.flush();
}

static void startSession() {
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (f) {
    f.println(&quot;ms,event,rssi,seq,label,addr,mfd&quot;);
    f.printf(&quot;# meta, firmware=%s, buf_size=%u\r\n&quot;, FW_TAG, (unsigned)RX_BUF_SIZE);
    f.flush();
  }
  t0Ms = millis();
  rxCount = 0;
  rxHead = rxTail = 0;
  bufOverflow = 0;
  lastFlushMs = t0Ms;
  condSeen = false;
  condWritten = false;
  condLabel[0] = &apos;\0&apos;;
  Serial.printf(&quot;[RX] start %s\n&quot;, path.c_str());
  trial = true;
}

static void endSession() {
  if (!trial) return;
  flushBuffer();
  if (f) { f.flush(); f.close(); }
  uint32_t t_ms = millis() - t0Ms;
  double dur_s = t_ms / 1000.0;
  double rate_hz = dur_s &gt; 0 ? (double)rxCount / dur_s : 0.0;
  Serial.printf(&quot;[RX] end ms_total=%lu rx=%lu buf_overflow=%lu rate_hz=%.2f\n&quot;,
                (unsigned long)t_ms,
                (unsigned long)rxCount,
                (unsigned long)bufOverflow,
                rate_hz);
  trial = false;
}

class AdvCB : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    const std::string&amp; mfd = d-&gt;getManufacturerData();
    uint16_t seq;
    std::string label;
    if (!parseMFD(mfd, seq, label)) return;
    if (!condSeen) {
      strncpy(condLabel, label.c_str(), sizeof(condLabel) - 1);
      condLabel[sizeof(condLabel) - 1] = &apos;\0&apos;;
      condSeen = true;
    }
    const std::string addr = d-&gt;getAddress().toString();

    uint16_t nextH = (rxHead + 1) % RX_BUF_SIZE;
    if (nextH == rxTail) { bufOverflow++; return; }
    RxEntry&amp; e = rxBuf[rxHead];
    e.ms = millis() - t0Ms;
    e.rssi = (int8_t)d-&gt;getRSSI();
    e.seq = seq;
    strncpy(e.label, label.c_str(), sizeof(e.label) - 1); e.label[sizeof(e.label) - 1] = &apos;\0&apos;;
    strncpy(e.addr, addr.c_str(), sizeof(e.addr) - 1); e.addr[sizeof(e.addr) - 1] = &apos;\0&apos;;
    strncpy(e.mfd, mfd.c_str(), sizeof(e.mfd) - 1); e.mfd[sizeof(e.mfd) - 1] = &apos;\0&apos;;
    rxHead = nextH; rxCount++;
  }
};

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;[RX] FW=RX_UCCS_D2B_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) { Serial.println(&quot;[SD] init FAIL&quot;); while (1) delay(1000); }
  pinMode(SYNC_IN, INPUT_PULLDOWN);

  NimBLEDevice::init(&quot;RX_ESP32&quot;);
  NimBLEScan* scan = NimBLEDevice::getScan();
  scan-&gt;setActiveScan(false);
  scan-&gt;setInterval(ms_to_0p625(SCAN_INTERVAL_MS));
  scan-&gt;setWindow(ms_to_0p625(SCAN_WINDOW_MS));
  scan-&gt;setDuplicateFilter(0);
  scan-&gt;setScanCallbacks(new AdvCB(), true);
  scan-&gt;start(0, false);

  Serial.printf(&quot;[RX] ready (buf=%u, flush=%lums, wait SYNC pin=%d)\n&quot;,
                (unsigned)RX_BUF_SIZE, (unsigned long)FLUSH_INTERVAL_MS, SYNC_IN);
}

void loop() {
  bool syncHigh = (digitalRead(SYNC_IN) == HIGH);

  if (!trial) {
    if (syncHigh) {
      if (syncHighSince == 0) syncHighSince = millis();
      if ((millis() - syncHighSince) &gt;= START_LEVEL_HOLD_MS) {
        startSession();
        syncState = true;
        syncLowSince = 0;
      }
    } else {
      syncHighSince = 0;
    }
  } else {
    if (!syncHigh &amp;&amp; syncState) {
      if (syncLowSince == 0) syncLowSince = millis();
      if ((millis() - syncLowSince) &gt;= SYNC_LOW_DEBOUNCE_MS) {
        endSession();
        syncState = false;
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
    }
    if (trial &amp;&amp; (millis() - t0Ms) &gt;= SESSION_TIMEOUT_MS) {
      Serial.println(&quot;[RX] force end by timeout&quot;);
      endSession();
      syncState = false;
      syncLowSince = 0;
    }
  }

  uint32_t now = millis();
  if (now - lastFlushMs &gt;= FLUSH_INTERVAL_MS) {
    flushBuffer();
    lastFlushMs = now;
  }
  vTaskDelay(1);
}</file><file path="uccs_d2_scan90/src/tx/TX_UCCS_D2_SCAN90/TX_UCCS_D2_SCAN90.ino">// TX_UCCS_D2_SCAN90.ino (uccs_d2_scan90)
//
// Step D2 (実機): 動的でも TL/Pout を評価できるように、広告payloadに step_idx を埋め込む。
// - stress_causal(S1/S4) の label/U/CCS をフラッシュに埋め込み、同一セッションを再生する。
// - 1回の起動で S1/S4 × {Fixed100, Fixed500, Policy(100↔500)} を自動実行（REPEAT回繰り返し）。
// - RX/TXSDへは SYNC(25) で開始/終了、TXSDへは preamble TICK(27) パルス数で cond_id を通知。
// - trial中は「広告更新」ごとに TICK を1発出し、TXSDで adv_count=tick_count として取得する（近似）。
//
// Payload (ManufacturerData):
//   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
//     step_idx: 100msグリッドの整数 (0..)
//     tag: &quot;F1-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P1-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;F4-...&quot; / &quot;P4-...&quot;
//          F=Fixed, P=Policy, 1/4=session, &lt;label&gt;=truth label (00..), &lt;itv&gt;=current interval (100/500)
//
// Note:
// - 実広告イベント数を厳密に数えるわけではない（tickはpayload更新回数の近似）。
// - interval変更は確実性優先で adv stop/start を行う（RESTART_ADV_ON_INTERVAL_CHANGE=true）。

#include &lt;Arduino.h&gt;
#include &lt;BLEDevice.h&gt;
#include &lt;math.h&gt;

#ifdef ARDUINO_ARCH_ESP32
#include &quot;esp_pm.h&quot;
#endif

#include &quot;../stress_causal_s1_s4_180s.h&quot;

// ==== スケジュール ====
static const uint32_t GAP_MS = 5000;         // 条件間ギャップ
static const uint8_t REPEAT = 3;             // 各条件×繰り返し回数（S1/S4それぞれに適用）
static const uint16_t EFFECTIVE_LEN_STEPS = 1800; // 100msグリッド長（&lt;=STRESS_CAUSAL_LEN）

// ==== ピン ====
static const int SYNC_OUT_PIN = 25; // TX -&gt; RX/TXSD SYNC
static const int TICK_OUT_PIN = 27; // TX -&gt; TXSD TICK (preamble + adv_count)
static const int LED_PIN = 2;

// ==== オプション ====
static const bool USE_LED = false;
static const bool ENABLE_TICK_PREAMBLE = true;
static const bool ENABLE_TICK_PER_UPDATE = true;
static const bool RESTART_ADV_ON_INTERVAL_CHANGE = true;

// TXSD preamble window と整合（TXSD側: 800ms）
static const uint32_t PREAMBLE_WINDOW_MS = 800;

// ==== actions（実機は 100↔500 に固定） ====
static const uint16_t ACTIONS[] = {100, 500};
static const uint8_t N_ACTIONS = sizeof(ACTIONS) / sizeof(ACTIONS[0]);

// ==== 代表ポリシー（D0確定: actions={100,500} δ=0.03 power-min） ====
static const float U_MID = 0.20f;
static const float U_HIGH = 0.35f;
static const float C_MID = 0.20f;
static const float C_HIGH = 0.35f;
static const float HYST = 0.02f;
static const float EMA_ALPHA = 0.20f; // 0..1

// ==== BLE ====
static BLEAdvertising* adv = nullptr;

#ifdef ARDUINO_ARCH_ESP32
static esp_pm_lock_handle_t noLightSleepLock = nullptr;
static bool sleepBlocked = false;
#endif

enum Session : uint8_t { SESSION_S1 = 1, SESSION_S4 = 4 };
enum Mode : uint8_t { MODE_FIXED = 0, MODE_POLICY = 1 };

struct Condition {
  uint8_t cond_id;       // TXSD: preamble pulses
  Session session;       // S1 or S4
  Mode mode;             // fixed/policy
  uint16_t fixed_ms;     // MODE_FIXED only
};

// cond_id（READMEと一致）
// 1: S1 fixed100
// 2: S1 fixed500
// 3: S1 policy
// 4: S4 fixed100
// 5: S4 fixed500
// 6: S4 policy
static const Condition CONDS[] = {
  {1, SESSION_S1, MODE_FIXED, 100},
  {2, SESSION_S1, MODE_FIXED, 500},
  {3, SESSION_S1, MODE_POLICY, 500},
  {4, SESSION_S4, MODE_FIXED, 100},
  {5, SESSION_S4, MODE_FIXED, 500},
  {6, SESSION_S4, MODE_POLICY, 500},
};
static const uint8_t N_CONDS = sizeof(CONDS) / sizeof(CONDS[0]);

// state
static bool trialRunning = false;
static bool pendingStart = false;
static uint32_t syncRiseMs = 0;
static uint32_t trialStartMs = 0;
static uint32_t nextUpdateMs = 0;
static uint32_t gapStartMs = 0;
static uint8_t condIndex = 0;
static uint8_t repIndex = 0;

static uint16_t stepIdx = 0;               // 100ms grid index
static uint16_t currentIntervalMs = 500;   // 100 or 500
static float uEma = 0.0f;
static float cEma = 0.0f;

static inline uint16_t ms_to_0p625(float ms) {
  long v = lroundf(ms / 0.625f);
  if (v &lt; 0x20) v = 0x20;     // 20ms minimum
  if (v &gt; 0x4000) v = 0x4000; // 10.24s maximum
  return (uint16_t)v;
}

static uint16_t clamp_interval(uint16_t interval_ms) {
  uint16_t best = ACTIONS[0];
  uint32_t bestDist = (uint32_t)abs((int)interval_ms - (int)best);
  for (uint8_t i = 1; i &lt; N_ACTIONS; i++) {
    uint16_t a = ACTIONS[i];
    uint32_t d = (uint32_t)abs((int)interval_ms - (int)a);
    if (d &lt; bestDist || (d == bestDist &amp;&amp; a &lt; best)) {
      best = a;
      bestDist = d;
    }
  }
  return best;
}

static void syncStart() {
  if (USE_LED) digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
}

static void syncEnd() {
  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_LED) digitalWrite(LED_PIN, LOW);
}

static void tickPulseOnce(uint16_t high_us = 200) {
  digitalWrite(TICK_OUT_PIN, HIGH);
  delayMicroseconds(high_us);
  digitalWrite(TICK_OUT_PIN, LOW);
}

static void tickPreamble(uint8_t nPulses) {
  if (!ENABLE_TICK_PREAMBLE) return;
  for (uint8_t i = 0; i &lt; nPulses; i++) {
    tickPulseOnce(200);
    delay(20);
  }
}

static void setAdvIntervalMs(uint16_t ms) {
  if (!adv) return;
  uint16_t units = ms_to_0p625((float)ms);
  adv-&gt;setMinInterval(units);
  adv-&gt;setMaxInterval(units);
}

static void setPayload(uint16_t step_idx, const char* tag) {
  if (!adv) return;
  BLEAdvertisementData ad;
  // ManufacturerData only（size節約のため name は入れない）
  String mfd = String((unsigned)step_idx) + &quot;_&quot; + String(tag);
  ad.setManufacturerData(mfd);
  adv-&gt;setAdvertisementData(ad);
}

static void setSleepAllowed(bool allowLightSleep) {
#ifdef ARDUINO_ARCH_ESP32
  if (!noLightSleepLock) return;
  if (allowLightSleep) {
    if (sleepBlocked) {
      esp_pm_lock_release(noLightSleepLock);
      sleepBlocked = false;
    }
  } else {
    if (!sleepBlocked) {
      esp_pm_lock_acquire(noLightSleepLock);
      sleepBlocked = true;
    }
  }
#else
  (void)allowLightSleep;
#endif
}

static inline uint8_t getLabel(Session s, uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0;
  if (s == SESSION_S1) return pgm_read_byte(&amp;S1_LABEL[idx]);
  return pgm_read_byte(&amp;S4_LABEL[idx]);
}

static inline float getU(Session s, uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = (s == SESSION_S1) ? pgm_read_byte(&amp;S1_U_Q[idx]) : pgm_read_byte(&amp;S4_U_Q[idx]);
  return q_to_f(q);
}

static inline float getCCS(Session s, uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = (s == SESSION_S1) ? pgm_read_byte(&amp;S1_CCS_Q[idx]) : pgm_read_byte(&amp;S4_CCS_Q[idx]);
  return q_to_f(q);
}

static uint16_t policyStep(uint16_t prevInterval, float u, float c) {
  // 2値（100/500）: HIGHで100へ、両方MIDより十分低いと500へ戻す（ヒステリシス）
  const float u_hi_up = U_HIGH;
  const float c_hi_up = C_HIGH;
  const float u_mid_down = U_MID - HYST;
  const float c_mid_down = C_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if ((u &gt;= u_hi_up) || (c &gt;= c_hi_up)) next = 100;
  } else { // prevInterval == 100
    if ((u &lt; u_mid_down) &amp;&amp; (c &lt; c_mid_down)) next = 500;
  }
  return clamp_interval(next);
}

static void applyInterval(uint16_t nextMs) {
  if (nextMs == currentIntervalMs) return;
  currentIntervalMs = nextMs;
  if (!adv) return;
  if (RESTART_ADV_ON_INTERVAL_CHANGE) {
    adv-&gt;stop();
    setAdvIntervalMs(currentIntervalMs);
    adv-&gt;start();
  } else {
    setAdvIntervalMs(currentIntervalMs);
  }
}

static void makeTag(char* out, size_t out_sz, const Condition&amp; c, uint8_t truthLabel, uint16_t intervalMs) {
  // &quot;F1-09-100&quot; / &quot;P4-11-500&quot; etc.
  const char mp = (c.mode == MODE_FIXED) ? &apos;F&apos; : &apos;P&apos;;
  const unsigned sess = (unsigned)c.session; // 1 or 4
  const unsigned lbl = (unsigned)truthLabel;
  const unsigned itv = (unsigned)intervalMs;
  snprintf(out, out_sz, &quot;%c%u-%02u-%u&quot;, mp, sess, lbl, itv);
}

static void beginCondition(const Condition&amp; c) {
  // per-trial init (adv is still stopped until preamble window passes)
  stepIdx = 0;
  uEma = 0.0f;
  cEma = 0.0f;
  currentIntervalMs = (c.mode == MODE_FIXED) ? c.fixed_ms : 500;
  currentIntervalMs = clamp_interval(currentIntervalMs);

  if (adv) adv-&gt;stop();
  setAdvIntervalMs(currentIntervalMs);

  setSleepAllowed(true);

  syncStart();
  syncRiseMs = millis();
  tickPreamble(c.cond_id);
  pendingStart = true;
}

static void startTrialNow(const Condition&amp; c) {
  trialStartMs = millis();
  trialRunning = true;

  // initial payload at step=0
  const uint8_t lbl = getLabel(c.session, 0);
  char tag[16];
  makeTag(tag, sizeof(tag), c, lbl, currentIntervalMs);
  setPayload(0, tag);

  if (adv) adv-&gt;start();
  if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

  // advance to next step index (= time axis). Next update happens after currentIntervalMs.
  const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
  stepIdx = (uint16_t)(stepIdx + deltaSteps);
  nextUpdateMs = millis() + currentIntervalMs;
}

static void endTrial() {
  trialRunning = false;
  pendingStart = false;
  if (adv) adv-&gt;stop();
  syncEnd();
  gapStartMs = millis();
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);
  digitalWrite(SYNC_OUT_PIN, LOW);
  pinMode(TICK_OUT_PIN, OUTPUT);
  digitalWrite(TICK_OUT_PIN, LOW);

  BLEDevice::init(&quot;TX_UCCS_D2_SCAN90&quot;);
  BLEDevice::setPower(ESP_PWR_LVL_N0);
  adv = BLEDevice::getAdvertising();
  adv-&gt;setScanResponse(false);
  adv-&gt;setMinPreferred(0);

#ifdef ARDUINO_ARCH_ESP32
  (void)esp_pm_lock_create(ESP_PM_NO_LIGHT_SLEEP, 0, &quot;uccs_d2&quot;, &amp;noLightSleepLock);
#endif

  condIndex = 0;
  repIndex = 0;
  gapStartMs = 0;
  trialRunning = false;
  pendingStart = false;

  beginCondition(CONDS[condIndex]);
}

void loop() {
  const uint32_t nowMs = millis();
  const Condition&amp; c = CONDS[condIndex];

  if (pendingStart) {
    if ((nowMs - syncRiseMs) &gt;= PREAMBLE_WINDOW_MS) {
      pendingStart = false;
      startTrialNow(c);
    } else {
      vTaskDelay(1);
      return;
    }
  }

  if (trialRunning) {
    // stop condition (time axis by stepIdx)
    if (stepIdx &gt;= EFFECTIVE_LEN_STEPS) {
      endTrial();
      vTaskDelay(pdMS_TO_TICKS(50));
      return;
    }

    if ((int32_t)(nowMs - nextUpdateMs) &gt;= 0) {
      // update at advertising cadence
      const uint8_t truthLabel = getLabel(c.session, stepIdx);

      if (c.mode == MODE_POLICY) {
        const float uRaw = getU(c.session, stepIdx);
        const float cRaw = getCCS(c.session, stepIdx);
        uEma = EMA_ALPHA * uRaw + (1.0f - EMA_ALPHA) * uEma;
        cEma = EMA_ALPHA * cRaw + (1.0f - EMA_ALPHA) * cEma;

        const uint16_t nextI = policyStep(currentIntervalMs, uEma, cEma);
        applyInterval(nextI);
      }

      char tag[16];
      makeTag(tag, sizeof(tag), c, truthLabel, currentIntervalMs);
      setPayload(stepIdx, tag);
      if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

      // advance time
      const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
      stepIdx = (uint16_t)(stepIdx + deltaSteps);
      nextUpdateMs = millis() + currentIntervalMs;
    }
    vTaskDelay(1);
    return;
  }

  // gap
  if (gapStartMs == 0) gapStartMs = nowMs;
  if ((nowMs - gapStartMs) &lt; GAP_MS) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return;
  }

  // next condition
  gapStartMs = 0;
  condIndex++;
  if (condIndex &gt;= N_CONDS) {
    condIndex = 0;
    repIndex++;
  }
  if (repIndex &gt;= REPEAT) {
    // done
    setSleepAllowed(true);
    if (adv) adv-&gt;stop();
    syncEnd();
    vTaskDelay(pdMS_TO_TICKS(1000));
    return;
  }

  beginCondition(CONDS[condIndex]);
  vTaskDelay(pdMS_TO_TICKS(200));
}</file><file path="uccs_d2_scan90/src/tx/TX_UCCS_D2B_SCAN90/TX_UCCS_D2B_SCAN90.ino">// TX_UCCS_D2B_SCAN90.ino (uccs_d2_scan90)
//
// Step D2 (実機): 動的でも TL/Pout を評価できるように、広告payloadに step_idx を埋め込む。
// - stress_causal(S1/S4) の label/U/CCS をフラッシュに埋め込み、同一セッションを再生する。
// - 1回の起動で S1/S4 × {Fixed100, Fixed500, Policy(100↔500)} を自動実行（REPEAT回繰り返し）。
// - RX/TXSDへは SYNC(25) で開始/終了、TXSDへは preamble TICK(27) パルス数で cond_id を通知。
// - trial中は「広告更新」ごとに TICK を1発出し、TXSDで adv_count=tick_count として取得する（近似）。
//
// Payload (ManufacturerData):
//   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
//     step_idx: 100msグリッドの整数 (0..)
//     tag: &quot;F1-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P1-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;F4-...&quot; / &quot;P4-...&quot;
//          F=Fixed, P=Policy, 1/4=session, &lt;label&gt;=truth label (00..), &lt;itv&gt;=current interval (100/500)
//
// Note:
// - 実広告イベント数を厳密に数えるわけではない（tickはpayload更新回数の近似）。
// - interval変更は確実性優先で adv stop/start を行う（RESTART_ADV_ON_INTERVAL_CHANGE=true）。
//
// D2b（policy修正版）:
// - `stress_causal_*` の CCS は「安定度（高いほどstable）」なので、policy側では change として扱うため
//   `CCS_change = 1 - CCS_stable` に変換して判定する（D0/D1のCCS定義と整合）。
// - preamble を TXSD が取りこぼして cond_id=0 になり得るため、SYNC HIGH の直後に少し待ってから
//   preamble TICK を打つ（TXSD側が SYNC HIGH を認識して tickAtSync を確定してからカウントできるようにする）。

#include &lt;Arduino.h&gt;
#include &lt;BLEDevice.h&gt;
#include &lt;math.h&gt;

#ifdef ARDUINO_ARCH_ESP32
#include &quot;esp_pm.h&quot;
#endif

#include &quot;../stress_causal_s1_s4_180s.h&quot;

// ==== スケジュール ====
static const uint32_t GAP_MS = 5000;         // 条件間ギャップ
static const uint8_t REPEAT = 3;             // 各条件×繰り返し回数（S1/S4それぞれに適用）
static const uint16_t EFFECTIVE_LEN_STEPS = 1800; // 100msグリッド長（&lt;=STRESS_CAUSAL_LEN）

// ==== ピン ====
static const int SYNC_OUT_PIN = 25; // TX -&gt; RX/TXSD SYNC
static const int TICK_OUT_PIN = 27; // TX -&gt; TXSD TICK (preamble + adv_count)
static const int LED_PIN = 2;

// ==== オプション ====
static const bool USE_LED = false;
static const bool ENABLE_TICK_PREAMBLE = true;
static const bool ENABLE_TICK_PER_UPDATE = true;
static const bool RESTART_ADV_ON_INTERVAL_CHANGE = true;

// TXSD preamble window と整合（TXSD側: 800ms）
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint32_t PREAMBLE_GUARD_MS  = 100;

// ==== actions（実機は 100↔500 に固定） ====
static const uint16_t ACTIONS[] = {100, 500};
static const uint8_t N_ACTIONS = sizeof(ACTIONS) / sizeof(ACTIONS[0]);

// ==== 代表ポリシー（D0確定: actions={100,500} δ=0.03 power-min） ====
static const float U_MID = 0.20f;
static const float U_HIGH = 0.35f;
static const float C_MID = 0.20f;
static const float C_HIGH = 0.35f;
static const float HYST = 0.02f;
static const float EMA_ALPHA = 0.20f; // 0..1

// ==== BLE ====
static BLEAdvertising* adv = nullptr;

#ifdef ARDUINO_ARCH_ESP32
static esp_pm_lock_handle_t noLightSleepLock = nullptr;
static bool sleepBlocked = false;
#endif

enum Session : uint8_t { SESSION_S1 = 1, SESSION_S4 = 4 };
enum Mode : uint8_t { MODE_FIXED = 0, MODE_POLICY = 1 };

struct Condition {
  uint8_t cond_id;       // TXSD: preamble pulses
  Session session;       // S1 or S4
  Mode mode;             // fixed/policy
  uint16_t fixed_ms;     // MODE_FIXED only
};

// cond_id（READMEと一致）
// 1: S1 fixed100
// 2: S1 fixed500
// 3: S1 policy
// 4: S4 fixed100
// 5: S4 fixed500
// 6: S4 policy
static const Condition CONDS[] = {
  {1, SESSION_S1, MODE_FIXED, 100},
  {2, SESSION_S1, MODE_FIXED, 500},
  {3, SESSION_S1, MODE_POLICY, 500},
  {4, SESSION_S4, MODE_FIXED, 100},
  {5, SESSION_S4, MODE_FIXED, 500},
  {6, SESSION_S4, MODE_POLICY, 500},
};
static const uint8_t N_CONDS = sizeof(CONDS) / sizeof(CONDS[0]);

// state
static bool trialRunning = false;
static bool pendingStart = false;
static uint32_t syncRiseMs = 0;
static uint32_t trialStartMs = 0;
static uint32_t nextUpdateMs = 0;
static uint32_t gapStartMs = 0;
static uint8_t condIndex = 0;
static uint8_t repIndex = 0;

static uint16_t stepIdx = 0;               // 100ms grid index
static uint16_t currentIntervalMs = 500;   // 100 or 500
static float uEma = 0.0f;
static float cEma = 0.0f;

static inline uint16_t ms_to_0p625(float ms) {
  long v = lroundf(ms / 0.625f);
  if (v &lt; 0x20) v = 0x20;     // 20ms minimum
  if (v &gt; 0x4000) v = 0x4000; // 10.24s maximum
  return (uint16_t)v;
}

static uint16_t clamp_interval(uint16_t interval_ms) {
  uint16_t best = ACTIONS[0];
  uint32_t bestDist = (uint32_t)abs((int)interval_ms - (int)best);
  for (uint8_t i = 1; i &lt; N_ACTIONS; i++) {
    uint16_t a = ACTIONS[i];
    uint32_t d = (uint32_t)abs((int)interval_ms - (int)a);
    if (d &lt; bestDist || (d == bestDist &amp;&amp; a &lt; best)) {
      best = a;
      bestDist = d;
    }
  }
  return best;
}

static void syncStart() {
  if (USE_LED) digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
}

static void syncEnd() {
  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_LED) digitalWrite(LED_PIN, LOW);
}

static void tickPulseOnce(uint16_t high_us = 200) {
  digitalWrite(TICK_OUT_PIN, HIGH);
  delayMicroseconds(high_us);
  digitalWrite(TICK_OUT_PIN, LOW);
}

static void tickPreamble(uint8_t nPulses) {
  if (!ENABLE_TICK_PREAMBLE) return;
  for (uint8_t i = 0; i &lt; nPulses; i++) {
    tickPulseOnce(200);
    delay(20);
  }
}

static void setAdvIntervalMs(uint16_t ms) {
  if (!adv) return;
  uint16_t units = ms_to_0p625((float)ms);
  adv-&gt;setMinInterval(units);
  adv-&gt;setMaxInterval(units);
}

static void setPayload(uint16_t step_idx, const char* tag) {
  if (!adv) return;
  BLEAdvertisementData ad;
  // ManufacturerData only（size節約のため name は入れない）
  String mfd = String((unsigned)step_idx) + &quot;_&quot; + String(tag);
  ad.setManufacturerData(mfd);
  adv-&gt;setAdvertisementData(ad);
}

static void setSleepAllowed(bool allowLightSleep) {
#ifdef ARDUINO_ARCH_ESP32
  if (!noLightSleepLock) return;
  if (allowLightSleep) {
    if (sleepBlocked) {
      esp_pm_lock_release(noLightSleepLock);
      sleepBlocked = false;
    }
  } else {
    if (!sleepBlocked) {
      esp_pm_lock_acquire(noLightSleepLock);
      sleepBlocked = true;
    }
  }
#else
  (void)allowLightSleep;
#endif
}

static inline uint8_t getLabel(Session s, uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0;
  if (s == SESSION_S1) return pgm_read_byte(&amp;S1_LABEL[idx]);
  return pgm_read_byte(&amp;S4_LABEL[idx]);
}

static inline float getU(Session s, uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = (s == SESSION_S1) ? pgm_read_byte(&amp;S1_U_Q[idx]) : pgm_read_byte(&amp;S4_U_Q[idx]);
  return q_to_f(q);
}

static inline float getCCS(Session s, uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = (s == SESSION_S1) ? pgm_read_byte(&amp;S1_CCS_Q[idx]) : pgm_read_byte(&amp;S4_CCS_Q[idx]);
  return q_to_f(q);
}

static uint16_t policyStep(uint16_t prevInterval, float u, float c) {
  // 2値（100/500）: HIGHで100へ、両方MIDより十分低いと500へ戻す（ヒステリシス）
  const float u_hi_up = U_HIGH;
  const float c_hi_up = C_HIGH;
  const float u_mid_down = U_MID - HYST;
  const float c_mid_down = C_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if ((u &gt;= u_hi_up) || (c &gt;= c_hi_up)) next = 100;
  } else { // prevInterval == 100
    if ((u &lt; u_mid_down) &amp;&amp; (c &lt; c_mid_down)) next = 500;
  }
  return clamp_interval(next);
}

static void applyInterval(uint16_t nextMs) {
  if (nextMs == currentIntervalMs) return;
  currentIntervalMs = nextMs;
  if (!adv) return;
  if (RESTART_ADV_ON_INTERVAL_CHANGE) {
    adv-&gt;stop();
    setAdvIntervalMs(currentIntervalMs);
    adv-&gt;start();
  } else {
    setAdvIntervalMs(currentIntervalMs);
  }
}

static void makeTag(char* out, size_t out_sz, const Condition&amp; c, uint8_t truthLabel, uint16_t intervalMs) {
  // &quot;F1-09-100&quot; / &quot;P4-11-500&quot; etc.
  const char mp = (c.mode == MODE_FIXED) ? &apos;F&apos; : &apos;P&apos;;
  const unsigned sess = (unsigned)c.session; // 1 or 4
  const unsigned lbl = (unsigned)truthLabel;
  const unsigned itv = (unsigned)intervalMs;
  snprintf(out, out_sz, &quot;%c%u-%02u-%u&quot;, mp, sess, lbl, itv);
}

static void beginCondition(const Condition&amp; c) {
  // per-trial init (adv is still stopped until preamble window passes)
  stepIdx = 0;
  uEma = 0.0f;
  cEma = 0.0f;
  currentIntervalMs = (c.mode == MODE_FIXED) ? c.fixed_ms : 500;
  currentIntervalMs = clamp_interval(currentIntervalMs);

  if (adv) adv-&gt;stop();
  setAdvIntervalMs(currentIntervalMs);

  setSleepAllowed(true);

  syncStart();
  syncRiseMs = millis();
  delay(PREAMBLE_GUARD_MS);
  tickPreamble(c.cond_id);
  pendingStart = true;
}

static void startTrialNow(const Condition&amp; c) {
  trialStartMs = millis();
  trialRunning = true;

  // initial payload at step=0
  const uint8_t lbl = getLabel(c.session, 0);
  char tag[16];
  makeTag(tag, sizeof(tag), c, lbl, currentIntervalMs);
  setPayload(0, tag);

  if (adv) adv-&gt;start();
  if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

  // advance to next step index (= time axis). Next update happens after currentIntervalMs.
  const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
  stepIdx = (uint16_t)(stepIdx + deltaSteps);
  nextUpdateMs = millis() + currentIntervalMs;
}

static void endTrial() {
  trialRunning = false;
  pendingStart = false;
  if (adv) adv-&gt;stop();
  syncEnd();
  gapStartMs = millis();
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);
  digitalWrite(SYNC_OUT_PIN, LOW);
  pinMode(TICK_OUT_PIN, OUTPUT);
  digitalWrite(TICK_OUT_PIN, LOW);

  BLEDevice::init(&quot;TX_UCCS_D2B_SCAN90&quot;);
  BLEDevice::setPower(ESP_PWR_LVL_N0);
  adv = BLEDevice::getAdvertising();
  adv-&gt;setScanResponse(false);
  adv-&gt;setMinPreferred(0);

#ifdef ARDUINO_ARCH_ESP32
  (void)esp_pm_lock_create(ESP_PM_NO_LIGHT_SLEEP, 0, &quot;uccs_d2&quot;, &amp;noLightSleepLock);
#endif

  condIndex = 0;
  repIndex = 0;
  gapStartMs = 0;
  trialRunning = false;
  pendingStart = false;

  beginCondition(CONDS[condIndex]);
}

void loop() {
  const uint32_t nowMs = millis();
  const Condition&amp; c = CONDS[condIndex];

  if (pendingStart) {
    if ((nowMs - syncRiseMs) &gt;= PREAMBLE_WINDOW_MS) {
      pendingStart = false;
      startTrialNow(c);
    } else {
      vTaskDelay(1);
      return;
    }
  }

  if (trialRunning) {
    // stop condition (time axis by stepIdx)
    if (stepIdx &gt;= EFFECTIVE_LEN_STEPS) {
      endTrial();
      vTaskDelay(pdMS_TO_TICKS(50));
      return;
    }

    if ((int32_t)(nowMs - nextUpdateMs) &gt;= 0) {
      // update at advertising cadence
      const uint8_t truthLabel = getLabel(c.session, stepIdx);

      if (c.mode == MODE_POLICY) {
        const float uRaw = getU(c.session, stepIdx);
        // `stress_causal_*` の CCS は安定度（高いほどstable）なので、changeとして扱うため反転する。
        const float cRawStable = getCCS(c.session, stepIdx);
        const float cRaw = 1.0f - cRawStable;
        uEma = EMA_ALPHA * uRaw + (1.0f - EMA_ALPHA) * uEma;
        cEma = EMA_ALPHA * cRaw + (1.0f - EMA_ALPHA) * cEma;

        const uint16_t nextI = policyStep(currentIntervalMs, uEma, cEma);
        applyInterval(nextI);
      }

      char tag[16];
      makeTag(tag, sizeof(tag), c, truthLabel, currentIntervalMs);
      setPayload(stepIdx, tag);
      if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

      // advance time
      const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
      stepIdx = (uint16_t)(stepIdx + deltaSteps);
      nextUpdateMs = millis() + currentIntervalMs;
    }
    vTaskDelay(1);
    return;
  }

  // gap
  if (gapStartMs == 0) gapStartMs = nowMs;
  if ((nowMs - gapStartMs) &lt; GAP_MS) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return;
  }

  // next condition
  gapStartMs = 0;
  condIndex++;
  if (condIndex &gt;= N_CONDS) {
    condIndex = 0;
    repIndex++;
  }
  if (repIndex &gt;= REPEAT) {
    // done
    setSleepAllowed(true);
    if (adv) adv-&gt;stop();
    syncEnd();
    vTaskDelay(pdMS_TO_TICKS(1000));
    return;
  }

  beginCondition(CONDS[condIndex]);
  vTaskDelay(pdMS_TO_TICKS(200));
}</file><file path="uccs_d2_scan90/src/tx/stress_causal_s1_s4_180s.h">// Auto-generated subset from stress_causal_S1/S4.csv (Mode_C_2_シミュレート_causal/ccs).
// N_STEPS=1800 (=180s @ 100ms grid)
#pragma once
#include &lt;Arduino.h&gt;

static const uint16_t STRESS_CAUSAL_LEN = 1800;

static const uint8_t S1_LABEL[] PROGMEM = {
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
};
static const uint8_t S1_U_Q[] PROGMEM = {
  255, 255, 245, 250, 224, 217, 219, 226, 216, 209, 196, 216, 183, 177, 178, 177, 172, 147, 170, 162, 165, 127, 134, 155,
  105, 134, 114, 112, 101, 101, 100, 109, 81, 81, 85, 69, 87, 92, 68, 72, 45, 61, 44, 28, 31, 46, 34, 13,
  246, 255, 220, 247, 229, 211, 227, 207, 236, 208, 198, 176, 178, 190, 207, 181, 180, 183, 145, 139, 147, 148, 134, 122,
  133, 132, 128, 132, 101, 116, 90, 63, 110, 59, 81, 250, 255, 244, 238, 213, 212, 223, 222, 210, 217, 239, 205, 184,
  192, 157, 193, 176, 168, 172, 151, 140, 141, 137, 146, 128, 133, 101, 115, 131, 124, 87, 108, 84, 96, 77, 75, 64,
  89, 68, 53, 55, 64, 35, 44, 21, 20, 17, 1, 18, 0, 15, 24, 0, 0, 0, 0, 17, 244, 255, 248, 233,
  235, 243, 228, 231, 218, 205, 203, 193, 202, 213, 200, 192, 177, 154, 172, 156, 175, 155, 130, 136, 113, 125, 123, 118,
  133, 111, 125, 105, 85, 61, 88, 77, 77, 59, 56, 41, 61, 28, 34, 53, 39, 27, 42, 30, 5, 15, 0, 0,
  4, 0, 0, 4, 1, 0, 11, 0, 11, 0, 0, 18, 4, 0, 0, 16, 0, 0, 0, 21, 14, 0, 0, 18,
  0, 0, 11, 1, 0, 0, 12, 0, 0, 7, 11, 14, 0, 3, 0, 0, 0, 4, 22, 1, 11, 0, 10, 4,
  0, 0, 29, 2, 0, 12, 0, 16, 0, 0, 27, 0, 27, 17, 0, 1, 0, 0, 16, 0, 0, 13, 1, 0,
  0, 0, 20, 0, 0, 7, 0, 10, 0, 7, 3, 2, 0, 9, 0, 26, 0, 0, 2, 6, 24, 0, 3, 5,
  0, 0, 8, 0, 17, 6, 0, 0, 0, 0, 252, 252, 233, 246, 237, 240, 209, 220, 213, 209, 202, 197, 220, 193,
  185, 186, 155, 184, 157, 150, 154, 138, 142, 129, 125, 115, 120, 127, 121, 102, 96, 85, 94, 99, 80, 67, 63, 52,
  81, 68, 40, 41, 52, 17, 46, 29, 0, 14, 43, 0, 12, 0, 0, 3, 0, 0, 36, 0, 10, 0, 0, 0,
  0, 0, 0, 14, 0, 0, 0, 0, 0, 1, 0, 2, 21, 0, 0, 0, 17, 12, 19, 25, 0, 1, 0, 13,
  0, 8, 9, 0, 6, 0, 0, 5, 9, 0, 0, 3, 0, 0, 0, 0, 7, 9, 15, 0, 1, 0, 11, 9,
  23, 0, 1, 0, 0, 0, 0, 0, 0, 18, 2, 0, 32, 0, 7, 31, 0, 0, 0, 10, 0, 15, 12, 23,
  13, 0, 0, 16, 16, 0, 3, 0, 4, 0, 5, 0, 20, 5, 0, 0, 7, 0, 18, 3, 0, 245, 234, 224,
  255, 217, 255, 253, 230, 232, 230, 230, 197, 225, 204, 190, 190, 187, 209, 185, 167, 158, 142, 165, 151, 164, 171, 150,
  101, 110, 139, 120, 102, 77, 109, 84, 103, 79, 81, 65, 71, 67, 78, 46, 47, 54, 37, 35, 22, 23, 2, 45,
  0, 0, 19, 0, 0, 0, 0, 0, 17, 0, 6, 0, 5, 1, 5, 1, 0, 0, 0, 0, 0, 0, 1, 0,
  16, 6, 0, 0, 4, 0, 0, 0, 0, 7, 0, 0, 23, 0, 0, 0, 3, 22, 0, 0, 9, 20, 10, 0,
  16, 0, 6, 5, 14, 0, 0, 0, 16, 1, 9, 20, 6, 18, 4, 0, 0, 8, 0, 9, 4, 0, 4, 0,
  5, 0, 0, 7, 0, 6, 0, 0, 5, 0, 0, 4, 0, 12, 14, 4, 0, 1, 0, 3, 0, 2, 3, 0,
  20, 6, 0, 9, 4, 0, 1, 4, 0, 0, 0, 0, 2, 23, 12, 2, 0, 0, 0, 12, 0, 5, 3, 0,
  3, 24, 0, 0, 255, 249, 243, 218, 243, 206, 216, 218, 195, 246, 199, 214, 185, 201, 201, 186, 171, 158, 166, 160,
  152, 146, 157, 154, 138, 123, 114, 131, 115, 116, 94, 72, 94, 84, 87, 87, 63, 64, 57, 54, 50, 40, 45, 29,
  41, 34, 24, 11, 11, 0, 27, 0, 2, 0, 9, 8, 30, 24, 13, 7, 0, 249, 243, 254, 255, 229, 253, 216,
  207, 217, 221, 199, 204, 245, 237, 235, 235, 244, 219, 216, 232, 246, 206, 189, 206, 208, 166, 161, 184, 139, 152, 168,
  255, 254, 209, 241, 214, 213, 225, 199, 205, 199, 210, 190, 255, 255, 254, 221, 236, 243, 225, 228, 208, 214, 202, 202,
  159, 203, 190, 174, 183, 163, 169, 148, 173, 140, 138, 165, 114, 139, 119, 105, 115, 116, 107, 80, 80, 255, 241, 237,
  227, 211, 241, 220, 201, 185, 212, 203, 196, 196, 183, 164, 169, 182, 178, 167, 141, 151, 153, 128, 139, 119, 151, 115,
  140, 115, 107, 112, 89, 90, 96, 96, 66, 63, 69, 61, 55, 49, 56, 54, 17, 19, 10, 28, 26, 16, 13, 0,
  0, 0, 0, 12, 15, 15, 6, 0, 10, 24, 0, 18, 18, 0, 22, 0, 0, 0, 2, 0, 23, 9, 0, 15,
  13, 0, 0, 4, 13, 19, 21, 0, 0, 6, 7, 0, 0, 0, 14, 13, 0, 6, 0, 10, 0, 0, 21, 0,
  9, 12, 0, 0, 0, 0, 0, 0, 0, 14, 22, 23, 0, 8, 0, 15, 0, 19, 0, 5, 19, 13, 0, 7,
  9, 0, 5, 0, 15, 23, 6, 0, 0, 0, 0, 32, 3, 12, 255, 223, 255, 241, 231, 219, 209, 224, 213, 208,
  215, 180, 203, 185, 138, 186, 161, 173, 170, 147, 148, 149, 143, 124, 130, 123, 128, 119, 113, 92, 120, 87, 89, 79,
  82, 70, 69, 57, 49, 56, 34, 77, 49, 46, 34, 35, 7, 25, 9, 9, 1, 0, 4, 15, 0, 3, 0, 0,
  0, 5, 19, 15, 0, 11, 0, 3, 2, 10, 4, 0, 6, 0, 0, 0, 13, 29, 10, 0, 2, 0, 14, 9,
  0, 12, 0, 17, 2, 0, 0, 23, 0, 0, 0, 0, 10, 8, 0, 1, 1, 7, 8, 9, 0, 6, 0, 0,
  0, 0, 12, 0, 1, 0, 20, 0, 0, 0, 0, 0, 228, 246, 252, 241, 223, 231, 241, 224, 218, 188, 212, 192,
  193, 188, 171, 191, 161, 170, 160, 148, 127, 154, 141, 134, 144, 124, 125, 106, 96, 96, 91, 110, 91, 93, 77, 50,
  89, 69, 71, 51, 72, 58, 52, 28, 26, 25, 31, 30, 0, 10, 24, 17, 0, 0, 14, 5, 20, 0, 0, 7,
  0, 0, 0, 17, 0, 0, 11, 4, 0, 0, 2, 5, 11, 4, 0, 5, 9, 18, 4, 0, 0, 15, 11, 8,
  9, 9, 7, 0, 4, 15, 4, 0, 0, 0, 11, 25, 5, 0, 22, 0, 238, 247, 232, 255, 229, 228, 242, 225,
  205, 210, 209, 195, 213, 190, 192, 189, 170, 185, 157, 158, 155, 141, 126, 123, 161, 146, 118, 140, 119, 105, 114, 83,
  70, 64, 87, 77, 83, 69, 70, 72, 35, 60, 59, 42, 48, 28, 13, 26, 8, 7, 10, 0, 13, 0, 19, 0,
  11, 0, 2, 0, 3, 8, 0, 0, 2, 3, 255, 239, 255, 234, 223, 229, 224, 193, 216, 213, 218, 191, 185, 207,
  168, 179, 172, 143, 169, 178, 123, 153, 123, 128, 111, 126, 133, 101, 117, 84, 94, 115, 84, 87, 70, 77, 74, 99,
  46, 65, 54, 52, 58, 34, 48, 29, 21, 2, 22, 15, 0, 0, 0, 4, 0, 13, 0, 16, 0, 6, 0, 0,
  2, 3, 0, 0, 0, 3, 16, 2, 11, 7, 10, 11, 13, 23, 224, 255, 255, 254, 255, 226, 229, 248, 226, 205,
  205, 216, 215, 197, 206, 166, 192, 167, 151, 150, 157, 191, 147, 122, 161, 126, 122, 116, 118, 99, 86, 117, 75, 106,
  99, 69, 77, 75, 42, 51, 66, 64, 41, 28, 14, 23, 27, 24, 11, 5, 8, 2, 0, 3, 16, 10, 8, 22,
  0, 0, 0, 0, 2, 3, 0, 2, 11, 0, 2, 9, 1, 1, 0, 0, 0, 0, 0, 18, 12, 0, 0, 6,
  12, 0, 12, 0, 10, 0, 4, 0, 0, 3, 2, 0, 0, 0, 8, 0, 0, 0, 15, 37, 0, 0, 7, 0,
  0, 5, 10, 13, 0, 0, 1, 32, 7, 0, 2, 2, 9, 0, 0, 0, 0, 0, 31, 3, 6, 0, 0, 8,
  15, 0, 13, 0, 11, 2, 10, 6, 0, 14, 0, 0, 13, 0, 0, 6, 0, 17, 0, 0, 0, 0, 30, 0,
  14, 0, 0, 0, 0, 2, 6, 0, 8, 0, 0, 0, 1, 0, 16, 0, 10, 16, 0, 2, 0, 0, 0, 0,
  10, 6, 11, 0, 13, 18, 4, 0, 0, 5, 0, 12, 0, 0, 5, 5, 3, 21, 3, 8, 0, 0, 255, 233,
  230, 212, 235, 243, 231, 224, 218, 221, 197, 196, 189, 216, 182, 175, 175, 171, 167, 148, 148, 146, 125, 155, 149, 117,
  107, 142, 124, 112, 98, 95, 84, 67, 89, 55, 74, 67, 77, 64, 49, 43, 34, 19, 9, 36, 65, 0, 2, 23,
  19, 0, 10, 0, 18, 0, 2, 0, 11, 22, 0, 20, 20, 0, 3, 0, 0, 0, 1, 6, 0, 0, 24, 2,
  4, 0, 0, 9, 0, 0, 13, 8, 7, 0, 0, 25, 0, 0, 5, 6, 5, 11, 6, 5, 20, 0, 0, 0,
  0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 28, 14, 0, 0, 0, 6, 8, 5, 0, 0, 0, 0, 5, 0,
  0, 4, 7, 0, 0, 3, 0, 17, 4, 18, 7, 6, 0, 6, 9, 0, 5, 0, 255, 255, 255, 235, 231, 225,
  222, 218, 197, 208, 196, 197, 208, 201, 177, 170, 189, 180, 160, 163, 138, 154, 156, 148, 142, 155, 128, 101, 114, 105,
  107, 106, 98, 95, 104, 76, 64, 69, 58, 48, 41, 40, 51, 58, 53, 26, 37, 23, 17, 0, 10, 0, 0, 1,
  0, 0, 0, 0, 11, 0, 1, 0, 0, 7, 0, 0, 0, 0, 0, 11, 21, 13, 12, 0, 5, 28, 2, 22,
  33, 6, 2, 0, 0, 9, 2, 5, 15, 4, 30, 12, 11, 1, 6, 0, 0, 0, 0, 8, 9, 0, 0, 0,
  0, 0, 0, 17, 22, 4, 0, 0, 14, 0, 11, 14, 6, 8, 13, 7, 17, 0, 0, 9, 0, 20, 0, 0,
  0, 0, 0, 3, 0, 0, 17, 13, 0, 0, 16, 2, 0, 25, 26, 0, 0, 0, 3, 0, 4, 1, 17, 16,
  16, 22, 0, 0, 9, 0, 0, 21, 4, 0, 6, 13, 13, 0, 5, 4, 5, 0, 0, 20, 0, 0, 9, 0,
  32, 0, 12, 0, 11, 3, 0, 0, 0, 6, 0, 7, 0, 24, 6, 0, 6, 7, 29, 1, 9, 0, 0, 0,
};
static const uint8_t S1_CCS_Q[] PROGMEM = {
  0, 2, 10, 8, 28, 34, 34, 31, 40, 46, 57, 44, 69, 75, 75, 78, 83, 102, 87, 94, 93, 122, 119, 105,
  142, 123, 138, 141, 151, 152, 154, 150, 171, 173, 171, 184, 173, 171, 189, 187, 209, 199, 212, 224, 224, 215, 225, 241,
  6, 2, 28, 10, 24, 38, 29, 44, 26, 47, 55, 72, 73, 65, 55, 75, 77, 77, 105, 111, 106, 107, 119, 128,
  122, 124, 129, 127, 151, 142, 162, 182, 151, 188, 174, 4, 2, 11, 16, 35, 38, 31, 34, 44, 41, 26, 52, 68,
  64, 90, 67, 80, 87, 86, 102, 111, 112, 116, 112, 125, 124, 148, 139, 129, 136, 164, 150, 169, 162, 177, 180, 189,
  173, 189, 201, 201, 196, 219, 213, 231, 233, 237, 249, 239, 253, 245, 239, 255, 255, 255, 255, 243, 7, 2, 8, 20,
  20, 16, 28, 27, 38, 48, 52, 61, 56, 49, 60, 67, 79, 97, 86, 98, 87, 102, 121, 119, 136, 129, 132, 137,
  128, 146, 137, 153, 168, 186, 169, 178, 180, 194, 198, 209, 197, 222, 219, 207, 218, 229, 219, 229, 248, 243, 255, 255,
  252, 255, 255, 252, 254, 255, 247, 255, 247, 255, 255, 242, 252, 255, 255, 244, 255, 255, 255, 240, 245, 255, 255, 242,
  255, 255, 247, 255, 255, 255, 247, 255, 255, 250, 247, 245, 255, 253, 255, 255, 255, 252, 240, 254, 247, 255, 248, 252,
  255, 255, 234, 253, 255, 247, 255, 244, 255, 255, 236, 255, 236, 243, 255, 254, 255, 255, 244, 255, 255, 246, 254, 255,
  255, 255, 241, 255, 255, 250, 255, 248, 255, 250, 253, 254, 255, 249, 255, 237, 255, 255, 254, 251, 238, 255, 253, 251,
  255, 255, 250, 255, 243, 251, 255, 255, 255, 255, 2, 4, 19, 11, 19, 18, 41, 35, 42, 46, 53, 58, 43, 63,
  70, 72, 94, 76, 96, 103, 101, 114, 113, 123, 127, 137, 134, 131, 137, 152, 157, 166, 162, 160, 175, 185, 190, 198,
  180, 191, 212, 213, 207, 232, 213, 227, 249, 241, 222, 253, 247, 255, 255, 253, 255, 255, 230, 255, 248, 255, 255, 255,
  255, 255, 255, 245, 255, 255, 255, 255, 255, 254, 255, 254, 240, 255, 255, 255, 243, 247, 242, 237, 255, 254, 255, 246,
  255, 249, 249, 255, 251, 255, 255, 252, 249, 255, 255, 253, 255, 255, 255, 255, 250, 249, 245, 255, 254, 255, 248, 249,
  239, 255, 254, 255, 255, 255, 255, 255, 255, 243, 253, 255, 232, 255, 250, 233, 255, 255, 255, 248, 255, 245, 246, 239,
  246, 255, 255, 243, 244, 255, 253, 255, 252, 255, 251, 255, 241, 252, 255, 255, 250, 255, 243, 253, 255, 7, 17, 22,
  2, 29, 5, 8, 25, 25, 29, 30, 55, 36, 53, 64, 65, 69, 55, 74, 87, 95, 108, 93, 105, 97, 94, 110,
  146, 142, 122, 138, 151, 170, 150, 168, 157, 175, 175, 188, 185, 190, 184, 207, 208, 205, 219, 221, 232, 232, 249, 221,
  253, 255, 242, 255, 255, 255, 255, 255, 243, 255, 251, 255, 252, 254, 251, 254, 255, 255, 255, 255, 255, 255, 254, 255,
  244, 251, 255, 255, 253, 255, 255, 255, 255, 250, 255, 255, 239, 255, 255, 255, 253, 239, 255, 255, 249, 241, 248, 255,
  244, 255, 251, 252, 245, 255, 255, 255, 244, 254, 249, 241, 251, 243, 253, 255, 255, 249, 255, 249, 252, 255, 252, 255,
  252, 255, 255, 250, 255, 251, 255, 255, 252, 255, 255, 252, 255, 247, 245, 252, 255, 254, 255, 253, 255, 254, 253, 255,
  241, 251, 255, 249, 252, 255, 254, 252, 255, 255, 255, 255, 254, 239, 247, 254, 255, 255, 255, 247, 255, 251, 253, 255,
  253, 238, 255, 255, 0, 6, 12, 30, 14, 42, 37, 36, 54, 20, 55, 46, 67, 57, 59, 71, 83, 94, 90, 95,
  103, 109, 102, 106, 119, 130, 138, 128, 141, 142, 158, 176, 162, 170, 169, 171, 190, 191, 197, 200, 205, 213, 212, 224,
  217, 224, 232, 243, 244, 253, 236, 255, 253, 255, 249, 249, 234, 238, 246, 250, 255, 4, 10, 4, 5, 24, 9, 36,
  44, 39, 37, 54, 53, 7, 14, 17, 19, 14, 33, 37, 27, 19, 48, 62, 51, 51, 82, 87, 73, 105, 98, 89,
  0, 2, 35, 14, 35, 37, 30, 50, 48, 53, 47, 62, 0, 2, 4, 28, 20, 16, 30, 29, 45, 42, 53, 54,
  85, 56, 67, 79, 75, 91, 88, 104, 88, 112, 115, 98, 135, 120, 135, 146, 141, 141, 149, 170, 172, 0, 11, 16,
  25, 37, 17, 33, 48, 61, 44, 52, 58, 59, 70, 85, 83, 76, 80, 89, 109, 103, 103, 122, 117, 132, 111, 138,
  122, 141, 148, 146, 164, 164, 162, 163, 186, 189, 187, 194, 200, 206, 202, 205, 232, 232, 241, 229, 232, 241, 245, 255,
  255, 255, 255, 247, 245, 244, 251, 255, 248, 238, 255, 242, 242, 255, 240, 255, 255, 255, 254, 255, 239, 249, 255, 245,
  246, 255, 255, 252, 246, 242, 240, 255, 255, 251, 250, 255, 255, 255, 245, 246, 255, 251, 255, 248, 255, 255, 240, 255,
  248, 247, 255, 255, 255, 255, 255, 255, 255, 245, 239, 239, 255, 249, 255, 245, 255, 242, 255, 251, 242, 246, 255, 250,
  249, 255, 251, 255, 245, 239, 251, 255, 255, 255, 255, 233, 253, 246, 0, 24, 3, 14, 23, 33, 41, 32, 41, 47,
  43, 70, 55, 69, 103, 72, 91, 83, 87, 104, 105, 107, 112, 127, 124, 130, 129, 137, 142, 158, 140, 165, 165, 173,
  173, 183, 185, 195, 203, 199, 216, 187, 209, 212, 222, 223, 244, 233, 246, 247, 254, 255, 252, 244, 255, 253, 255, 255,
  255, 252, 242, 245, 255, 248, 255, 253, 254, 248, 252, 255, 251, 255, 255, 255, 246, 235, 248, 255, 254, 255, 245, 249,
  255, 246, 255, 243, 254, 255, 255, 239, 255, 255, 255, 255, 248, 249, 255, 255, 254, 250, 249, 249, 255, 251, 255, 255,
  255, 255, 246, 255, 255, 255, 241, 255, 255, 255, 255, 255, 19, 8, 5, 14, 29, 24, 19, 33, 38, 60, 45, 61,
  62, 67, 80, 67, 90, 85, 94, 104, 120, 103, 114, 120, 114, 130, 131, 146, 154, 156, 161, 149, 164, 164, 177, 197,
  171, 187, 187, 203, 190, 201, 206, 225, 227, 230, 227, 229, 252, 247, 238, 243, 255, 255, 245, 252, 241, 255, 255, 250,
  255, 255, 255, 243, 255, 255, 247, 252, 255, 255, 253, 252, 247, 252, 255, 251, 249, 242, 252, 255, 255, 245, 248, 250,
  249, 248, 250, 255, 252, 245, 252, 255, 255, 255, 247, 238, 251, 255, 240, 255, 12, 7, 19, 5, 24, 26, 18, 32,
  47, 45, 48, 59, 48, 65, 65, 69, 84, 75, 96, 97, 101, 112, 124, 127, 103, 115, 136, 122, 138, 149, 145, 168,
  179, 184, 170, 178, 175, 187, 188, 188, 215, 199, 201, 215, 213, 228, 239, 232, 246, 248, 248, 255, 246, 255, 241, 255,
  247, 255, 254, 255, 253, 249, 255, 255, 253, 253, 0, 13, 3, 19, 29, 26, 31, 54, 40, 43, 41, 62, 67, 54,
  83, 76, 82, 104, 88, 83, 123, 103, 126, 124, 138, 129, 125, 149, 139, 164, 158, 146, 168, 168, 182, 178, 182, 166,
  205, 193, 202, 205, 202, 221, 212, 227, 234, 249, 237, 243, 255, 255, 255, 252, 255, 246, 255, 244, 255, 251, 255, 255,
  253, 253, 255, 255, 255, 253, 244, 254, 247, 250, 248, 247, 246, 239, 21, 0, 2, 4, 5, 26, 26, 14, 31, 47,
  49, 42, 45, 59, 54, 84, 67, 86, 99, 101, 97, 75, 108, 127, 101, 127, 132, 137, 137, 152, 163, 142, 173, 154,
  160, 182, 178, 181, 206, 201, 192, 195, 212, 223, 234, 229, 228, 232, 243, 249, 248, 253, 255, 253, 244, 248, 250, 239,
  255, 255, 255, 255, 254, 253, 255, 254, 247, 255, 254, 248, 254, 254, 255, 255, 255, 255, 255, 242, 247, 255, 255, 251,
  246, 255, 247, 255, 248, 255, 252, 255, 255, 253, 254, 255, 255, 255, 250, 255, 255, 255, 244, 229, 255, 255, 250, 255,
  255, 251, 248, 246, 255, 255, 254, 232, 250, 255, 253, 254, 248, 255, 255, 255, 255, 255, 233, 253, 251, 255, 255, 249,
  244, 255, 246, 255, 247, 253, 248, 251, 255, 245, 255, 255, 246, 255, 255, 251, 255, 243, 255, 255, 255, 255, 234, 255,
  245, 255, 255, 255, 255, 254, 251, 255, 249, 255, 255, 255, 254, 255, 244, 255, 248, 244, 255, 254, 255, 255, 255, 255,
  248, 250, 247, 255, 246, 242, 252, 255, 255, 252, 255, 247, 255, 255, 252, 252, 253, 240, 253, 250, 255, 255, 0, 17,
  20, 35, 20, 16, 26, 32, 38, 37, 56, 58, 65, 47, 72, 79, 80, 85, 89, 104, 106, 108, 125, 105, 111, 135,
  143, 121, 135, 144, 156, 160, 169, 182, 168, 194, 182, 188, 183, 194, 205, 211, 219, 231, 239, 222, 203, 250, 251, 237,
  241, 255, 248, 255, 242, 255, 254, 255, 248, 240, 255, 241, 241, 255, 253, 255, 255, 255, 255, 251, 255, 255, 238, 254,
  252, 255, 255, 248, 255, 255, 246, 249, 250, 255, 255, 237, 255, 255, 251, 251, 251, 248, 251, 252, 241, 255, 255, 255,
  255, 255, 255, 255, 255, 250, 255, 255, 255, 255, 236, 246, 255, 255, 255, 251, 249, 252, 255, 255, 255, 255, 252, 255,
  255, 252, 250, 255, 255, 253, 255, 243, 252, 243, 250, 251, 255, 251, 249, 255, 252, 255, 0, 2, 3, 18, 23, 29,
  32, 36, 53, 47, 56, 58, 51, 58, 76, 83, 71, 79, 94, 93, 112, 103, 103, 110, 116, 108, 129, 149, 141, 149,
  149, 152, 159, 162, 158, 179, 189, 187, 196, 205, 211, 213, 207, 203, 209, 229, 223, 234, 240, 253, 248, 255, 255, 254,
  255, 255, 255, 255, 247, 255, 254, 255, 255, 250, 255, 255, 255, 255, 255, 247, 240, 246, 247, 255, 251, 236, 254, 240,
  232, 251, 254, 255, 255, 249, 253, 251, 245, 252, 234, 246, 247, 254, 251, 255, 255, 255, 255, 249, 248, 255, 255, 255,
  255, 255, 255, 243, 240, 252, 255, 255, 245, 255, 247, 245, 251, 249, 246, 250, 243, 255, 255, 249, 255, 241, 255, 255,
  255, 255, 255, 253, 255, 255, 243, 246, 255, 255, 244, 253, 255, 238, 237, 255, 255, 255, 253, 255, 252, 255, 243, 244,
  244, 239, 255, 255, 249, 255, 255, 240, 253, 255, 251, 246, 246, 255, 252, 252, 252, 255, 255, 241, 255, 255, 249, 255,
  232, 255, 247, 255, 247, 253, 255, 255, 255, 251, 255, 250, 255, 238, 251, 255, 251, 250, 235, 255, 249, 255, 255, 255,
};

static const uint8_t S4_LABEL[] PROGMEM = {
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 7, 7, 7, 7, 7,
  7, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
};
static const uint8_t S4_U_Q[] PROGMEM = {
  255, 238, 239, 227, 232, 228, 232, 202, 200, 227, 221, 213, 211, 255, 232, 225, 250, 232, 231, 246, 222, 194, 197, 189,
  173, 195, 192, 149, 178, 196, 168, 172, 153, 146, 157, 155, 147, 118, 115, 160, 119, 97, 100, 98, 99, 104, 89, 68,
  102, 87, 72, 55, 27, 62, 65, 20, 36, 19, 10, 13, 10, 31, 8, 11, 14, 1, 0, 0, 2, 3, 25, 0,
  0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 255, 255, 242, 254, 255, 235, 242, 224,
  233, 255, 253, 243, 237, 221, 209, 251, 220, 227, 205, 198, 208, 187, 169, 182, 179, 169, 179, 153, 182, 150, 176, 149,
  243, 255, 242, 232, 218, 247, 218, 209, 215, 227, 221, 189, 235, 180, 196, 185, 178, 164, 162, 152, 144, 119, 153, 127,
  142, 114, 117, 127, 114, 115, 105, 87, 93, 90, 80, 91, 81, 58, 38, 67, 42, 42, 58, 12, 52, 41, 26, 10,
  7, 6, 0, 3, 7, 0, 0, 6, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 5,
  16, 9, 16, 0, 0, 0, 22, 22, 0, 0, 11, 10, 14, 14, 0, 0, 0, 0, 2, 6, 0, 0, 0, 0,
  27, 0, 0, 0, 11, 5, 0, 18, 0, 0, 20, 32, 9, 4, 0, 29, 2, 0, 2, 9, 2, 13, 0, 0,
  3, 30, 3, 3, 5, 255, 255, 217, 242, 222, 221, 222, 230, 237, 215, 210, 197, 207, 178, 164, 165, 166, 169, 154,
  161, 154, 170, 143, 154, 138, 122, 125, 76, 118, 119, 94, 73, 85, 99, 58, 70, 89, 47, 37, 35, 54, 50, 40,
  21, 48, 42, 30, 12, 0, 0, 0, 0, 4, 20, 4, 0, 1, 3, 15, 11, 25, 0, 0, 0, 0, 0, 0,
  0, 0, 14, 0, 14, 0, 0, 0, 0, 0, 0, 16, 0, 0, 9, 0, 0, 7, 0, 7, 10, 10, 0, 0,
  18, 2, 255, 251, 236, 243, 235, 230, 229, 227, 200, 185, 211, 209, 203, 188, 189, 177, 167, 173, 172, 164, 162, 152,
  125, 125, 255, 255, 242, 214, 232, 219, 223, 240, 212, 205, 193, 173, 173, 198, 255, 250, 255, 255, 242, 221, 238, 209,
  219, 201, 210, 201, 199, 191, 197, 201, 163, 160, 167, 140, 131, 155, 156, 137, 129, 110, 135, 115, 116, 111, 104, 99,
  87, 94, 98, 80, 84, 78, 60, 80, 46, 48, 29, 33, 34, 13, 27, 12, 22, 0, 9, 6, 0, 239, 255, 255,
  246, 236, 241, 208, 214, 215, 227, 201, 217, 199, 201, 187, 190, 177, 163, 166, 144, 164, 127, 153, 113, 133, 128, 128,
  100, 90, 97, 104, 123, 90, 85, 90, 80, 59, 51, 86, 56, 60, 27, 44, 35, 30, 22, 15, 13, 2, 4, 9,
  0, 11, 16, 25, 22, 0, 0, 21, 0, 0, 0, 0, 1, 0, 0, 29, 0, 0, 9, 16, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 4, 0, 0, 22, 0, 15, 0, 0, 0, 0, 0, 9, 35, 2, 0, 19, 0, 2, 0,
  0, 0, 0, 0, 21, 15, 6, 0, 0, 12, 0, 0, 0, 0, 0, 0, 16, 6, 12, 3, 0, 8, 1, 0,
  8, 11, 0, 3, 0, 3, 4, 0, 0, 5, 4, 7, 0, 0, 0, 0, 0, 7, 2, 0, 12, 16, 0, 0,
  10, 26, 6, 5, 12, 4, 0, 0, 0, 21, 41, 8, 9, 0, 2, 13, 8, 0, 22, 0, 8, 0, 9, 0,
  0, 7, 0, 3, 0, 255, 237, 244, 246, 239, 217, 206, 211, 231, 238, 255, 252, 237, 247, 221, 216, 248, 230, 222,
  192, 198, 210, 174, 192, 205, 189, 175, 190, 150, 175, 159, 130, 152, 136, 145, 140, 133, 255, 255, 240, 254, 247, 237,
  217, 213, 203, 227, 215, 210, 208, 201, 180, 181, 163, 154, 153, 149, 149, 122, 158, 134, 136, 134, 125, 117, 102, 97,
  109, 80, 89, 85, 70, 62, 52, 76, 255, 255, 254, 233, 245, 244, 207, 228, 186, 188, 237, 193, 196, 191, 180, 179,
  169, 180, 158, 173, 164, 171, 163, 120, 123, 133, 109, 127, 128, 111, 95, 111, 92, 79, 255, 233, 255, 240, 241, 225,
  217, 210, 252, 213, 253, 251, 248, 232, 245, 228, 221, 243, 233, 192, 198, 212, 170, 187, 167, 180, 166, 150, 163, 150,
  153, 130, 159, 134, 99, 144, 134, 108, 104, 120, 110, 119, 85, 105, 71, 69, 69, 55, 86, 82, 51, 30, 51, 41,
  11, 45, 19, 32, 3, 14, 0, 255, 255, 255, 238, 223, 252, 250, 218, 216, 193, 206, 185, 201, 192, 176, 163, 177,
  163, 174, 143, 143, 255, 254, 233, 250, 237, 250, 234, 244, 193, 220, 214, 200, 200, 195, 166, 169, 177, 158, 165, 157,
  146, 165, 152, 147, 127, 106, 123, 111, 106, 126, 105, 110, 77, 78, 58, 64, 78, 75, 79, 49, 66, 53, 50, 38,
  40, 30, 0, 26, 19, 12, 9, 24, 0, 0, 0, 0, 25, 0, 11, 12, 0, 0, 247, 255, 255, 227, 246, 230,
  209, 234, 223, 200, 199, 203, 188, 201, 200, 160, 178, 173, 169, 159, 146, 140, 141, 142, 131, 158, 116, 124, 88, 121,
  95, 110, 89, 68, 86, 83, 73, 81, 61, 55, 54, 25, 51, 29, 10, 32, 19, 13, 0, 0, 15, 0, 16, 0,
  13, 20, 4, 2, 0, 0, 0, 19, 0, 0, 0, 0, 2, 0, 8, 0, 0, 8, 9, 27, 0, 0, 9, 7,
  0, 3, 12, 19, 11, 7, 9, 9, 0, 2, 7, 4, 1, 0, 0, 9, 0, 0, 0, 15, 5, 0, 8, 15,
  4, 5, 8, 255, 255, 242, 255, 242, 240, 218, 204, 240, 204, 207, 206, 206, 181, 184, 195, 180, 189, 168, 166, 145,
  131, 133, 147, 137, 123, 121, 136, 118, 103, 105, 89, 82, 83, 69, 79, 52, 70, 51, 71, 67, 38, 26, 33, 41,
  47, 8, 33, 9, 0, 0, 0, 0, 12, 3, 6, 0, 27, 10, 17, 0, 0, 0, 8, 0, 6, 0, 0, 0,
  3, 0, 0, 255, 240, 228, 242, 233, 230, 231, 216, 203, 194, 201, 196, 183, 195, 179, 188, 170, 198, 158, 159, 250,
  255, 255, 244, 211, 236, 225, 250, 209, 199, 203, 202, 198, 177, 165, 159, 171, 183, 174, 144, 156, 116, 136, 149, 116,
  144, 113, 104, 120, 93, 89, 104, 251, 235, 230, 226, 233, 228, 223, 224, 230, 223, 191, 162, 193, 166, 189, 159, 176,
  164, 178, 141, 153, 155, 124, 134, 128, 134, 96, 108, 121, 104, 103, 102, 84, 93, 79, 78, 70, 50, 67, 72, 69,
  251, 250, 252, 255, 241, 236, 234, 247, 233, 225, 217, 203, 186, 208, 186, 206, 180, 181, 168, 159, 172, 164, 147, 150,
  121, 143, 157, 113, 116, 130, 111, 109, 77, 98, 92, 104, 77, 67, 75, 62, 47, 64, 51, 38, 34, 32, 43, 3,
  28, 18, 7, 6, 10, 27, 0, 0, 15, 0, 10, 10, 16, 20, 0, 0, 8, 0, 0, 0, 11, 14, 0, 9,
  2, 14, 0, 0, 9, 0, 5, 0, 4, 0, 0, 9, 9, 5, 0, 5, 0, 0, 2, 9, 18, 1, 0, 0,
  243, 255, 235, 236, 222, 244, 227, 225, 197, 182, 202, 208, 194, 190, 191, 203, 178, 168, 162, 151, 158, 152, 129, 144,
  162, 135, 141, 122, 100, 99, 114, 114, 89, 91, 93, 97, 44, 39, 93, 55, 36, 56, 60, 48, 30, 22, 4, 0,
  3, 11, 0, 6, 0, 3, 0, 0, 12, 0, 235, 255, 250, 255, 227, 210, 222, 216, 209, 199, 193, 176, 183, 193,
  207, 170, 203, 250, 255, 255, 252, 227, 231, 220, 214, 222, 203, 224, 199, 210, 197, 177, 179, 173, 155, 153, 167, 142,
  146, 134, 128, 147, 120, 116, 110, 122, 109, 105, 107, 83, 86, 63, 92, 83, 56, 94, 54, 49, 55, 55, 61, 37,
  16, 24, 29, 12, 28, 0, 0, 0, 12, 0, 10, 19, 28, 0, 2, 4, 0, 11, 10, 0, 14, 32, 0, 15,
  3, 0, 0, 0, 0, 0, 0, 14, 13, 0, 10, 0, 0, 0, 0, 0, 7, 0, 8, 17, 0, 9, 17, 0,
  14, 0, 0, 16, 0, 1, 6, 15, 0, 0, 0, 0, 245, 238, 235, 226, 221, 214, 250, 255, 242, 252, 234, 250,
  249, 250, 250, 255, 227, 223, 226, 216, 185, 190, 201, 185, 174, 162, 186, 167, 192, 152, 154, 152, 131, 133, 151, 102,
  116, 123, 93, 108, 125, 112, 98, 69, 87, 65, 60, 76, 88, 81, 44, 36, 21, 35, 255, 246, 235, 255, 217, 226,
  214, 235, 187, 216, 197, 194, 196, 213, 199, 189, 172, 176, 158, 165, 148, 135, 157, 117, 126, 145, 121, 103, 96, 89,
  106, 105, 113, 98, 87, 71, 78, 54, 90, 48, 78, 45, 23, 30, 44, 16, 5, 21, 7, 24, 0, 0, 10, 0,
  0, 0, 0, 0, 0, 0, 26, 1, 7, 2, 0, 255, 244, 237, 243, 237, 240, 223, 183, 195, 206, 215, 228, 170,
  182, 202, 177, 181, 182, 176, 155, 156, 140, 162, 143, 148, 141, 108, 116, 131, 100, 116, 81, 92, 64, 72, 95, 74,
  67, 56, 69, 54, 51, 44, 60, 45, 31, 12, 6, 19, 9, 0, 0, 18, 3, 0, 0, 1, 0, 255, 255, 245,
  250, 244, 242, 227, 214, 201, 180, 199, 203, 209, 204, 176, 147, 163, 180, 172, 154, 156, 129, 250, 249, 248, 229, 223,
  248, 226, 208, 232, 220, 203, 255, 252, 240, 247, 229, 235, 211, 231, 209, 206, 227, 216, 196, 253, 255, 226, 253, 246,
  220, 230, 223, 204, 222, 210, 196, 184, 194, 208, 163, 170, 167, 156, 159, 148, 143, 148, 127, 143, 136, 168, 98, 97,
  116, 119, 89, 91, 61, 84, 79, 70, 76, 79, 59, 62, 32, 73, 45, 47, 26, 22, 23, 18, 7, 8, 255, 255,
  219, 243, 244, 244, 228, 222, 218, 215, 209, 207, 194, 196, 170, 158, 153, 170, 187, 229, 247, 252, 255, 249, 255, 255,
  237, 235, 250, 222, 218, 233, 241, 209, 185, 199, 198, 184, 175, 178, 154, 159, 163, 165, 138, 116, 125, 137, 125, 130,
  103, 118, 102, 88, 93, 104, 88, 77, 73, 85, 66, 91, 57, 43, 26, 13, 11, 48, 35, 31, 31, 27, 0, 0,
  0, 3, 8, 0, 0, 3, 8, 4, 0, 1, 0, 0, 6, 5, 255, 246, 229, 254, 222, 215, 231, 237, 208, 221,
  203, 201, 214, 181, 190, 177, 170, 175, 167, 168, 165, 155, 158, 140, 131, 124, 115, 108, 101, 90, 101, 98, 118, 93,
};
static const uint8_t S4_CCS_Q[] PROGMEM = {
  0, 14, 14, 24, 22, 27, 25, 48, 51, 33, 39, 46, 49, 0, 18, 24, 8, 22, 24, 16, 34, 55, 55, 61,
  75, 60, 64, 96, 77, 66, 87, 85, 101, 107, 101, 104, 111, 133, 136, 106, 137, 153, 153, 156, 157, 155, 167, 183,
  160, 173, 185, 198, 219, 196, 196, 229, 219, 232, 240, 240, 243, 230, 248, 247, 245, 254, 255, 255, 254, 253, 238, 255,
  255, 255, 244, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 255, 0, 2, 12, 1, 2, 17, 14, 28,
  23, 0, 3, 11, 17, 30, 40, 12, 35, 32, 49, 55, 50, 66, 80, 72, 76, 85, 79, 99, 80, 104, 88, 108,
  8, 2, 12, 21, 32, 13, 35, 43, 40, 33, 39, 63, 32, 72, 63, 72, 79, 90, 92, 101, 108, 128, 105, 125,
  116, 137, 136, 131, 141, 142, 151, 165, 162, 166, 175, 168, 177, 195, 210, 191, 210, 212, 202, 236, 209, 219, 231, 244,
  247, 249, 255, 253, 250, 255, 255, 251, 255, 255, 255, 232, 255, 255, 255, 255, 255, 255, 255, 241, 255, 255, 255, 252,
  244, 249, 244, 255, 255, 255, 240, 239, 255, 255, 247, 248, 245, 245, 255, 255, 255, 255, 253, 251, 255, 255, 255, 255,
  236, 255, 255, 255, 247, 252, 255, 243, 255, 255, 241, 232, 249, 252, 255, 235, 254, 255, 254, 249, 254, 246, 255, 255,
  253, 234, 253, 253, 251, 0, 2, 29, 13, 30, 32, 32, 28, 25, 42, 47, 57, 52, 74, 85, 86, 87, 86, 99,
  95, 101, 92, 112, 106, 119, 132, 131, 167, 139, 140, 158, 175, 168, 160, 190, 183, 171, 202, 211, 214, 202, 206, 215,
  229, 212, 218, 228, 242, 252, 253, 255, 255, 252, 241, 252, 255, 254, 253, 244, 247, 238, 255, 255, 255, 255, 255, 255,
  255, 255, 245, 255, 245, 255, 255, 255, 255, 255, 255, 244, 255, 255, 248, 255, 255, 250, 255, 250, 248, 248, 255, 255,
  242, 254, 0, 4, 17, 13, 20, 25, 28, 30, 51, 63, 46, 49, 55, 66, 67, 77, 86, 83, 85, 93, 96, 104,
  125, 126, 0, 2, 12, 33, 22, 33, 32, 21, 42, 49, 59, 74, 75, 60, 0, 5, 3, 5, 15, 31, 21, 43,
  37, 51, 47, 55, 57, 64, 62, 60, 89, 93, 89, 109, 117, 102, 103, 118, 125, 140, 124, 139, 140, 145, 152, 157,
  167, 163, 162, 176, 175, 180, 195, 182, 208, 208, 223, 221, 222, 238, 230, 242, 237, 253, 249, 251, 255, 11, 2, 3,
  11, 19, 18, 42, 40, 40, 34, 53, 43, 57, 58, 69, 68, 79, 90, 90, 107, 94, 122, 105, 134, 122, 127, 129,
  149, 158, 155, 152, 140, 164, 169, 167, 176, 192, 199, 177, 199, 197, 222, 212, 220, 225, 232, 239, 241, 250, 251, 249,
  255, 247, 244, 237, 239, 255, 255, 241, 255, 255, 255, 255, 254, 255, 255, 235, 255, 255, 248, 244, 255, 255, 255, 255,
  255, 254, 255, 255, 255, 252, 255, 255, 240, 255, 244, 255, 255, 255, 255, 255, 248, 231, 254, 255, 242, 255, 254, 255,
  255, 255, 255, 255, 240, 245, 251, 255, 255, 247, 255, 255, 255, 255, 255, 255, 244, 251, 247, 253, 255, 250, 254, 255,
  249, 247, 255, 253, 255, 253, 252, 255, 255, 251, 253, 250, 255, 255, 255, 255, 255, 250, 254, 255, 247, 244, 255, 255,
  248, 237, 251, 251, 246, 252, 255, 255, 255, 240, 227, 249, 249, 255, 254, 246, 249, 255, 239, 255, 249, 255, 249, 255,
  255, 250, 255, 253, 255, 0, 14, 11, 11, 18, 34, 44, 42, 29, 26, 0, 4, 16, 11, 30, 35, 14, 28, 35,
  58, 55, 49, 75, 64, 56, 69, 81, 71, 101, 85, 98, 120, 106, 119, 114, 119, 125, 0, 2, 13, 5, 12, 20,
  36, 40, 49, 33, 44, 48, 51, 57, 74, 75, 89, 96, 99, 103, 105, 125, 102, 120, 120, 123, 131, 138, 150, 155,
  148, 170, 165, 170, 182, 189, 197, 182, 0, 2, 3, 20, 13, 15, 43, 29, 60, 61, 28, 60, 60, 64, 74, 76,
  85, 79, 95, 87, 95, 91, 98, 129, 129, 124, 142, 131, 132, 145, 158, 148, 163, 174, 0, 17, 3, 15, 16, 28,
  35, 42, 14, 43, 1, 5, 8, 21, 13, 26, 33, 19, 28, 58, 55, 47, 78, 67, 83, 75, 87, 100, 92, 103,
  102, 119, 101, 120, 146, 116, 125, 144, 149, 139, 148, 142, 168, 155, 181, 184, 185, 196, 177, 181, 204, 220, 207, 216,
  238, 216, 235, 228, 250, 244, 255, 0, 2, 3, 16, 29, 10, 13, 37, 39, 57, 49, 66, 56, 64, 76, 87, 79,
  90, 84, 107, 109, 0, 2, 18, 8, 19, 11, 24, 19, 55, 38, 44, 55, 57, 62, 84, 83, 79, 94, 91, 98,
  107, 95, 106, 111, 126, 142, 132, 142, 147, 135, 151, 149, 173, 174, 190, 187, 179, 182, 181, 204, 193, 204, 208, 218,
  218, 226, 249, 232, 238, 245, 248, 238, 255, 255, 255, 255, 238, 255, 247, 247, 255, 255, 5, 2, 3, 24, 12, 25,
  41, 25, 35, 52, 55, 53, 66, 58, 60, 89, 79, 83, 88, 96, 107, 113, 113, 114, 123, 106, 137, 133, 160, 138,
  158, 149, 165, 181, 171, 174, 182, 179, 194, 200, 202, 224, 207, 224, 239, 225, 235, 241, 252, 253, 244, 255, 244, 255,
  246, 241, 252, 253, 255, 255, 255, 242, 255, 255, 255, 255, 253, 255, 249, 255, 255, 249, 249, 236, 255, 255, 249, 250,
  255, 253, 247, 242, 247, 250, 249, 249, 255, 254, 250, 252, 255, 255, 255, 248, 255, 255, 255, 244, 251, 255, 250, 245,
  252, 251, 249, 0, 2, 12, 5, 15, 18, 35, 47, 23, 50, 49, 51, 53, 72, 71, 65, 77, 72, 89, 91, 108,
  119, 119, 111, 120, 131, 134, 125, 139, 151, 151, 164, 170, 171, 182, 177, 197, 186, 201, 188, 193, 215, 224, 221, 217,
  215, 243, 227, 246, 253, 255, 255, 255, 246, 253, 251, 255, 236, 248, 243, 255, 255, 255, 249, 255, 251, 255, 255, 255,
  253, 255, 255, 0, 12, 22, 14, 22, 25, 26, 38, 49, 56, 53, 58, 69, 62, 75, 70, 84, 66, 95, 96, 3,
  2, 3, 12, 37, 21, 30, 14, 44, 53, 51, 54, 58, 74, 85, 90, 83, 76, 84, 107, 100, 129, 117, 110, 134,
  116, 139, 147, 138, 158, 162, 153, 3, 16, 20, 25, 22, 27, 31, 32, 30, 36, 60, 82, 62, 83, 67, 90, 80,
  89, 81, 109, 102, 102, 125, 120, 126, 123, 151, 144, 137, 150, 152, 155, 168, 164, 176, 177, 185, 200, 190, 188, 191,
  3, 5, 2, 2, 13, 18, 21, 13, 25, 32, 39, 50, 64, 50, 67, 54, 74, 75, 85, 93, 86, 93, 107, 106,
  127, 113, 105, 138, 137, 129, 144, 147, 171, 157, 163, 156, 176, 185, 181, 192, 203, 193, 204, 214, 219, 222, 215, 245,
  229, 238, 247, 249, 248, 236, 255, 255, 245, 255, 248, 248, 244, 241, 255, 255, 249, 255, 255, 255, 248, 245, 255, 249,
  253, 246, 255, 255, 248, 255, 252, 255, 252, 255, 255, 249, 249, 251, 255, 252, 255, 255, 253, 249, 243, 254, 255, 255,
  8, 2, 17, 18, 30, 15, 29, 32, 53, 65, 52, 49, 61, 65, 67, 60, 79, 87, 93, 102, 98, 104, 122, 113,
  102, 122, 119, 134, 152, 154, 145, 146, 165, 165, 165, 164, 203, 208, 172, 200, 214, 202, 201, 211, 225, 232, 246, 250,
  250, 246, 255, 251, 255, 253, 255, 255, 246, 255, 14, 2, 6, 5, 26, 39, 32, 38, 44, 53, 59, 72, 69, 63,
  55, 82, 61, 4, 2, 3, 6, 26, 24, 34, 40, 36, 50, 37, 56, 50, 61, 76, 76, 82, 96, 99, 91, 110,
  109, 118, 124, 113, 132, 137, 143, 136, 147, 151, 151, 169, 169, 187, 167, 175, 196, 171, 200, 205, 203, 204, 202, 220,
  236, 232, 230, 244, 234, 255, 255, 255, 247, 255, 248, 242, 235, 255, 253, 252, 255, 247, 248, 255, 245, 233, 255, 245,
  253, 255, 255, 255, 255, 255, 255, 245, 246, 255, 248, 255, 255, 255, 255, 255, 250, 255, 250, 243, 255, 249, 243, 255,
  245, 255, 255, 244, 255, 254, 250, 244, 255, 255, 255, 255, 7, 13, 17, 25, 30, 36, 3, 2, 12, 7, 15, 5,
  7, 8, 9, 8, 29, 33, 32, 41, 64, 62, 56, 69, 78, 88, 73, 88, 71, 101, 101, 104, 120, 120, 110, 145,
  137, 134, 156, 147, 137, 148, 159, 181, 170, 187, 191, 182, 175, 182, 209, 216, 228, 219, 0, 8, 17, 5, 33, 28,
  38, 25, 60, 41, 56, 60, 60, 49, 60, 69, 83, 81, 95, 92, 105, 116, 102, 132, 127, 115, 134, 148, 154, 161,
  150, 153, 148, 161, 170, 183, 179, 198, 174, 205, 185, 210, 227, 223, 215, 236, 245, 236, 247, 237, 255, 255, 248, 255,
  255, 255, 255, 255, 255, 255, 237, 254, 250, 254, 255, 0, 9, 16, 13, 19, 18, 31, 61, 55, 48, 44, 36, 78,
  71, 58, 77, 76, 77, 83, 99, 100, 113, 99, 113, 111, 118, 143, 138, 129, 153, 143, 169, 163, 184, 180, 166, 182,
  188, 197, 190, 202, 206, 212, 202, 214, 226, 241, 247, 238, 247, 255, 255, 242, 253, 255, 255, 254, 255, 0, 2, 10,
  8, 14, 17, 29, 39, 50, 66, 54, 54, 50, 56, 77, 99, 89, 78, 86, 100, 100, 120, 3, 6, 8, 23, 28,
  12, 29, 44, 28, 38, 52, 0, 4, 14, 10, 24, 21, 40, 27, 44, 48, 35, 44, 60, 2, 2, 23, 6, 13,
  32, 27, 33, 48, 37, 47, 58, 68, 62, 54, 87, 84, 88, 97, 96, 106, 110, 109, 124, 115, 121, 100, 151, 153,
  142, 141, 164, 163, 187, 171, 177, 184, 182, 181, 197, 196, 219, 192, 213, 213, 229, 234, 234, 239, 248, 249, 0, 2,
  28, 13, 14, 16, 28, 34, 38, 42, 47, 50, 61, 62, 81, 91, 96, 86, 75, 18, 7, 5, 5, 4, 2, 3,
  17, 20, 11, 33, 37, 28, 24, 48, 66, 58, 60, 71, 79, 78, 97, 95, 94, 94, 114, 131, 126, 119, 129, 127,
  147, 138, 151, 163, 161, 155, 167, 176, 181, 174, 189, 173, 198, 209, 223, 234, 237, 212, 223, 227, 229, 233, 253, 255,
  255, 253, 249, 255, 255, 253, 249, 252, 255, 254, 255, 255, 251, 251, 0, 8, 21, 6, 29, 36, 26, 23, 45, 38,
  52, 54, 47, 72, 67, 77, 84, 82, 89, 90, 94, 102, 101, 116, 124, 130, 138, 144, 151, 160, 154, 157, 145, 164,
};

static inline float q_to_f(uint8_t q){ return ((float)q) / 255.0f; }</file><file path="uccs_d2_scan90/src/txsd/TXSD_UCCS_D2_SCAN90/TXSD_UCCS_D2_SCAN90.ino">// TXSD_UCCS_D2_SCAN90.ino (uccs_d2_scan90)
// INA219 logger for Step D2. Start/stop via SYNC (TX GPIO25 -&gt; TXSD GPIO26).
// TX sends preamble pulses on TICK (TX GPIO27 -&gt; TXSD GPIO33) to encode cond_id.
// During trial, TX additionally emits 1 tick per payload update, and TXSD uses tick_count as adv_count (approx).
//
// cond_id:
//   1: S1 fixed100
//   2: S1 fixed500
//   3: S1 policy (100↔500, D0 params)
//   4: S4 fixed100
//   5: S4 fixed500
//   6: S4 policy (100↔500, D0 params)

#include &lt;Arduino.h&gt;
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;Adafruit_INA219.h&gt;

// Pins
static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26;
static const int SYNC_OFF_IN = -1; // unused
static const int TICK_IN = 33;
static const int I2C_SDA = 21;
static const int I2C_SCL = 22;

// Settings
static const uint32_t SAMPLE_US    = 10000;   // 10ms = 100Hz
static const uint32_t FALLBACK_MS  = 2400000; // safety fallback (~40 min)
static const uint32_t MIN_TRIAL_MS = 1000;    // ignore trials shorter than 1s
static const uint32_t TICK_PER_TRIAL = 0;     // 0=disabled (use SYNC to end)
static const char SUBJECT_ID[] = &quot;uccs_d2_scan90&quot;;

// Preamble window (count TICK pulses after SYNC rising edge)
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint8_t PREAMBLE_MAX_ID = 16;

HardwareSerial Debug(0);
Adafruit_INA219 ina;
File f;

volatile uint32_t tickCountRaw=0; // cumulative
uint32_t tickStart=0;
uint32_t tickCount=0;
bool logging=false;
bool pendingStart=false;
uint32_t t0_ms=0, nextSampleUs=0;
uint32_t badLines=0;
uint32_t syncLowSince=0;
uint32_t pendingSinceMs=0;
uint32_t tickAtSync=0;
uint8_t condId=0;

// Stats
double sumP=0.0; double sumV=0.0; double sumI=0.0; uint32_t sampN=0;

static bool condInfo(uint8_t id, const char** tag){
  switch(id){
    case 1: *tag = &quot;s1_fixed100&quot;; return true;
    case 2: *tag = &quot;s1_fixed500&quot;; return true;
    case 3: *tag = &quot;s1_policy&quot;;   return true;
    case 4: *tag = &quot;s4_fixed100&quot;; return true;
    case 5: *tag = &quot;s4_fixed500&quot;; return true;
    case 6: *tag = &quot;s4_policy&quot;;   return true;
    default: break;
  }
  *tag = &quot;unk&quot;;
  return false;
}

static inline String nextPath(uint8_t id){
  SD.mkdir(&quot;/logs&quot;);
  char p[96];
  const char* tag=&quot;unk&quot;;
  (void)condInfo(id, &amp;tag);
  for (uint32_t trial_idx=1;;++trial_idx){
    snprintf(p,sizeof(p),&quot;/logs/trial_%03lu_c%u_%s.csv&quot;,
             (unsigned long)trial_idx, (unsigned)id, tag);
    if(!SD.exists(p)) return String(p);
  }
}

void IRAM_ATTR onTickRaw(){ tickCountRaw++; }

static void startTrial(uint8_t id){
  condId = id;
  const char* tag=&quot;unk&quot;;
  (void)condInfo(condId, &amp;tag);
  String path = nextPath(id);
  f = SD.open(path, FILE_WRITE);
  if (!f){ Debug.println(&quot;[SD] open FAIL&quot;); return; }
  f.println(&quot;ms,mV,uA,p_mW&quot;);

  f.printf(&quot;# meta, firmware=TXSD_UCCS_D2_SCAN90, cond_id=%u, tag=%s, subject=%s\r\n&quot;,
           (unsigned)condId, tag, SUBJECT_ID);
  if (condId == 3 || condId == 6){
    f.printf(&quot;# meta, policy=actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20\r\n&quot;);
  }
  f.flush();

  logging = true;
  t0_ms = millis();
  nextSampleUs = micros() + SAMPLE_US;
  badLines = 0;
  tickCount = 0;
  tickStart = tickCountRaw; // exclude preamble pulses
  sumP=sumV=sumI=0.0;
  sampN=0;
  Debug.printf(&quot;[PWR] start %s subject=%s\n&quot;, path.c_str(), SUBJECT_ID);
}

static void endTrial(){
  if (!logging) return;
  logging = false;
  uint32_t ms_total = millis() - t0_ms;
  tickCount = tickCountRaw - tickStart;

  if (ms_total &lt; MIN_TRIAL_MS){
    Debug.printf(&quot;[PWR] ignore short trial ms_total=%lu\n&quot;, (unsigned long)ms_total);
    if (f){ f.flush(); f.close(); }
    return;
  }

  double meanP = (sampN&gt;0)? (sumP/sampN) : 0.0;
  double meanV = (sampN&gt;0)? (sumV/sampN) : 0.0;
  double meanI = (sampN&gt;0)? (sumI/sampN) : 0.0;
  double E_mJ  = meanP * (ms_total/1000.0);

  f.printf(&quot;# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, subject=%s\r\n&quot;,
           (unsigned long)ms_total, (unsigned long)tickCount, E_mJ, SUBJECT_ID);
  f.printf(&quot;# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f, parse_drop=%lu\r\n&quot;,
           (unsigned long)sampN,
           (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
           meanV, meanI, meanP, (unsigned long)badLines);
  f.flush(); f.close();

  Debug.printf(&quot;[PWR] end ms=%lu adv_count=%lu E=%.3fmJ\n&quot;,
               (unsigned long)ms_total, (unsigned long)tickCount, E_mJ);
  Debug.printf(&quot;[PWR] diag samples=%lu rate=%.2f mean_v=%.3f mean_i=%.3f mean_p=%.1f parse_drop=%lu\n&quot;,
               (unsigned long)sampN,
               (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
               meanV, meanI, meanP, (unsigned long)badLines);
}

void setup(){
  Debug.begin(115200);
  Debug.println(&quot;[PWR] FW=TXSD_UCCS_D2_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)){ Debug.println(&quot;[SD] init FAIL&quot;); while(1) delay(1000); }

  pinMode(SYNC_IN, INPUT_PULLDOWN);
  if (SYNC_OFF_IN &gt;= 0) pinMode(SYNC_OFF_IN, INPUT_PULLDOWN);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTickRaw, RISING);

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  ina.begin();
  ina.setCalibration_16V_400mA();

  Debug.println(&quot;[PWR] ready&quot;);
}

void loop(){
  uint32_t nowMs = millis();

  int syncIn = digitalRead(SYNC_IN);
  int syncOff = (SYNC_OFF_IN &gt;= 0) ? digitalRead(SYNC_OFF_IN) : HIGH;

  // start: SYNC rising -&gt; preamble window
  if (!logging &amp;&amp; !pendingStart &amp;&amp; syncIn == HIGH){
    pendingStart = true;
    pendingSinceMs = nowMs;
    tickAtSync = tickCountRaw;
    syncLowSince = 0;
    Debug.printf(&quot;[PWR] SYNC high, wait preamble %lums (tick_raw=%lu)\n&quot;,
                 (unsigned long)PREAMBLE_WINDOW_MS, (unsigned long)tickCountRaw);
  }

  if (pendingStart){
    if (syncIn == LOW){
      pendingStart = false;
      Debug.println(&quot;[PWR] pending start canceled (SYNC LOW)&quot;);
    } else if ((nowMs - pendingSinceMs) &gt;= PREAMBLE_WINDOW_MS){
      uint32_t pulses = tickCountRaw - tickAtSync;
      uint8_t id = (pulses &gt;= 1 &amp;&amp; pulses &lt;= PREAMBLE_MAX_ID) ? (uint8_t)pulses : 0;
      startTrial(id);
      pendingStart = false;
      syncLowSince = 0;
      Debug.printf(&quot;[PWR] trigger start by preamble pulses=%lu -&gt; cond_id=%u\n&quot;, (unsigned long)pulses, (unsigned)id);
      nowMs = millis();
    }
  }

  if (logging){
    bool syncLow = (syncIn == LOW) || (syncOff == LOW);
    if (syncLow){
      if (syncLowSince == 0) syncLowSince = nowMs;
      if ((nowMs - syncLowSince) &gt;= 100){
        Debug.printf(&quot;[PWR] end by SYNC/SYNC_OFF sync=%d sync_off=%d\n&quot;, syncIn, syncOff);
        endTrial();
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
      tickCount = tickCountRaw - tickStart;
      if (TICK_PER_TRIAL &gt; 0 &amp;&amp; tickCount &gt;= TICK_PER_TRIAL){
        Debug.printf(&quot;[PWR] force end by TICK (count=%lu)\n&quot;, (unsigned long)tickCount);
        endTrial();
      }
      if ((nowMs - t0_ms) &gt;= FALLBACK_MS){
        Debug.printf(&quot;[PWR] force end by timeout (ms=%lu)\n&quot;, (unsigned long)(nowMs - t0_ms));
        endTrial();
      }
    }

    uint32_t nowUs = micros();
    while ((int32_t)(nowUs - nextSampleUs) &gt;= 0){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();
      int32_t mv = (int32_t)lroundf(v*1000.0f);
      int32_t uA = (int32_t)lroundf(i*1000.0f);
      double p_mW = v*i;
      uint32_t relMs = millis() - t0_ms;

      sumP += p_mW;
      sumV += v;
      sumI += i;
      sampN++;

      char buf[64];
      int n = snprintf(buf, sizeof(buf), &quot;%lu,%ld,%ld,%.1f\r\n&quot;,
                       (unsigned long)relMs, (long)mv, (long)uA, p_mW);
      if (n &gt; 0) f.write((uint8_t*)buf, n); else badLines++;
      nowUs = micros();
    }
  }

  vTaskDelay(1);
}</file><file path="uccs_d2_scan90/src/txsd/TXSD_UCCS_D2B_SCAN90/TXSD_UCCS_D2B_SCAN90.ino">// TXSD_UCCS_D2B_SCAN90.ino (uccs_d2_scan90)
// INA219 logger for Step D2. Start/stop via SYNC (TX GPIO25 -&gt; TXSD GPIO26).
// TX sends preamble pulses on TICK (TX GPIO27 -&gt; TXSD GPIO33) to encode cond_id.
// During trial, TX additionally emits 1 tick per payload update, and TXSD uses tick_count as adv_count (approx).
//
// cond_id:
//   1: S1 fixed100
//   2: S1 fixed500
//   3: S1 policy (100↔500, D0 params)
//   4: S4 fixed100
//   5: S4 fixed500
//   6: S4 policy (100↔500, D0 params)

#include &lt;Arduino.h&gt;
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;Adafruit_INA219.h&gt;

// Pins
static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26;
static const int SYNC_OFF_IN = -1; // unused
static const int TICK_IN = 33;
static const int I2C_SDA = 21;
static const int I2C_SCL = 22;

// Settings
static const uint32_t SAMPLE_US    = 10000;   // 10ms = 100Hz
static const uint32_t FALLBACK_MS  = 2400000; // safety fallback (~40 min)
static const uint32_t MIN_TRIAL_MS = 1000;    // ignore trials shorter than 1s
static const uint32_t TICK_PER_TRIAL = 0;     // 0=disabled (use SYNC to end)
static const char SUBJECT_ID[] = &quot;uccs_d2_scan90_d2b&quot;;

// Preamble window (count TICK pulses after SYNC rising edge)
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint8_t PREAMBLE_MAX_ID = 16;

HardwareSerial Debug(0);
Adafruit_INA219 ina;
File f;

volatile uint32_t tickCountRaw=0; // cumulative
uint32_t tickStart=0;
uint32_t tickCount=0;
bool logging=false;
bool pendingStart=false;
uint32_t t0_ms=0, nextSampleUs=0;
uint32_t badLines=0;
uint32_t syncLowSince=0;
uint32_t pendingSinceMs=0;
uint32_t tickAtSync=0;
uint8_t condId=0;

// Stats
double sumP=0.0; double sumV=0.0; double sumI=0.0; uint32_t sampN=0;

static bool condInfo(uint8_t id, const char** tag){
  switch(id){
    case 1: *tag = &quot;s1_fixed100&quot;; return true;
    case 2: *tag = &quot;s1_fixed500&quot;; return true;
    case 3: *tag = &quot;s1_policy&quot;;   return true;
    case 4: *tag = &quot;s4_fixed100&quot;; return true;
    case 5: *tag = &quot;s4_fixed500&quot;; return true;
    case 6: *tag = &quot;s4_policy&quot;;   return true;
    default: break;
  }
  *tag = &quot;unk&quot;;
  return false;
}

static inline String nextPath(uint8_t id){
  SD.mkdir(&quot;/logs&quot;);
  char p[96];
  const char* tag=&quot;unk&quot;;
  (void)condInfo(id, &amp;tag);
  for (uint32_t trial_idx=1;;++trial_idx){
    snprintf(p,sizeof(p),&quot;/logs/trial_%03lu_c%u_%s.csv&quot;,
             (unsigned long)trial_idx, (unsigned)id, tag);
    if(!SD.exists(p)) return String(p);
  }
}

void IRAM_ATTR onTickRaw(){ tickCountRaw++; }

static void startTrial(uint8_t id){
  condId = id;
  const char* tag=&quot;unk&quot;;
  (void)condInfo(condId, &amp;tag);
  String path = nextPath(id);
  f = SD.open(path, FILE_WRITE);
  if (!f){ Debug.println(&quot;[SD] open FAIL&quot;); return; }
  f.println(&quot;ms,mV,uA,p_mW&quot;);

  f.printf(&quot;# meta, firmware=TXSD_UCCS_D2B_SCAN90, cond_id=%u, tag=%s, subject=%s\r\n&quot;,
           (unsigned)condId, tag, SUBJECT_ID);
  if (condId == 3 || condId == 6){
    f.printf(&quot;# meta, policy=actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20 ccs_inverted=true preamble_guard_ms=100\r\n&quot;);
  }
  f.flush();

  logging = true;
  t0_ms = millis();
  nextSampleUs = micros() + SAMPLE_US;
  badLines = 0;
  tickCount = 0;
  tickStart = tickCountRaw; // exclude preamble pulses
  sumP=sumV=sumI=0.0;
  sampN=0;
  Debug.printf(&quot;[PWR] start %s subject=%s\n&quot;, path.c_str(), SUBJECT_ID);
}

static void endTrial(){
  if (!logging) return;
  logging = false;
  uint32_t ms_total = millis() - t0_ms;
  tickCount = tickCountRaw - tickStart;

  if (ms_total &lt; MIN_TRIAL_MS){
    Debug.printf(&quot;[PWR] ignore short trial ms_total=%lu\n&quot;, (unsigned long)ms_total);
    if (f){ f.flush(); f.close(); }
    return;
  }

  double meanP = (sampN&gt;0)? (sumP/sampN) : 0.0;
  double meanV = (sampN&gt;0)? (sumV/sampN) : 0.0;
  double meanI = (sampN&gt;0)? (sumI/sampN) : 0.0;
  double E_mJ  = meanP * (ms_total/1000.0);

  f.printf(&quot;# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, subject=%s\r\n&quot;,
           (unsigned long)ms_total, (unsigned long)tickCount, E_mJ, SUBJECT_ID);
  f.printf(&quot;# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f, parse_drop=%lu\r\n&quot;,
           (unsigned long)sampN,
           (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
           meanV, meanI, meanP, (unsigned long)badLines);
  f.flush(); f.close();

  Debug.printf(&quot;[PWR] end ms=%lu adv_count=%lu E=%.3fmJ\n&quot;,
               (unsigned long)ms_total, (unsigned long)tickCount, E_mJ);
  Debug.printf(&quot;[PWR] diag samples=%lu rate=%.2f mean_v=%.3f mean_i=%.3f mean_p=%.1f parse_drop=%lu\n&quot;,
               (unsigned long)sampN,
               (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
               meanV, meanI, meanP, (unsigned long)badLines);
}

void setup(){
  Debug.begin(115200);
  Debug.println(&quot;[PWR] FW=TXSD_UCCS_D2B_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)){ Debug.println(&quot;[SD] init FAIL&quot;); while(1) delay(1000); }

  pinMode(SYNC_IN, INPUT_PULLDOWN);
  if (SYNC_OFF_IN &gt;= 0) pinMode(SYNC_OFF_IN, INPUT_PULLDOWN);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTickRaw, RISING);

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  ina.begin();
  ina.setCalibration_16V_400mA();

  Debug.println(&quot;[PWR] ready&quot;);
}

void loop(){
  uint32_t nowMs = millis();

  int syncIn = digitalRead(SYNC_IN);
  int syncOff = (SYNC_OFF_IN &gt;= 0) ? digitalRead(SYNC_OFF_IN) : HIGH;

  // start: SYNC rising -&gt; preamble window
  if (!logging &amp;&amp; !pendingStart &amp;&amp; syncIn == HIGH){
    pendingStart = true;
    pendingSinceMs = nowMs;
    tickAtSync = tickCountRaw;
    syncLowSince = 0;
    Debug.printf(&quot;[PWR] SYNC high, wait preamble %lums (tick_raw=%lu)\n&quot;,
                 (unsigned long)PREAMBLE_WINDOW_MS, (unsigned long)tickCountRaw);
  }

  if (pendingStart){
    if (syncIn == LOW){
      pendingStart = false;
      Debug.println(&quot;[PWR] pending start canceled (SYNC LOW)&quot;);
    } else if ((nowMs - pendingSinceMs) &gt;= PREAMBLE_WINDOW_MS){
      uint32_t pulses = tickCountRaw - tickAtSync;
      uint8_t id = (pulses &gt;= 1 &amp;&amp; pulses &lt;= PREAMBLE_MAX_ID) ? (uint8_t)pulses : 0;
      startTrial(id);
      pendingStart = false;
      syncLowSince = 0;
      Debug.printf(&quot;[PWR] trigger start by preamble pulses=%lu -&gt; cond_id=%u\n&quot;, (unsigned long)pulses, (unsigned)id);
      nowMs = millis();
    }
  }

  if (logging){
    bool syncLow = (syncIn == LOW) || (syncOff == LOW);
    if (syncLow){
      if (syncLowSince == 0) syncLowSince = nowMs;
      if ((nowMs - syncLowSince) &gt;= 100){
        Debug.printf(&quot;[PWR] end by SYNC/SYNC_OFF sync=%d sync_off=%d\n&quot;, syncIn, syncOff);
        endTrial();
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
      tickCount = tickCountRaw - tickStart;
      if (TICK_PER_TRIAL &gt; 0 &amp;&amp; tickCount &gt;= TICK_PER_TRIAL){
        Debug.printf(&quot;[PWR] force end by TICK (count=%lu)\n&quot;, (unsigned long)tickCount);
        endTrial();
      }
      if ((nowMs - t0_ms) &gt;= FALLBACK_MS){
        Debug.printf(&quot;[PWR] force end by timeout (ms=%lu)\n&quot;, (unsigned long)(nowMs - t0_ms));
        endTrial();
      }
    }

    uint32_t nowUs = micros();
    while ((int32_t)(nowUs - nextSampleUs) &gt;= 0){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();
      int32_t mv = (int32_t)lroundf(v*1000.0f);
      int32_t uA = (int32_t)lroundf(i*1000.0f);
      double p_mW = v*i;
      uint32_t relMs = millis() - t0_ms;

      sumP += p_mW;
      sumV += v;
      sumI += i;
      sampN++;

      char buf[64];
      int n = snprintf(buf, sizeof(buf), &quot;%lu,%ld,%ld,%.1f\r\n&quot;,
                       (unsigned long)relMs, (long)mv, (long)uA, p_mW);
      if (n &gt; 0) f.write((uint8_t*)buf, n); else badLines++;
      nowUs = micros();
    }
  }

  vTaskDelay(1);
}</file><file path="uccs_d3_scan70/metrics/01/effects_ci.csv">metric,cond_a,cond_b,label,n_a,n_b,mean_a,mean_b,delta_mean,ci_low,ci_high,p_two_sided,n_boot,alpha,seed,generated_local,source_csv
pout_1s,S4_policy,S4_fixed500,Δpout (policy − fixed500),3,3,0.08943066666666666,0.2845526666666667,-0.19512200000000002,-0.2601626666666667,-0.13008133333333335,0.0,20000,0.05,20251217,2025-12-17 10:56,uccs_d3_scan70/metrics/01/per_trial.csv
avg_power_mW,S4_policy,S4_fixed100,Δpower_mW (policy − fixed100),3,3,202.11704727801632,209.87827976275707,-7.761232484740759,-8.244096320546646,-7.224741775455584,0.0,20000,0.05,20251217,2025-12-17 10:56,uccs_d3_scan70/metrics/01/per_trial.csv</file><file path="uccs_d3_scan70/metrics/01/effects_ci.md"># effects_ci: D3 scan70 S4 (run01)

- source: `uccs_d3_scan70/metrics/01/per_trial.csv`
- generated: 2025-12-17 10:56 (local)
- bootstrap: percentile CI, n_boot=20000, alpha=0.05, seed=20251217

| label | delta(mean) | 95% CI | p(two-sided) |
|---|---:|---:|---:|
| Δpout (policy − fixed500) | -0.1951 | [-0.2602, -0.1301] | 0.0000 |
| Δpower_mW (policy − fixed100) | -7.7612 | [-8.2441, -7.2247] | 0.0000 |</file><file path="uccs_d3_scan70/metrics/01/per_trial.csv">rx_trial_id,condition,repeat_idx,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_mtime_s,txsd_path,rx_path
10,S4_fixed100,1,FIXED_100,568,568,1796,0.316258,1.0,1.35225,14.4065,0.097561,0.073171,0.073171,-1148.0,567,181426.0,37975.314,209.31572101021905,315500596.0,uccs_d3_scan70/data/01/TX/trial_006_c2_s4_fixed500.csv,uccs_d3_scan70/data/01/RX/rx_trial_010.csv
11,S4_fixed500,1,FIXED_500,237,237,359,0.660167,0.000847,3.391575,20.44275,0.292683,0.121951,0.121951,-631.0,237,179594.0,34076.595,189.74239117119726,315500782.0,uccs_d3_scan70/data/01/TX/trial_004_c3_s4_policy.csv,uccs_d3_scan70/data/01/RX/rx_trial_011.csv
12,S4_policy,1,POLICY,439,439,1227,0.357783,0.440252,1.426366,14.1972,0.097561,0.073171,0.073171,-828.0,439,180869.0,36553.523,202.09943660881632,315500968.0,uccs_d3_scan70/data/01/TX/trial_004_c4_unk.csv,uccs_d3_scan70/data/01/RX/rx_trial_012.csv
13,S4_fixed100,2,FIXED_100,559,559,1796,0.311247,1.0,1.36078,13.7353,0.04878,0.04878,0.04878,-1133.0,559,181415.0,38167.396,210.38721164181575,315501156.0,uccs_d3_scan70/data/01/TX/trial_007_c2_s4_fixed500.csv,uccs_d3_scan70/data/01/RX/rx_trial_013.csv
14,S4_fixed500,2,FIXED_500,232,232,359,0.64624,0.0,1.709275,15.2669,0.219512,0.097561,0.097561,-586.0,232,179580.0,34098.496,189.87914021605968,315501342.0,uccs_d3_scan70/data/01/TX/trial_005_c3_s4_policy.csv,uccs_d3_scan70/data/01/RX/rx_trial_014.csv
15,S4_policy,2,POLICY,425,425,1227,0.346373,0.413233,1.453275,14.6777,0.121951,0.073171,0.073171,-789.0,425,180855.0,36536.55,202.02123247905783,315501528.0,uccs_d3_scan70/data/01/TX/trial_005_c4_unk.csv,uccs_d3_scan70/data/01/RX/rx_trial_015.csv
16,S4_fixed100,3,FIXED_100,511,511,1796,0.284521,1.0,1.313976,13.838,0.04878,0.04878,0.04878,-1129.0,511,181398.0,38081.228,209.93190663623636,315501716.0,uccs_d3_scan70/data/01/TX/trial_008_c2_s4_fixed500.csv,uccs_d3_scan70/data/01/RX/rx_trial_016.csv
17,S4_fixed500,3,FIXED_500,233,233,359,0.649025,0.000861,3.683317,20.2645,0.341463,0.121951,0.121951,-561.0,233,179564.0,33937.529,188.99962687398366,315501902.0,uccs_d3_scan70/data/01/TX/trial_006_c3_s4_policy.csv,uccs_d3_scan70/data/01/RX/rx_trial_017.csv
18,S4_policy,3,POLICY,398,398,1227,0.324368,0.406332,1.319695,14.3289,0.04878,0.04878,0.04878,-750.5,398,180837.0,36570.752,202.23047274617474,315502088.0,uccs_d3_scan70/data/01/TX/trial_006_c4_unk.csv,uccs_d3_scan70/data/01/RX/rx_trial_018.csv</file><file path="uccs_d3_scan70/src/tx/TX_UCCS_D3_SCAN70/TX_UCCS_D3_SCAN70.ino">// TX_UCCS_D3_SCAN70.ino (uccs_d3_scan70)
//
// Step D3: scan dutyを90%→70%に落として適応性（固定500が崩れる条件）を確認する。
// - S4のみ
// - 3条件×REPEAT回を自動実行:
//   1) Fixed100
//   2) Fixed500
//   3) Policy(U+CCS, 100↔500)  ※D2bと同一ロジック
//
// 動的でもTL/Poutが評価できるよう、payloadに step_idx（100msグリッド）を入れる。
// TXSDへは SYNC(25) + preamble TICK(27) で cond_id を通知し、trial中は「更新（=現在の広告間隔）ごと」に
// TICKを1発出して adv_count近似とする（D2bと同じ定義）。
//
// Payload (ManufacturerData):
//   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
//     tag例: &quot;F4-09-100&quot; / &quot;P4-11-500&quot; 等（labelとintervalを含む）
//
// NOTE:
// - `stress_causal_*` の CCS は「安定度（高いほどstable）」なので、changeとして扱うため `CCS_change = 1-CCS` に変換する。

#include &lt;Arduino.h&gt;
#include &lt;BLEDevice.h&gt;
#include &lt;math.h&gt;

#ifdef ARDUINO_ARCH_ESP32
#include &quot;esp_pm.h&quot;
#endif

#include &quot;../stress_causal_s1_s4_180s.h&quot;

// ==== schedule ====
static const uint32_t GAP_MS = 5000;
static const uint8_t REPEAT = 3;
static const uint16_t EFFECTIVE_LEN_STEPS = 1800; // 180s @ 100ms

// ==== pins ====
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN = 2;

// ==== options ====
static const bool USE_LED = false;
static const bool ENABLE_TICK_PREAMBLE = true;
static const bool ENABLE_TICK_PER_UPDATE = true;
static const bool RESTART_ADV_ON_INTERVAL_CHANGE = true;

static const uint32_t PREAMBLE_WINDOW_MS = 800; // TXSD window
static const uint32_t PREAMBLE_GUARD_MS = 100;  // after SYNC HIGH before preamble

// ==== actions ====
static const uint16_t ACTIONS[] = {100, 500};
static const uint8_t N_ACTIONS = sizeof(ACTIONS) / sizeof(ACTIONS[0]);

// ==== policy params（D2bと同一） ====
static const float U_MID = 0.20f;
static const float U_HIGH = 0.35f;
static const float C_MID = 0.20f;
static const float C_HIGH = 0.35f;
static const float HYST = 0.02f;
static const float EMA_ALPHA = 0.20f;

// ==== BLE ====
static BLEAdvertising* adv = nullptr;

#ifdef ARDUINO_ARCH_ESP32
static esp_pm_lock_handle_t noLightSleepLock = nullptr;
static bool sleepBlocked = false;
#endif

enum Mode : uint8_t { MODE_FIXED = 0, MODE_POLICY = 1 };
struct Condition {
  uint8_t cond_id;   // TXSD preamble pulses
  Mode mode;
  uint16_t fixed_ms; // MODE_FIXED only
};

// cond_id:
//  1: S4 fixed100
//  2: S4 fixed500
//  3: S4 policy (U+CCS, 100↔500)
static const Condition CONDS[] = {
  {1, MODE_FIXED, 100},
  {2, MODE_FIXED, 500},
  {3, MODE_POLICY, 500},
};
static const uint8_t N_CONDS = sizeof(CONDS) / sizeof(CONDS[0]);

// state
static bool trialRunning = false;
static bool pendingStart = false;
static uint32_t syncRiseMs = 0;
static uint32_t trialStartMs = 0;
static uint32_t nextUpdateMs = 0;
static uint32_t gapStartMs = 0;
static uint8_t condIndex = 0;
static uint8_t repIndex = 0;

static uint16_t stepIdx = 0;               // 100ms grid index
static uint16_t currentIntervalMs = 500;   // 100 or 500
static float uEma = 0.0f;
static float cEma = 0.0f;

static inline uint16_t ms_to_0p625(float ms) {
  long v = lroundf(ms / 0.625f);
  if (v &lt; 0x20) v = 0x20;     // 20ms minimum
  if (v &gt; 0x4000) v = 0x4000; // 10.24s maximum
  return (uint16_t)v;
}

static uint16_t clamp_interval(uint16_t interval_ms) {
  uint16_t best = ACTIONS[0];
  uint32_t bestDist = (uint32_t)abs((int)interval_ms - (int)best);
  for (uint8_t i = 1; i &lt; N_ACTIONS; i++) {
    uint16_t a = ACTIONS[i];
    uint32_t d = (uint32_t)abs((int)interval_ms - (int)a);
    if (d &lt; bestDist || (d == bestDist &amp;&amp; a &lt; best)) {
      best = a;
      bestDist = d;
    }
  }
  return best;
}

static void syncStart() {
  if (USE_LED) digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
  syncRiseMs = millis();
}

static void syncEnd() {
  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_LED) digitalWrite(LED_PIN, LOW);
}

static void tickPulseOnce(uint16_t high_us = 200) {
  digitalWrite(TICK_OUT_PIN, HIGH);
  delayMicroseconds(high_us);
  digitalWrite(TICK_OUT_PIN, LOW);
}

static void tickPreamble(uint8_t nPulses) {
  if (!ENABLE_TICK_PREAMBLE) return;
  for (uint8_t i = 0; i &lt; nPulses; i++) {
    tickPulseOnce(200);
    delay(20);
  }
}

static void setAdvIntervalMs(uint16_t ms) {
  if (!adv) return;
  uint16_t units = ms_to_0p625((float)ms);
  adv-&gt;setMinInterval(units);
  adv-&gt;setMaxInterval(units);
}

static void setPayload(uint16_t step_idx, const char* tag) {
  if (!adv) return;
  BLEAdvertisementData ad;
  String mfd = String((unsigned)step_idx) + &quot;_&quot; + String(tag);
  ad.setManufacturerData(mfd);
  adv-&gt;setAdvertisementData(ad);
}

static void setSleepAllowed(bool allowLightSleep) {
#ifdef ARDUINO_ARCH_ESP32
  if (!noLightSleepLock) return;
  if (allowLightSleep) {
    if (sleepBlocked) {
      esp_pm_lock_release(noLightSleepLock);
      sleepBlocked = false;
    }
  } else {
    if (!sleepBlocked) {
      esp_pm_lock_acquire(noLightSleepLock);
      sleepBlocked = true;
    }
  }
#else
  (void)allowLightSleep;
#endif
}

static inline float getU(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_U_Q[idx]);
  return q_to_f(q);
}

static inline float getCCSStable(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_CCS_Q[idx]);
  return q_to_f(q);
}

static uint16_t policyStep(uint16_t prevInterval, float u, float c_change) {
  const float u_hi_up = U_HIGH;
  const float c_hi_up = C_HIGH;
  const float u_mid_down = U_MID - HYST;
  const float c_mid_down = C_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if ((u &gt;= u_hi_up) || (c_change &gt;= c_hi_up)) next = 100;
  } else { // prevInterval == 100
    if ((u &lt; u_mid_down) &amp;&amp; (c_change &lt; c_mid_down)) next = 500;
  }
  return clamp_interval(next);
}

static void applyInterval(uint16_t nextMs) {
  if (nextMs == currentIntervalMs) return;
  currentIntervalMs = nextMs;
  if (!adv) return;
  if (RESTART_ADV_ON_INTERVAL_CHANGE) {
    adv-&gt;stop();
    setAdvIntervalMs(currentIntervalMs);
    adv-&gt;start();
  } else {
    setAdvIntervalMs(currentIntervalMs);
  }
}

static inline uint8_t getLabel(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0;
  return pgm_read_byte(&amp;S4_LABEL[idx]);
}

static void makeTag(char* out, size_t out_sz, const Condition&amp; c, uint8_t truthLabel, uint16_t intervalMs) {
  // &quot;F4-09-100&quot; / &quot;P4-11-500&quot;
  const char mp = (c.mode == MODE_FIXED) ? &apos;F&apos; : &apos;P&apos;;
  const unsigned lbl = (unsigned)truthLabel;
  const unsigned itv = (unsigned)intervalMs;
  snprintf(out, out_sz, &quot;%c4-%02u-%u&quot;, mp, lbl, itv);
}

static void beginCondition(const Condition&amp; c) {
  stepIdx = 0;
  uEma = 0.0f;
  cEma = 0.0f;
  currentIntervalMs = (c.mode == MODE_FIXED) ? c.fixed_ms : 500;
  currentIntervalMs = clamp_interval(currentIntervalMs);

  if (adv) adv-&gt;stop();
  setAdvIntervalMs(currentIntervalMs);

  setSleepAllowed(true);

  syncStart();
  delay(PREAMBLE_GUARD_MS);
  tickPreamble(c.cond_id);
  pendingStart = true;
}

static void startTrialNow(const Condition&amp; c) {
  trialStartMs = millis();
  trialRunning = true;

  const uint8_t lbl = getLabel(0);
  char tag[16];
  makeTag(tag, sizeof(tag), c, lbl, currentIntervalMs);
  setPayload(0, tag);

  if (adv) adv-&gt;start();
  if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

  const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
  stepIdx = (uint16_t)(stepIdx + deltaSteps);
  nextUpdateMs = millis() + currentIntervalMs;
}

static void endTrial() {
  trialRunning = false;
  pendingStart = false;
  if (adv) adv-&gt;stop();
  syncEnd();
  gapStartMs = millis();
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);
  digitalWrite(SYNC_OUT_PIN, LOW);
  pinMode(TICK_OUT_PIN, OUTPUT);
  digitalWrite(TICK_OUT_PIN, LOW);

  BLEDevice::init(&quot;TX_UCCS_D3_SCAN70&quot;);
  BLEDevice::setPower(ESP_PWR_LVL_N0);
  adv = BLEDevice::getAdvertising();
  adv-&gt;setScanResponse(false);
  adv-&gt;setMinPreferred(0);

#ifdef ARDUINO_ARCH_ESP32
  (void)esp_pm_lock_create(ESP_PM_NO_LIGHT_SLEEP, 0, &quot;d3_scan70&quot;, &amp;noLightSleepLock);
#endif

  condIndex = 0;
  repIndex = 0;
  gapStartMs = 0;
  trialRunning = false;
  pendingStart = false;

  beginCondition(CONDS[condIndex]);
}

void loop() {
  const uint32_t nowMs = millis();
  const Condition&amp; c = CONDS[condIndex];

  if (pendingStart) {
    if ((nowMs - syncRiseMs) &gt;= PREAMBLE_WINDOW_MS) {
      pendingStart = false;
      startTrialNow(c);
    } else {
      vTaskDelay(1);
      return;
    }
  }

  if (trialRunning) {
    if (stepIdx &gt;= EFFECTIVE_LEN_STEPS) {
      endTrial();
      vTaskDelay(pdMS_TO_TICKS(50));
      return;
    }

    if ((int32_t)(nowMs - nextUpdateMs) &gt;= 0) {
      const uint8_t truthLabel = getLabel(stepIdx);

      if (c.mode == MODE_POLICY) {
        const float uRaw = getU(stepIdx);
        const float cStable = getCCSStable(stepIdx);
        const float cChange = 1.0f - cStable;
        uEma = EMA_ALPHA * uRaw + (1.0f - EMA_ALPHA) * uEma;
        cEma = EMA_ALPHA * cChange + (1.0f - EMA_ALPHA) * cEma;

        const uint16_t nextI = policyStep(currentIntervalMs, uEma, cEma);
        applyInterval(nextI);
      }

      char tag[16];
      makeTag(tag, sizeof(tag), c, truthLabel, currentIntervalMs);
      setPayload(stepIdx, tag);
      if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

      const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
      stepIdx = (uint16_t)(stepIdx + deltaSteps);
      nextUpdateMs = millis() + currentIntervalMs;
    }
    vTaskDelay(1);
    return;
  }

  // gap
  if (gapStartMs == 0) gapStartMs = nowMs;
  if ((nowMs - gapStartMs) &lt; GAP_MS) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return;
  }

  gapStartMs = 0;
  condIndex++;
  if (condIndex &gt;= N_CONDS) {
    condIndex = 0;
    repIndex++;
  }
  if (repIndex &gt;= REPEAT) {
    setSleepAllowed(true);
    if (adv) adv-&gt;stop();
    syncEnd();
    vTaskDelay(pdMS_TO_TICKS(1000));
    return;
  }

  beginCondition(CONDS[condIndex]);
}</file><file path="uccs_d3_scan70/src/tx/stress_causal_s1_s4_180s.h">// stress_causal_s1_s4_180s.h (uccs_d3_scan70)
// D3では truth（S1/S4, 100msグリッド）を D2で凍結済みのヘッダから参照する。
// Arduino IDEの相対includeでそのままビルドできるように、薄いラッパにしている。

#pragma once

#include &quot;../../../uccs_d2_scan90/src/tx/stress_causal_s1_s4_180s.h&quot;</file><file path="uccs_d3_scan70/src/txsd/TXSD_UCCS_D3_SCAN70/TXSD_UCCS_D3_SCAN70.ino">// TXSD_UCCS_D3_SCAN70.ino (uccs_d3_scan70)
// INA219 logger for Step D3 (scan70 on RX).
// Start/stop via SYNC (TX GPIO25 -&gt; TXSD GPIO26).
// TX sends preamble pulses on TICK (TX GPIO27 -&gt; TXSD GPIO33) to encode cond_id.
// During trial, TX additionally emits 1 tick per payload update; TXSD uses tick_count as adv_count (approx).
//
// cond_id:
//   1: S4 fixed100
//   2: S4 fixed500
//   3: S4 policy (U+CCS, 100↔500)

#include &lt;Arduino.h&gt;
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;Adafruit_INA219.h&gt;

// Pins
static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26;
static const int SYNC_OFF_IN = -1; // unused
static const int TICK_IN = 33;
static const int I2C_SDA = 21;
static const int I2C_SCL = 22;

// Settings
static const uint32_t SAMPLE_US    = 10000;   // 10ms = 100Hz
static const uint32_t FALLBACK_MS  = 2400000; // safety fallback
static const uint32_t MIN_TRIAL_MS = 1000;
static const uint32_t TICK_PER_TRIAL = 0;     // 0=disabled (use SYNC to end)
static const char SUBJECT_ID[] = &quot;uccs_d3_scan70&quot;;

// Preamble window (count TICK pulses after SYNC rising edge)
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint8_t PREAMBLE_MAX_ID = 16;

HardwareSerial Debug(0);
Adafruit_INA219 ina;
File f;

volatile uint32_t tickCountRaw=0; // cumulative
uint32_t tickStart=0;
uint32_t tickCount=0;
bool logging=false;
bool pendingStart=false;
uint32_t t0_ms=0, nextSampleUs=0;
uint32_t badLines=0;
uint32_t syncLowSince=0;
uint32_t pendingSinceMs=0;
uint32_t tickAtSync=0;
uint8_t condId=0;

// Stats
double sumP=0.0; double sumV=0.0; double sumI=0.0; uint32_t sampN=0;

static bool condInfo(uint8_t id, const char** tag){
  switch(id){
    case 1: *tag = &quot;s4_fixed100&quot;; return true;
    case 2: *tag = &quot;s4_fixed500&quot;; return true;
    case 3: *tag = &quot;s4_policy&quot;;   return true;
    default: break;
  }
  *tag = &quot;unk&quot;;
  return false;
}

static inline String nextPath(uint8_t id){
  SD.mkdir(&quot;/logs&quot;);
  char p[96];
  const char* tag=&quot;unk&quot;;
  (void)condInfo(id, &amp;tag);
  for (uint32_t trial_idx=1;;++trial_idx){
    snprintf(p,sizeof(p),&quot;/logs/trial_%03lu_c%u_%s.csv&quot;,
             (unsigned long)trial_idx, (unsigned)id, tag);
    if(!SD.exists(p)) return String(p);
  }
}

void IRAM_ATTR onTickRaw(){ tickCountRaw++; }

static void startTrial(uint8_t id){
  condId = id;
  const char* tag=&quot;unk&quot;;
  (void)condInfo(condId, &amp;tag);
  String path = nextPath(id);
  f = SD.open(path, FILE_WRITE);
  if (!f){ Debug.println(&quot;[SD] open FAIL&quot;); return; }
  f.println(&quot;ms,mV,uA,p_mW&quot;);

  f.printf(&quot;# meta, firmware=TXSD_UCCS_D3_SCAN70, cond_id=%u, tag=%s, subject=%s\r\n&quot;,
           (unsigned)condId, tag, SUBJECT_ID);
  if (condId == 3){
    f.printf(&quot;# meta, policy=actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20 ccs_inverted=true preamble_guard=true\r\n&quot;);
  }
  f.flush();

  logging = true;
  t0_ms = millis();
  nextSampleUs = micros() + SAMPLE_US;
  badLines = 0;
  tickCount = 0;
  tickStart = tickCountRaw; // exclude preamble pulses
  sumP=sumV=sumI=0.0;
  sampN=0;
  Debug.printf(&quot;[PWR] start %s subject=%s\n&quot;, path.c_str(), SUBJECT_ID);
}

static void endTrial(){
  if (!logging) return;
  logging = false;
  uint32_t ms_total = millis() - t0_ms;
  tickCount = tickCountRaw - tickStart;

  if (ms_total &lt; MIN_TRIAL_MS){
    Debug.printf(&quot;[PWR] ignore short trial ms_total=%lu\n&quot;, (unsigned long)ms_total);
    if (f){ f.flush(); f.close(); }
    return;
  }

  double meanP = (sampN&gt;0)? (sumP/sampN) : 0.0;
  double meanV = (sampN&gt;0)? (sumV/sampN) : 0.0;
  double meanI = (sampN&gt;0)? (sumI/sampN) : 0.0;
  double E_mJ  = meanP * (ms_total/1000.0);

  f.printf(&quot;# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, subject=%s\r\n&quot;,
           (unsigned long)ms_total, (unsigned long)tickCount, E_mJ, SUBJECT_ID);
  f.printf(&quot;# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f, parse_drop=%lu\r\n&quot;,
           (unsigned long)sampN,
           (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
           meanV, meanI, meanP, (unsigned long)badLines);
  f.flush(); f.close();

  Debug.printf(&quot;[PWR] end ms=%lu adv_count=%lu E=%.3fmJ\n&quot;,
               (unsigned long)ms_total, (unsigned long)tickCount, E_mJ);
  Debug.printf(&quot;[PWR] diag samples=%lu rate=%.2f mean_v=%.3f mean_i=%.3f mean_p=%.1f parse_drop=%lu\n&quot;,
               (unsigned long)sampN,
               (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
               meanV, meanI, meanP, (unsigned long)badLines);
}

void setup(){
  Debug.begin(115200);
  Debug.println(&quot;[PWR] FW=TXSD_UCCS_D3_SCAN70&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)){ Debug.println(&quot;[SD] init FAIL&quot;); while(1) delay(1000); }

  pinMode(SYNC_IN, INPUT_PULLDOWN);
  if (SYNC_OFF_IN &gt;= 0) pinMode(SYNC_OFF_IN, INPUT_PULLDOWN);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTickRaw, RISING);

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  ina.begin();
  ina.setCalibration_16V_400mA();

  Debug.println(&quot;[PWR] ready&quot;);
}

void loop(){
  uint32_t nowMs = millis();
  int syncIn = digitalRead(SYNC_IN);
  int syncOff = (SYNC_OFF_IN &gt;= 0) ? digitalRead(SYNC_OFF_IN) : HIGH;

  if (!logging &amp;&amp; !pendingStart &amp;&amp; syncIn == HIGH){
    pendingStart = true;
    pendingSinceMs = nowMs;
    tickAtSync = tickCountRaw;
    syncLowSince = 0;
    Debug.printf(&quot;[PWR] SYNC high, wait preamble %lums (tick_raw=%lu)\n&quot;,
                 (unsigned long)PREAMBLE_WINDOW_MS, (unsigned long)tickCountRaw);
  }

  if (pendingStart){
    if (syncIn == LOW){
      pendingStart = false;
      Debug.println(&quot;[PWR] pending start canceled (SYNC LOW)&quot;);
    } else if ((nowMs - pendingSinceMs) &gt;= PREAMBLE_WINDOW_MS){
      uint32_t pulses = tickCountRaw - tickAtSync;
      uint8_t id = (pulses &gt;= 1 &amp;&amp; pulses &lt;= PREAMBLE_MAX_ID) ? (uint8_t)pulses : 0;
      startTrial(id);
      pendingStart = false;
      syncLowSince = 0;
      Debug.printf(&quot;[PWR] trigger start by preamble pulses=%lu -&gt; cond_id=%u\n&quot;,
                   (unsigned long)pulses, (unsigned)id);
      nowMs = millis();
    }
  }

  if (logging){
    bool syncLow = (syncIn == LOW) || (syncOff == LOW);
    if (syncLow){
      if (syncLowSince == 0) syncLowSince = nowMs;
      if ((nowMs - syncLowSince) &gt;= 100){
        Debug.printf(&quot;[PWR] end by SYNC/SYNC_OFF sync=%d sync_off=%d\n&quot;, syncIn, syncOff);
        endTrial();
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
      tickCount = tickCountRaw - tickStart;
      if (TICK_PER_TRIAL &gt; 0 &amp;&amp; tickCount &gt;= TICK_PER_TRIAL){
        Debug.printf(&quot;[PWR] force end by TICK (count=%lu)\n&quot;, (unsigned long)tickCount);
        endTrial();
      }
      if ((nowMs - t0_ms) &gt;= FALLBACK_MS){
        Debug.printf(&quot;[PWR] force end by timeout (ms=%lu)\n&quot;, (unsigned long)(nowMs - t0_ms));
        endTrial();
      }
    }

    uint32_t nowUs = micros();
    while ((int32_t)(nowUs - nextSampleUs) &gt;= 0){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();
      int32_t mv = (int32_t)lroundf(v*1000.0f);
      int32_t uA = (int32_t)lroundf(i*1000.0f);
      double p_mW = v*i;
      uint32_t relMs = millis() - t0_ms;

      sumP += p_mW;
      sumV += v;
      sumI += i;
      sampN++;

      char buf[64];
      int n = snprintf(buf, sizeof(buf), &quot;%lu,%ld,%ld,%.1f\r\n&quot;,
                       (unsigned long)relMs, (long)mv, (long)uA, p_mW);
      if (n &gt; 0) f.write((uint8_t*)buf, n); else badLines++;
      nowUs = micros();
    }
  } else {
    delay(10);
  }
}</file><file path="uccs_d4_scan90/analysis/plot_power_vs_pout.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Plot Step D4 (U ablation) tradeoff: avg_power_mW vs pout_1s with share100 annotation.

Input: summary_by_condition.csv generated by summarize_d4_run.py
Output: PNG/PDF figure for quick paper-ready inspection.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import os
from pathlib import Path
from typing import Dict, Optional, Tuple


def f_or_none(v: str) -&gt; Optional[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary_by_condition(path: Path) -&gt; Dict[str, Dict[str, Optional[float]]]:
    out: Dict[str, Dict[str, Optional[float]]] = {}
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            out[cond] = {
                &quot;pout_1s_mean&quot;: f_or_none(row.get(&quot;pout_1s_mean&quot;) or &quot;&quot;),
                &quot;pout_1s_std&quot;: f_or_none(row.get(&quot;pout_1s_std&quot;) or &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: f_or_none(row.get(&quot;avg_power_mW_mean&quot;) or &quot;&quot;),
                &quot;avg_power_mW_std&quot;: f_or_none(row.get(&quot;avg_power_mW_std&quot;) or &quot;&quot;),
                &quot;adv_count_mean&quot;: f_or_none(row.get(&quot;adv_count_mean&quot;) or &quot;&quot;),
                &quot;rx_share100_mean&quot;: f_or_none(row.get(&quot;rx_tag_share100_time_est_mean&quot;) or &quot;&quot;),
            }
    return out


def compute_share100_from_adv(
    adv_count_policy: Optional[float],
    adv_count_fixed100: Optional[float],
    adv_count_fixed500: Optional[float],
) -&gt; Optional[float]:
    if (
        adv_count_policy is None
        or adv_count_fixed100 is None
        or adv_count_fixed500 is None
        or adv_count_fixed100 &lt;= adv_count_fixed500
    ):
        return None
    return (adv_count_policy - adv_count_fixed500) / (adv_count_fixed100 - adv_count_fixed500)


def get_point(
    rows: Dict[str, Dict[str, Optional[float]]],
    key: str,
) -&gt; Tuple[float, float, float, float, Optional[float], Optional[float]]:
    r = rows.get(key, {})
    x = r.get(&quot;avg_power_mW_mean&quot;)
    y = r.get(&quot;pout_1s_mean&quot;)
    if x is None or y is None:
        raise SystemExit(f&quot;missing required metrics for {key} in summary csv&quot;)
    xerr = r.get(&quot;avg_power_mW_std&quot;) or 0.0
    yerr = r.get(&quot;pout_1s_std&quot;) or 0.0
    adv = r.get(&quot;adv_count_mean&quot;)
    rx_share = r.get(&quot;rx_share100_mean&quot;)
    return float(x), float(y), float(xerr), float(yerr), adv, rx_share


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--summary-csv&quot;, type=Path, required=True, help=&quot;metrics/*/summary_by_condition.csv&quot;)
    ap.add_argument(&quot;--out&quot;, type=Path, required=True, help=&quot;output png path&quot;)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;&quot;, help=&quot;optional title&quot;)
    args = ap.parse_args()

    # Matplotlib cache/rc write avoidance.
    repo_root = Path.cwd()
    xdg_cache = repo_root / &quot;.cache&quot;
    xdg_cache.mkdir(exist_ok=True)
    os.environ.setdefault(&quot;XDG_CACHE_HOME&quot;, str(xdg_cache))
    mpl_dir = repo_root / &quot;.mplconfig&quot;
    mpl_dir.mkdir(exist_ok=True)
    os.environ.setdefault(&quot;MPLCONFIGDIR&quot;, str(mpl_dir))

    import matplotlib

    matplotlib.use(&quot;Agg&quot;)
    import matplotlib.pyplot as plt  # type: ignore

    rows = read_summary_by_condition(args.summary_csv)

    # Required keys (S4 only).
    k100 = &quot;S4_fixed100&quot;
    k500 = &quot;S4_fixed500&quot;
    kpol = &quot;S4_policy&quot;
    kabl = &quot;S4_ablation_u_shuf&quot;

    x100, y100, x100e, y100e, adv100, _ = get_point(rows, k100)
    x500, y500, x500e, y500e, adv500, _ = get_point(rows, k500)
    xpol, ypol, xpole, ypole, advpol, rx_share_pol = get_point(rows, kpol)
    xabl, yabl, xable, yable, advabl, rx_share_abl = get_point(rows, kabl)

    fig, ax = plt.subplots(figsize=(7.0, 4.6))

    # fixed
    ax.errorbar(
        [x100, x500],
        [y100, y500],
        xerr=[x100e, x500e],
        yerr=[y100e, y500e],
        fmt=&quot;s&quot;,
        ms=7,
        color=&quot;#1f77b4&quot;,
        capsize=3,
        linestyle=&quot;none&quot;,
        label=&quot;fixed&quot;,
    )

    # policy
    ax.errorbar(
        [xpol],
        [ypol],
        xerr=[xpole],
        yerr=[ypole],
        fmt=&quot;o&quot;,
        ms=8,
        color=&quot;#ff7f0e&quot;,
        capsize=3,
        linestyle=&quot;none&quot;,
        label=&quot;policy (U+CCS)&quot;,
    )

    # ablation
    ax.errorbar(
        [xabl],
        [yabl],
        xerr=[xable],
        yerr=[yable],
        fmt=&quot;^&quot;,
        ms=8,
        color=&quot;#2ca02c&quot;,
        capsize=3,
        linestyle=&quot;none&quot;,
        label=&quot;ablation (U-shuffle)&quot;,
    )

    def annotate_share(x: float, y: float, adv: Optional[float], rx_share: Optional[float], color: str) -&gt; None:
        share_tx = compute_share100_from_adv(adv, adv100, adv500)
        share = share_tx if share_tx is not None else rx_share
        if share is None:
            return
        ax.annotate(
            f&quot;share100≈{share:.2f}&quot;,
            (x, y),
            textcoords=&quot;offset points&quot;,
            xytext=(8, 8),
            ha=&quot;left&quot;,
            fontsize=10,
            color=color,
        )

    annotate_share(xpol, ypol, advpol, rx_share_pol, &quot;#ff7f0e&quot;)
    annotate_share(xabl, yabl, advabl, rx_share_abl, &quot;#2ca02c&quot;)

    ax.annotate(&quot;100&quot;, (x100, y100), textcoords=&quot;offset points&quot;, xytext=(6, -12), fontsize=9, color=&quot;#1f77b4&quot;)
    ax.annotate(&quot;500&quot;, (x500, y500), textcoords=&quot;offset points&quot;, xytext=(6, -12), fontsize=9, color=&quot;#1f77b4&quot;)

    ax.set_xlabel(&quot;avg_power_mW (TXSD)&quot;)
    ax.set_ylabel(&quot;pout_1s&quot;)
    ax.grid(True, alpha=0.3)

    title = args.title.strip()
    if not title:
        title = f&quot;{args.summary_csv.parent.name}: avg_power vs pout_1s (D4 ablation, S4)&quot;
    ax.set_title(title)
    ax.legend(loc=&quot;best&quot;, frameon=True, fontsize=9)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    if args.out.suffix.lower() == &quot;.png&quot;:
        fig.savefig(args.out.with_suffix(&quot;.pdf&quot;))


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4_scan90/analysis/summarize_d4_run_v2.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Summarize uccs_d4_scan90 run (RX + TXSD) and compute TL/Pout using step_idx-aligned payload.

This v2 intentionally pairs RX↔TXSD by *file modification time order* (TXSD filenames are not globally
monotonic because trial index is allocated per (cond_id,tag) combination). This also makes the summary
robust to preamble pulse off-by-one issues observed in some runs.

Step D4 (U ablation):
  - S4 only
  - 4 conditions × 3 repeats = 12 trials
    - S4_fixed100 (F4-..-100)
    - S4_fixed500 (F4-..-500)
    - S4_policy (P4-..-itv)
    - S4_ablation_u_shuf (A4-..-itv)

RX ManufacturerData: &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
  tag: &quot;F4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;A4-&lt;label&gt;-&lt;itv&gt;&quot;

Alignment:
  - Estimate per-trial constant offset:
      offset_ms = median(step_idx*100 - first_rx_ms(step_idx))
  - Align RX timestamps onto truth axis and compute TL/Pout from truth transitions.

Outputs (out_dir):
  - per_trial.csv
  - summary_by_condition.csv
  - summary.md
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import re
import statistics
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


TRUTH_DT_MS = 100
TAU_VALUES_S = (1.0, 2.0, 3.0)
VALID_MIN_DURATION_MS = 160_000  # ~180s trials

TAG_RE = re.compile(r&quot;^(?P&lt;mode&gt;[FPA])(?P&lt;sess&gt;[14])-(?P&lt;label&gt;\d+)-(?P&lt;itv&gt;\d+)$&quot;)
RX_TRIAL_RE = re.compile(r&quot;rx_trial_(?P&lt;id&gt;\d+)\.csv$&quot;)
TXSD_NAME_RE = re.compile(r&quot;trial_(?P&lt;idx&gt;\d+)_c(?P&lt;cond&gt;\d+)_(?P&lt;tag&gt;.+)\.csv$&quot;)


@dataclass(frozen=True)
class RxEvent:
    rx_ms: float
    step_idx: int
    truth_label: int
    itv_ms: int
    tag: str


@dataclass
class RxTrial:
    rx_id: int
    path: Path
    duration_ms: float
    session: int  # 4
    mode: str  # F/P/A
    fixed_itv: Optional[int]  # 100/500 if fixed
    events: List[RxEvent]


@dataclass
class TxsdTrial:
    path: Path
    mtime_s: float
    trial_idx: int
    cond_id: int
    tag: str
    ms_total: float
    adv_count: int
    e_total_mj: float
    avg_power_mw: float


def read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def parse_mfd(s: str) -&gt; Optional[Tuple[int, str]]:
    s = (s or &quot;&quot;).strip()
    if not s:
        return None
    us = s.find(&quot;_&quot;)
    if us &lt;= 0:
        return None
    try:
        step_idx = int(s[:us])
    except Exception:
        return None
    tag = s[us + 1 :].strip()
    if not tag:
        return None
    return step_idx, tag


def read_rx_trial(path: Path) -&gt; RxTrial:
    m = RX_TRIAL_RE.search(path.name)
    if not m:
        raise ValueError(f&quot;not rx_trial: {path}&quot;)
    rx_id = int(m.group(&quot;id&quot;))

    events: List[RxEvent] = []
    last_ms: float = 0.0

    mode_c: Dict[str, int] = {&quot;F&quot;: 0, &quot;P&quot;: 0, &quot;A&quot;: 0}
    sess_c: Dict[int, int] = {1: 0, 4: 0}
    itv_c: Dict[int, int] = {}

    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or 0.0)
            except Exception:
                continue
            last_ms = max(last_ms, rx_ms)

            try:
                step_idx = int(row.get(&quot;seq&quot;) or 0)
            except Exception:
                continue

            tag = (row.get(&quot;label&quot;) or &quot;&quot;).strip()
            tm = TAG_RE.match(tag)
            if not tm:
                continue
            mode = tm.group(&quot;mode&quot;)
            sess = int(tm.group(&quot;sess&quot;))
            truth_label = int(tm.group(&quot;label&quot;))
            itv_ms = int(tm.group(&quot;itv&quot;))

            mode_c[mode] = mode_c.get(mode, 0) + 1
            sess_c[sess] = sess_c.get(sess, 0) + 1
            itv_c[itv_ms] = itv_c.get(itv_ms, 0) + 1

            events.append(
                RxEvent(
                    rx_ms=rx_ms,
                    step_idx=step_idx,
                    truth_label=truth_label,
                    itv_ms=itv_ms,
                    tag=tag,
                )
            )

    if not events:
        raise ValueError(f&quot;empty/invalid RX: {path}&quot;)

    mode = max(mode_c.items(), key=lambda kv: kv[1])[0]
    session = 4 if sess_c.get(4, 0) &gt;= sess_c.get(1, 0) else 1
    if session != 4:
        raise ValueError(f&quot;expected S4 only in D4, got session={session}: {path}&quot;)

    fixed_itv: Optional[int] = None
    if mode == &quot;F&quot;:
        fixed_itv = max(itv_c.items(), key=lambda kv: kv[1])[0] if itv_c else None
        if fixed_itv not in (100, 500):
            raise ValueError(f&quot;unexpected fixed interval {fixed_itv} in {path}&quot;)

    return RxTrial(
        rx_id=rx_id,
        path=path,
        duration_ms=last_ms,
        session=session,
        mode=mode,
        fixed_itv=fixed_itv,
        events=events,
    )


def rx_bucket(t: RxTrial) -&gt; str:
    if t.mode == &quot;P&quot;:
        return &quot;P4&quot;
    if t.mode == &quot;A&quot;:
        return &quot;A4&quot;
    return f&quot;F4_{t.fixed_itv}&quot;


def select_balanced_window(trials: List[RxTrial]) -&gt; List[RxTrial]:
    candidates = [t for t in trials if t.duration_ms &gt;= VALID_MIN_DURATION_MS]
    candidates.sort(key=lambda t: t.rx_id)
    if len(candidates) &lt; 12:
        raise SystemExit(f&quot;not enough valid RX trials (&gt;= {VALID_MIN_DURATION_MS}ms): {len(candidates)}&quot;)

    want = {&quot;F4_100&quot;, &quot;F4_500&quot;, &quot;P4&quot;, &quot;A4&quot;}
    best: Optional[List[RxTrial]] = None
    for start in range(0, len(candidates) - 12 + 1):
        window = candidates[start : start + 12]
        counts: Dict[str, int] = {}
        for t in window:
            counts[rx_bucket(t)] = counts.get(rx_bucket(t), 0) + 1
        if set(counts.keys()) == want and all(v == 3 for v in counts.values()):
            best = window
    if not best:
        raise SystemExit(&quot;could not find balanced 12-trial RX window (F4_100/F4_500/P4/A4 × 3 repeats)&quot;)
    return best


def estimate_offset_ms(events: List[RxEvent]) -&gt; Tuple[float, int]:
    first_ms: Dict[int, float] = {}
    for e in sorted(events, key=lambda x: x.rx_ms):
        if e.step_idx not in first_ms:
            first_ms[e.step_idx] = e.rx_ms
    deltas: List[float] = []
    for step, ms in first_ms.items():
        if step &lt;= 0:
            continue
        deltas.append(step * TRUTH_DT_MS - ms)
    if not deltas:
        return 0.0, 0
    return statistics.median(deltas), len(deltas)


def compute_tl_and_pout(
    truth_labels: List[int], aligned_events: List[Tuple[float, int]]
) -&gt; Tuple[float, float, Dict[float, float]]:
    transitions_ms: List[int] = []
    prev = truth_labels[0]
    for idx, lab in enumerate(truth_labels[1:], start=1):
        if lab != prev:
            transitions_ms.append(idx * TRUTH_DT_MS)
            prev = lab
    if not transitions_ms:
        return 0.0, 0.0, {tau: 0.0 for tau in TAU_VALUES_S}

    aligned_events_sorted = sorted(aligned_events, key=lambda x: x[0])
    tl_list_s: List[float] = []
    for t_ms in transitions_ms:
        idx = min(t_ms // TRUTH_DT_MS, len(truth_labels) - 1)
        true_label = truth_labels[idx]
        arrival: Optional[float] = None
        for ms, lbl in aligned_events_sorted:
            if ms &gt; t_ms and lbl == true_label:
                arrival = ms
                break
        if arrival is None:
            tl_list_s.append(float(&quot;inf&quot;))
        else:
            tl_list_s.append((arrival - t_ms) / 1000.0)

    finite = [x for x in tl_list_s if x != float(&quot;inf&quot;)]
    tl_mean = statistics.mean(finite) if finite else float(&quot;inf&quot;)
    tl_p95 = statistics.quantiles(finite, n=20)[18] if len(finite) &gt;= 20 else (max(finite) if finite else float(&quot;inf&quot;))
    pout: Dict[float, float] = {}
    for tau in TAU_VALUES_S:
        miss = sum(1 for x in tl_list_s if x == float(&quot;inf&quot;) or x &gt; tau)
        pout[tau] = miss / len(tl_list_s)
    return tl_mean, tl_p95, pout


def parse_txsd_summary(path: Path) -&gt; Optional[TxsdTrial]:
    m = TXSD_NAME_RE.match(path.name)
    if not m:
        return None
    trial_idx = int(m.group(&quot;idx&quot;))
    cond_id = int(m.group(&quot;cond&quot;))
    tag = m.group(&quot;tag&quot;)

    ms_total = None
    adv_count = None
    e_total_mj = None
    with path.open() as f:
        for line in f:
            if line.startswith(&quot;# summary&quot;):
                parts = [p.strip() for p in line.strip().split(&quot;,&quot;)]
                kv: Dict[str, str] = {}
                for p in parts:
                    if &quot;=&quot; in p:
                        k, v = p.split(&quot;=&quot;, 1)
                        kv[k.strip(&quot;# &quot;).strip()] = v.strip()
                ms_total = float(kv.get(&quot;ms_total&quot;)) if kv.get(&quot;ms_total&quot;) else None
                adv_count = int(kv.get(&quot;adv_count&quot;)) if kv.get(&quot;adv_count&quot;) else None
                e_total_mj = float(kv.get(&quot;E_total_mJ&quot;)) if kv.get(&quot;E_total_mJ&quot;) else None
                break
    if ms_total is None or adv_count is None or e_total_mj is None:
        return None
    if ms_total &lt;= 0:
        return None
    avg_power = e_total_mj / (ms_total / 1000.0)
    return TxsdTrial(
        path=path,
        mtime_s=path.stat().st_mtime,
        trial_idx=trial_idx,
        cond_id=cond_id,
        tag=tag,
        ms_total=ms_total,
        adv_count=adv_count,
        e_total_mj=e_total_mj,
        avg_power_mw=avg_power,
    )


def estimate_rx_tag_share100_time_est(events: List[RxEvent]) -&gt; Optional[float]:
    itv_by_step: Dict[int, int] = {}
    for e in events:
        if e.step_idx not in itv_by_step:
            itv_by_step[e.step_idx] = e.itv_ms
    n100 = sum(1 for v in itv_by_step.values() if v == 100)
    n500 = sum(1 for v in itv_by_step.values() if v == 500)
    denom_ms = n100 * 100 + n500 * 500
    if denom_ms &lt;= 0:
        return None
    return (n100 * 100) / denom_ms


def mean_std(xs: List[float]) -&gt; Tuple[float, float]:
    if not xs:
        return 0.0, 0.0
    if len(xs) == 1:
        return xs[0], 0.0
    return statistics.mean(xs), statistics.stdev(xs)


def condition_name(rx: RxTrial) -&gt; str:
    if rx.mode == &quot;F&quot;:
        if rx.fixed_itv == 100:
            return &quot;S4_fixed100&quot;
        if rx.fixed_itv == 500:
            return &quot;S4_fixed500&quot;
        raise ValueError(f&quot;unexpected fixed interval: {rx.fixed_itv}&quot;)
    if rx.mode == &quot;P&quot;:
        return &quot;S4_policy&quot;
    if rx.mode == &quot;A&quot;:
        return &quot;S4_ablation_u_shuf&quot;
    raise ValueError(f&quot;unexpected mode: {rx.mode}&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--txsd-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth-s4&quot;, type=Path, default=Path(&quot;Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv&quot;))
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    args = ap.parse_args()

    truth = read_truth_labels(args.truth_s4, args.n_steps)

    # RX
    rx_all: List[RxTrial] = []
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        try:
            rx_all.append(read_rx_trial(p))
        except Exception:
            continue
    rx_trials = select_balanced_window(rx_all)
    rx_trials.sort(key=lambda t: t.rx_id)

    # TXSD (by mtime order)
    txsd_all: List[TxsdTrial] = []
    for p in sorted(args.txsd_dir.glob(&quot;trial_*.csv&quot;)):
        tt = parse_txsd_summary(p)
        if not tt:
            continue
        if tt.ms_total &gt;= VALID_MIN_DURATION_MS:
            txsd_all.append(tt)
    txsd_all.sort(key=lambda t: t.mtime_s)
    if len(txsd_all) &lt; len(rx_trials):
        raise SystemExit(f&quot;not enough valid TXSD trials: {len(txsd_all)} &lt; {len(rx_trials)}&quot;)
    txsd_trials = txsd_all[-len(rx_trials) :]

    # Pair in chronological order (RX by rx_id, TXSD by mtime).
    pairs = list(zip(rx_trials, txsd_trials))

    # Repeat index in appearance order.
    rep_counter: Dict[str, int] = {}

    per_rows: List[Dict[str, object]] = []
    for rx, tx in pairs:
        cond = condition_name(rx)
        rep_counter[cond] = rep_counter.get(cond, 0) + 1
        rep_idx = rep_counter[cond]

        offset_ms, offset_n = estimate_offset_ms(rx.events)

        aligned_events: List[Tuple[float, int]] = []
        step_set: set[int] = set()
        for e in rx.events:
            t_ms = e.rx_ms + offset_ms
            if 0.0 &lt;= t_ms &lt; (args.n_steps * TRUTH_DT_MS):
                aligned_events.append((t_ms, e.truth_label))
            if e.step_idx &gt;= 0:
                step_set.add(e.step_idx)

        tl_mean, tl_p95, pout = compute_tl_and_pout(truth, aligned_events)

        rx_unique = len(step_set)
        pdr_unique = min(rx_unique, tx.adv_count) / tx.adv_count if tx.adv_count &gt; 0 else 0.0
        share100 = estimate_rx_tag_share100_time_est(rx.events)

        per_rows.append(
            {
                &quot;rx_trial_id&quot;: rx.rx_id,
                &quot;condition&quot;: cond,
                &quot;repeat_idx&quot;: rep_idx,
                &quot;mode&quot;: (&quot;POLICY&quot; if rx.mode == &quot;P&quot; else (&quot;ABL_U_SHUF&quot; if rx.mode == &quot;A&quot; else f&quot;FIXED_{rx.fixed_itv}&quot;)),
                &quot;rx_count&quot;: len(rx.events),
                &quot;rx_unique&quot;: rx_unique,
                &quot;adv_count&quot;: tx.adv_count,
                &quot;pdr_unique&quot;: round(pdr_unique, 6),
                &quot;rx_tag_share100_time_est&quot;: (round(share100, 6) if share100 is not None else &quot;&quot;),
                &quot;tl_mean_s&quot;: round(tl_mean, 6),
                &quot;tl_p95_s&quot;: round(tl_p95, 6),
                &quot;pout_1s&quot;: round(pout[1.0], 6),
                &quot;pout_2s&quot;: round(pout[2.0], 6),
                &quot;pout_3s&quot;: round(pout[3.0], 6),
                &quot;tl_time_offset_ms&quot;: round(offset_ms, 3),
                &quot;tl_time_offset_n&quot;: offset_n,
                &quot;txsd_ms_total&quot;: tx.ms_total,
                &quot;E_total_mJ&quot;: tx.e_total_mj,
                &quot;avg_power_mW&quot;: tx.avg_power_mw,
                &quot;txsd_mtime_s&quot;: round(tx.mtime_s, 3),
                &quot;txsd_path&quot;: str(tx.path),
                &quot;rx_path&quot;: str(rx.path),
            }
        )

    per_rows.sort(key=lambda r: int(r[&quot;rx_trial_id&quot;]))
    args.out_dir.mkdir(parents=True, exist_ok=True)
    per_path = args.out_dir / &quot;per_trial.csv&quot;
    with per_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(per_rows[0].keys()))
        w.writeheader()
        w.writerows(per_rows)

    # Summary by condition
    by_cond: Dict[str, List[Dict[str, object]]] = {}
    for r in per_rows:
        by_cond.setdefault(str(r[&quot;condition&quot;]), []).append(r)

    summary_rows: List[Dict[str, object]] = []
    for cond, rows in sorted(by_cond.items()):
        pout_1s_list = [float(r[&quot;pout_1s&quot;]) for r in rows]
        tl_list = [float(r[&quot;tl_mean_s&quot;]) for r in rows]
        pdr_list = [float(r[&quot;pdr_unique&quot;]) for r in rows]
        pwr_list = [float(r[&quot;avg_power_mW&quot;]) for r in rows]
        adv_list = [float(r[&quot;adv_count&quot;]) for r in rows]
        share_list = [float(r[&quot;rx_tag_share100_time_est&quot;]) for r in rows if r[&quot;rx_tag_share100_time_est&quot;] != &quot;&quot;]

        pout_m, pout_s = mean_std(pout_1s_list)
        tl_m, tl_s = mean_std(tl_list)
        pdr_m, pdr_s = mean_std(pdr_list)
        pwr_m, pwr_s = mean_std(pwr_list)
        adv_m, adv_s = mean_std(adv_list)
        sh_m, sh_s = mean_std(share_list) if share_list else (0.0, 0.0)

        summary_rows.append(
            {
                &quot;condition&quot;: cond,
                &quot;n_trials&quot;: len(rows),
                &quot;pout_1s_mean&quot;: round(pout_m, 6),
                &quot;pout_1s_std&quot;: round(pout_s, 6),
                &quot;tl_mean_s_mean&quot;: round(tl_m, 6),
                &quot;tl_mean_s_std&quot;: round(tl_s, 6),
                &quot;pdr_unique_mean&quot;: round(pdr_m, 6),
                &quot;pdr_unique_std&quot;: round(pdr_s, 6),
                &quot;rx_tag_share100_time_est_mean&quot;: (round(sh_m, 6) if share_list else &quot;&quot;),
                &quot;rx_tag_share100_time_est_std&quot;: (round(sh_s, 6) if share_list else &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: round(pwr_m, 3),
                &quot;avg_power_mW_std&quot;: round(pwr_s, 3),
                &quot;adv_count_mean&quot;: round(adv_m, 3),
                &quot;adv_count_std&quot;: round(adv_s, 3),
            }
        )

    sum_path = args.out_dir / &quot;summary_by_condition.csv&quot;
    with sum_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(summary_rows[0].keys()))
        w.writeheader()
        w.writerows(summary_rows)

    # Markdown summary
    lines: List[str] = []
    lines.append(&quot;# uccs_d4_scan90 metrics summary (v2)\n\n&quot;)
    lines.append(f&quot;- source RX: `{args.rx_dir}`\n&quot;)
    lines.append(f&quot;- source TXSD: `{args.txsd_dir}`\n&quot;)
    lines.append(f&quot;- truth: `{args.truth_s4}` (n_steps={args.n_steps}, dt=100ms)\n&quot;)
    lines.append(
        f&quot;- selected RX trials: {rx_trials[0].rx_id:03d}..{rx_trials[-1].rx_id:03d} (n={len(rx_trials)})\n&quot;
    )
    lines.append(
        f&quot;- selected TXSD trials (by mtime): {Path(txsd_trials[0].path).name} .. {Path(txsd_trials[-1].path).name} (n={len(txsd_trials)})\n&quot;
    )
    lines.append(f&quot;- generated: {datetime.now().strftime(&apos;%Y-%m-%d %H:%M&apos;)} (local)\n&quot;)
    lines.append(
        f&quot;- command: `python3 uccs_d4_scan90/analysis/summarize_d4_run_v2.py --rx-dir {args.rx_dir} --txsd-dir {args.txsd_dir} --out-dir {args.out_dir}`\n&quot;
    )
    lines.append(&quot;\n## Summary (mean ± std)\n&quot;)
    lines.append(&quot;| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |\n&quot;)
    lines.append(&quot;|---|---:|---:|---:|---:|---:|---:|\n&quot;)

    def fmt_pm(m: object, s: object, decimals: int) -&gt; str:
        if m == &quot;&quot; or s == &quot;&quot;:
            return &quot;&quot;
        return f&quot;{float(m):.{decimals}f}±{float(s):.{decimals}f}&quot;

    for r in summary_rows:
        lines.append(
            f&quot;| {r[&apos;condition&apos;]} | {fmt_pm(r[&apos;pout_1s_mean&apos;], r[&apos;pout_1s_std&apos;], 4)} | &quot;
            f&quot;{fmt_pm(r[&apos;tl_mean_s_mean&apos;], r[&apos;tl_mean_s_std&apos;], 3)} | &quot;
            f&quot;{fmt_pm(r[&apos;pdr_unique_mean&apos;], r[&apos;pdr_unique_std&apos;], 3)} | &quot;
            f&quot;{fmt_pm(r[&apos;avg_power_mW_mean&apos;], r[&apos;avg_power_mW_std&apos;], 1)} | &quot;
            f&quot;{fmt_pm(r[&apos;adv_count_mean&apos;], r[&apos;adv_count_std&apos;], 1)} | &quot;
            f&quot;{fmt_pm(r[&apos;rx_tag_share100_time_est_mean&apos;], r[&apos;rx_tag_share100_time_est_std&apos;], 3) if r.get(&apos;rx_tag_share100_time_est_mean&apos;,&apos;&apos;)!=&apos;&apos; else &apos;&apos;} |&quot;
            &quot;\n&quot;
        )

    lines.append(&quot;\n## Notes\n&quot;)
    lines.append(&quot;- RX window: latest 12 trials that form 4 conditions × 3 repeats (duration&gt;=160s).\n&quot;)
    lines.append(&quot;- TXSD pairing: last 12 TXSD trials by file modification time; zipped in order with RX window.\n&quot;)
    lines.append(&quot;- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).\n&quot;)
    lines.append(&quot;- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique.\n&quot;)
    lines.append(&quot;- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).\n&quot;)

    md_path = args.out_dir / &quot;summary.md&quot;
    md_path.write_text(&quot;&quot;.join(lines), encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4_scan90/analysis/summarize_d4_run.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Summarize uccs_d4_scan90 run (RX + TXSD) and compute TL/Pout using step_idx-aligned payload.

Step D4 idea:
  - TX ManufacturerData is &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;, where step_idx is the 100ms truth grid index.
  - Tag includes mode:
      F4-&lt;label&gt;-&lt;itv&gt;  (fixed)
      P4-&lt;label&gt;-&lt;itv&gt;  (policy U+CCS)
      A4-&lt;label&gt;-&lt;itv&gt;  (ablation: U-shuffle)
  - Align RX time to truth time via a constant offset:
      offset_ms = median(step_idx*100 - first_rx_ms(step_idx))
  - Then compute TL/Pout on truth-time axis (100ms grid).

Inputs:
  - RX:  uccs_d4_scan90/data/&lt;run&gt;/RX/rx_trial_*.csv
  - TXSD: uccs_d4_scan90/data/&lt;run&gt;/TX/trial_*.csv (copied SD:/logs)
  - truth: Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv

Outputs (out_dir):
  - per_trial.csv
  - summary_by_condition.csv
  - summary.md
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import re
import statistics
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


TRUTH_DT_MS = 100
TAU_VALUES_S = (1.0, 2.0, 3.0)
VALID_MIN_DURATION_MS = 160_000  # ~180s trials

TAG_RE = re.compile(r&quot;^(?P&lt;mode&gt;[FPA])(?P&lt;sess&gt;[14])-(?P&lt;label&gt;\d+)-(?P&lt;itv&gt;\d+)$&quot;)
RX_TRIAL_RE = re.compile(r&quot;rx_trial_(?P&lt;id&gt;\d+)\.csv$&quot;)
TXSD_NAME_RE = re.compile(r&quot;trial_(?P&lt;idx&gt;\d+)_c(?P&lt;cond&gt;\d+)_(?P&lt;tag&gt;.+)\.csv$&quot;)


@dataclass(frozen=True)
class RxEvent:
    rx_ms: float
    step_idx: int
    tag: str


@dataclass
class RxTrial:
    rx_id: int
    path: Path
    duration_ms: float
    session: int  # 1 or 4
    mode: str  # &quot;F&quot; / &quot;P&quot; / &quot;A&quot;
    fixed_itv: Optional[int]  # 100/500 if fixed, else None
    events: List[RxEvent]


@dataclass
class TxsdTrial:
    path: Path
    trial_idx: int
    cond_id: int
    tag: str
    ms_total: float
    adv_count: int
    e_total_mj: float
    avg_power_mw: float
    kind: str = &quot;unk&quot;  # fixed100/fixed500/policy/ablation/unk


def read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def read_rx_trial(path: Path) -&gt; RxTrial:
    m = RX_TRIAL_RE.search(path.name)
    if not m:
        raise ValueError(f&quot;not rx_trial: {path}&quot;)
    rx_id = int(m.group(&quot;id&quot;))

    events: List[RxEvent] = []
    last_ms: float = 0.0

    mode_c: Dict[str, int] = {&quot;F&quot;: 0, &quot;P&quot;: 0, &quot;A&quot;: 0}
    sess_c: Dict[int, int] = {1: 0, 4: 0}
    itv_c: Dict[int, int] = {}

    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or 0.0)
            except Exception:
                continue
            last_ms = max(last_ms, rx_ms)

            try:
                step_idx = int(row.get(&quot;seq&quot;) or 0)
            except Exception:
                continue

            tag = (row.get(&quot;label&quot;) or &quot;&quot;).strip()
            if tag:
                tm = TAG_RE.match(tag)
                if tm:
                    mode_c[tm.group(&quot;mode&quot;)] += 1
                    sess_c[int(tm.group(&quot;sess&quot;))] += 1
                    itv = int(tm.group(&quot;itv&quot;))
                    itv_c[itv] = itv_c.get(itv, 0) + 1

            events.append(RxEvent(rx_ms=rx_ms, step_idx=step_idx, tag=tag))

    if not events:
        raise ValueError(f&quot;empty RX: {path}&quot;)

    # robust majority
    mode = max(mode_c.items(), key=lambda kv: kv[1])[0]
    session = 4 if sess_c[4] &gt;= sess_c[1] else 1

    fixed_itv: Optional[int] = None
    if mode == &quot;F&quot;:
        if not itv_c:
            raise ValueError(f&quot;cannot infer fixed interval from tags: {path}&quot;)
        fixed_itv = max(itv_c.items(), key=lambda kv: kv[1])[0]

    return RxTrial(
        rx_id=rx_id,
        path=path,
        duration_ms=last_ms,
        session=session,
        mode=mode,
        fixed_itv=fixed_itv,
        events=events,
    )


def _rx_bucket(t: RxTrial) -&gt; str:
    if t.mode == &quot;P&quot;:
        return f&quot;P{t.session}&quot;
    if t.mode == &quot;A&quot;:
        return f&quot;A{t.session}&quot;
    return f&quot;F{t.session}_{t.fixed_itv}&quot;


def select_balanced_window(trials: List[RxTrial]) -&gt; List[RxTrial]:
    &quot;&quot;&quot;
    Pick the latest contiguous window that forms 4 conditions × 3 repeats = 12 trials (S4 only).
    Buckets required: F4_100, F4_500, P4, A4.
    &quot;&quot;&quot;
    candidates = [t for t in trials if t.duration_ms &gt;= VALID_MIN_DURATION_MS]
    candidates.sort(key=lambda t: t.rx_id)
    if len(candidates) &lt; 12:
        raise SystemExit(f&quot;not enough valid RX trials (&gt;= {VALID_MIN_DURATION_MS}ms): {len(candidates)}&quot;)

    want = {&quot;F4_100&quot;, &quot;F4_500&quot;, &quot;P4&quot;, &quot;A4&quot;}
    best: Optional[List[RxTrial]] = None
    for start in range(0, len(candidates) - 12 + 1):
        window = candidates[start : start + 12]
        counts: Dict[str, int] = {}
        for t in window:
            counts[_rx_bucket(t)] = counts.get(_rx_bucket(t), 0) + 1
        if set(counts.keys()) == want and all(v == 3 for v in counts.values()):
            best = window  # latest wins
    if not best:
        raise SystemExit(&quot;could not find balanced 12-trial window (F4_100/F4_500/P4/A4 × 3 repeats)&quot;)
    return best


def estimate_offset_ms(events: List[RxEvent]) -&gt; Tuple[float, int]:
    first_ms: Dict[int, float] = {}
    for e in sorted(events, key=lambda x: x.rx_ms):
        if e.step_idx not in first_ms:
            first_ms[e.step_idx] = e.rx_ms
    deltas: List[float] = []
    for step, ms in first_ms.items():
        if step &lt;= 0:
            continue
        deltas.append(step * TRUTH_DT_MS - ms)
    if not deltas:
        return 0.0, 0
    return statistics.median(deltas), len(deltas)


def compute_tl_and_pout(
    truth_labels: List[int], aligned_events: List[Tuple[float, int]]
) -&gt; Tuple[float, float, Dict[float, float]]:
    transitions_ms: List[int] = []
    prev = truth_labels[0]
    for idx, lab in enumerate(truth_labels[1:], start=1):
        if lab != prev:
            transitions_ms.append(idx * TRUTH_DT_MS)
            prev = lab
    if not transitions_ms:
        return 0.0, 0.0, {tau: 0.0 for tau in TAU_VALUES_S}

    aligned_events_sorted = sorted(aligned_events, key=lambda x: x[0])
    tl_list_s: List[float] = []
    for t_ms in transitions_ms:
        idx = min(t_ms // TRUTH_DT_MS, len(truth_labels) - 1)
        true_label = truth_labels[idx]
        arrival: Optional[float] = None
        for ms, lbl in aligned_events_sorted:
            if ms &gt; t_ms and lbl == true_label:
                arrival = ms
                break
        if arrival is None:
            tl_list_s.append(float(&quot;inf&quot;))
        else:
            tl_list_s.append((arrival - t_ms) / 1000.0)

    finite = [x for x in tl_list_s if x != float(&quot;inf&quot;)]
    tl_mean = statistics.mean(finite) if finite else float(&quot;inf&quot;)
    tl_p95 = statistics.quantiles(finite, n=20)[18] if len(finite) &gt;= 20 else (max(finite) if finite else float(&quot;inf&quot;))
    pout: Dict[float, float] = {}
    for tau in TAU_VALUES_S:
        if not tl_list_s:
            pout[tau] = 0.0
        else:
            miss = sum(1 for x in tl_list_s if x == float(&quot;inf&quot;) or x &gt; tau)
            pout[tau] = miss / len(tl_list_s)
    return tl_mean, tl_p95, pout


def parse_txsd_summary(path: Path) -&gt; Optional[TxsdTrial]:
    m = TXSD_NAME_RE.match(path.name)
    if not m:
        return None
    trial_idx = int(m.group(&quot;idx&quot;))
    cond_id = int(m.group(&quot;cond&quot;))
    tag = m.group(&quot;tag&quot;)

    ms_total = None
    adv_count = None
    e_total_mj = None
    with path.open() as f:
        for line in f:
            if line.startswith(&quot;# summary&quot;):
                parts = [p.strip() for p in line.strip().split(&quot;,&quot;)]
                kv: Dict[str, str] = {}
                for p in parts:
                    if &quot;=&quot; in p:
                        k, v = p.split(&quot;=&quot;, 1)
                        kv[k.strip(&quot;# &quot;).strip()] = v.strip()
                ms_total = float(kv.get(&quot;ms_total&quot;)) if kv.get(&quot;ms_total&quot;) else None
                adv_count = int(kv.get(&quot;adv_count&quot;)) if kv.get(&quot;adv_count&quot;) else None
                e_total_mj = float(kv.get(&quot;E_total_mJ&quot;)) if kv.get(&quot;E_total_mJ&quot;) else None
                break
    if ms_total is None or adv_count is None or e_total_mj is None:
        return None
    if ms_total &lt;= 0:
        return None
    avg_power = e_total_mj / (ms_total / 1000.0)
    return TxsdTrial(
        path=path,
        trial_idx=trial_idx,
        cond_id=cond_id,
        tag=tag,
        ms_total=ms_total,
        adv_count=adv_count,
        e_total_mj=e_total_mj,
        avg_power_mw=avg_power,
    )


def infer_txsd_kind(t: TxsdTrial) -&gt; None:
    name = t.path.name.lower()
    tag = t.tag.lower()

    # Prefer explicit cond_id/tag when available.
    if t.cond_id == 1 or &quot;fixed100&quot; in name or &quot;fixed100&quot; in tag:
        t.kind = &quot;fixed100&quot;
        return
    if t.cond_id == 2 or &quot;fixed500&quot; in name or &quot;fixed500&quot; in tag:
        t.kind = &quot;fixed500&quot;
        return
    if t.cond_id == 3 or (&quot;policy&quot; in name or &quot;policy&quot; in tag):
        t.kind = &quot;policy&quot;
        return
    if t.cond_id == 4 or (&quot;ablation&quot; in name or &quot;ushuf&quot; in name or &quot;ushuf&quot; in tag):
        t.kind = &quot;ablation&quot;
        return

    # Fallback by adv_count
    if 300 &lt;= t.adv_count &lt;= 450:
        t.kind = &quot;fixed500&quot;
        return
    if 1750 &lt;= t.adv_count &lt;= 1850:
        t.kind = &quot;fixed100&quot;
        return
    t.kind = &quot;unk&quot;


def estimate_rx_tag_share100_time_est(events: List[RxEvent]) -&gt; Optional[float]:
    rx_itv_by_step: Dict[int, int] = {}
    for e in events:
        step = e.step_idx
        if step &lt; 0:
            continue
        tm = TAG_RE.match(e.tag)
        if tm and step not in rx_itv_by_step:
            try:
                rx_itv_by_step[step] = int(tm.group(&quot;itv&quot;))
            except Exception:
                pass
    n100 = sum(1 for v in rx_itv_by_step.values() if v == 100)
    n500 = sum(1 for v in rx_itv_by_step.values() if v == 500)
    denom_ms = n100 * 100 + n500 * 500
    if denom_ms &lt;= 0:
        return None
    return (n100 * 100) / denom_ms


def mean_std(xs: List[float]) -&gt; Tuple[float, float]:
    if not xs:
        return 0.0, 0.0
    if len(xs) == 1:
        return xs[0], 0.0
    return statistics.mean(xs), statistics.stdev(xs)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--txsd-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth-s4&quot;, type=Path, default=Path(&quot;Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv&quot;))
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    args = ap.parse_args()

    truth = read_truth_labels(args.truth_s4, args.n_steps)

    rx_trials_all: List[RxTrial] = []
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        try:
            rx_trials_all.append(read_rx_trial(p))
        except ValueError:
            continue
    rx_trials = select_balanced_window(rx_trials_all)

    # TXSD trials
    txsd_trials: List[TxsdTrial] = []
    for p in sorted(args.txsd_dir.glob(&quot;trial_*.csv&quot;)):
        tt = parse_txsd_summary(p)
        if not tt:
            continue
        infer_txsd_kind(tt)
        if tt.ms_total &gt;= VALID_MIN_DURATION_MS:
            txsd_trials.append(tt)

    # Policy-like unknown recovery (optional): use RX-derived share targets to label missing policy/ablation.
    fixed100_counts = [t.adv_count for t in txsd_trials if t.kind == &quot;fixed100&quot;]
    fixed500_counts = [t.adv_count for t in txsd_trials if t.kind == &quot;fixed500&quot;]
    adv_fixed100 = statistics.median(fixed100_counts) if fixed100_counts else None
    adv_fixed500 = statistics.median(fixed500_counts) if fixed500_counts else None
    rx_share_policy = statistics.mean(
        [s for s in (estimate_rx_tag_share100_time_est(t.events) for t in rx_trials) if s is not None and t.mode == &quot;P&quot;]
    ) if any(t.mode == &quot;P&quot; for t in rx_trials) else None
    rx_share_ablation = statistics.mean(
        [s for s in (estimate_rx_tag_share100_time_est(t.events) for t in rx_trials) if s is not None and t.mode == &quot;A&quot;]
    ) if any(t.mode == &quot;A&quot; for t in rx_trials) else None
    if adv_fixed100 is not None and adv_fixed500 is not None and adv_fixed100 &gt; adv_fixed500 and rx_share_policy is not None and rx_share_ablation is not None:
        denom = adv_fixed100 - adv_fixed500
        for t in txsd_trials:
            if t.kind != &quot;unk&quot;:
                continue
            share_tx = (t.adv_count - adv_fixed500) / denom
            d_pol = abs(share_tx - rx_share_policy)
            d_abl = abs(share_tx - rx_share_ablation)
            best = &quot;policy&quot; if d_pol &lt;= d_abl else &quot;ablation&quot;
            if min(d_pol, d_abl) &lt;= 0.15:
                t.kind = best

    # Group RX/TXSD by condition
    def rx_cond_key(t: RxTrial) -&gt; str:
        if t.session != 4:
            return &quot;UNK&quot;
        if t.mode == &quot;F&quot; and t.fixed_itv == 100:
            return &quot;S4_fixed100&quot;
        if t.mode == &quot;F&quot; and t.fixed_itv == 500:
            return &quot;S4_fixed500&quot;
        if t.mode == &quot;P&quot;:
            return &quot;S4_policy&quot;
        if t.mode == &quot;A&quot;:
            return &quot;S4_ablation_u_shuf&quot;
        return &quot;UNK&quot;

    def tx_cond_key(t: TxsdTrial) -&gt; str:
        if t.kind == &quot;fixed100&quot;:
            return &quot;S4_fixed100&quot;
        if t.kind == &quot;fixed500&quot;:
            return &quot;S4_fixed500&quot;
        if t.kind == &quot;policy&quot;:
            return &quot;S4_policy&quot;
        if t.kind == &quot;ablation&quot;:
            return &quot;S4_ablation_u_shuf&quot;
        return &quot;UNK&quot;

    rx_by_cond: Dict[str, List[RxTrial]] = {}
    for t in rx_trials:
        rx_by_cond.setdefault(rx_cond_key(t), []).append(t)
    for v in rx_by_cond.values():
        v.sort(key=lambda t: t.rx_id)

    tx_by_cond: Dict[str, List[TxsdTrial]] = {}
    for t in txsd_trials:
        k = tx_cond_key(t)
        if k != &quot;UNK&quot;:
            tx_by_cond.setdefault(k, []).append(t)
    for v in tx_by_cond.values():
        v.sort(key=lambda t: (t.trial_idx, t.cond_id, t.path.name))

    args.out_dir.mkdir(parents=True, exist_ok=True)

    # Per-trial table (paired within condition by order)
    per_rows: List[Dict[str, object]] = []
    for cond, rx_list in rx_by_cond.items():
        tx_list = tx_by_cond.get(cond, [])
        n_pair = len(rx_list) if not tx_list else min(len(rx_list), len(tx_list))
        for i in range(n_pair):
            rx = rx_list[i]
            tx = tx_list[i] if i &lt; len(tx_list) else None

            offset_ms, offset_n = estimate_offset_ms(rx.events)
            aligned_events: List[Tuple[float, int]] = []
            step_set = set()
            rx_itv_by_step: Dict[int, int] = {}
            for e in rx.events:
                step = e.step_idx
                if 0 &lt;= step &lt; args.n_steps:
                    aligned_events.append((e.rx_ms + offset_ms, truth[step]))
                    step_set.add(step)
                    tm = TAG_RE.match(e.tag)
                    if tm and step not in rx_itv_by_step:
                        try:
                            rx_itv_by_step[step] = int(tm.group(&quot;itv&quot;))
                        except Exception:
                            pass

            rx_tag_n100 = sum(1 for v in rx_itv_by_step.values() if v == 100)
            rx_tag_n500 = sum(1 for v in rx_itv_by_step.values() if v == 500)
            rx_tag_share100_time_est = &quot;&quot;
            denom_ms = rx_tag_n100 * 100 + rx_tag_n500 * 500
            if denom_ms &gt; 0:
                rx_tag_share100_time_est = (rx_tag_n100 * 100) / denom_ms

            tl_mean, tl_p95, pout = compute_tl_and_pout(truth, aligned_events)

            rx_count = len(rx.events)
            rx_unique = len(step_set)
            adv_count = tx.adv_count if tx else &quot;&quot;
            pdr_unique = (
                (min(rx_unique, adv_count) / adv_count) if isinstance(adv_count, int) and adv_count &gt; 0 else &quot;&quot;
            )

            per_rows.append(
                {
                    &quot;rx_trial_id&quot;: rx.rx_id,
                    &quot;condition&quot;: cond,
                    &quot;repeat_idx&quot;: i + 1,
                    &quot;mode&quot;: (&quot;POLICY&quot; if rx.mode == &quot;P&quot; else (&quot;ABL_U_SHUF&quot; if rx.mode == &quot;A&quot; else f&quot;FIXED_{rx.fixed_itv}&quot;)),
                    &quot;rx_count&quot;: rx_count,
                    &quot;rx_unique&quot;: rx_unique,
                    &quot;adv_count&quot;: adv_count,
                    &quot;pdr_unique&quot;: round(pdr_unique, 6) if pdr_unique != &quot;&quot; else &quot;&quot;,
                    &quot;rx_tag_n100&quot;: rx_tag_n100,
                    &quot;rx_tag_n500&quot;: rx_tag_n500,
                    &quot;rx_tag_share100_time_est&quot;: (
                        round(rx_tag_share100_time_est, 6) if rx_tag_share100_time_est != &quot;&quot; else &quot;&quot;
                    ),
                    &quot;tl_mean_s&quot;: round(tl_mean, 6),
                    &quot;tl_p95_s&quot;: round(tl_p95, 6),
                    &quot;pout_1s&quot;: round(pout[1.0], 6),
                    &quot;pout_2s&quot;: round(pout[2.0], 6),
                    &quot;pout_3s&quot;: round(pout[3.0], 6),
                    &quot;tl_time_offset_ms&quot;: round(offset_ms, 3),
                    &quot;tl_time_offset_n&quot;: offset_n,
                    &quot;txsd_ms_total&quot;: tx.ms_total if tx else &quot;&quot;,
                    &quot;E_total_mJ&quot;: tx.e_total_mj if tx else &quot;&quot;,
                    &quot;avg_power_mW&quot;: tx.avg_power_mw if tx else &quot;&quot;,
                    &quot;txsd_path&quot;: str(tx.path) if tx else &quot;&quot;,
                    &quot;rx_path&quot;: str(rx.path),
                }
            )

    per_rows.sort(key=lambda r: int(r[&quot;rx_trial_id&quot;]))
    per_path = args.out_dir / &quot;per_trial.csv&quot;
    with per_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(per_rows[0].keys()))
        w.writeheader()
        w.writerows(per_rows)

    # Summary by condition
    by_cond: Dict[str, List[Dict[str, object]]] = {}
    for r in per_rows:
        by_cond.setdefault(str(r[&quot;condition&quot;]), []).append(r)

    summary_rows: List[Dict[str, object]] = []
    for cond, rows in sorted(by_cond.items()):
        pout_1s_list = [float(r[&quot;pout_1s&quot;]) for r in rows if r[&quot;pout_1s&quot;] != &quot;&quot;]
        tl_list = [float(r[&quot;tl_mean_s&quot;]) for r in rows if r[&quot;tl_mean_s&quot;] != &quot;&quot;]
        pdr_list = [float(r[&quot;pdr_unique&quot;]) for r in rows if r[&quot;pdr_unique&quot;] != &quot;&quot;]
        pwr_list = [float(r[&quot;avg_power_mW&quot;]) for r in rows if r[&quot;avg_power_mW&quot;] != &quot;&quot;]
        adv_list = [float(r[&quot;adv_count&quot;]) for r in rows if isinstance(r[&quot;adv_count&quot;], int)]
        share100_list = [
            float(r[&quot;rx_tag_share100_time_est&quot;]) for r in rows if r[&quot;rx_tag_share100_time_est&quot;] != &quot;&quot;
        ]

        pout_m, pout_s = mean_std(pout_1s_list)
        tl_m, tl_s = mean_std(tl_list)
        pdr_m, pdr_s = mean_std(pdr_list)
        pwr_m, pwr_s = mean_std(pwr_list)
        adv_m, adv_s = mean_std(adv_list)
        sh_m, sh_s = mean_std(share100_list)

        summary_rows.append(
            {
                &quot;condition&quot;: cond,
                &quot;n_trials&quot;: len(rows),
                &quot;pout_1s_mean&quot;: round(pout_m, 6),
                &quot;pout_1s_std&quot;: round(pout_s, 6),
                &quot;tl_mean_s_mean&quot;: round(tl_m, 6),
                &quot;tl_mean_s_std&quot;: round(tl_s, 6),
                &quot;pdr_unique_mean&quot;: round(pdr_m, 6) if pdr_list else &quot;&quot;,
                &quot;pdr_unique_std&quot;: round(pdr_s, 6) if pdr_list else &quot;&quot;,
                &quot;rx_tag_share100_time_est_mean&quot;: round(sh_m, 6) if share100_list else &quot;&quot;,
                &quot;rx_tag_share100_time_est_std&quot;: round(sh_s, 6) if share100_list else &quot;&quot;,
                &quot;avg_power_mW_mean&quot;: round(pwr_m, 3) if pwr_list else &quot;&quot;,
                &quot;avg_power_mW_std&quot;: round(pwr_s, 3) if pwr_list else &quot;&quot;,
                &quot;adv_count_mean&quot;: round(adv_m, 3) if adv_list else &quot;&quot;,
                &quot;adv_count_std&quot;: round(adv_s, 3) if adv_list else &quot;&quot;,
            }
        )

    sum_path = args.out_dir / &quot;summary_by_condition.csv&quot;
    with sum_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(summary_rows[0].keys()))
        w.writeheader()
        w.writerows(summary_rows)

    # Markdown summary
    lines: List[str] = []
    lines.append(&quot;# uccs_d4_scan90 metrics summary\n\n&quot;)
    lines.append(f&quot;- source RX: `{args.rx_dir}`\n&quot;)
    lines.append(f&quot;- source TXSD: `{args.txsd_dir}`\n&quot;)
    lines.append(f&quot;- truth: `{args.truth_s4}` (n_steps={args.n_steps}, dt=100ms)\n&quot;)
    lines.append(
        f&quot;- selected RX trials: {rx_trials[0].rx_id:03d}..{rx_trials[-1].rx_id:03d} (n={len(rx_trials)})\n&quot;
    )
    lines.append(f&quot;- generated: {datetime.now().strftime(&apos;%Y-%m-%d %H:%M&apos;)} (local)\n&quot;)
    lines.append(
        f&quot;- command: `python3 uccs_d4_scan90/analysis/summarize_d4_run.py --rx-dir {args.rx_dir} --txsd-dir {args.txsd_dir} --out-dir {args.out_dir}`\n&quot;
    )
    lines.append(&quot;\n## Summary (mean ± std)\n&quot;)
    lines.append(&quot;| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |\n&quot;)
    lines.append(&quot;|---|---:|---:|---:|---:|---:|---:|\n&quot;)
    for r in summary_rows:
        def fmt_pm(mean_key: str, std_key: str, decimals: int = 4) -&gt; str:
            m = r.get(mean_key, &quot;&quot;)
            s = r.get(std_key, &quot;&quot;)
            if m == &quot;&quot; or s == &quot;&quot;:
                return &quot;&quot;
            return f&quot;{float(m):.{decimals}f}±{float(s):.{decimals}f}&quot;

        pout = fmt_pm(&quot;pout_1s_mean&quot;, &quot;pout_1s_std&quot;, 4)
        tl = fmt_pm(&quot;tl_mean_s_mean&quot;, &quot;tl_mean_s_std&quot;, 3)
        pdr = fmt_pm(&quot;pdr_unique_mean&quot;, &quot;pdr_unique_std&quot;, 3) if r.get(&quot;pdr_unique_mean&quot;, &quot;&quot;) != &quot;&quot; else &quot;&quot;
        pwr = fmt_pm(&quot;avg_power_mW_mean&quot;, &quot;avg_power_mW_std&quot;, 1) if r.get(&quot;avg_power_mW_mean&quot;, &quot;&quot;) != &quot;&quot; else &quot;&quot;
        adv = fmt_pm(&quot;adv_count_mean&quot;, &quot;adv_count_std&quot;, 1) if r.get(&quot;adv_count_mean&quot;, &quot;&quot;) != &quot;&quot; else &quot;&quot;
        sh = fmt_pm(&quot;rx_tag_share100_time_est_mean&quot;, &quot;rx_tag_share100_time_est_std&quot;, 3) if r.get(&quot;rx_tag_share100_time_est_mean&quot;, &quot;&quot;) != &quot;&quot; else &quot;&quot;
        lines.append(f&quot;| {r[&apos;condition&apos;]} | {pout} | {tl} | {pdr} | {pwr} | {adv} | {sh} |\n&quot;)

    lines.append(&quot;\n## Notes\n&quot;)
    lines.append(&quot;- RX trial selection: latest 12 trials that form 4 conditions × 3 repeats (duration&gt;=160s).\n&quot;)
    lines.append(&quot;- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).\n&quot;)
    lines.append(&quot;- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique when available.\n&quot;)
    lines.append(&quot;- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).\n&quot;)

    md_path = args.out_dir / &quot;summary.md&quot;
    md_path.write_text(&quot;&quot;.join(lines), encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4_scan90/metrics/01/effects_ci.csv">metric,cond_a,cond_b,label,n_a,n_b,mean_a,mean_b,delta_mean,ci_low,ci_high,p_two_sided,n_boot,alpha,seed,generated_local,source_csv
avg_power_mW,S4_policy,S4_ablation_u_shuf,Δpower_mW (policy − U-shuf),3,3,200.53050596988783,208.1082346520751,-7.577728682187285,-8.387487258529745,-6.926056002554532,0.0,20000,0.05,20251217,2025-12-17 10:56,uccs_d4_scan90/metrics/01/per_trial.csv
pout_1s,S4_policy,S4_ablation_u_shuf,Δpout (policy − U-shuf),3,3,0.09756100000000001,0.04878,0.04878100000000001,0.024391000000000003,0.07317099999999999,0.0,20000,0.05,20251217,2025-12-17 10:56,uccs_d4_scan90/metrics/01/per_trial.csv</file><file path="uccs_d4_scan90/metrics/01/effects_ci.md"># effects_ci: D4 scan90 S4 (run01)

- source: `uccs_d4_scan90/metrics/01/per_trial.csv`
- generated: 2025-12-17 10:56 (local)
- bootstrap: percentile CI, n_boot=20000, alpha=0.05, seed=20251217

| label | delta(mean) | 95% CI | p(two-sided) |
|---|---:|---:|---:|
| Δpower_mW (policy − U-shuf) | -7.5777 | [-8.3875, -6.9261] | 0.0000 |
| Δpout (policy − U-shuf) | 0.0488 | [0.0244, 0.0732] | 0.0000 |</file><file path="uccs_d4_scan90/metrics/01/per_trial.csv">rx_trial_id,condition,repeat_idx,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_mtime_s,txsd_path,rx_path
1,S4_fixed100,1,FIXED_100,1406,1406,1796,0.782851,1.0,1.247732,13.6733,0.04878,0.04878,0.04878,-1247.0,1405,181462.0,37557.87,206.97374656952974,315500596.0,uccs_d4_scan90/data/01/TX/trial_003_c1_s4_fixed100.csv,uccs_d4_scan90/data/01/RX/rx_trial_001.csv
2,S4_fixed500,1,FIXED_500,293,293,359,0.816156,0.000684,1.629675,15.2854,0.121951,0.121951,0.121951,-699.0,293,179643.0,33730.189,187.7623341850225,315500782.0,uccs_d4_scan90/data/01/TX/trial_001_c3_s4_policy.csv,uccs_d4_scan90/data/01/RX/rx_trial_002.csv
3,S4_policy,1,POLICY,966,965,1227,0.786471,0.596491,1.293976,13.9341,0.121951,0.04878,0.04878,-931.0,965,180903.0,36117.799,199.6528471059076,315500970.0,uccs_d4_scan90/data/01/TX/trial_001_c4_s4_ablation_ushuf.csv,uccs_d4_scan90/data/01/RX/rx_trial_003.csv
4,S4_ablation_u_shuf,1,ABL_U_SHUF,1338,1338,1715,0.780175,0.942939,1.234524,13.6617,0.04878,0.04878,0.04878,-1178.5,1338,181370.0,37797.006,208.39723217731708,315501156.0,uccs_d4_scan90/data/01/TX/trial_001_c5_unk.csv,uccs_d4_scan90/data/01/RX/rx_trial_004.csv
5,S4_fixed100,2,FIXED_100,1408,1406,1796,0.782851,1.0,1.232451,13.641,0.04878,0.04878,0.04878,-1205.5,1406,181475.0,38015.021,209.47800523488084,315501344.0,uccs_d4_scan90/data/01/TX/trial_001_c2_s4_fixed500.csv,uccs_d4_scan90/data/01/RX/rx_trial_005.csv
6,S4_fixed500,2,FIXED_500,293,293,359,0.816156,0.000684,1.52135,15.2484,0.121951,0.097561,0.097561,-690.0,293,179625.0,33907.168,188.76641892832288,315501530.0,uccs_d4_scan90/data/01/TX/trial_002_c3_s4_policy.csv,uccs_d4_scan90/data/01/RX/rx_trial_006.csv
7,S4_policy,2,POLICY,968,967,1227,0.788101,0.599438,1.272024,13.9467,0.097561,0.04878,0.04878,-910.0,967,180893.0,36330.713,200.84090042179633,315501716.0,uccs_d4_scan90/data/01/TX/trial_002_c4_s4_ablation_ushuf.csv,uccs_d4_scan90/data/01/RX/rx_trial_007.csv
8,S4_ablation_u_shuf,2,ABL_U_SHUF,1359,1359,1715,0.79242,0.943781,1.227634,13.625,0.04878,0.04878,0.04878,-1142.0,1359,181371.0,37704.698,207.88713741447086,315501904.0,uccs_d4_scan90/data/01/TX/trial_002_c5_unk.csv,uccs_d4_scan90/data/01/RX/rx_trial_008.csv
9,S4_fixed100,3,FIXED_100,1428,1427,1796,0.794543,1.0,1.240683,13.6383,0.04878,0.04878,0.04878,-1190.0,1427,181460.0,37762.289,208.1025515265072,315502092.0,uccs_d4_scan90/data/01/TX/trial_002_c2_s4_fixed500.csv,uccs_d4_scan90/data/01/RX/rx_trial_009.csv
10,S4_fixed500,3,FIXED_500,290,290,359,0.807799,0.0,1.608756,14.9814,0.146341,0.097561,0.097561,-647.0,290,179612.0,33634.486,187.26190900385274,315502278.0,uccs_d4_scan90/data/01/TX/trial_003_c3_s4_policy.csv,uccs_d4_scan90/data/01/RX/rx_trial_010.csv
11,S4_policy,3,POLICY,976,974,1227,0.793806,0.582763,1.267988,13.9737,0.073171,0.04878,0.04878,-862.5,974,180883.0,36375.168,201.09777038195958,315502464.0,uccs_d4_scan90/data/01/TX/trial_003_c4_s4_ablation_ushuf.csv,uccs_d4_scan90/data/01/RX/rx_trial_011.csv
12,S4_ablation_u_shuf,3,ABL_U_SHUF,1358,1358,1715,0.791837,0.943741,1.238366,13.6982,0.04878,0.04878,0.04878,-1089.0,1358,181359.0,37729.987,208.04033436443737,315502652.0,uccs_d4_scan90/data/01/TX/trial_003_c5_unk.csv,uccs_d4_scan90/data/01/RX/rx_trial_012.csv</file><file path="uccs_d4_scan90/metrics/01/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std
S4_ablation_u_shuf,3,0.04878,0.0,1.233508,0.005438,0.788144,0.006908,0.943487,0.000475,208.108,0.262,1715.0,0.0
S4_fixed100,3,0.04878,0.0,1.240289,0.007648,0.786748,0.00675,1.0,0.0,208.185,1.254,1796.0,0.0
S4_fixed500,3,0.130081,0.014082,1.586594,0.057463,0.81337,0.004825,0.000456,0.000395,187.93,0.766,359.0,0.0
S4_policy,3,0.097561,0.02439,1.277996,0.013985,0.789459,0.003852,0.592897,0.008899,200.531,0.771,1227.0,0.0</file><file path="uccs_d4_scan90/metrics/01/summary.md"># uccs_d4_scan90 metrics summary (v2)

- source RX: `uccs_d4_scan90/data/01/RX`
- source TXSD: `uccs_d4_scan90/data/01/TX`
- truth: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv` (n_steps=1800, dt=100ms)
- selected RX trials: 001..012 (n=12)
- selected TXSD trials (by mtime): trial_003_c1_s4_fixed100.csv .. trial_003_c5_unk.csv (n=12)
- generated: 2025-12-16 18:40 (local)
- command: `python3 uccs_d4_scan90/analysis/summarize_d4_run_v2.py --rx-dir uccs_d4_scan90/data/01/RX --txsd-dir uccs_d4_scan90/data/01/TX --out-dir uccs_d4_scan90/metrics/01`

## Summary (mean ± std)
| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |
|---|---:|---:|---:|---:|---:|---:|
| S4_ablation_u_shuf | 0.0488±0.0000 | 1.234±0.005 | 0.788±0.007 | 208.1±0.3 | 1715.0±0.0 | 0.943±0.000 |
| S4_fixed100 | 0.0488±0.0000 | 1.240±0.008 | 0.787±0.007 | 208.2±1.3 | 1796.0±0.0 | 1.000±0.000 |
| S4_fixed500 | 0.1301±0.0141 | 1.587±0.057 | 0.813±0.005 | 187.9±0.8 | 359.0±0.0 | 0.000±0.000 |
| S4_policy | 0.0976±0.0244 | 1.278±0.014 | 0.789±0.004 | 200.5±0.8 | 1227.0±0.0 | 0.593±0.009 |

## Notes
- RX window: latest 12 trials that form 4 conditions × 3 repeats (duration&gt;=160s).
- TXSD pairing: last 12 TXSD trials by file modification time; zipped in order with RX window.
- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).
- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique.
- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).</file><file path="uccs_d4_scan90/src/rx/RX_UCCS_D4_SCAN90/RX_UCCS_D4_SCAN90.ino">// RX_UCCS_D4_SCAN90.ino (uccs_d4_scan90)
// Receive TX_UCCS_D4 packets (MFD &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;) and log to SD.
// - SYNC gate: TX GPIO25 -&gt; RX GPIO26.
// - NimBLE passive scan with scan90% (interval=100ms, window=90ms).

#include &lt;Arduino.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NimBLEDevice.h&gt;
#include &lt;math.h&gt;

static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26; // TX GPIO25 -&gt; RX GPIO26

// scan90
static const float SCAN_INTERVAL_MS = 100.0f;
static const float SCAN_WINDOW_MS   = 90.0f;

static const uint32_t SESSION_TIMEOUT_MS = 1200000; // safety timeout (~20 min)
static const uint32_t SYNC_LOW_DEBOUNCE_MS = 100;
static const uint32_t START_LEVEL_HOLD_MS = 200;

static inline uint16_t ms_to_0p625(float ms){ return (uint16_t)lroundf(ms / 0.625f); }

static const uint16_t RX_BUF_SIZE = 512;
static const uint32_t FLUSH_INTERVAL_MS = 500;

struct RxEntry {
  uint32_t ms;
  int8_t   rssi;
  uint16_t seq;        // step_idx
  char     label[20];  // tag (e.g., A4-09-500)
  char     addr[18];
  char     mfd[48];
};

static RxEntry rxBuf[RX_BUF_SIZE];
static volatile uint16_t rxHead = 0;
static uint16_t rxTail = 0;
static uint32_t bufOverflow = 0;
static uint32_t lastFlushMs = 0;

static bool trial = false;
static bool syncState = false;
static uint32_t t0Ms = 0;
static uint32_t rxCount = 0;
static uint32_t syncLowSince = 0;
static uint32_t syncHighSince = 0;

static File f;
static const char FW_TAG[] = &quot;RX_UCCS_D4_SCAN90&quot;;
static bool condSeen = false;
static bool condWritten = false;
static char condLabel[24] = {0};

// MFD parser: &quot;&lt;seq&gt;_&lt;label&gt;&quot;
static bool parseMFD(const std::string&amp; s, uint16_t&amp; seq, std::string&amp; label) {
  size_t usPos = s.find(&apos;_&apos;);
  if (usPos == std::string::npos || usPos &lt; 1) return false;
  std::string seqStr = s.substr(0, usPos);
  label = s.substr(usPos + 1);
  if (label.empty()) return false;
  char* endp = nullptr;
  unsigned long v = strtoul(seqStr.c_str(), &amp;endp, 10);
  if (endp == seqStr.c_str() || v &gt; 65535UL) return false;
  seq = static_cast&lt;uint16_t&gt;(v);
  return true;
}

static String nextPath() {
  SD.mkdir(&quot;/logs&quot;);
  char p[64];
  for (uint32_t id = 1;; ++id) {
    snprintf(p, sizeof(p), &quot;/logs/rx_trial_%03lu.csv&quot;, (unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

static void flushBuffer() {
  if (!f) return;
  if (!condWritten &amp;&amp; condSeen) {
    f.printf(&quot;# condition_label=%s\r\n&quot;, condLabel);
    condWritten = true;
  }
  uint16_t head = rxHead;
  bool wrote = false;
  while (rxTail != head) {
    RxEntry&amp; e = rxBuf[rxTail];
    f.printf(&quot;%lu,ADV,%d,%u,%s,%s,%s\r\n&quot;,
             (unsigned long)e.ms,
             (int)e.rssi,
             (unsigned)e.seq,
             e.label,
             e.addr,
             e.mfd);
    rxTail = (rxTail + 1) % RX_BUF_SIZE;
    wrote = true;
  }
  if (wrote) f.flush();
}

static void startSession() {
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (f) {
    f.println(&quot;ms,event,rssi,seq,label,addr,mfd&quot;);
    f.printf(&quot;# meta, firmware=%s, buf_size=%u\r\n&quot;, FW_TAG, (unsigned)RX_BUF_SIZE);
    f.flush();
  }
  t0Ms = millis();
  rxCount = 0;
  rxHead = rxTail = 0;
  bufOverflow = 0;
  lastFlushMs = t0Ms;
  condSeen = false;
  condWritten = false;
  condLabel[0] = &apos;\0&apos;;
  Serial.printf(&quot;[RX] start %s\n&quot;, path.c_str());
  trial = true;
}

static void endSession() {
  if (!trial) return;
  flushBuffer();
  if (f) { f.flush(); f.close(); }
  uint32_t t_ms = millis() - t0Ms;
  double dur_s = t_ms / 1000.0;
  double rate_hz = dur_s &gt; 0 ? (double)rxCount / dur_s : 0.0;
  Serial.printf(&quot;[RX] end ms_total=%lu rx=%lu buf_overflow=%lu rate_hz=%.2f\n&quot;,
                (unsigned long)t_ms,
                (unsigned long)rxCount,
                (unsigned long)bufOverflow,
                rate_hz);
  trial = false;
}

class AdvCB : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    const std::string&amp; mfd = d-&gt;getManufacturerData();
    uint16_t seq;
    std::string label;
    if (!parseMFD(mfd, seq, label)) return;
    if (!condSeen) {
      strncpy(condLabel, label.c_str(), sizeof(condLabel) - 1);
      condLabel[sizeof(condLabel) - 1] = &apos;\0&apos;;
      condSeen = true;
    }
    const std::string addr = d-&gt;getAddress().toString();

    uint16_t nextH = (rxHead + 1) % RX_BUF_SIZE;
    if (nextH == rxTail) { bufOverflow++; return; }
    RxEntry&amp; e = rxBuf[rxHead];
    e.ms = millis() - t0Ms;
    e.rssi = (int8_t)d-&gt;getRSSI();
    e.seq = seq;
    strncpy(e.label, label.c_str(), sizeof(e.label) - 1); e.label[sizeof(e.label) - 1] = &apos;\0&apos;;
    strncpy(e.addr, addr.c_str(), sizeof(e.addr) - 1); e.addr[sizeof(e.addr) - 1] = &apos;\0&apos;;
    strncpy(e.mfd, mfd.c_str(), sizeof(e.mfd) - 1); e.mfd[sizeof(e.mfd) - 1] = &apos;\0&apos;;
    rxHead = nextH; rxCount++;
  }
};

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;[RX] FW=RX_UCCS_D4_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) { Serial.println(&quot;[SD] init FAIL&quot;); while (1) delay(1000); }
  pinMode(SYNC_IN, INPUT_PULLDOWN);

  NimBLEDevice::init(&quot;RX_ESP32&quot;);
  NimBLEScan* scan = NimBLEDevice::getScan();
  scan-&gt;setActiveScan(false);
  scan-&gt;setInterval(ms_to_0p625(SCAN_INTERVAL_MS));
  scan-&gt;setWindow(ms_to_0p625(SCAN_WINDOW_MS));
  scan-&gt;setDuplicateFilter(0);
  scan-&gt;setScanCallbacks(new AdvCB(), true);
  scan-&gt;start(0, false);

  Serial.printf(&quot;[RX] ready (buf=%u, flush=%lums, wait SYNC pin=%d)\n&quot;,
                (unsigned)RX_BUF_SIZE, (unsigned long)FLUSH_INTERVAL_MS, SYNC_IN);
}

void loop() {
  bool syncHigh = (digitalRead(SYNC_IN) == HIGH);

  if (!trial) {
    if (syncHigh) {
      if (syncHighSince == 0) syncHighSince = millis();
      if ((millis() - syncHighSince) &gt;= START_LEVEL_HOLD_MS) {
        startSession();
        syncState = true;
        syncLowSince = 0;
      }
    } else {
      syncHighSince = 0;
    }
  } else {
    if (!syncHigh &amp;&amp; syncState) {
      if (syncLowSince == 0) syncLowSince = millis();
      if ((millis() - syncLowSince) &gt;= SYNC_LOW_DEBOUNCE_MS) {
        endSession();
        syncState = false;
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
    }
    if (trial &amp;&amp; (millis() - t0Ms) &gt;= SESSION_TIMEOUT_MS) {
      Serial.println(&quot;[RX] force end by timeout&quot;);
      endSession();
      syncState = false;
      syncLowSince = 0;
    }
  }

  uint32_t now = millis();
  if (now - lastFlushMs &gt;= FLUSH_INTERVAL_MS) {
    flushBuffer();
    lastFlushMs = now;
  }
  vTaskDelay(1);
}</file><file path="uccs_d4_scan90/src/tx/stress_causal_s1_s4_180s.h">// Auto-generated subset from stress_causal_S1/S4.csv (Mode_C_2_シミュレート_causal/ccs).
// N_STEPS=1800 (=180s @ 100ms grid)
#pragma once
#include &lt;Arduino.h&gt;

static const uint16_t STRESS_CAUSAL_LEN = 1800;

static const uint8_t S1_LABEL[] PROGMEM = {
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
};
static const uint8_t S1_U_Q[] PROGMEM = {
  255, 255, 245, 250, 224, 217, 219, 226, 216, 209, 196, 216, 183, 177, 178, 177, 172, 147, 170, 162, 165, 127, 134, 155,
  105, 134, 114, 112, 101, 101, 100, 109, 81, 81, 85, 69, 87, 92, 68, 72, 45, 61, 44, 28, 31, 46, 34, 13,
  246, 255, 220, 247, 229, 211, 227, 207, 236, 208, 198, 176, 178, 190, 207, 181, 180, 183, 145, 139, 147, 148, 134, 122,
  133, 132, 128, 132, 101, 116, 90, 63, 110, 59, 81, 250, 255, 244, 238, 213, 212, 223, 222, 210, 217, 239, 205, 184,
  192, 157, 193, 176, 168, 172, 151, 140, 141, 137, 146, 128, 133, 101, 115, 131, 124, 87, 108, 84, 96, 77, 75, 64,
  89, 68, 53, 55, 64, 35, 44, 21, 20, 17, 1, 18, 0, 15, 24, 0, 0, 0, 0, 17, 244, 255, 248, 233,
  235, 243, 228, 231, 218, 205, 203, 193, 202, 213, 200, 192, 177, 154, 172, 156, 175, 155, 130, 136, 113, 125, 123, 118,
  133, 111, 125, 105, 85, 61, 88, 77, 77, 59, 56, 41, 61, 28, 34, 53, 39, 27, 42, 30, 5, 15, 0, 0,
  4, 0, 0, 4, 1, 0, 11, 0, 11, 0, 0, 18, 4, 0, 0, 16, 0, 0, 0, 21, 14, 0, 0, 18,
  0, 0, 11, 1, 0, 0, 12, 0, 0, 7, 11, 14, 0, 3, 0, 0, 0, 4, 22, 1, 11, 0, 10, 4,
  0, 0, 29, 2, 0, 12, 0, 16, 0, 0, 27, 0, 27, 17, 0, 1, 0, 0, 16, 0, 0, 13, 1, 0,
  0, 0, 20, 0, 0, 7, 0, 10, 0, 7, 3, 2, 0, 9, 0, 26, 0, 0, 2, 6, 24, 0, 3, 5,
  0, 0, 8, 0, 17, 6, 0, 0, 0, 0, 252, 252, 233, 246, 237, 240, 209, 220, 213, 209, 202, 197, 220, 193,
  185, 186, 155, 184, 157, 150, 154, 138, 142, 129, 125, 115, 120, 127, 121, 102, 96, 85, 94, 99, 80, 67, 63, 52,
  81, 68, 40, 41, 52, 17, 46, 29, 0, 14, 43, 0, 12, 0, 0, 3, 0, 0, 36, 0, 10, 0, 0, 0,
  0, 0, 0, 14, 0, 0, 0, 0, 0, 1, 0, 2, 21, 0, 0, 0, 17, 12, 19, 25, 0, 1, 0, 13,
  0, 8, 9, 0, 6, 0, 0, 5, 9, 0, 0, 3, 0, 0, 0, 0, 7, 9, 15, 0, 1, 0, 11, 9,
  23, 0, 1, 0, 0, 0, 0, 0, 0, 18, 2, 0, 32, 0, 7, 31, 0, 0, 0, 10, 0, 15, 12, 23,
  13, 0, 0, 16, 16, 0, 3, 0, 4, 0, 5, 0, 20, 5, 0, 0, 7, 0, 18, 3, 0, 245, 234, 224,
  255, 217, 255, 253, 230, 232, 230, 230, 197, 225, 204, 190, 190, 187, 209, 185, 167, 158, 142, 165, 151, 164, 171, 150,
  101, 110, 139, 120, 102, 77, 109, 84, 103, 79, 81, 65, 71, 67, 78, 46, 47, 54, 37, 35, 22, 23, 2, 45,
  0, 0, 19, 0, 0, 0, 0, 0, 17, 0, 6, 0, 5, 1, 5, 1, 0, 0, 0, 0, 0, 0, 1, 0,
  16, 6, 0, 0, 4, 0, 0, 0, 0, 7, 0, 0, 23, 0, 0, 0, 3, 22, 0, 0, 9, 20, 10, 0,
  16, 0, 6, 5, 14, 0, 0, 0, 16, 1, 9, 20, 6, 18, 4, 0, 0, 8, 0, 9, 4, 0, 4, 0,
  5, 0, 0, 7, 0, 6, 0, 0, 5, 0, 0, 4, 0, 12, 14, 4, 0, 1, 0, 3, 0, 2, 3, 0,
  20, 6, 0, 9, 4, 0, 1, 4, 0, 0, 0, 0, 2, 23, 12, 2, 0, 0, 0, 12, 0, 5, 3, 0,
  3, 24, 0, 0, 255, 249, 243, 218, 243, 206, 216, 218, 195, 246, 199, 214, 185, 201, 201, 186, 171, 158, 166, 160,
  152, 146, 157, 154, 138, 123, 114, 131, 115, 116, 94, 72, 94, 84, 87, 87, 63, 64, 57, 54, 50, 40, 45, 29,
  41, 34, 24, 11, 11, 0, 27, 0, 2, 0, 9, 8, 30, 24, 13, 7, 0, 249, 243, 254, 255, 229, 253, 216,
  207, 217, 221, 199, 204, 245, 237, 235, 235, 244, 219, 216, 232, 246, 206, 189, 206, 208, 166, 161, 184, 139, 152, 168,
  255, 254, 209, 241, 214, 213, 225, 199, 205, 199, 210, 190, 255, 255, 254, 221, 236, 243, 225, 228, 208, 214, 202, 202,
  159, 203, 190, 174, 183, 163, 169, 148, 173, 140, 138, 165, 114, 139, 119, 105, 115, 116, 107, 80, 80, 255, 241, 237,
  227, 211, 241, 220, 201, 185, 212, 203, 196, 196, 183, 164, 169, 182, 178, 167, 141, 151, 153, 128, 139, 119, 151, 115,
  140, 115, 107, 112, 89, 90, 96, 96, 66, 63, 69, 61, 55, 49, 56, 54, 17, 19, 10, 28, 26, 16, 13, 0,
  0, 0, 0, 12, 15, 15, 6, 0, 10, 24, 0, 18, 18, 0, 22, 0, 0, 0, 2, 0, 23, 9, 0, 15,
  13, 0, 0, 4, 13, 19, 21, 0, 0, 6, 7, 0, 0, 0, 14, 13, 0, 6, 0, 10, 0, 0, 21, 0,
  9, 12, 0, 0, 0, 0, 0, 0, 0, 14, 22, 23, 0, 8, 0, 15, 0, 19, 0, 5, 19, 13, 0, 7,
  9, 0, 5, 0, 15, 23, 6, 0, 0, 0, 0, 32, 3, 12, 255, 223, 255, 241, 231, 219, 209, 224, 213, 208,
  215, 180, 203, 185, 138, 186, 161, 173, 170, 147, 148, 149, 143, 124, 130, 123, 128, 119, 113, 92, 120, 87, 89, 79,
  82, 70, 69, 57, 49, 56, 34, 77, 49, 46, 34, 35, 7, 25, 9, 9, 1, 0, 4, 15, 0, 3, 0, 0,
  0, 5, 19, 15, 0, 11, 0, 3, 2, 10, 4, 0, 6, 0, 0, 0, 13, 29, 10, 0, 2, 0, 14, 9,
  0, 12, 0, 17, 2, 0, 0, 23, 0, 0, 0, 0, 10, 8, 0, 1, 1, 7, 8, 9, 0, 6, 0, 0,
  0, 0, 12, 0, 1, 0, 20, 0, 0, 0, 0, 0, 228, 246, 252, 241, 223, 231, 241, 224, 218, 188, 212, 192,
  193, 188, 171, 191, 161, 170, 160, 148, 127, 154, 141, 134, 144, 124, 125, 106, 96, 96, 91, 110, 91, 93, 77, 50,
  89, 69, 71, 51, 72, 58, 52, 28, 26, 25, 31, 30, 0, 10, 24, 17, 0, 0, 14, 5, 20, 0, 0, 7,
  0, 0, 0, 17, 0, 0, 11, 4, 0, 0, 2, 5, 11, 4, 0, 5, 9, 18, 4, 0, 0, 15, 11, 8,
  9, 9, 7, 0, 4, 15, 4, 0, 0, 0, 11, 25, 5, 0, 22, 0, 238, 247, 232, 255, 229, 228, 242, 225,
  205, 210, 209, 195, 213, 190, 192, 189, 170, 185, 157, 158, 155, 141, 126, 123, 161, 146, 118, 140, 119, 105, 114, 83,
  70, 64, 87, 77, 83, 69, 70, 72, 35, 60, 59, 42, 48, 28, 13, 26, 8, 7, 10, 0, 13, 0, 19, 0,
  11, 0, 2, 0, 3, 8, 0, 0, 2, 3, 255, 239, 255, 234, 223, 229, 224, 193, 216, 213, 218, 191, 185, 207,
  168, 179, 172, 143, 169, 178, 123, 153, 123, 128, 111, 126, 133, 101, 117, 84, 94, 115, 84, 87, 70, 77, 74, 99,
  46, 65, 54, 52, 58, 34, 48, 29, 21, 2, 22, 15, 0, 0, 0, 4, 0, 13, 0, 16, 0, 6, 0, 0,
  2, 3, 0, 0, 0, 3, 16, 2, 11, 7, 10, 11, 13, 23, 224, 255, 255, 254, 255, 226, 229, 248, 226, 205,
  205, 216, 215, 197, 206, 166, 192, 167, 151, 150, 157, 191, 147, 122, 161, 126, 122, 116, 118, 99, 86, 117, 75, 106,
  99, 69, 77, 75, 42, 51, 66, 64, 41, 28, 14, 23, 27, 24, 11, 5, 8, 2, 0, 3, 16, 10, 8, 22,
  0, 0, 0, 0, 2, 3, 0, 2, 11, 0, 2, 9, 1, 1, 0, 0, 0, 0, 0, 18, 12, 0, 0, 6,
  12, 0, 12, 0, 10, 0, 4, 0, 0, 3, 2, 0, 0, 0, 8, 0, 0, 0, 15, 37, 0, 0, 7, 0,
  0, 5, 10, 13, 0, 0, 1, 32, 7, 0, 2, 2, 9, 0, 0, 0, 0, 0, 31, 3, 6, 0, 0, 8,
  15, 0, 13, 0, 11, 2, 10, 6, 0, 14, 0, 0, 13, 0, 0, 6, 0, 17, 0, 0, 0, 0, 30, 0,
  14, 0, 0, 0, 0, 2, 6, 0, 8, 0, 0, 0, 1, 0, 16, 0, 10, 16, 0, 2, 0, 0, 0, 0,
  10, 6, 11, 0, 13, 18, 4, 0, 0, 5, 0, 12, 0, 0, 5, 5, 3, 21, 3, 8, 0, 0, 255, 233,
  230, 212, 235, 243, 231, 224, 218, 221, 197, 196, 189, 216, 182, 175, 175, 171, 167, 148, 148, 146, 125, 155, 149, 117,
  107, 142, 124, 112, 98, 95, 84, 67, 89, 55, 74, 67, 77, 64, 49, 43, 34, 19, 9, 36, 65, 0, 2, 23,
  19, 0, 10, 0, 18, 0, 2, 0, 11, 22, 0, 20, 20, 0, 3, 0, 0, 0, 1, 6, 0, 0, 24, 2,
  4, 0, 0, 9, 0, 0, 13, 8, 7, 0, 0, 25, 0, 0, 5, 6, 5, 11, 6, 5, 20, 0, 0, 0,
  0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 28, 14, 0, 0, 0, 6, 8, 5, 0, 0, 0, 0, 5, 0,
  0, 4, 7, 0, 0, 3, 0, 17, 4, 18, 7, 6, 0, 6, 9, 0, 5, 0, 255, 255, 255, 235, 231, 225,
  222, 218, 197, 208, 196, 197, 208, 201, 177, 170, 189, 180, 160, 163, 138, 154, 156, 148, 142, 155, 128, 101, 114, 105,
  107, 106, 98, 95, 104, 76, 64, 69, 58, 48, 41, 40, 51, 58, 53, 26, 37, 23, 17, 0, 10, 0, 0, 1,
  0, 0, 0, 0, 11, 0, 1, 0, 0, 7, 0, 0, 0, 0, 0, 11, 21, 13, 12, 0, 5, 28, 2, 22,
  33, 6, 2, 0, 0, 9, 2, 5, 15, 4, 30, 12, 11, 1, 6, 0, 0, 0, 0, 8, 9, 0, 0, 0,
  0, 0, 0, 17, 22, 4, 0, 0, 14, 0, 11, 14, 6, 8, 13, 7, 17, 0, 0, 9, 0, 20, 0, 0,
  0, 0, 0, 3, 0, 0, 17, 13, 0, 0, 16, 2, 0, 25, 26, 0, 0, 0, 3, 0, 4, 1, 17, 16,
  16, 22, 0, 0, 9, 0, 0, 21, 4, 0, 6, 13, 13, 0, 5, 4, 5, 0, 0, 20, 0, 0, 9, 0,
  32, 0, 12, 0, 11, 3, 0, 0, 0, 6, 0, 7, 0, 24, 6, 0, 6, 7, 29, 1, 9, 0, 0, 0,
};
static const uint8_t S1_CCS_Q[] PROGMEM = {
  0, 2, 10, 8, 28, 34, 34, 31, 40, 46, 57, 44, 69, 75, 75, 78, 83, 102, 87, 94, 93, 122, 119, 105,
  142, 123, 138, 141, 151, 152, 154, 150, 171, 173, 171, 184, 173, 171, 189, 187, 209, 199, 212, 224, 224, 215, 225, 241,
  6, 2, 28, 10, 24, 38, 29, 44, 26, 47, 55, 72, 73, 65, 55, 75, 77, 77, 105, 111, 106, 107, 119, 128,
  122, 124, 129, 127, 151, 142, 162, 182, 151, 188, 174, 4, 2, 11, 16, 35, 38, 31, 34, 44, 41, 26, 52, 68,
  64, 90, 67, 80, 87, 86, 102, 111, 112, 116, 112, 125, 124, 148, 139, 129, 136, 164, 150, 169, 162, 177, 180, 189,
  173, 189, 201, 201, 196, 219, 213, 231, 233, 237, 249, 239, 253, 245, 239, 255, 255, 255, 255, 243, 7, 2, 8, 20,
  20, 16, 28, 27, 38, 48, 52, 61, 56, 49, 60, 67, 79, 97, 86, 98, 87, 102, 121, 119, 136, 129, 132, 137,
  128, 146, 137, 153, 168, 186, 169, 178, 180, 194, 198, 209, 197, 222, 219, 207, 218, 229, 219, 229, 248, 243, 255, 255,
  252, 255, 255, 252, 254, 255, 247, 255, 247, 255, 255, 242, 252, 255, 255, 244, 255, 255, 255, 240, 245, 255, 255, 242,
  255, 255, 247, 255, 255, 255, 247, 255, 255, 250, 247, 245, 255, 253, 255, 255, 255, 252, 240, 254, 247, 255, 248, 252,
  255, 255, 234, 253, 255, 247, 255, 244, 255, 255, 236, 255, 236, 243, 255, 254, 255, 255, 244, 255, 255, 246, 254, 255,
  255, 255, 241, 255, 255, 250, 255, 248, 255, 250, 253, 254, 255, 249, 255, 237, 255, 255, 254, 251, 238, 255, 253, 251,
  255, 255, 250, 255, 243, 251, 255, 255, 255, 255, 2, 4, 19, 11, 19, 18, 41, 35, 42, 46, 53, 58, 43, 63,
  70, 72, 94, 76, 96, 103, 101, 114, 113, 123, 127, 137, 134, 131, 137, 152, 157, 166, 162, 160, 175, 185, 190, 198,
  180, 191, 212, 213, 207, 232, 213, 227, 249, 241, 222, 253, 247, 255, 255, 253, 255, 255, 230, 255, 248, 255, 255, 255,
  255, 255, 255, 245, 255, 255, 255, 255, 255, 254, 255, 254, 240, 255, 255, 255, 243, 247, 242, 237, 255, 254, 255, 246,
  255, 249, 249, 255, 251, 255, 255, 252, 249, 255, 255, 253, 255, 255, 255, 255, 250, 249, 245, 255, 254, 255, 248, 249,
  239, 255, 254, 255, 255, 255, 255, 255, 255, 243, 253, 255, 232, 255, 250, 233, 255, 255, 255, 248, 255, 245, 246, 239,
  246, 255, 255, 243, 244, 255, 253, 255, 252, 255, 251, 255, 241, 252, 255, 255, 250, 255, 243, 253, 255, 7, 17, 22,
  2, 29, 5, 8, 25, 25, 29, 30, 55, 36, 53, 64, 65, 69, 55, 74, 87, 95, 108, 93, 105, 97, 94, 110,
  146, 142, 122, 138, 151, 170, 150, 168, 157, 175, 175, 188, 185, 190, 184, 207, 208, 205, 219, 221, 232, 232, 249, 221,
  253, 255, 242, 255, 255, 255, 255, 255, 243, 255, 251, 255, 252, 254, 251, 254, 255, 255, 255, 255, 255, 255, 254, 255,
  244, 251, 255, 255, 253, 255, 255, 255, 255, 250, 255, 255, 239, 255, 255, 255, 253, 239, 255, 255, 249, 241, 248, 255,
  244, 255, 251, 252, 245, 255, 255, 255, 244, 254, 249, 241, 251, 243, 253, 255, 255, 249, 255, 249, 252, 255, 252, 255,
  252, 255, 255, 250, 255, 251, 255, 255, 252, 255, 255, 252, 255, 247, 245, 252, 255, 254, 255, 253, 255, 254, 253, 255,
  241, 251, 255, 249, 252, 255, 254, 252, 255, 255, 255, 255, 254, 239, 247, 254, 255, 255, 255, 247, 255, 251, 253, 255,
  253, 238, 255, 255, 0, 6, 12, 30, 14, 42, 37, 36, 54, 20, 55, 46, 67, 57, 59, 71, 83, 94, 90, 95,
  103, 109, 102, 106, 119, 130, 138, 128, 141, 142, 158, 176, 162, 170, 169, 171, 190, 191, 197, 200, 205, 213, 212, 224,
  217, 224, 232, 243, 244, 253, 236, 255, 253, 255, 249, 249, 234, 238, 246, 250, 255, 4, 10, 4, 5, 24, 9, 36,
  44, 39, 37, 54, 53, 7, 14, 17, 19, 14, 33, 37, 27, 19, 48, 62, 51, 51, 82, 87, 73, 105, 98, 89,
  0, 2, 35, 14, 35, 37, 30, 50, 48, 53, 47, 62, 0, 2, 4, 28, 20, 16, 30, 29, 45, 42, 53, 54,
  85, 56, 67, 79, 75, 91, 88, 104, 88, 112, 115, 98, 135, 120, 135, 146, 141, 141, 149, 170, 172, 0, 11, 16,
  25, 37, 17, 33, 48, 61, 44, 52, 58, 59, 70, 85, 83, 76, 80, 89, 109, 103, 103, 122, 117, 132, 111, 138,
  122, 141, 148, 146, 164, 164, 162, 163, 186, 189, 187, 194, 200, 206, 202, 205, 232, 232, 241, 229, 232, 241, 245, 255,
  255, 255, 255, 247, 245, 244, 251, 255, 248, 238, 255, 242, 242, 255, 240, 255, 255, 255, 254, 255, 239, 249, 255, 245,
  246, 255, 255, 252, 246, 242, 240, 255, 255, 251, 250, 255, 255, 255, 245, 246, 255, 251, 255, 248, 255, 255, 240, 255,
  248, 247, 255, 255, 255, 255, 255, 255, 255, 245, 239, 239, 255, 249, 255, 245, 255, 242, 255, 251, 242, 246, 255, 250,
  249, 255, 251, 255, 245, 239, 251, 255, 255, 255, 255, 233, 253, 246, 0, 24, 3, 14, 23, 33, 41, 32, 41, 47,
  43, 70, 55, 69, 103, 72, 91, 83, 87, 104, 105, 107, 112, 127, 124, 130, 129, 137, 142, 158, 140, 165, 165, 173,
  173, 183, 185, 195, 203, 199, 216, 187, 209, 212, 222, 223, 244, 233, 246, 247, 254, 255, 252, 244, 255, 253, 255, 255,
  255, 252, 242, 245, 255, 248, 255, 253, 254, 248, 252, 255, 251, 255, 255, 255, 246, 235, 248, 255, 254, 255, 245, 249,
  255, 246, 255, 243, 254, 255, 255, 239, 255, 255, 255, 255, 248, 249, 255, 255, 254, 250, 249, 249, 255, 251, 255, 255,
  255, 255, 246, 255, 255, 255, 241, 255, 255, 255, 255, 255, 19, 8, 5, 14, 29, 24, 19, 33, 38, 60, 45, 61,
  62, 67, 80, 67, 90, 85, 94, 104, 120, 103, 114, 120, 114, 130, 131, 146, 154, 156, 161, 149, 164, 164, 177, 197,
  171, 187, 187, 203, 190, 201, 206, 225, 227, 230, 227, 229, 252, 247, 238, 243, 255, 255, 245, 252, 241, 255, 255, 250,
  255, 255, 255, 243, 255, 255, 247, 252, 255, 255, 253, 252, 247, 252, 255, 251, 249, 242, 252, 255, 255, 245, 248, 250,
  249, 248, 250, 255, 252, 245, 252, 255, 255, 255, 247, 238, 251, 255, 240, 255, 12, 7, 19, 5, 24, 26, 18, 32,
  47, 45, 48, 59, 48, 65, 65, 69, 84, 75, 96, 97, 101, 112, 124, 127, 103, 115, 136, 122, 138, 149, 145, 168,
  179, 184, 170, 178, 175, 187, 188, 188, 215, 199, 201, 215, 213, 228, 239, 232, 246, 248, 248, 255, 246, 255, 241, 255,
  247, 255, 254, 255, 253, 249, 255, 255, 253, 253, 0, 13, 3, 19, 29, 26, 31, 54, 40, 43, 41, 62, 67, 54,
  83, 76, 82, 104, 88, 83, 123, 103, 126, 124, 138, 129, 125, 149, 139, 164, 158, 146, 168, 168, 182, 178, 182, 166,
  205, 193, 202, 205, 202, 221, 212, 227, 234, 249, 237, 243, 255, 255, 255, 252, 255, 246, 255, 244, 255, 251, 255, 255,
  253, 253, 255, 255, 255, 253, 244, 254, 247, 250, 248, 247, 246, 239, 21, 0, 2, 4, 5, 26, 26, 14, 31, 47,
  49, 42, 45, 59, 54, 84, 67, 86, 99, 101, 97, 75, 108, 127, 101, 127, 132, 137, 137, 152, 163, 142, 173, 154,
  160, 182, 178, 181, 206, 201, 192, 195, 212, 223, 234, 229, 228, 232, 243, 249, 248, 253, 255, 253, 244, 248, 250, 239,
  255, 255, 255, 255, 254, 253, 255, 254, 247, 255, 254, 248, 254, 254, 255, 255, 255, 255, 255, 242, 247, 255, 255, 251,
  246, 255, 247, 255, 248, 255, 252, 255, 255, 253, 254, 255, 255, 255, 250, 255, 255, 255, 244, 229, 255, 255, 250, 255,
  255, 251, 248, 246, 255, 255, 254, 232, 250, 255, 253, 254, 248, 255, 255, 255, 255, 255, 233, 253, 251, 255, 255, 249,
  244, 255, 246, 255, 247, 253, 248, 251, 255, 245, 255, 255, 246, 255, 255, 251, 255, 243, 255, 255, 255, 255, 234, 255,
  245, 255, 255, 255, 255, 254, 251, 255, 249, 255, 255, 255, 254, 255, 244, 255, 248, 244, 255, 254, 255, 255, 255, 255,
  248, 250, 247, 255, 246, 242, 252, 255, 255, 252, 255, 247, 255, 255, 252, 252, 253, 240, 253, 250, 255, 255, 0, 17,
  20, 35, 20, 16, 26, 32, 38, 37, 56, 58, 65, 47, 72, 79, 80, 85, 89, 104, 106, 108, 125, 105, 111, 135,
  143, 121, 135, 144, 156, 160, 169, 182, 168, 194, 182, 188, 183, 194, 205, 211, 219, 231, 239, 222, 203, 250, 251, 237,
  241, 255, 248, 255, 242, 255, 254, 255, 248, 240, 255, 241, 241, 255, 253, 255, 255, 255, 255, 251, 255, 255, 238, 254,
  252, 255, 255, 248, 255, 255, 246, 249, 250, 255, 255, 237, 255, 255, 251, 251, 251, 248, 251, 252, 241, 255, 255, 255,
  255, 255, 255, 255, 255, 250, 255, 255, 255, 255, 236, 246, 255, 255, 255, 251, 249, 252, 255, 255, 255, 255, 252, 255,
  255, 252, 250, 255, 255, 253, 255, 243, 252, 243, 250, 251, 255, 251, 249, 255, 252, 255, 0, 2, 3, 18, 23, 29,
  32, 36, 53, 47, 56, 58, 51, 58, 76, 83, 71, 79, 94, 93, 112, 103, 103, 110, 116, 108, 129, 149, 141, 149,
  149, 152, 159, 162, 158, 179, 189, 187, 196, 205, 211, 213, 207, 203, 209, 229, 223, 234, 240, 253, 248, 255, 255, 254,
  255, 255, 255, 255, 247, 255, 254, 255, 255, 250, 255, 255, 255, 255, 255, 247, 240, 246, 247, 255, 251, 236, 254, 240,
  232, 251, 254, 255, 255, 249, 253, 251, 245, 252, 234, 246, 247, 254, 251, 255, 255, 255, 255, 249, 248, 255, 255, 255,
  255, 255, 255, 243, 240, 252, 255, 255, 245, 255, 247, 245, 251, 249, 246, 250, 243, 255, 255, 249, 255, 241, 255, 255,
  255, 255, 255, 253, 255, 255, 243, 246, 255, 255, 244, 253, 255, 238, 237, 255, 255, 255, 253, 255, 252, 255, 243, 244,
  244, 239, 255, 255, 249, 255, 255, 240, 253, 255, 251, 246, 246, 255, 252, 252, 252, 255, 255, 241, 255, 255, 249, 255,
  232, 255, 247, 255, 247, 253, 255, 255, 255, 251, 255, 250, 255, 238, 251, 255, 251, 250, 235, 255, 249, 255, 255, 255,
};

static const uint8_t S4_LABEL[] PROGMEM = {
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 7, 7, 7, 7, 7,
  7, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  10, 10, 10, 10, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  9, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
};
static const uint8_t S4_U_Q[] PROGMEM = {
  255, 238, 239, 227, 232, 228, 232, 202, 200, 227, 221, 213, 211, 255, 232, 225, 250, 232, 231, 246, 222, 194, 197, 189,
  173, 195, 192, 149, 178, 196, 168, 172, 153, 146, 157, 155, 147, 118, 115, 160, 119, 97, 100, 98, 99, 104, 89, 68,
  102, 87, 72, 55, 27, 62, 65, 20, 36, 19, 10, 13, 10, 31, 8, 11, 14, 1, 0, 0, 2, 3, 25, 0,
  0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 255, 255, 242, 254, 255, 235, 242, 224,
  233, 255, 253, 243, 237, 221, 209, 251, 220, 227, 205, 198, 208, 187, 169, 182, 179, 169, 179, 153, 182, 150, 176, 149,
  243, 255, 242, 232, 218, 247, 218, 209, 215, 227, 221, 189, 235, 180, 196, 185, 178, 164, 162, 152, 144, 119, 153, 127,
  142, 114, 117, 127, 114, 115, 105, 87, 93, 90, 80, 91, 81, 58, 38, 67, 42, 42, 58, 12, 52, 41, 26, 10,
  7, 6, 0, 3, 7, 0, 0, 6, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 5,
  16, 9, 16, 0, 0, 0, 22, 22, 0, 0, 11, 10, 14, 14, 0, 0, 0, 0, 2, 6, 0, 0, 0, 0,
  27, 0, 0, 0, 11, 5, 0, 18, 0, 0, 20, 32, 9, 4, 0, 29, 2, 0, 2, 9, 2, 13, 0, 0,
  3, 30, 3, 3, 5, 255, 255, 217, 242, 222, 221, 222, 230, 237, 215, 210, 197, 207, 178, 164, 165, 166, 169, 154,
  161, 154, 170, 143, 154, 138, 122, 125, 76, 118, 119, 94, 73, 85, 99, 58, 70, 89, 47, 37, 35, 54, 50, 40,
  21, 48, 42, 30, 12, 0, 0, 0, 0, 4, 20, 4, 0, 1, 3, 15, 11, 25, 0, 0, 0, 0, 0, 0,
  0, 0, 14, 0, 14, 0, 0, 0, 0, 0, 0, 16, 0, 0, 9, 0, 0, 7, 0, 7, 10, 10, 0, 0,
  18, 2, 255, 251, 236, 243, 235, 230, 229, 227, 200, 185, 211, 209, 203, 188, 189, 177, 167, 173, 172, 164, 162, 152,
  125, 125, 255, 255, 242, 214, 232, 219, 223, 240, 212, 205, 193, 173, 173, 198, 255, 250, 255, 255, 242, 221, 238, 209,
  219, 201, 210, 201, 199, 191, 197, 201, 163, 160, 167, 140, 131, 155, 156, 137, 129, 110, 135, 115, 116, 111, 104, 99,
  87, 94, 98, 80, 84, 78, 60, 80, 46, 48, 29, 33, 34, 13, 27, 12, 22, 0, 9, 6, 0, 239, 255, 255,
  246, 236, 241, 208, 214, 215, 227, 201, 217, 199, 201, 187, 190, 177, 163, 166, 144, 164, 127, 153, 113, 133, 128, 128,
  100, 90, 97, 104, 123, 90, 85, 90, 80, 59, 51, 86, 56, 60, 27, 44, 35, 30, 22, 15, 13, 2, 4, 9,
  0, 11, 16, 25, 22, 0, 0, 21, 0, 0, 0, 0, 1, 0, 0, 29, 0, 0, 9, 16, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 4, 0, 0, 22, 0, 15, 0, 0, 0, 0, 0, 9, 35, 2, 0, 19, 0, 2, 0,
  0, 0, 0, 0, 21, 15, 6, 0, 0, 12, 0, 0, 0, 0, 0, 0, 16, 6, 12, 3, 0, 8, 1, 0,
  8, 11, 0, 3, 0, 3, 4, 0, 0, 5, 4, 7, 0, 0, 0, 0, 0, 7, 2, 0, 12, 16, 0, 0,
  10, 26, 6, 5, 12, 4, 0, 0, 0, 21, 41, 8, 9, 0, 2, 13, 8, 0, 22, 0, 8, 0, 9, 0,
  0, 7, 0, 3, 0, 255, 237, 244, 246, 239, 217, 206, 211, 231, 238, 255, 252, 237, 247, 221, 216, 248, 230, 222,
  192, 198, 210, 174, 192, 205, 189, 175, 190, 150, 175, 159, 130, 152, 136, 145, 140, 133, 255, 255, 240, 254, 247, 237,
  217, 213, 203, 227, 215, 210, 208, 201, 180, 181, 163, 154, 153, 149, 149, 122, 158, 134, 136, 134, 125, 117, 102, 97,
  109, 80, 89, 85, 70, 62, 52, 76, 255, 255, 254, 233, 245, 244, 207, 228, 186, 188, 237, 193, 196, 191, 180, 179,
  169, 180, 158, 173, 164, 171, 163, 120, 123, 133, 109, 127, 128, 111, 95, 111, 92, 79, 255, 233, 255, 240, 241, 225,
  217, 210, 252, 213, 253, 251, 248, 232, 245, 228, 221, 243, 233, 192, 198, 212, 170, 187, 167, 180, 166, 150, 163, 150,
  153, 130, 159, 134, 99, 144, 134, 108, 104, 120, 110, 119, 85, 105, 71, 69, 69, 55, 86, 82, 51, 30, 51, 41,
  11, 45, 19, 32, 3, 14, 0, 255, 255, 255, 238, 223, 252, 250, 218, 216, 193, 206, 185, 201, 192, 176, 163, 177,
  163, 174, 143, 143, 255, 254, 233, 250, 237, 250, 234, 244, 193, 220, 214, 200, 200, 195, 166, 169, 177, 158, 165, 157,
  146, 165, 152, 147, 127, 106, 123, 111, 106, 126, 105, 110, 77, 78, 58, 64, 78, 75, 79, 49, 66, 53, 50, 38,
  40, 30, 0, 26, 19, 12, 9, 24, 0, 0, 0, 0, 25, 0, 11, 12, 0, 0, 247, 255, 255, 227, 246, 230,
  209, 234, 223, 200, 199, 203, 188, 201, 200, 160, 178, 173, 169, 159, 146, 140, 141, 142, 131, 158, 116, 124, 88, 121,
  95, 110, 89, 68, 86, 83, 73, 81, 61, 55, 54, 25, 51, 29, 10, 32, 19, 13, 0, 0, 15, 0, 16, 0,
  13, 20, 4, 2, 0, 0, 0, 19, 0, 0, 0, 0, 2, 0, 8, 0, 0, 8, 9, 27, 0, 0, 9, 7,
  0, 3, 12, 19, 11, 7, 9, 9, 0, 2, 7, 4, 1, 0, 0, 9, 0, 0, 0, 15, 5, 0, 8, 15,
  4, 5, 8, 255, 255, 242, 255, 242, 240, 218, 204, 240, 204, 207, 206, 206, 181, 184, 195, 180, 189, 168, 166, 145,
  131, 133, 147, 137, 123, 121, 136, 118, 103, 105, 89, 82, 83, 69, 79, 52, 70, 51, 71, 67, 38, 26, 33, 41,
  47, 8, 33, 9, 0, 0, 0, 0, 12, 3, 6, 0, 27, 10, 17, 0, 0, 0, 8, 0, 6, 0, 0, 0,
  3, 0, 0, 255, 240, 228, 242, 233, 230, 231, 216, 203, 194, 201, 196, 183, 195, 179, 188, 170, 198, 158, 159, 250,
  255, 255, 244, 211, 236, 225, 250, 209, 199, 203, 202, 198, 177, 165, 159, 171, 183, 174, 144, 156, 116, 136, 149, 116,
  144, 113, 104, 120, 93, 89, 104, 251, 235, 230, 226, 233, 228, 223, 224, 230, 223, 191, 162, 193, 166, 189, 159, 176,
  164, 178, 141, 153, 155, 124, 134, 128, 134, 96, 108, 121, 104, 103, 102, 84, 93, 79, 78, 70, 50, 67, 72, 69,
  251, 250, 252, 255, 241, 236, 234, 247, 233, 225, 217, 203, 186, 208, 186, 206, 180, 181, 168, 159, 172, 164, 147, 150,
  121, 143, 157, 113, 116, 130, 111, 109, 77, 98, 92, 104, 77, 67, 75, 62, 47, 64, 51, 38, 34, 32, 43, 3,
  28, 18, 7, 6, 10, 27, 0, 0, 15, 0, 10, 10, 16, 20, 0, 0, 8, 0, 0, 0, 11, 14, 0, 9,
  2, 14, 0, 0, 9, 0, 5, 0, 4, 0, 0, 9, 9, 5, 0, 5, 0, 0, 2, 9, 18, 1, 0, 0,
  243, 255, 235, 236, 222, 244, 227, 225, 197, 182, 202, 208, 194, 190, 191, 203, 178, 168, 162, 151, 158, 152, 129, 144,
  162, 135, 141, 122, 100, 99, 114, 114, 89, 91, 93, 97, 44, 39, 93, 55, 36, 56, 60, 48, 30, 22, 4, 0,
  3, 11, 0, 6, 0, 3, 0, 0, 12, 0, 235, 255, 250, 255, 227, 210, 222, 216, 209, 199, 193, 176, 183, 193,
  207, 170, 203, 250, 255, 255, 252, 227, 231, 220, 214, 222, 203, 224, 199, 210, 197, 177, 179, 173, 155, 153, 167, 142,
  146, 134, 128, 147, 120, 116, 110, 122, 109, 105, 107, 83, 86, 63, 92, 83, 56, 94, 54, 49, 55, 55, 61, 37,
  16, 24, 29, 12, 28, 0, 0, 0, 12, 0, 10, 19, 28, 0, 2, 4, 0, 11, 10, 0, 14, 32, 0, 15,
  3, 0, 0, 0, 0, 0, 0, 14, 13, 0, 10, 0, 0, 0, 0, 0, 7, 0, 8, 17, 0, 9, 17, 0,
  14, 0, 0, 16, 0, 1, 6, 15, 0, 0, 0, 0, 245, 238, 235, 226, 221, 214, 250, 255, 242, 252, 234, 250,
  249, 250, 250, 255, 227, 223, 226, 216, 185, 190, 201, 185, 174, 162, 186, 167, 192, 152, 154, 152, 131, 133, 151, 102,
  116, 123, 93, 108, 125, 112, 98, 69, 87, 65, 60, 76, 88, 81, 44, 36, 21, 35, 255, 246, 235, 255, 217, 226,
  214, 235, 187, 216, 197, 194, 196, 213, 199, 189, 172, 176, 158, 165, 148, 135, 157, 117, 126, 145, 121, 103, 96, 89,
  106, 105, 113, 98, 87, 71, 78, 54, 90, 48, 78, 45, 23, 30, 44, 16, 5, 21, 7, 24, 0, 0, 10, 0,
  0, 0, 0, 0, 0, 0, 26, 1, 7, 2, 0, 255, 244, 237, 243, 237, 240, 223, 183, 195, 206, 215, 228, 170,
  182, 202, 177, 181, 182, 176, 155, 156, 140, 162, 143, 148, 141, 108, 116, 131, 100, 116, 81, 92, 64, 72, 95, 74,
  67, 56, 69, 54, 51, 44, 60, 45, 31, 12, 6, 19, 9, 0, 0, 18, 3, 0, 0, 1, 0, 255, 255, 245,
  250, 244, 242, 227, 214, 201, 180, 199, 203, 209, 204, 176, 147, 163, 180, 172, 154, 156, 129, 250, 249, 248, 229, 223,
  248, 226, 208, 232, 220, 203, 255, 252, 240, 247, 229, 235, 211, 231, 209, 206, 227, 216, 196, 253, 255, 226, 253, 246,
  220, 230, 223, 204, 222, 210, 196, 184, 194, 208, 163, 170, 167, 156, 159, 148, 143, 148, 127, 143, 136, 168, 98, 97,
  116, 119, 89, 91, 61, 84, 79, 70, 76, 79, 59, 62, 32, 73, 45, 47, 26, 22, 23, 18, 7, 8, 255, 255,
  219, 243, 244, 244, 228, 222, 218, 215, 209, 207, 194, 196, 170, 158, 153, 170, 187, 229, 247, 252, 255, 249, 255, 255,
  237, 235, 250, 222, 218, 233, 241, 209, 185, 199, 198, 184, 175, 178, 154, 159, 163, 165, 138, 116, 125, 137, 125, 130,
  103, 118, 102, 88, 93, 104, 88, 77, 73, 85, 66, 91, 57, 43, 26, 13, 11, 48, 35, 31, 31, 27, 0, 0,
  0, 3, 8, 0, 0, 3, 8, 4, 0, 1, 0, 0, 6, 5, 255, 246, 229, 254, 222, 215, 231, 237, 208, 221,
  203, 201, 214, 181, 190, 177, 170, 175, 167, 168, 165, 155, 158, 140, 131, 124, 115, 108, 101, 90, 101, 98, 118, 93,
};
static const uint8_t S4_CCS_Q[] PROGMEM = {
  0, 14, 14, 24, 22, 27, 25, 48, 51, 33, 39, 46, 49, 0, 18, 24, 8, 22, 24, 16, 34, 55, 55, 61,
  75, 60, 64, 96, 77, 66, 87, 85, 101, 107, 101, 104, 111, 133, 136, 106, 137, 153, 153, 156, 157, 155, 167, 183,
  160, 173, 185, 198, 219, 196, 196, 229, 219, 232, 240, 240, 243, 230, 248, 247, 245, 254, 255, 255, 254, 253, 238, 255,
  255, 255, 244, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 243, 255, 0, 2, 12, 1, 2, 17, 14, 28,
  23, 0, 3, 11, 17, 30, 40, 12, 35, 32, 49, 55, 50, 66, 80, 72, 76, 85, 79, 99, 80, 104, 88, 108,
  8, 2, 12, 21, 32, 13, 35, 43, 40, 33, 39, 63, 32, 72, 63, 72, 79, 90, 92, 101, 108, 128, 105, 125,
  116, 137, 136, 131, 141, 142, 151, 165, 162, 166, 175, 168, 177, 195, 210, 191, 210, 212, 202, 236, 209, 219, 231, 244,
  247, 249, 255, 253, 250, 255, 255, 251, 255, 255, 255, 232, 255, 255, 255, 255, 255, 255, 255, 241, 255, 255, 255, 252,
  244, 249, 244, 255, 255, 255, 240, 239, 255, 255, 247, 248, 245, 245, 255, 255, 255, 255, 253, 251, 255, 255, 255, 255,
  236, 255, 255, 255, 247, 252, 255, 243, 255, 255, 241, 232, 249, 252, 255, 235, 254, 255, 254, 249, 254, 246, 255, 255,
  253, 234, 253, 253, 251, 0, 2, 29, 13, 30, 32, 32, 28, 25, 42, 47, 57, 52, 74, 85, 86, 87, 86, 99,
  95, 101, 92, 112, 106, 119, 132, 131, 167, 139, 140, 158, 175, 168, 160, 190, 183, 171, 202, 211, 214, 202, 206, 215,
  229, 212, 218, 228, 242, 252, 253, 255, 255, 252, 241, 252, 255, 254, 253, 244, 247, 238, 255, 255, 255, 255, 255, 255,
  255, 255, 245, 255, 245, 255, 255, 255, 255, 255, 255, 244, 255, 255, 248, 255, 255, 250, 255, 250, 248, 248, 255, 255,
  242, 254, 0, 4, 17, 13, 20, 25, 28, 30, 51, 63, 46, 49, 55, 66, 67, 77, 86, 83, 85, 93, 96, 104,
  125, 126, 0, 2, 12, 33, 22, 33, 32, 21, 42, 49, 59, 74, 75, 60, 0, 5, 3, 5, 15, 31, 21, 43,
  37, 51, 47, 55, 57, 64, 62, 60, 89, 93, 89, 109, 117, 102, 103, 118, 125, 140, 124, 139, 140, 145, 152, 157,
  167, 163, 162, 176, 175, 180, 195, 182, 208, 208, 223, 221, 222, 238, 230, 242, 237, 253, 249, 251, 255, 11, 2, 3,
  11, 19, 18, 42, 40, 40, 34, 53, 43, 57, 58, 69, 68, 79, 90, 90, 107, 94, 122, 105, 134, 122, 127, 129,
  149, 158, 155, 152, 140, 164, 169, 167, 176, 192, 199, 177, 199, 197, 222, 212, 220, 225, 232, 239, 241, 250, 251, 249,
  255, 247, 244, 237, 239, 255, 255, 241, 255, 255, 255, 255, 254, 255, 255, 235, 255, 255, 248, 244, 255, 255, 255, 255,
  255, 254, 255, 255, 255, 252, 255, 255, 240, 255, 244, 255, 255, 255, 255, 255, 248, 231, 254, 255, 242, 255, 254, 255,
  255, 255, 255, 255, 240, 245, 251, 255, 255, 247, 255, 255, 255, 255, 255, 255, 244, 251, 247, 253, 255, 250, 254, 255,
  249, 247, 255, 253, 255, 253, 252, 255, 255, 251, 253, 250, 255, 255, 255, 255, 255, 250, 254, 255, 247, 244, 255, 255,
  248, 237, 251, 251, 246, 252, 255, 255, 255, 240, 227, 249, 249, 255, 254, 246, 249, 255, 239, 255, 249, 255, 249, 255,
  255, 250, 255, 253, 255, 0, 14, 11, 11, 18, 34, 44, 42, 29, 26, 0, 4, 16, 11, 30, 35, 14, 28, 35,
  58, 55, 49, 75, 64, 56, 69, 81, 71, 101, 85, 98, 120, 106, 119, 114, 119, 125, 0, 2, 13, 5, 12, 20,
  36, 40, 49, 33, 44, 48, 51, 57, 74, 75, 89, 96, 99, 103, 105, 125, 102, 120, 120, 123, 131, 138, 150, 155,
  148, 170, 165, 170, 182, 189, 197, 182, 0, 2, 3, 20, 13, 15, 43, 29, 60, 61, 28, 60, 60, 64, 74, 76,
  85, 79, 95, 87, 95, 91, 98, 129, 129, 124, 142, 131, 132, 145, 158, 148, 163, 174, 0, 17, 3, 15, 16, 28,
  35, 42, 14, 43, 1, 5, 8, 21, 13, 26, 33, 19, 28, 58, 55, 47, 78, 67, 83, 75, 87, 100, 92, 103,
  102, 119, 101, 120, 146, 116, 125, 144, 149, 139, 148, 142, 168, 155, 181, 184, 185, 196, 177, 181, 204, 220, 207, 216,
  238, 216, 235, 228, 250, 244, 255, 0, 2, 3, 16, 29, 10, 13, 37, 39, 57, 49, 66, 56, 64, 76, 87, 79,
  90, 84, 107, 109, 0, 2, 18, 8, 19, 11, 24, 19, 55, 38, 44, 55, 57, 62, 84, 83, 79, 94, 91, 98,
  107, 95, 106, 111, 126, 142, 132, 142, 147, 135, 151, 149, 173, 174, 190, 187, 179, 182, 181, 204, 193, 204, 208, 218,
  218, 226, 249, 232, 238, 245, 248, 238, 255, 255, 255, 255, 238, 255, 247, 247, 255, 255, 5, 2, 3, 24, 12, 25,
  41, 25, 35, 52, 55, 53, 66, 58, 60, 89, 79, 83, 88, 96, 107, 113, 113, 114, 123, 106, 137, 133, 160, 138,
  158, 149, 165, 181, 171, 174, 182, 179, 194, 200, 202, 224, 207, 224, 239, 225, 235, 241, 252, 253, 244, 255, 244, 255,
  246, 241, 252, 253, 255, 255, 255, 242, 255, 255, 255, 255, 253, 255, 249, 255, 255, 249, 249, 236, 255, 255, 249, 250,
  255, 253, 247, 242, 247, 250, 249, 249, 255, 254, 250, 252, 255, 255, 255, 248, 255, 255, 255, 244, 251, 255, 250, 245,
  252, 251, 249, 0, 2, 12, 5, 15, 18, 35, 47, 23, 50, 49, 51, 53, 72, 71, 65, 77, 72, 89, 91, 108,
  119, 119, 111, 120, 131, 134, 125, 139, 151, 151, 164, 170, 171, 182, 177, 197, 186, 201, 188, 193, 215, 224, 221, 217,
  215, 243, 227, 246, 253, 255, 255, 255, 246, 253, 251, 255, 236, 248, 243, 255, 255, 255, 249, 255, 251, 255, 255, 255,
  253, 255, 255, 0, 12, 22, 14, 22, 25, 26, 38, 49, 56, 53, 58, 69, 62, 75, 70, 84, 66, 95, 96, 3,
  2, 3, 12, 37, 21, 30, 14, 44, 53, 51, 54, 58, 74, 85, 90, 83, 76, 84, 107, 100, 129, 117, 110, 134,
  116, 139, 147, 138, 158, 162, 153, 3, 16, 20, 25, 22, 27, 31, 32, 30, 36, 60, 82, 62, 83, 67, 90, 80,
  89, 81, 109, 102, 102, 125, 120, 126, 123, 151, 144, 137, 150, 152, 155, 168, 164, 176, 177, 185, 200, 190, 188, 191,
  3, 5, 2, 2, 13, 18, 21, 13, 25, 32, 39, 50, 64, 50, 67, 54, 74, 75, 85, 93, 86, 93, 107, 106,
  127, 113, 105, 138, 137, 129, 144, 147, 171, 157, 163, 156, 176, 185, 181, 192, 203, 193, 204, 214, 219, 222, 215, 245,
  229, 238, 247, 249, 248, 236, 255, 255, 245, 255, 248, 248, 244, 241, 255, 255, 249, 255, 255, 255, 248, 245, 255, 249,
  253, 246, 255, 255, 248, 255, 252, 255, 252, 255, 255, 249, 249, 251, 255, 252, 255, 255, 253, 249, 243, 254, 255, 255,
  8, 2, 17, 18, 30, 15, 29, 32, 53, 65, 52, 49, 61, 65, 67, 60, 79, 87, 93, 102, 98, 104, 122, 113,
  102, 122, 119, 134, 152, 154, 145, 146, 165, 165, 165, 164, 203, 208, 172, 200, 214, 202, 201, 211, 225, 232, 246, 250,
  250, 246, 255, 251, 255, 253, 255, 255, 246, 255, 14, 2, 6, 5, 26, 39, 32, 38, 44, 53, 59, 72, 69, 63,
  55, 82, 61, 4, 2, 3, 6, 26, 24, 34, 40, 36, 50, 37, 56, 50, 61, 76, 76, 82, 96, 99, 91, 110,
  109, 118, 124, 113, 132, 137, 143, 136, 147, 151, 151, 169, 169, 187, 167, 175, 196, 171, 200, 205, 203, 204, 202, 220,
  236, 232, 230, 244, 234, 255, 255, 255, 247, 255, 248, 242, 235, 255, 253, 252, 255, 247, 248, 255, 245, 233, 255, 245,
  253, 255, 255, 255, 255, 255, 255, 245, 246, 255, 248, 255, 255, 255, 255, 255, 250, 255, 250, 243, 255, 249, 243, 255,
  245, 255, 255, 244, 255, 254, 250, 244, 255, 255, 255, 255, 7, 13, 17, 25, 30, 36, 3, 2, 12, 7, 15, 5,
  7, 8, 9, 8, 29, 33, 32, 41, 64, 62, 56, 69, 78, 88, 73, 88, 71, 101, 101, 104, 120, 120, 110, 145,
  137, 134, 156, 147, 137, 148, 159, 181, 170, 187, 191, 182, 175, 182, 209, 216, 228, 219, 0, 8, 17, 5, 33, 28,
  38, 25, 60, 41, 56, 60, 60, 49, 60, 69, 83, 81, 95, 92, 105, 116, 102, 132, 127, 115, 134, 148, 154, 161,
  150, 153, 148, 161, 170, 183, 179, 198, 174, 205, 185, 210, 227, 223, 215, 236, 245, 236, 247, 237, 255, 255, 248, 255,
  255, 255, 255, 255, 255, 255, 237, 254, 250, 254, 255, 0, 9, 16, 13, 19, 18, 31, 61, 55, 48, 44, 36, 78,
  71, 58, 77, 76, 77, 83, 99, 100, 113, 99, 113, 111, 118, 143, 138, 129, 153, 143, 169, 163, 184, 180, 166, 182,
  188, 197, 190, 202, 206, 212, 202, 214, 226, 241, 247, 238, 247, 255, 255, 242, 253, 255, 255, 254, 255, 0, 2, 10,
  8, 14, 17, 29, 39, 50, 66, 54, 54, 50, 56, 77, 99, 89, 78, 86, 100, 100, 120, 3, 6, 8, 23, 28,
  12, 29, 44, 28, 38, 52, 0, 4, 14, 10, 24, 21, 40, 27, 44, 48, 35, 44, 60, 2, 2, 23, 6, 13,
  32, 27, 33, 48, 37, 47, 58, 68, 62, 54, 87, 84, 88, 97, 96, 106, 110, 109, 124, 115, 121, 100, 151, 153,
  142, 141, 164, 163, 187, 171, 177, 184, 182, 181, 197, 196, 219, 192, 213, 213, 229, 234, 234, 239, 248, 249, 0, 2,
  28, 13, 14, 16, 28, 34, 38, 42, 47, 50, 61, 62, 81, 91, 96, 86, 75, 18, 7, 5, 5, 4, 2, 3,
  17, 20, 11, 33, 37, 28, 24, 48, 66, 58, 60, 71, 79, 78, 97, 95, 94, 94, 114, 131, 126, 119, 129, 127,
  147, 138, 151, 163, 161, 155, 167, 176, 181, 174, 189, 173, 198, 209, 223, 234, 237, 212, 223, 227, 229, 233, 253, 255,
  255, 253, 249, 255, 255, 253, 249, 252, 255, 254, 255, 255, 251, 251, 0, 8, 21, 6, 29, 36, 26, 23, 45, 38,
  52, 54, 47, 72, 67, 77, 84, 82, 89, 90, 94, 102, 101, 116, 124, 130, 138, 144, 151, 160, 154, 157, 145, 164,
};

static inline float q_to_f(uint8_t q){ return ((float)q) / 255.0f; }</file><file path="uccs_d4_scan90/src/txsd/TXSD_UCCS_D4_SCAN90/TXSD_UCCS_D4_SCAN90.ino">// TXSD_UCCS_D4_SCAN90.ino (uccs_d4_scan90)
// INA219 logger for Step D4 (U ablation).
// Start/stop via SYNC (TX GPIO25 -&gt; TXSD GPIO26).
// TX sends preamble pulses on TICK (TX GPIO27 -&gt; TXSD GPIO33) to encode cond_id.
// During trial, TX emits 1 tick per payload update, and TXSD uses tick_count as adv_count (approx).
//
// cond_id:
//   1: S4 fixed100
//   2: S4 fixed500
//   3: S4 policy (U+CCS, 100↔500)
//   4: S4 ablation_u_shuf (U shuffled)

#include &lt;Arduino.h&gt;
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;Adafruit_INA219.h&gt;

// Pins
static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26;
static const int SYNC_OFF_IN = -1; // unused
static const int TICK_IN = 33;
static const int I2C_SDA = 21;
static const int I2C_SCL = 22;

// Settings
static const uint32_t SAMPLE_US    = 10000;   // 10ms = 100Hz
static const uint32_t FALLBACK_MS  = 2400000; // safety fallback (~40 min)
static const uint32_t MIN_TRIAL_MS = 1000;    // ignore trials shorter than 1s
static const uint32_t TICK_PER_TRIAL = 0;     // 0=disabled (use SYNC to end)
static const char SUBJECT_ID[] = &quot;uccs_d4_scan90_d4&quot;;

// Preamble window (count TICK pulses after SYNC rising edge)
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint8_t PREAMBLE_MAX_ID = 16;

HardwareSerial Debug(0);
Adafruit_INA219 ina;
File f;

volatile uint32_t tickCountRaw=0; // cumulative
uint32_t tickStart=0;
uint32_t tickCount=0;
bool logging=false;
bool pendingStart=false;
uint32_t t0_ms=0, nextSampleUs=0;
uint32_t badLines=0;
uint32_t syncLowSince=0;
uint32_t pendingSinceMs=0;
uint32_t tickAtSync=0;
uint8_t condId=0;

// Stats
double sumP=0.0; double sumV=0.0; double sumI=0.0; uint32_t sampN=0;

static bool condInfo(uint8_t id, const char** tag){
  switch(id){
    case 1: *tag = &quot;s4_fixed100&quot;;      return true;
    case 2: *tag = &quot;s4_fixed500&quot;;      return true;
    case 3: *tag = &quot;s4_policy&quot;;        return true;
    case 4: *tag = &quot;s4_ablation_ushuf&quot;; return true;
    default: break;
  }
  *tag = &quot;unk&quot;;
  return false;
}

static inline String nextPath(uint8_t id){
  SD.mkdir(&quot;/logs&quot;);
  char p[96];
  const char* tag=&quot;unk&quot;;
  (void)condInfo(id, &amp;tag);
  for (uint32_t trial_idx=1;;++trial_idx){
    snprintf(p,sizeof(p),&quot;/logs/trial_%03lu_c%u_%s.csv&quot;,
             (unsigned long)trial_idx, (unsigned)id, tag);
    if(!SD.exists(p)) return String(p);
  }
}

void IRAM_ATTR onTickRaw(){ tickCountRaw++; }

static void startTrial(uint8_t id){
  condId = id;
  const char* tag=&quot;unk&quot;;
  (void)condInfo(condId, &amp;tag);
  String path = nextPath(id);
  f = SD.open(path, FILE_WRITE);
  if (!f){ Debug.println(&quot;[SD] open FAIL&quot;); return; }
  f.println(&quot;ms,mV,uA,p_mW&quot;);

  f.printf(&quot;# meta, firmware=TXSD_UCCS_D4_SCAN90, cond_id=%u, tag=%s, subject=%s\r\n&quot;,
           (unsigned)condId, tag, SUBJECT_ID);
  if (condId == 3){
    f.printf(&quot;# meta, policy=actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20 ccs_inverted=true\r\n&quot;);
  }
  if (condId == 4){
    f.printf(&quot;# meta, ablation=u_shuf u_shuffle_seed=0xD4B40201 policy=actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20 ccs_inverted=true\r\n&quot;);
  }
  f.flush();

  logging = true;
  t0_ms = millis();
  nextSampleUs = micros() + SAMPLE_US;
  badLines = 0;
  tickCount = 0;
  tickStart = tickCountRaw; // exclude preamble pulses
  sumP=sumV=sumI=0.0;
  sampN=0;
  Debug.printf(&quot;[PWR] start %s subject=%s\n&quot;, path.c_str(), SUBJECT_ID);
}

static void endTrial(){
  if (!logging) return;
  logging = false;
  uint32_t ms_total = millis() - t0_ms;
  tickCount = tickCountRaw - tickStart;

  if (ms_total &lt; MIN_TRIAL_MS){
    Debug.printf(&quot;[PWR] ignore short trial ms_total=%lu\n&quot;, (unsigned long)ms_total);
    if (f){ f.flush(); f.close(); }
    return;
  }

  double meanP = (sampN&gt;0)? (sumP/sampN) : 0.0;
  double meanV = (sampN&gt;0)? (sumV/sampN) : 0.0;
  double meanI = (sampN&gt;0)? (sumI/sampN) : 0.0;
  double E_mJ  = meanP * (ms_total/1000.0);

  f.printf(&quot;# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, subject=%s\r\n&quot;,
           (unsigned long)ms_total, (unsigned long)tickCount, E_mJ, SUBJECT_ID);
  f.printf(&quot;# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f, parse_drop=%lu\r\n&quot;,
           (unsigned long)sampN,
           (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
           meanV, meanI, meanP, (unsigned long)badLines);
  f.flush(); f.close();

  Debug.printf(&quot;[PWR] end ms=%lu adv_count=%lu E=%.3fmJ\n&quot;,
               (unsigned long)ms_total, (unsigned long)tickCount, E_mJ);
  Debug.printf(&quot;[PWR] diag samples=%lu rate=%.2f mean_v=%.3f mean_i=%.3f mean_p=%.1f parse_drop=%lu\n&quot;,
               (unsigned long)sampN,
               (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
               meanV, meanI, meanP, (unsigned long)badLines);
}

void setup(){
  Debug.begin(115200);
  Debug.println(&quot;[PWR] FW=TXSD_UCCS_D4_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)){ Debug.println(&quot;[SD] init FAIL&quot;); while(1) delay(1000); }

  pinMode(SYNC_IN, INPUT_PULLDOWN);
  if (SYNC_OFF_IN &gt;= 0) pinMode(SYNC_OFF_IN, INPUT_PULLDOWN);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTickRaw, RISING);

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  ina.begin();
  ina.setCalibration_16V_400mA();

  Debug.println(&quot;[PWR] ready&quot;);
}

void loop(){
  uint32_t nowMs = millis();

  int syncIn = digitalRead(SYNC_IN);
  int syncOff = (SYNC_OFF_IN &gt;= 0) ? digitalRead(SYNC_OFF_IN) : HIGH;

  if (!logging &amp;&amp; !pendingStart &amp;&amp; syncIn == HIGH){
    pendingStart = true;
    pendingSinceMs = nowMs;
    tickAtSync = tickCountRaw;
    syncLowSince = 0;
    Debug.printf(&quot;[PWR] SYNC high, wait preamble %lums (tick_raw=%lu)\n&quot;,
                 (unsigned long)PREAMBLE_WINDOW_MS, (unsigned long)tickCountRaw);
  }

  if (pendingStart){
    if (syncIn == LOW){
      pendingStart = false;
      Debug.println(&quot;[PWR] pending start canceled (SYNC LOW)&quot;);
    } else if ((nowMs - pendingSinceMs) &gt;= PREAMBLE_WINDOW_MS){
      uint32_t pulses = tickCountRaw - tickAtSync;
      uint8_t id = (pulses &gt;= 1 &amp;&amp; pulses &lt;= PREAMBLE_MAX_ID) ? (uint8_t)pulses : 0;
      startTrial(id);
      pendingStart = false;
      syncLowSince = 0;
      Debug.printf(&quot;[PWR] trigger start by preamble pulses=%lu -&gt; cond_id=%u\n&quot;, (unsigned long)pulses, (unsigned)id);
      nowMs = millis();
    }
  }

  if (logging){
    bool syncLow = (syncIn == LOW) || (syncOff == LOW);
    if (syncLow){
      if (syncLowSince == 0) syncLowSince = nowMs;
      if ((nowMs - syncLowSince) &gt;= 100){
        Debug.printf(&quot;[PWR] end by SYNC/SYNC_OFF sync=%d sync_off=%d\n&quot;, syncIn, syncOff);
        endTrial();
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
      tickCount = tickCountRaw - tickStart;
      if (TICK_PER_TRIAL &gt; 0 &amp;&amp; tickCount &gt;= TICK_PER_TRIAL){
        Debug.printf(&quot;[PWR] force end by TICK (count=%lu)\n&quot;, (unsigned long)tickCount);
        endTrial();
      }
      if ((nowMs - t0_ms) &gt;= FALLBACK_MS){
        Debug.printf(&quot;[PWR] force end by timeout (ms=%lu)\n&quot;, (unsigned long)(nowMs - t0_ms));
        endTrial();
      }
    }

    uint32_t nowUs = micros();
    while ((int32_t)(nowUs - nextSampleUs) &gt;= 0){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();
      int32_t mv = (int32_t)lroundf(v*1000.0f);
      int32_t uA = (int32_t)lroundf(i*1000.0f);
      double p_mW = v*i;
      uint32_t relMs = millis() - t0_ms;

      sumP += p_mW;
      sumV += v;
      sumI += i;
      sampN++;

      char buf[64];
      int n = snprintf(buf, sizeof(buf), &quot;%lu,%ld,%ld,%.1f\r\n&quot;,
                       (unsigned long)relMs, (long)mv, (long)uA, p_mW);
      if (n &gt; 0) f.write((uint8_t*)buf, n); else badLines++;
      nowUs = micros();
    }
  }

  vTaskDelay(1);
}</file><file path="uccs_d4b_scan70/src/rx/RX_UCCS_D4B_SCAN70/RX_UCCS_D4B_SCAN70.ino">// RX_UCCS_D4B_SCAN70.ino (uccs_d4b_scan70)
// Receive TX_UCCS_D4B packets (MFD &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;) and log to SD.
// - SYNC gate: TX GPIO25 -&gt; RX GPIO26.
// - NimBLE passive scan with scan70% (interval=100ms, window=70ms).

#include &lt;Arduino.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NimBLEDevice.h&gt;
#include &lt;math.h&gt;

static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26; // TX GPIO25 -&gt; RX GPIO26

// scan70
static const float SCAN_INTERVAL_MS = 100.0f;
static const float SCAN_WINDOW_MS   = 70.0f;

static const uint32_t SESSION_TIMEOUT_MS = 1200000;
static const uint32_t SYNC_LOW_DEBOUNCE_MS = 100;
static const uint32_t START_LEVEL_HOLD_MS = 200;

static inline uint16_t ms_to_0p625(float ms){ return (uint16_t)lroundf(ms / 0.625f); }

static const uint16_t RX_BUF_SIZE = 512;
static const uint32_t FLUSH_INTERVAL_MS = 500;

struct RxEntry {
  uint32_t ms;
  int8_t   rssi;
  uint16_t seq;
  char     label[24];
  char     addr[18];
  char     mfd[48];
};

static RxEntry rxBuf[RX_BUF_SIZE];
static volatile uint16_t rxHead = 0;
static uint16_t rxTail = 0;
static uint32_t bufOverflow = 0;
static uint32_t lastFlushMs = 0;

static bool trial = false;
static uint32_t t0Ms = 0;
static uint32_t rxCount = 0;
static uint32_t syncLowSince = 0;
static uint32_t syncHighSince = 0;

static File f;
static const char FW_TAG[] = &quot;RX_UCCS_D4B_SCAN70&quot;;
static bool condSeen = false;
static bool condWritten = false;
static char condLabel[24] = {0};

static bool parseMFD(const std::string&amp; s, uint16_t&amp; seq, std::string&amp; label) {
  size_t usPos = s.find(&apos;_&apos;);
  if (usPos == std::string::npos || usPos &lt; 1) return false;
  std::string seqStr = s.substr(0, usPos);
  label = s.substr(usPos + 1);
  if (label.empty()) return false;
  char* endp = nullptr;
  unsigned long v = strtoul(seqStr.c_str(), &amp;endp, 10);
  if (endp == seqStr.c_str() || v &gt; 65535UL) return false;
  seq = static_cast&lt;uint16_t&gt;(v);
  return true;
}

static String nextPath() {
  SD.mkdir(&quot;/logs&quot;);
  char p[64];
  for (uint32_t id = 1;; ++id) {
    snprintf(p, sizeof(p), &quot;/logs/rx_trial_%03lu.csv&quot;, (unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

static void flushBuffer() {
  if (!f) return;
  if (!condWritten &amp;&amp; condSeen) {
    f.printf(&quot;# condition_label=%s\r\n&quot;, condLabel);
    condWritten = true;
  }
  uint16_t head = rxHead;
  bool wrote = false;
  while (rxTail != head) {
    RxEntry&amp; e = rxBuf[rxTail];
    f.printf(&quot;%lu,ADV,%d,%u,%s,%s,%s\r\n&quot;,
             (unsigned long)e.ms,
             (int)e.rssi,
             (unsigned)e.seq,
             e.label,
             e.addr,
             e.mfd);
    rxTail = (rxTail + 1) % RX_BUF_SIZE;
    wrote = true;
  }
  if (wrote) f.flush();
}

static void startSession() {
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (f) {
    f.println(&quot;ms,event,rssi,seq,label,addr,mfd&quot;);
    f.printf(&quot;# meta, firmware=%s, buf_size=%u\r\n&quot;, FW_TAG, (unsigned)RX_BUF_SIZE);
    f.printf(&quot;# meta, scan_interval_ms=%.1f, scan_window_ms=%.1f\r\n&quot;, SCAN_INTERVAL_MS, SCAN_WINDOW_MS);
    f.flush();
  }
  t0Ms = millis();
  rxCount = 0;
  rxHead = rxTail = 0;
  bufOverflow = 0;
  lastFlushMs = t0Ms;
  condSeen = false;
  condWritten = false;
  condLabel[0] = &apos;\0&apos;;
  Serial.printf(&quot;[RX] start %s\n&quot;, path.c_str());
  trial = true;
}

static void endSession() {
  if (!trial) return;
  flushBuffer();
  if (f) { f.flush(); f.close(); }
  uint32_t t_ms = millis() - t0Ms;
  double dur_s = t_ms / 1000.0;
  double rate_hz = dur_s &gt; 0 ? (double)rxCount / dur_s : 0.0;
  Serial.printf(&quot;[RX] end ms_total=%lu rx=%lu buf_overflow=%lu rate_hz=%.2f\n&quot;,
                (unsigned long)t_ms,
                (unsigned long)rxCount,
                (unsigned long)bufOverflow,
                rate_hz);
  trial = false;
}

class AdvCB : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    const std::string&amp; mfd = d-&gt;getManufacturerData();
    uint16_t seq;
    std::string label;
    if (!parseMFD(mfd, seq, label)) return;
    if (!condSeen) {
      strncpy(condLabel, label.c_str(), sizeof(condLabel) - 1);
      condLabel[sizeof(condLabel) - 1] = &apos;\0&apos;;
      condSeen = true;
    }
    const std::string addr = d-&gt;getAddress().toString();

    uint16_t nextH = (rxHead + 1) % RX_BUF_SIZE;
    if (nextH == rxTail) { bufOverflow++; return; }

    RxEntry&amp; e = rxBuf[rxHead];
    e.ms = millis() - t0Ms;
    e.rssi = (int8_t)d-&gt;getRSSI();
    e.seq = seq;
    strncpy(e.label, label.c_str(), sizeof(e.label) - 1);
    e.label[sizeof(e.label) - 1] = &apos;\0&apos;;
    strncpy(e.addr, addr.c_str(), sizeof(e.addr) - 1);
    e.addr[sizeof(e.addr) - 1] = &apos;\0&apos;;
    strncpy(e.mfd, mfd.c_str(), sizeof(e.mfd) - 1);
    e.mfd[sizeof(e.mfd) - 1] = &apos;\0&apos;;

    rxHead = nextH;
    rxCount++;
  }
};

static NimBLEScan* scan = nullptr;
static AdvCB cb;

void setup() {
  Serial.begin(115200);
  Serial.printf(&quot;[RX] FW=%s\n&quot;, FW_TAG);

  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) {
    Serial.println(&quot;[RX] SD init FAIL&quot;);
    while (1) delay(1000);
  }

  pinMode(SYNC_IN, INPUT_PULLDOWN);

  NimBLEDevice::init(&quot;&quot;);
  scan = NimBLEDevice::getScan();
  scan-&gt;setScanCallbacks(&amp;cb, false);
  scan-&gt;setActiveScan(false);
  scan-&gt;setInterval(ms_to_0p625(SCAN_INTERVAL_MS));
  scan-&gt;setWindow(ms_to_0p625(SCAN_WINDOW_MS));
  scan-&gt;setMaxResults(0);
  scan-&gt;start(0, false, false);

  Serial.printf(&quot;[RX] ready (buf=%u, flush=%lums, wait SYNC pin=%d)\n&quot;,
                (unsigned)RX_BUF_SIZE, (unsigned long)FLUSH_INTERVAL_MS, SYNC_IN);
}

void loop() {
  uint32_t nowMs = millis();
  int syncIn = digitalRead(SYNC_IN);

  if (!trial) {
    if (syncIn == HIGH) {
      if (syncHighSince == 0) syncHighSince = nowMs;
      if ((nowMs - syncHighSince) &gt;= START_LEVEL_HOLD_MS) {
        startSession();
        syncHighSince = 0;
        syncLowSince = 0;
      }
    } else {
      syncHighSince = 0;
    }
    vTaskDelay(pdMS_TO_TICKS(10));
    return;
  }

  if ((nowMs - lastFlushMs) &gt;= FLUSH_INTERVAL_MS) {
    flushBuffer();
    lastFlushMs = nowMs;
  }

  if (syncIn == LOW) {
    if (syncLowSince == 0) syncLowSince = nowMs;
    if ((nowMs - syncLowSince) &gt;= SYNC_LOW_DEBOUNCE_MS) {
      endSession();
      syncLowSince = 0;
    }
  } else {
    syncLowSince = 0;
  }

  if ((nowMs - t0Ms) &gt;= SESSION_TIMEOUT_MS) {
    endSession();
  }

  vTaskDelay(pdMS_TO_TICKS(10));
}</file><file path="uccs_d4b_scan70/src/tx/TX_UCCS_D4B_SCAN70/TX_UCCS_D4B_SCAN70.ino">// TX_UCCS_D4B_SCAN70.ino (uccs_d4b_scan70)
//
// Step D4B（CCSが効いている切り分け / Ablation）を scan70（RX duty 70%）で再現するためのTX。
// - S4のみを再生し、4条件×REPEAT回を自動実行する。
//   1) Fixed100
//   2) Fixed500
//   3) Policy(U+CCS, 100↔500)
//   4) Ablation_CCS_off（= U-only, 100↔500）
//
// Payload (ManufacturerData):
//   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
//     tag: &quot;F4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;U4-&lt;label&gt;-&lt;itv&gt;&quot;
//
// Note:
// - `stress_causal_*` の CCS は「安定度（高いほどstable）」なので、changeとして扱うため `CCS_change = 1-CCS` に変換する。
// - U-only（CCS-off）は「上げる判定/戻す判定ともUだけ」を使う（CCSで戻りをブロックしない）。

#include &lt;Arduino.h&gt;
#include &lt;BLEDevice.h&gt;
#include &lt;math.h&gt;

#ifdef ARDUINO_ARCH_ESP32
#include &quot;esp_pm.h&quot;
#endif

#include &quot;../stress_causal_s1_s4_180s.h&quot;

// ==== schedule ====
static const uint32_t GAP_MS = 5000;
static const uint8_t REPEAT = 3;
static const uint16_t EFFECTIVE_LEN_STEPS = 1800; // 180s @ 100ms grid

// ==== pins ====
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN = 2;

// ==== options ====
static const bool USE_LED = false;
static const bool ENABLE_TICK_PREAMBLE = true;
static const bool ENABLE_TICK_PER_UPDATE = true;
static const bool RESTART_ADV_ON_INTERVAL_CHANGE = true;

static const uint32_t PREAMBLE_WINDOW_MS = 800; // TXSD window
static const uint32_t PREAMBLE_GUARD_MS = 100;  // after SYNC HIGH before preamble

// ==== actions（実機は100↔500に固定） ====
static const uint16_t ACTIONS[] = {100, 500};
static const uint8_t N_ACTIONS = sizeof(ACTIONS) / sizeof(ACTIONS[0]);

// ==== policy params（D4B scan90と同一） ====
static const float U_MID = 0.20f;
static const float U_HIGH = 0.35f;
static const float C_MID = 0.20f;
static const float C_HIGH = 0.35f;
static const float HYST = 0.02f;
static const float EMA_ALPHA = 0.20f;

// ==== BLE ====
static BLEAdvertising* adv = nullptr;

#ifdef ARDUINO_ARCH_ESP32
static esp_pm_lock_handle_t noLightSleepLock = nullptr;
static bool sleepBlocked = false;
#endif

enum Mode : uint8_t {
  MODE_FIXED = 0,
  MODE_POLICY = 1,
  MODE_ABL_CCS_OFF = 2,
};

struct Condition {
  uint8_t cond_id;   // TXSD preamble pulses
  Mode mode;
  uint16_t fixed_ms; // MODE_FIXED only
};

// cond_id:
//  1: S4 fixed100
//  2: S4 fixed500
//  3: S4 policy
//  4: S4 ablation_ccs_off (U-only)
static const Condition CONDS[] = {
  {1, MODE_FIXED, 100},
  {2, MODE_FIXED, 500},
  {3, MODE_POLICY, 500},
  {4, MODE_ABL_CCS_OFF, 500},
};
static const uint8_t N_CONDS = sizeof(CONDS) / sizeof(CONDS[0]);

// state
static bool trialRunning = false;
static bool pendingStart = false;
static uint32_t syncRiseMs = 0;
static uint32_t trialStartMs = 0;
static uint32_t nextUpdateMs = 0;
static uint32_t gapStartMs = 0;
static uint8_t condIndex = 0;
static uint8_t repIndex = 0;

static uint16_t stepIdx = 0;               // 100ms grid index
static uint16_t currentIntervalMs = 500;   // 100 or 500
static float uEma = 0.0f;
static float cEma = 0.0f;                  // change-CCS EMA (policy only)

static inline uint16_t ms_to_0p625(float ms) {
  long v = lroundf(ms / 0.625f);
  if (v &lt; 0x20) v = 0x20;     // 20ms minimum
  if (v &gt; 0x4000) v = 0x4000; // 10.24s maximum
  return (uint16_t)v;
}

static uint16_t clamp_interval(uint16_t interval_ms) {
  uint16_t best = ACTIONS[0];
  uint32_t bestDist = (uint32_t)abs((int)interval_ms - (int)best);
  for (uint8_t i = 1; i &lt; N_ACTIONS; i++) {
    uint16_t a = ACTIONS[i];
    uint32_t d = (uint32_t)abs((int)interval_ms - (int)a);
    if (d &lt; bestDist || (d == bestDist &amp;&amp; a &lt; best)) {
      best = a;
      bestDist = d;
    }
  }
  return best;
}

static void syncStart() {
  if (USE_LED) digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
  syncRiseMs = millis();
}

static void syncEnd() {
  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_LED) digitalWrite(LED_PIN, LOW);
}

static void tickPulseOnce(uint16_t high_us = 200) {
  digitalWrite(TICK_OUT_PIN, HIGH);
  delayMicroseconds(high_us);
  digitalWrite(TICK_OUT_PIN, LOW);
}

static void tickPreamble(uint8_t nPulses) {
  if (!ENABLE_TICK_PREAMBLE) return;
  for (uint8_t i = 0; i &lt; nPulses; i++) {
    tickPulseOnce(200);
    delay(20);
  }
}

static void setAdvIntervalMs(uint16_t ms) {
  if (!adv) return;
  uint16_t units = ms_to_0p625((float)ms);
  adv-&gt;setMinInterval(units);
  adv-&gt;setMaxInterval(units);
}

static void setPayload(uint16_t step_idx, const char* tag) {
  if (!adv) return;
  BLEAdvertisementData ad;
  String mfd = String((unsigned)step_idx) + &quot;_&quot; + String(tag);
  ad.setManufacturerData(mfd);
  adv-&gt;setAdvertisementData(ad);
}

static void setSleepAllowed(bool allowLightSleep) {
#ifdef ARDUINO_ARCH_ESP32
  if (!noLightSleepLock) return;
  if (allowLightSleep) {
    if (sleepBlocked) {
      esp_pm_lock_release(noLightSleepLock);
      sleepBlocked = false;
    }
  } else {
    if (!sleepBlocked) {
      esp_pm_lock_acquire(noLightSleepLock);
      sleepBlocked = true;
    }
  }
#else
  (void)allowLightSleep;
#endif
}

static inline uint8_t getLabel(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0;
  return pgm_read_byte(&amp;S4_LABEL[idx]);
}

static inline float getU(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_U_Q[idx]);
  return q_to_f(q);
}

static inline float getCCSStable(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_CCS_Q[idx]);
  return q_to_f(q);
}

static void makeTag(char* out, size_t out_sz, const Condition&amp; c, uint8_t truthLabel, uint16_t intervalMs) {
  const char mp = (c.mode == MODE_FIXED) ? &apos;F&apos; : (c.mode == MODE_POLICY ? &apos;P&apos; : &apos;U&apos;);
  const unsigned lbl = (unsigned)truthLabel;
  const unsigned itv = (unsigned)intervalMs;
  snprintf(out, out_sz, &quot;%c4-%02u-%u&quot;, mp, lbl, itv);
}

static uint16_t policyStep_U_CCS(uint16_t prevInterval, float u, float c_change) {
  const float u_hi_up = U_HIGH;
  const float c_hi_up = C_HIGH;
  const float u_mid_down = U_MID - HYST;
  const float c_mid_down = C_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if (u &gt;= u_hi_up || c_change &gt;= c_hi_up) next = 100;
  } else { // prev=100
    // return condition: do not block by CCS (avoid sticky-100)
    if (u &lt; u_mid_down) next = 500;
  }
  return clamp_interval(next);
}

static uint16_t policyStep_U_only(uint16_t prevInterval, float u) {
  const float u_hi_up = U_HIGH;
  const float u_mid_down = U_MID - HYST;
  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if (u &gt;= u_hi_up) next = 100;
  } else {
    if (u &lt; u_mid_down) next = 500;
  }
  return clamp_interval(next);
}

static void startTrial(const Condition&amp; c) {
  trialRunning = true;
  pendingStart = false;
  trialStartMs = millis();
  nextUpdateMs = trialStartMs;
  stepIdx = 0;
  currentIntervalMs = clamp_interval(c.fixed_ms ? c.fixed_ms : 500);
  uEma = 0.0f;
  cEma = 0.0f;

  // sleep allowed (no busy prints)
  setSleepAllowed(true);

  syncStart();
  adv-&gt;start();

  delay(PREAMBLE_GUARD_MS);
  tickPreamble(c.cond_id);
}

static void endTrial() {
  trialRunning = false;
  adv-&gt;stop();
  syncEnd();
  gapStartMs = millis();
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);
  digitalWrite(SYNC_OUT_PIN, LOW);
  pinMode(TICK_OUT_PIN, OUTPUT);
  digitalWrite(TICK_OUT_PIN, LOW);

  BLEDevice::init(&quot;TX_UCCS_D4B70&quot;);
  BLEDevice::setPower(ESP_PWR_LVL_N0);
  adv = BLEDevice::getAdvertising();
  adv-&gt;setScanResponse(false);
  adv-&gt;setMinPreferred(0);

#ifdef ARDUINO_ARCH_ESP32
  (void)esp_pm_lock_create(ESP_PM_NO_LIGHT_SLEEP, 0, &quot;uccs_d4b70&quot;, &amp;noLightSleepLock);
  // allow sleep by default
  setSleepAllowed(true);
#endif

  condIndex = 0;
  repIndex = 0;
  gapStartMs = 0;

  startTrial(CONDS[condIndex]);
}

void loop() {
  uint32_t nowMs = millis();

  if (!trialRunning) {
    if ((nowMs - gapStartMs) &lt; GAP_MS) {
      vTaskDelay(pdMS_TO_TICKS(50));
      return;
    }
    condIndex++;
    if (condIndex &gt;= N_CONDS) {
      condIndex = 0;
      repIndex++;
    }
    if (repIndex &gt;= REPEAT) {
      vTaskDelay(pdMS_TO_TICKS(1000));
      return;
    }
    startTrial(CONDS[condIndex]);
    vTaskDelay(pdMS_TO_TICKS(20));
    return;
  }

  if ((nowMs - trialStartMs) &gt;= (uint32_t)EFFECTIVE_LEN_STEPS * 100) {
    endTrial();
    return;
  }

  if ((int32_t)(nowMs - nextUpdateMs) &lt; 0) {
    vTaskDelay(pdMS_TO_TICKS(5));
    return;
  }
  nextUpdateMs += 100; // 100ms grid
  if (stepIdx &gt;= EFFECTIVE_LEN_STEPS) {
    endTrial();
    return;
  }

  const Condition&amp; c = CONDS[condIndex];
  const uint8_t lbl = getLabel(stepIdx);
  const float u = getU(stepIdx);
  const float ccsStable = getCCSStable(stepIdx);
  const float ccsChange = 1.0f - ccsStable;

  // EMA
  uEma = EMA_ALPHA * u + (1.0f - EMA_ALPHA) * uEma;
  cEma = EMA_ALPHA * ccsChange + (1.0f - EMA_ALPHA) * cEma;

  uint16_t nextItv = currentIntervalMs;
  if (c.mode == MODE_FIXED) {
    nextItv = clamp_interval(c.fixed_ms);
  } else if (c.mode == MODE_POLICY) {
    nextItv = policyStep_U_CCS(currentIntervalMs, uEma, cEma);
  } else {
    nextItv = policyStep_U_only(currentIntervalMs, uEma);
  }

  char tag[24];
  makeTag(tag, sizeof(tag), c, lbl, nextItv);
  setPayload(stepIdx, tag);

  if (nextItv != currentIntervalMs) {
    currentIntervalMs = nextItv;
    setAdvIntervalMs(currentIntervalMs);
    if (RESTART_ADV_ON_INTERVAL_CHANGE) {
      adv-&gt;stop();
      delay(10);
      adv-&gt;start();
    }
  } else {
    setAdvIntervalMs(currentIntervalMs);
  }

  if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);
  stepIdx++;
}</file><file path="uccs_d4b_scan70/src/tx/stress_causal_s1_s4_180s.h">// stress_causal_s1_s4_180s.h (uccs_d4b_scan70)
// Wrapper to reuse the frozen truth header from D2.

#pragma once

#include &quot;../../../uccs_d2_scan90/src/tx/stress_causal_s1_s4_180s.h&quot;</file><file path="uccs_d4b_scan70/src/txsd/TXSD_UCCS_D4B_SCAN70/TXSD_UCCS_D4B_SCAN70.ino">// TXSD_UCCS_D4B_SCAN70.ino (uccs_d4b_scan70)
// INA219 logger for Step D4B (CCS ablation) under scan70.
// Start/stop via SYNC (TX GPIO25 -&gt; TXSD GPIO26).
// TX sends preamble pulses on TICK (TX GPIO27 -&gt; TXSD GPIO33) to encode cond_id.
// During trial, TX additionally emits 1 tick per payload update; TXSD uses tick_count as adv_count (approx).
//
// cond_id:
//   1: S4 fixed100
//   2: S4 fixed500
//   3: S4 policy (U+CCS)
//   4: S4 ablation_ccs_off (U-only)

#include &lt;Arduino.h&gt;
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;Adafruit_INA219.h&gt;

// Pins
static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26;
static const int SYNC_OFF_IN = -1; // unused
static const int TICK_IN = 33;
static const int I2C_SDA = 21;
static const int I2C_SCL = 22;

// Settings
static const uint32_t SAMPLE_US    = 10000;   // 10ms = 100Hz
static const uint32_t FALLBACK_MS  = 2400000; // safety fallback
static const uint32_t MIN_TRIAL_MS = 1000;
static const uint32_t TICK_PER_TRIAL = 0;     // 0=disabled (use SYNC to end)
static const char SUBJECT_ID[] = &quot;uccs_d4b_scan70&quot;;

// Preamble window (count TICK pulses after SYNC rising edge)
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint8_t PREAMBLE_MAX_ID = 16;

HardwareSerial Debug(0);
Adafruit_INA219 ina;
File f;

volatile uint32_t tickCountRaw=0; // cumulative
uint32_t tickStart=0;
uint32_t tickCount=0;
bool logging=false;
bool pendingStart=false;
uint32_t t0_ms=0, nextSampleUs=0;
uint32_t badLines=0;
uint32_t syncLowSince=0;
uint32_t pendingSinceMs=0;
uint32_t tickAtSync=0;
uint8_t condId=0;

// Stats
double sumP=0.0; double sumV=0.0; double sumI=0.0; uint32_t sampN=0;

static bool condInfo(uint8_t id, const char** tag){
  switch(id){
    case 1: *tag = &quot;s4_fixed100&quot;; return true;
    case 2: *tag = &quot;s4_fixed500&quot;; return true;
    case 3: *tag = &quot;s4_policy&quot;; return true;
    case 4: *tag = &quot;s4_ablation_ccs_off&quot;; return true;
    default: break;
  }
  *tag = &quot;unk&quot;;
  return false;
}

static inline String nextPath(uint8_t id){
  SD.mkdir(&quot;/logs&quot;);
  char p[96];
  const char* tag=&quot;unk&quot;;
  (void)condInfo(id, &amp;tag);
  for (uint32_t trial_idx=1;;++trial_idx){
    snprintf(p,sizeof(p),&quot;/logs/trial_%03lu_c%u_%s.csv&quot;,
             (unsigned long)trial_idx, (unsigned)id, tag);
    if(!SD.exists(p)) return String(p);
  }
}

void IRAM_ATTR onTickRaw(){ tickCountRaw++; }

static void startTrial(uint8_t id){
  condId = id;
  const char* tag=&quot;unk&quot;;
  (void)condInfo(condId, &amp;tag);
  String path = nextPath(id);
  f = SD.open(path, FILE_WRITE);
  if (!f){ Debug.println(&quot;[SD] open FAIL&quot;); return; }
  f.println(&quot;ms,mV,uA,p_mW&quot;);

  f.printf(&quot;# meta, firmware=TXSD_UCCS_D4B_SCAN70, cond_id=%u, tag=%s, subject=%s\r\n&quot;,
           (unsigned)condId, tag, SUBJECT_ID);
  if (condId == 3){
    f.printf(&quot;# meta, policy=U+CCS actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20 ccs_inverted=true\r\n&quot;);
  } else if (condId == 4){
    f.printf(&quot;# meta, ablation=ccs_off policy=U_only actions{100,500} u_mid=0.20 u_high=0.35 hyst=0.02 ema_alpha=0.20\r\n&quot;);
  }
  f.flush();

  logging = true;
  t0_ms = millis();
  nextSampleUs = micros() + SAMPLE_US;
  badLines = 0;
  tickCount = 0;
  tickStart = tickCountRaw; // exclude preamble pulses
  sumP=sumV=sumI=0.0;
  sampN=0;
  Debug.printf(&quot;[PWR] start %s subject=%s\n&quot;, path.c_str(), SUBJECT_ID);
}

static void endTrial(){
  if (!logging) return;
  logging = false;
  uint32_t ms_total = millis() - t0_ms;
  tickCount = tickCountRaw - tickStart;

  if (ms_total &lt; MIN_TRIAL_MS){
    Debug.printf(&quot;[PWR] ignore short trial ms_total=%lu\n&quot;, (unsigned long)ms_total);
    if (f){ f.flush(); f.close(); }
    return;
  }

  double meanP = (sampN&gt;0)? (sumP/sampN) : 0.0;
  double meanV = (sampN&gt;0)? (sumV/sampN) : 0.0;
  double meanI = (sampN&gt;0)? (sumI/sampN) : 0.0;
  double E_mJ  = meanP * (ms_total/1000.0);

  f.printf(&quot;# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, subject=%s\r\n&quot;,
           (unsigned long)ms_total, (unsigned long)tickCount, E_mJ, SUBJECT_ID);
  f.printf(&quot;# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f, parse_drop=%lu\r\n&quot;,
           (unsigned long)sampN,
           (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
           meanV, meanI, meanP, (unsigned long)badLines);
  f.flush(); f.close();

  Debug.printf(&quot;[PWR] end ms=%lu adv_count=%lu E=%.3fmJ\n&quot;,
               (unsigned long)ms_total, (unsigned long)tickCount, E_mJ);
  Debug.printf(&quot;[PWR] diag samples=%lu rate=%.2f mean_v=%.3f mean_i=%.3f mean_p=%.1f parse_drop=%lu\n&quot;,
               (unsigned long)sampN,
               (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
               meanV, meanI, meanP, (unsigned long)badLines);
}

void setup(){
  Debug.begin(115200);
  Debug.println(&quot;[PWR] FW=TXSD_UCCS_D4B_SCAN70&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)){ Debug.println(&quot;[SD] init FAIL&quot;); while(1) delay(1000); }

  pinMode(SYNC_IN, INPUT_PULLDOWN);
  if (SYNC_OFF_IN &gt;= 0) pinMode(SYNC_OFF_IN, INPUT_PULLDOWN);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTickRaw, RISING);

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  ina.begin();
  ina.setCalibration_16V_400mA();

  Debug.println(&quot;[PWR] ready&quot;);
}

void loop(){
  uint32_t nowMs = millis();
  int syncIn = digitalRead(SYNC_IN);
  int syncOff = (SYNC_OFF_IN &gt;= 0) ? digitalRead(SYNC_OFF_IN) : HIGH;

  if (!logging &amp;&amp; !pendingStart &amp;&amp; syncIn == HIGH){
    pendingStart = true;
    pendingSinceMs = nowMs;
    tickAtSync = tickCountRaw;
    syncLowSince = 0;
    Debug.printf(&quot;[PWR] SYNC high, wait preamble %lums (tick_raw=%lu)\n&quot;,
                 (unsigned long)PREAMBLE_WINDOW_MS, (unsigned long)tickCountRaw);
  }

  if (pendingStart){
    if (syncIn == LOW){
      pendingStart = false;
      Debug.println(&quot;[PWR] pending start canceled (SYNC LOW)&quot;);
    } else if ((nowMs - pendingSinceMs) &gt;= PREAMBLE_WINDOW_MS){
      uint32_t pulses = tickCountRaw - tickAtSync;
      uint8_t id = (pulses &gt;= 1 &amp;&amp; pulses &lt;= PREAMBLE_MAX_ID) ? (uint8_t)pulses : 0;
      startTrial(id);
      pendingStart = false;
      syncLowSince = 0;
      Debug.printf(&quot;[PWR] trigger start by preamble pulses=%lu -&gt; cond_id=%u\n&quot;,
                   (unsigned long)pulses, (unsigned)id);
      nowMs = millis();
    }
  }

  if (logging){
    bool syncLow = (syncIn == LOW) || (syncOff == LOW);
    if (syncLow){
      if (syncLowSince == 0) syncLowSince = nowMs;
      if ((nowMs - syncLowSince) &gt;= 100){
        Debug.printf(&quot;[PWR] end by SYNC/SYNC_OFF sync=%d sync_off=%d\n&quot;, syncIn, syncOff);
        endTrial();
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
      tickCount = tickCountRaw - tickStart;
      if (TICK_PER_TRIAL &gt; 0 &amp;&amp; tickCount &gt;= TICK_PER_TRIAL){
        Debug.printf(&quot;[PWR] force end by TICK (count=%lu)\n&quot;, (unsigned long)tickCount);
        endTrial();
      }
      if ((nowMs - t0_ms) &gt;= FALLBACK_MS){
        Debug.printf(&quot;[PWR] force end by timeout (ms=%lu)\n&quot;, (unsigned long)(nowMs - t0_ms));
        endTrial();
      }
    }

    uint32_t nowUs = micros();
    while ((int32_t)(nowUs - nextSampleUs) &gt;= 0){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();
      int32_t mv = (int32_t)lroundf(v*1000.0f);
      int32_t uA = (int32_t)lroundf(i*1000.0f);
      double p_mW = v*i;
      uint32_t relMs = millis() - t0_ms;

      sumP += p_mW;
      sumV += v;
      sumI += i;
      sampN++;

      char buf[64];
      int n = snprintf(buf, sizeof(buf), &quot;%lu,%ld,%ld,%.1f\r\n&quot;,
                       (unsigned long)relMs, (long)mv, (long)uA, p_mW);
      if (n &gt; 0) f.write((uint8_t*)buf, n); else badLines++;
      nowUs = micros();
    }
  } else {
    delay(10);
  }
}</file><file path="uccs_d4b_scan70/README.md"># uccs_d4b_scan70（Step D4B-scan70: CCS寄与をscan70で確認 / Ablation）

## 目的

`uccs_d4b_scan90` の D4B（CCS-off=U-only）に対して、**受信条件を1段悪化（scan duty 90→70%）**させた環境でも
「U-only と U+CCS が同電力（同α）なのに、U+CCS がQoS（Pout/TL）を改善する」が成立するかを確認する。

* 対象セッション: **S4のみ**
* 条件: 4条件（Fixed100 / Fixed500 / Policy(U+CCS) / U-only(CCS-off)）
* 目安: n=2〜3（時間が許す範囲で増やす）

## 真値（truth）

* `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv`（100msグリッド, n_steps=1800=180s）
* TXは上記CSV由来の `label/U/CCS` をフラッシュに埋め込み、同一セッションを再生する。

## スケッチ（Arduino IDE 用）

* TX: `uccs_d4b_scan70/src/tx/TX_UCCS_D4B_SCAN70/TX_UCCS_D4B_SCAN70.ino`
* RX: `uccs_d4b_scan70/src/rx/RX_UCCS_D4B_SCAN70/RX_UCCS_D4B_SCAN70.ino`
* TXSD: `uccs_d4b_scan70/src/txsd/TXSD_UCCS_D4B_SCAN70/TXSD_UCCS_D4B_SCAN70.ino`

## scan70 の設定（RX）

* scan interval: 100ms
* scan window: 70ms

## 配線

* TX `GPIO25 (SYNC_OUT)` → RX `GPIO26 (SYNC_IN)` / TXSD `GPIO26 (SYNC_IN)`
* TX `GPIO27 (TICK_OUT)` → TXSD `GPIO33 (TICK_IN)`

## 実行

* 1回の起動で S4 × 4条件を自動実行（`REPEAT`回数はスケッチ内）。
* trial長: 180s（`EFFECTIVE_LEN_STEPS=1800`）。

## TX payload仕様（ManufacturerData）

形式: `&lt;step_idx&gt;_&lt;tag&gt;`

* `step_idx`: 100msグリッドの整数
* `tag`: `F4-&lt;label&gt;-&lt;itv&gt;` / `P4-&lt;label&gt;-&lt;itv&gt;` / `U4-&lt;label&gt;-&lt;itv&gt;`
  * `F`: fixed, `P`: policy(U+CCS), `U`: U-only（CCS-off）
  * `&lt;label&gt;`: truth label
  * `&lt;itv&gt;`: current interval（100 or 500）

## データ配置

* SDから吸い上げた `/logs/` を `uccs_d4b_scan70/data/&lt;run&gt;/{RX,TX}/` にコピーする（TX=TXSDログ）。
* `uccs_d4b_scan70/data/&lt;run&gt;/README.md` に測定条件をメモ。

## 解析

scan90と同じスクリプトをそのまま使える（RX tag / TXSD adv_count クラスタリング）:

* `python3 uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py --rx-dir uccs_d4b_scan70/data/&lt;run&gt;/RX --txsd-dir uccs_d4b_scan70/data/&lt;run&gt;/TX --out-dir uccs_d4b_scan70/metrics/&lt;run&gt;`</file><file path="uccs_d4b_scan90/analysis/ccs_timing_analysis_conditional.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Conditional timing analysis for D4B (run01):
  &quot;average over all transitions&quot; can hide differences, because pout_1s is driven by a few failures.

This script re-computes a minimal timing view (P(interval=100) around transitions) on a *subset* of transitions.

Inputs:
  - RX dir (D4B run01): `.../RX` containing rx_trial_*.csv
  - truth CSV (100ms grid): stress_causal_S4.csv
  - outage_ranking.csv (from outage_story_trace.py) to choose subset transitions

Outputs (out_dir):
  - selected_transitions.csv
  - fig_event_triggered_p100_conditional.svg

No external dependencies.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple


DT_MS = 100


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        r = csv.DictReader(f)
        for row in r:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def _extract_transitions(labels: List[int]) -&gt; List[int]:
    out: List[int] = []
    prev = labels[0]
    for i in range(1, len(labels)):
        cur = labels[i]
        if cur != prev:
            out.append(i)
        prev = cur
    return out


def _parse_step_idx_from_mfd(mfd: str) -&gt; Optional[int]:
    mfd = (mfd or &quot;&quot;).strip()
    if not mfd:
        return None
    us = mfd.find(&quot;_&quot;)
    if us &lt;= 0:
        return None
    try:
        return int(mfd[:us])
    except Exception:
        return None


def _parse_tag(tag: str) -&gt; Optional[Tuple[str, int, int]]:
    # ex: P4-03-100, U4-01-500
    tag = (tag or &quot;&quot;).strip()
    if not tag:
        return None
    mode = tag[0]
    if mode not in (&quot;P&quot;, &quot;U&quot;):
        return None
    parts = tag.split(&quot;-&quot;)
    if len(parts) &lt; 3:
        return None
    try:
        itv = int(parts[2])
    except Exception:
        return None
    if itv not in (100, 500):
        return None
    return mode, itv


@dataclass(frozen=True)
class RxEvent:
    step_idx: int
    rx_ms: float
    itv_ms: int


def _read_rx_events_by_mode(path: Path, n_steps: int) -&gt; Dict[str, List[RxEvent]]:
    out: Dict[str, List[RxEvent]] = {&quot;P&quot;: [], &quot;U&quot;: []}
    with path.open(newline=&quot;&quot;) as f:
        r = csv.DictReader(f)
        for row in r:
            parsed = _parse_tag(row.get(&quot;label&quot;) or &quot;&quot;)
            if parsed is None:
                continue
            mode, itv = parsed
            step = _parse_step_idx_from_mfd(row.get(&quot;mfd&quot;) or &quot;&quot;)
            if step is None or not (0 &lt;= step &lt; n_steps):
                continue
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or &quot;&quot;)
            except Exception:
                continue
            out[mode].append(RxEvent(step_idx=step, rx_ms=rx_ms, itv_ms=itv))
    return out


def _dominant_mode(events_by_mode: Dict[str, List[RxEvent]]) -&gt; Optional[str]:
    p = len(events_by_mode.get(&quot;P&quot;) or [])
    u = len(events_by_mode.get(&quot;U&quot;) or [])
    if p == 0 and u == 0:
        return None
    return &quot;P&quot; if p &gt;= u else &quot;U&quot;


def _ffill_itv(n_steps: int, itv_by_step: Dict[int, int]) -&gt; List[int]:
    if not itv_by_step:
        return [500] * n_steps
    first = min(itv_by_step.keys())
    cur = itv_by_step[first]
    out = [cur] * n_steps
    for t in range(n_steps):
        if t in itv_by_step:
            cur = itv_by_step[t]
        out[t] = cur
    return out


def _select_transition_subset(
    ranking_csv: Path,
    subset: str,
    top_k: int,
) -&gt; List[int]:
    rows: List[Dict[str, str]] = []
    with ranking_csv.open(newline=&quot;&quot;) as f:
        rows = list(csv.DictReader(f))
    items: List[Tuple[int, float, float, float]] = []
    for r in rows:
        try:
            step = int(float(r[&quot;transition_step&quot;]))
            du = float(r[&quot;u_minus_p_out_rate&quot;])
            ur = float(r[&quot;u_only_out_rate&quot;])
            pr = float(r[&quot;policy_out_rate&quot;])
        except Exception:
            continue
        if math.isnan(du) or math.isinf(du):
            continue
        items.append((step, du, ur, pr))

    if subset == &quot;u_only_worse&quot;:
        # where U-only is worse in outage-rate than policy
        items = [x for x in items if x[1] &gt; 0]
        items.sort(key=lambda x: x[1], reverse=True)
    elif subset == &quot;u_only_outage&quot;:
        # where U-only has any outage-rate
        items = [x for x in items if x[2] &gt; 0]
        items.sort(key=lambda x: (x[2], x[1]), reverse=True)
    else:
        raise SystemExit(f&quot;unknown subset: {subset}&quot;)

    return [step for step, _du, _ur, _pr in items[:top_k]]


def _plot_event_triggered_svg(
    out_svg: Path,
    title: str,
    window_steps: int,
    p100_policy: List[float],
    p100_uonly: List[float],
) -&gt; None:
    width, height = 920, 520
    ml, mr, mt, mb = 70, 30, 70, 60
    pw = width - ml - mr
    ph = height - mt - mb
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    col_p = &quot;#2563eb&quot;
    col_u = &quot;#ef4444&quot;

    xs = list(range(-window_steps, window_steps + 1))
    xmin, xmax = xs[0], xs[-1]

    def xpx(x: float) -&gt; float:
        if xmax == xmin:
            return ml + pw / 2
        return ml + (x - xmin) * pw / (xmax - xmin)

    def ypx(y: float) -&gt; float:
        return mt + (1 - max(0.0, min(1.0, y))) * ph

    svg: List[str] = []
    svg.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;#ffffff&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{title}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    # grid
    for i in range(6):
        y = i / 5
        py = ypx(y)
        svg.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml-8}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{y:.1f}&lt;/text&gt;&apos;)
    # x ticks
    for i in range(7):
        x = xmin + (xmax - xmin) * i / 6
        px = xpx(x)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{mt+ph}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{mt+ph+26}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{(x*DT_MS)/1000:.1f}&lt;/text&gt;&apos;)

    # vertical line at 0
    px0 = xpx(0)
    svg.append(f&apos;&lt;line x1=&quot;{px0:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px0:.2f}&quot; y2=&quot;{mt+ph}&quot; stroke=&quot;#6b7280&quot; stroke-width=&quot;2&quot; stroke-dasharray=&quot;6 4&quot;/&gt;&apos;)

    def path(vals: List[float], col: str) -&gt; None:
        d = [f&quot;M {xpx(xs[0]):.2f} {ypx(vals[0]):.2f}&quot;]
        for x, y in zip(xs[1:], vals[1:]):
            d.append(f&quot;L {xpx(x):.2f} {ypx(y):.2f}&quot;)
        d_str = &quot; &quot;.join(d)
        svg.append(f&apos;&lt;path d=&quot;{d_str}&quot; fill=&quot;none&quot; stroke=&quot;{col}&quot; stroke-width=&quot;2.5&quot;/&gt;&apos;)

    path(p100_policy, col_p)
    path(p100_uonly, col_u)

    # legend
    lx, ly = ml + pw - 240, mt + 10
    svg.append(f&apos;&lt;rect x=&quot;{lx}&quot; y=&quot;{ly}&quot; width=&quot;230&quot; height=&quot;54&quot; fill=&quot;#ffffff&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;line x1=&quot;{lx+14}&quot; y1=&quot;{ly+20}&quot; x2=&quot;{lx+34}&quot; y2=&quot;{ly+20}&quot; stroke=&quot;{col_p}&quot; stroke-width=&quot;3&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{lx+42}&quot; y=&quot;{ly+24}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;Policy (U+CCS)&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;line x1=&quot;{lx+14}&quot; y1=&quot;{ly+40}&quot; x2=&quot;{lx+34}&quot; y2=&quot;{ly+40}&quot; stroke=&quot;{col_u}&quot; stroke-width=&quot;3&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{lx+42}&quot; y=&quot;{ly+44}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;U-only (CCS-off)&lt;/text&gt;&apos;)

    svg.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-20}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;relative time to truth transition [s]&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;18&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 18 {mt+ph/2:.1f})&quot;&gt;P(interval=100ms)&lt;/text&gt;&apos;)
    svg.append(&quot;&lt;/svg&gt;&quot;)

    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(svg), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth&quot;, type=Path, required=True)
    ap.add_argument(&quot;--outage-ranking-csv&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    ap.add_argument(&quot;--window-s&quot;, type=float, default=2.0)
    ap.add_argument(&quot;--subset&quot;, choices=(&quot;u_only_worse&quot;, &quot;u_only_outage&quot;), default=&quot;u_only_worse&quot;)
    ap.add_argument(&quot;--top-k&quot;, type=int, default=5)
    args = ap.parse_args()

    window_steps = int(round(args.window_s * 1000 / DT_MS))
    truth = _read_truth_labels(args.truth, n_steps=args.n_steps)
    all_trans = _extract_transitions(truth)

    subset_steps = _select_transition_subset(args.outage_ranking_csv, subset=args.subset, top_k=args.top_k)
    subset_steps = [s for s in subset_steps if s in set(all_trans)]
    if not subset_steps:
        raise SystemExit(&quot;empty transition subset&quot;)

    # Build action series per trial, per mode
    series: Dict[str, List[List[int]]] = {&quot;P&quot;: [], &quot;U&quot;: []}  # mode -&gt; list of itv series (len=n_steps)
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        ev_by_mode = _read_rx_events_by_mode(p, n_steps=args.n_steps)
        mode = _dominant_mode(ev_by_mode)
        if mode is None or mode not in (&quot;P&quot;, &quot;U&quot;):
            continue
        evs = ev_by_mode[mode]
        if len(evs) &lt; 80:
            continue
        itv_by_step: Dict[int, int] = {}
        for e in evs:
            if e.step_idx not in itv_by_step:
                itv_by_step[e.step_idx] = e.itv_ms
        series[mode].append(_ffill_itv(args.n_steps, itv_by_step))

    if not series[&quot;P&quot;] or not series[&quot;U&quot;]:
        raise SystemExit(&quot;missing P or U trials in RX dir&quot;)

    # event-triggered P(100ms) around selected transitions
    def compute_p100(mode: str) -&gt; List[float]:
        acc = [0.0] * (2 * window_steps + 1)
        denom = 0
        for itv in series[mode]:
            for t0 in subset_steps:
                if t0 - window_steps &lt; 0 or t0 + window_steps &gt;= args.n_steps:
                    continue
                denom += 1
                for i, dt in enumerate(range(-window_steps, window_steps + 1)):
                    acc[i] += 1.0 if itv[t0 + dt] == 100 else 0.0
        if denom == 0:
            return [0.0] * len(acc)
        return [v / denom for v in acc]

    p100_p = compute_p100(&quot;P&quot;)
    p100_u = compute_p100(&quot;U&quot;)

    args.out_dir.mkdir(parents=True, exist_ok=True)
    # write selected transitions list
    with (args.out_dir / &quot;selected_transitions.csv&quot;).open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.writer(f)
        w.writerow([&quot;transition_step&quot;])
        for s in subset_steps:
            w.writerow([s])

    _plot_event_triggered_svg(
        args.out_dir / &quot;fig_event_triggered_p100_conditional.svg&quot;,
        title=_svg_escape(f&quot;D4B conditional timing: P(100ms) around transitions ({args.subset}, topK={args.top_k})&quot;),
        window_steps=window_steps,
        p100_policy=p100_p,
        p100_uonly=p100_u,
    )


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/analysis/ccs_timing_analysis.py">#!/usr/bin/env python3
&quot;&quot;&quot;
D4B (scan90, S4) analysis-only: visualize that CCS improves QoS by placing 100ms closer to transitions.

Inputs:
  - RX logs: rx_trial_*.csv (expects columns: ms, seq, label, mfd)
    - label example: &quot;P4-03-100&quot;, &quot;U4-03-500&quot; (mode P=policy(U+CCS), U=U-only(CCS-off))
    - mfd example:   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
  - truth: stress_causal_S4.csv (expects columns: idx, label; dt=100ms)

Outputs (out_dir):
  - event_triggered_p100.csv : tau_s vs P(100ms) curves (policy vs u-only)
  - hit_cover_lag_summary.csv: per-condition summary of Hit/PreHit/Cover/Lag metrics
  - lag_cdf.csv              : CDF of lag-to-100 after transition
  - fig_event_triggered_p100.svg
  - fig_lag_cdf.svg
  - fig_hit_cover.svg

No external dependencies (no pandas/matplotlib).
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple


DT_MS_DEFAULT = 100


@dataclass(frozen=True)
class RxObs:
    step_idx: int
    itv_ms: int
    mode: str  # &quot;P&quot; or &quot;U&quot;


def _read_truth_labels(truth_csv: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with truth_csv.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {truth_csv} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def _read_truth_fields(truth_csv: Path, n_steps: int) -&gt; Tuple[List[int], List[float], List[float]]:
    labels: List[int] = []
    us: List[float] = []
    ccss: List[float] = []
    with truth_csv.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            us.append(float(row.get(&quot;U&quot;) or &quot;nan&quot;))
            ccss.append(float(row.get(&quot;CCS&quot;) or &quot;nan&quot;))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {truth_csv} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels, us, ccss


def _extract_transitions(labels: List[int]) -&gt; List[int]:
    out: List[int] = []
    for i in range(1, len(labels)):
        if labels[i] != labels[i - 1]:
            out.append(i)
    return out


def _parse_step_idx_from_mfd(mfd: str) -&gt; Optional[int]:
    mfd = (mfd or &quot;&quot;).strip()
    if not mfd:
        return None
    us = mfd.find(&quot;_&quot;)
    if us &lt;= 0:
        return None
    try:
        return int(mfd[:us])
    except Exception:
        return None


def _parse_mode_and_itv(tag: str) -&gt; Optional[Tuple[str, int]]:
    tag = (tag or &quot;&quot;).strip()
    if not tag:
        return None
    # ex: P4-03-500 / U4-01-100
    if len(tag) &lt; 2:
        return None
    mode = tag[0]
    if mode not in (&quot;P&quot;, &quot;U&quot;):
        return None
    try:
        itv_ms = int(tag.split(&quot;-&quot;)[-1])
    except Exception:
        return None
    if itv_ms not in (100, 500):
        return None
    return mode, itv_ms


def _read_rx_trial(path: Path) -&gt; List[RxObs]:
    obs: List[RxObs] = []
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            tag = (row.get(&quot;label&quot;) or &quot;&quot;).strip()
            parsed = _parse_mode_and_itv(tag)
            if parsed is None:
                continue
            mode, itv_ms = parsed
            step_idx = _parse_step_idx_from_mfd(row.get(&quot;mfd&quot;) or &quot;&quot;)
            if step_idx is None:
                # fallback: seq
                try:
                    step_idx = int(row.get(&quot;seq&quot;) or &quot;&quot;)
                except Exception:
                    continue
            obs.append(RxObs(step_idx=step_idx, itv_ms=itv_ms, mode=mode))
    return obs


def _build_itv_series(n_steps: int, obs: List[RxObs]) -&gt; Optional[Tuple[str, List[int]]]:
    if not obs:
        return None
    # RXログはtrial境界で前後のパケットが少量混入し得るため、
    # そのtrialで支配的なmode（P/U）を採用し、他modeは捨てる。
    counts: Dict[str, int] = {&quot;P&quot;: 0, &quot;U&quot;: 0}
    for o in obs:
        if o.mode in counts:
            counts[o.mode] += 1
    mode = &quot;P&quot; if counts[&quot;P&quot;] &gt;= counts[&quot;U&quot;] else &quot;U&quot;
    obs = [o for o in obs if o.mode == mode]
    if not obs:
        return None
    # Guard: a trial with only a handful of packets is likely contamination/noise.
    if len(obs) &lt; 50:
        return None
    # step_idx -&gt; itv, first-seen wins
    itv_by_step: Dict[int, int] = {}
    for o in obs:
        if 0 &lt;= o.step_idx &lt; n_steps and o.step_idx not in itv_by_step:
            itv_by_step[o.step_idx] = o.itv_ms
    if not itv_by_step:
        return None
    first_step = min(itv_by_step.keys())
    cur = itv_by_step[first_step]
    series: List[int] = [cur] * n_steps
    for t in range(n_steps):
        if t in itv_by_step:
            cur = itv_by_step[t]
        series[t] = cur
    return mode, series


def _mean(xs: Iterable[float]) -&gt; float:
    xs = list(xs)
    if not xs:
        return float(&quot;nan&quot;)
    return sum(xs) / len(xs)


def _cdf(values_s: List[float], xs_s: List[float]) -&gt; List[float]:
    if not values_s:
        return [float(&quot;nan&quot;)] * len(xs_s)
    vs = sorted(values_s)
    out: List[float] = []
    n = len(vs)
    j = 0
    for x in xs_s:
        while j &lt; n and vs[j] &lt;= x + 1e-12:
            j += 1
        out.append(j / n)
    return out


def _write_csv(path: Path, header: List[str], rows: List[List[object]]) -&gt; None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.writer(f)
        w.writerow(header)
        w.writerows(rows)


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _fmt(v: float, digits: int = 3) -&gt; str:
    if math.isnan(v) or math.isinf(v):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def _plot_lines_svg(
    out_svg: Path,
    title: str,
    x_label: str,
    y_label: str,
    xs: List[float],
    series: List[Tuple[str, List[float], str]],
    y_min: float = 0.0,
    y_max: float = 1.0,
) -&gt; None:
    width, height = 920, 560
    ml, mr, mt, mb = 80, 30, 60, 70
    pw, ph = width - ml - mr, height - mt - mb
    xmin, xmax = min(xs), max(xs)
    ymin, ymax = y_min, y_max

    def xpx(x: float) -&gt; float:
        return ml + (x - xmin) * pw / (xmax - xmin) if xmax &gt; xmin else ml + pw / 2

    def ypx(y: float) -&gt; float:
        return mt + (ymax - y) * ph / (ymax - ymin) if ymax &gt; ymin else mt + ph / 2

    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    bg = &quot;#ffffff&quot;

    lines: List[str] = []
    lines.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    lines.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;{bg}&quot;/&gt;&apos;)
    lines.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    lines.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    # ticks
    for i in range(6):
        tx = xmin + (xmax - xmin) * i / 5.0
        px = xpx(tx)
        lines.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{mt+ph}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        lines.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{mt+ph+24}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(tx, 1)}&lt;/text&gt;&apos;)
    for i in range(6):
        ty = ymin + (ymax - ymin) * i / 5.0
        py = ypx(ty)
        lines.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        lines.append(f&apos;&lt;text x=&quot;{ml-10}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(ty, 2)}&lt;/text&gt;&apos;)

    # axis labels
    lines.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-24}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(x_label)}&lt;/text&gt;&apos;)
    lines.append(f&apos;&lt;text x=&quot;22&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 {mt+ph/2:.1f})&quot;&gt;{_svg_escape(y_label)}&lt;/text&gt;&apos;)

    # series
    for name, ys, color in series:
        pts = [f&quot;{xpx(x):.2f},{ypx(y):.2f}&quot; for x, y in zip(xs, ys)]
        lines.append(f&apos;&lt;polyline fill=&quot;none&quot; stroke=&quot;{color}&quot; stroke-width=&quot;3&quot; points=&quot;{&quot; &quot;.join(pts)}&quot;/&gt;&apos;)
        # marker at tau=0
        if 0.0 &gt;= xmin and 0.0 &lt;= xmax:
            i0 = min(range(len(xs)), key=lambda i: abs(xs[i] - 0.0))
            lines.append(f&apos;&lt;circle cx=&quot;{xpx(xs[i0]):.2f}&quot; cy=&quot;{ypx(ys[i0]):.2f}&quot; r=&quot;4.5&quot; fill=&quot;{color}&quot;/&gt;&apos;)

    # legend
    lx, ly = ml + 10, mt + 10
    lines.append(f&apos;&lt;rect x=&quot;{lx-6}&quot; y=&quot;{ly-6}&quot; width=&quot;260&quot; height=&quot;{26*len(series)+12}&quot; fill=&quot;#ffffff&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
    for i, (name, _, color) in enumerate(series):
        cy = ly + 18 + i * 26
        lines.append(f&apos;&lt;line x1=&quot;{lx}&quot; y1=&quot;{cy}&quot; x2=&quot;{lx+28}&quot; y2=&quot;{cy}&quot; stroke=&quot;{color}&quot; stroke-width=&quot;4&quot;/&gt;&apos;)
        lines.append(f&apos;&lt;text x=&quot;{lx+36}&quot; y=&quot;{cy+5}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(name)}&lt;/text&gt;&apos;)

    lines.append(&quot;&lt;/svg&gt;\n&quot;)
    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(lines), encoding=&quot;utf-8&quot;)


def _plot_bars_svg(
    out_svg: Path,
    title: str,
    items: List[Tuple[str, float, str]],
    y_label: str,
    y_max: float,
) -&gt; None:
    width, height = 920, 520
    ml, mr, mt, mb = 80, 30, 60, 70
    pw, ph = width - ml - mr, height - mt - mb
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    bg = &quot;#ffffff&quot;

    def ypx(v: float) -&gt; float:
        return mt + (y_max - v) * ph / y_max if y_max &gt; 0 else mt + ph

    n = len(items)
    bar_w = pw / max(1, (n * 1.6))
    gap = bar_w * 0.6
    start = ml + (pw - (n * bar_w + (n - 1) * gap)) / 2

    lines: List[str] = []
    lines.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    lines.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;{bg}&quot;/&gt;&apos;)
    lines.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    lines.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)
    for i in range(6):
        ty = y_max * i / 5.0
        py = ypx(ty)
        lines.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        lines.append(f&apos;&lt;text x=&quot;{ml-10}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(ty, 2)}&lt;/text&gt;&apos;)

    lines.append(f&apos;&lt;text x=&quot;22&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 {mt+ph/2:.1f})&quot;&gt;{_svg_escape(y_label)}&lt;/text&gt;&apos;)

    for i, (name, val, color) in enumerate(items):
        x = start + i * (bar_w + gap)
        y = ypx(val)
        h = mt + ph - y
        lines.append(f&apos;&lt;rect x=&quot;{x:.2f}&quot; y=&quot;{y:.2f}&quot; width=&quot;{bar_w:.2f}&quot; height=&quot;{h:.2f}&quot; fill=&quot;{color}&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        lines.append(f&apos;&lt;text x=&quot;{x+bar_w/2:.2f}&quot; y=&quot;{mt+ph+24}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(name)}&lt;/text&gt;&apos;)
        lines.append(f&apos;&lt;text x=&quot;{x+bar_w/2:.2f}&quot; y=&quot;{y-6:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(val, 3)}&lt;/text&gt;&apos;)

    lines.append(&quot;&lt;/svg&gt;\n&quot;)
    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(lines), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    ap.add_argument(&quot;--dt-ms&quot;, type=int, default=DT_MS_DEFAULT)
    ap.add_argument(&quot;--window-s&quot;, type=float, default=2.0)
    ap.add_argument(&quot;--hit-s&quot;, type=float, default=1.0)
    ap.add_argument(&quot;--prehit-s&quot;, type=float, default=0.5)
    ap.add_argument(&quot;--cover-s&quot;, type=float, default=1.0)
    args = ap.parse_args()

    n_steps = args.n_steps
    dt_ms = args.dt_ms
    w_steps = int(round(args.window_s * 1000 / dt_ms))
    hit_steps = int(round(args.hit_s * 1000 / dt_ms))
    pre_steps = int(round(args.prehit_s * 1000 / dt_ms))
    cover_steps = int(round(args.cover_s * 1000 / dt_ms))

    truth_labels, truth_u, truth_ccs = _read_truth_fields(args.truth, n_steps=n_steps)
    transitions = _extract_transitions(truth_labels)
    if not transitions:
        raise SystemExit(&quot;no transitions found in truth&quot;)

    # Build per-trial interval series for policy (P) and u-only (U)
    series_by_mode: Dict[str, List[List[int]]] = {&quot;P&quot;: [], &quot;U&quot;: []}
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        obs = _read_rx_trial(p)
        built = _build_itv_series(n_steps=n_steps, obs=obs)
        if built is None:
            continue
        mode, series = built
        if mode in series_by_mode:
            series_by_mode[mode].append(series)

    if not series_by_mode[&quot;P&quot;] or not series_by_mode[&quot;U&quot;]:
        raise SystemExit(f&quot;not enough trials: policy={len(series_by_mode[&apos;P&apos;])}, u_only={len(series_by_mode[&apos;U&apos;])}&quot;)

    taus = list(range(-w_steps, w_steps + 1))
    tau_s = [t * dt_ms / 1000.0 for t in taus]

    def event_triggered_p100(mode: str) -&gt; List[float]:
        ys: List[float] = []
        trials = series_by_mode[mode]
        for tau in taus:
            vals: List[float] = []
            for k in transitions:
                t = k + tau
                if t &lt; 0 or t &gt;= n_steps:
                    continue
                for s in trials:
                    vals.append(1.0 if s[t] == 100 else 0.0)
            ys.append(_mean(vals))
        return ys

    p100_policy = event_triggered_p100(&quot;P&quot;)
    p100_uonly = event_triggered_p100(&quot;U&quot;)

    _write_csv(
        args.out_dir / &quot;event_triggered_p100.csv&quot;,
        [&quot;tau_s&quot;, &quot;p100_policy&quot;, &quot;p100_u_only&quot;],
        [[tau_s[i], p100_policy[i], p100_uonly[i]] for i in range(len(tau_s))],
    )

    # Hit/PreHit/Cover/Lag metrics
    def compute_metrics(mode: str) -&gt; Tuple[float, float, float, List[float]]:
        trials = series_by_mode[mode]
        hit_flags: List[float] = []
        pre_flags: List[float] = []
        covers: List[float] = []
        lags_s: List[float] = []
        for k in transitions:
            # aggregate over trials, then average over transitions
            for s in trials:
                w0 = max(0, k - cover_steps)
                w1 = min(n_steps - 1, k + cover_steps)
                window = s[w0 : w1 + 1]
                covers.append(sum(1 for v in window if v == 100) / len(window))

                hit_w = s[k : min(n_steps, k + hit_steps + 1)]
                hit_flags.append(1.0 if any(v == 100 for v in hit_w) else 0.0)

                pre_w = s[max(0, k - pre_steps) : k + 1]
                pre_flags.append(1.0 if any(v == 100 for v in pre_w) else 0.0)

                lag = None
                for t in range(k, n_steps):
                    if s[t] == 100:
                        lag = (t - k) * dt_ms / 1000.0
                        break
                if lag is not None:
                    lags_s.append(lag)
        return _mean(hit_flags), _mean(pre_flags), _mean(covers), lags_s

    hit_p, pre_p, cov_p, lags_p = compute_metrics(&quot;P&quot;)
    hit_u, pre_u, cov_u, lags_u = compute_metrics(&quot;U&quot;)

    _write_csv(
        args.out_dir / &quot;hit_cover_lag_summary.csv&quot;,
        [&quot;condition&quot;, &quot;n_trials&quot;, &quot;hit_rate&quot;, &quot;pre_hit_rate&quot;, &quot;cover_ratio&quot;, &quot;lag_median_s&quot;, &quot;lag_p90_s&quot;],
        [
            [&quot;policy(U+CCS)&quot;, len(series_by_mode[&quot;P&quot;]), hit_p, pre_p, cov_p, float(&quot;nan&quot;) if not lags_p else sorted(lags_p)[len(lags_p)//2], float(&quot;nan&quot;) if not lags_p else sorted(lags_p)[int(0.9*(len(lags_p)-1))]],
            [&quot;u_only(CCS-off)&quot;, len(series_by_mode[&quot;U&quot;]), hit_u, pre_u, cov_u, float(&quot;nan&quot;) if not lags_u else sorted(lags_u)[len(lags_u)//2], float(&quot;nan&quot;) if not lags_u else sorted(lags_u)[int(0.9*(len(lags_u)-1))]],
        ],
    )

    # lag CDF
    xs = [i * 0.1 for i in range(0, int(round(args.window_s / 0.1)) + 1)]
    cdf_p = _cdf(lags_p, xs)
    cdf_u = _cdf(lags_u, xs)
    _write_csv(
        args.out_dir / &quot;lag_cdf.csv&quot;,
        [&quot;x_s&quot;, &quot;cdf_policy&quot;, &quot;cdf_u_only&quot;],
        [[xs[i], cdf_p[i], cdf_u[i]] for i in range(len(xs))],
    )

    # Plots
    _plot_lines_svg(
        args.out_dir / &quot;fig_event_triggered_p100.svg&quot;,
        title=f&quot;D4B timing (S4, scan90): P(100ms) around truth transitions (±{args.window_s:.1f}s)&quot;,
        x_label=&quot;relative time from transition [s]&quot;,
        y_label=&quot;P(interval=100ms)&quot;,
        xs=tau_s,
        series=[
            (&quot;policy (U+CCS)&quot;, p100_policy, &quot;#10b981&quot;),
            (&quot;u-only (CCS-off)&quot;, p100_uonly, &quot;#f59e0b&quot;),
        ],
        y_min=0.0,
        y_max=1.0,
    )

    _plot_lines_svg(
        args.out_dir / &quot;fig_lag_cdf.svg&quot;,
        title=&quot;D4B timing (S4, scan90): CDF of lag-to-100ms after transition&quot;,
        x_label=&quot;time since transition [s]&quot;,
        y_label=&quot;CDF&quot;,
        xs=xs,
        series=[
            (&quot;policy (U+CCS)&quot;, cdf_p, &quot;#10b981&quot;),
            (&quot;u-only (CCS-off)&quot;, cdf_u, &quot;#f59e0b&quot;),
        ],
        y_min=0.0,
        y_max=1.0,
    )

    _plot_bars_svg(
        args.out_dir / &quot;fig_hit_cover.svg&quot;,
        title=&quot;D4B timing (S4, scan90): transition hit/prehit/cover (mean over transitions×trials)&quot;,
        items=[
            (&quot;hit@1s P&quot;, hit_p, &quot;#10b981&quot;),
            (&quot;hit@1s U&quot;, hit_u, &quot;#f59e0b&quot;),
            (&quot;pre@0.5s P&quot;, pre_p, &quot;#10b981&quot;),
            (&quot;pre@0.5s U&quot;, pre_u, &quot;#f59e0b&quot;),
            (&quot;cover±1s P&quot;, cov_p, &quot;#10b981&quot;),
            (&quot;cover±1s U&quot;, cov_u, &quot;#f59e0b&quot;),
        ],
        y_label=&quot;ratio&quot;,
        y_max=1.0,
    )

    # Allocation efficiency: does 100ms land on high-CCS steps?
    def topq_indices(values: List[float], q: float) -&gt; List[int]:
        vv = [(i, v) for i, v in enumerate(values) if not (math.isnan(v) or math.isinf(v))]
        if not vv:
            return []
        vv.sort(key=lambda x: x[1], reverse=True)
        k = max(1, int(round(len(vv) * q)))
        return [i for i, _ in vv[:k]]

    # In this project, CCS is sometimes stored as &quot;stability-like&quot; (high=stable).
    # For &quot;transition-likeness&quot; we use CCS_change = 1 - CCS.
    truth_ccs_change: List[float] = []
    for v in truth_ccs:
        if math.isnan(v) or math.isinf(v):
            truth_ccs_change.append(float(&quot;nan&quot;))
        else:
            truth_ccs_change.append(1.0 - v)

    top_ccs_change = set(topq_indices(truth_ccs_change, 0.10))  # top-10% (1-CCS)
    top_u = set(topq_indices(truth_u, 0.10))  # top-10% U

    def alloc_metrics(mode: str) -&gt; Tuple[float, float, float, float, float]:
        trials = series_by_mode[mode]
        if not trials:
            return float(&quot;nan&quot;), float(&quot;nan&quot;), float(&quot;nan&quot;), float(&quot;nan&quot;), float(&quot;nan&quot;)
        mean_ccs_all = _mean(v for v in truth_ccs_change if not (math.isnan(v) or math.isinf(v)))
        # average across trials
        ccs_when100: List[float] = []
        cover_top_ccs: List[float] = []
        cover_top_u: List[float] = []
        for s in trials:
            idx100 = [i for i, itv in enumerate(s) if itv == 100]
            if idx100:
                ccs_when100.append(
                    _mean(
                        truth_ccs_change[i]
                        for i in idx100
                        if not (math.isnan(truth_ccs_change[i]) or math.isinf(truth_ccs_change[i]))
                    )
                )
            if top_ccs_change:
                cover_top_ccs.append(sum(1 for i in top_ccs_change if s[i] == 100) / len(top_ccs_change))
            if top_u:
                cover_top_u.append(sum(1 for i in top_u if s[i] == 100) / len(top_u))
        return mean_ccs_all, _mean(ccs_when100), _mean(cover_top_ccs), _mean(cover_top_u), _mean([sum(1 for itv in s if itv == 100) / len(s) for s in trials])

    ccs_all_p, ccs_100_p, topccs_p, topu_p, share_p = alloc_metrics(&quot;P&quot;)
    ccs_all_u, ccs_100_u, topccs_u, topu_u, share_u = alloc_metrics(&quot;U&quot;)

    _write_csv(
        args.out_dir / &quot;alloc_efficiency_summary.csv&quot;,
        [
            &quot;condition&quot;,
            &quot;n_trials&quot;,
            &quot;share100_time&quot;,
            &quot;mean_CCS_change_all&quot;,
            &quot;mean_CCS_change_when100&quot;,
            &quot;top10pct_CCS_change_covered_by100&quot;,
            &quot;top10pct_U_covered_by100&quot;,
        ],
        [
            [&quot;policy(U+CCS)&quot;, len(series_by_mode[&quot;P&quot;]), share_p, ccs_all_p, ccs_100_p, topccs_p, topu_p],
            [&quot;u_only(CCS-off)&quot;, len(series_by_mode[&quot;U&quot;]), share_u, ccs_all_u, ccs_100_u, topccs_u, topu_u],
        ],
    )

    _plot_bars_svg(
        args.out_dir / &quot;fig_alloc_efficiency.svg&quot;,
        title=&quot;D4B timing (S4, scan90): allocation efficiency of 100ms (higher=better)&quot;,
        items=[
            (&quot;top10 (1-CCS) P&quot;, topccs_p, &quot;#10b981&quot;),
            (&quot;top10 (1-CCS) U&quot;, topccs_u, &quot;#f59e0b&quot;),
            (&quot;mean (1-CCS)|100 P&quot;, ccs_100_p, &quot;#10b981&quot;),
            (&quot;mean (1-CCS)|100 U&quot;, ccs_100_u, &quot;#f59e0b&quot;),
        ],
        y_label=&quot;ratio / score&quot;,
        y_max=max(1.0, topccs_p, topccs_u, ccs_100_p, ccs_100_u),
    )


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/analysis/outage_story_trace.py">#!/usr/bin/env python3
&quot;&quot;&quot;
D4B story analysis (no new data):
  - Extract per-transition TL and outage events (TL&gt;tau) exactly as the v5 scripts do:
      * truth transitions by 100ms grid
      * align RX timestamps by per-trial constant offset (median(step_idx*100ms - rx_ms))
      * TL at transition = time until first received packet whose *truth label == new label* after the transition
        (indexing RX events by label)
  - Rank which transitions contribute most to Pout(1s)
  - Generate a single failure-centered &quot;story timeline&quot; SVG comparing U-only vs Policy(U+CCS)

Outputs (out_dir):
  - per_transition.csv
  - outage_ranking.csv
  - selected_event.json
  - fig_outage_timeline.svg

No external dependencies.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import json
import math
import statistics
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple


DT_MS = 100


@dataclass(frozen=True)
class RxEvent:
    rx_ms: float
    step_idx: int
    truth_label: int
    itv_ms: int
    mode: str  # &quot;P&quot; or &quot;U&quot;


@dataclass(frozen=True)
class Trial:
    path: Path
    mode: str  # &quot;P&quot; or &quot;U&quot;
    offset_ms: float
    aligned_events: List[Tuple[float, int, int, int]]  # (aligned_ms, truth_label, step_idx, itv_ms)
    itv_by_step: Dict[int, int]
    lbl_by_step: Dict[int, int]


def _read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        r = csv.DictReader(f)
        for row in r:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def _extract_transitions(labels: List[int]) -&gt; List[int]:
    out: List[int] = []
    prev = labels[0]
    for i in range(1, len(labels)):
        cur = labels[i]
        if cur != prev:
            out.append(i)
        prev = cur
    return out


def _parse_step_idx_from_mfd(mfd: str) -&gt; Optional[int]:
    mfd = (mfd or &quot;&quot;).strip()
    if not mfd:
        return None
    us = mfd.find(&quot;_&quot;)
    if us &lt;= 0:
        return None
    try:
        return int(mfd[:us])
    except Exception:
        return None


def _parse_tag(tag: str) -&gt; Optional[Tuple[str, int, int]]:
    # ex: P4-03-100, U4-01-500
    tag = (tag or &quot;&quot;).strip()
    if not tag:
        return None
    mode = tag[0]
    if mode not in (&quot;P&quot;, &quot;U&quot;):
        return None
    parts = tag.split(&quot;-&quot;)
    if len(parts) &lt; 3:
        return None
    try:
        lbl = int(parts[1])
        itv = int(parts[2])
    except Exception:
        return None
    if itv not in (100, 500):
        return None
    return mode, lbl, itv


def _read_rx_events(path: Path, n_steps: int) -&gt; List[RxEvent]:
    evs: List[RxEvent] = []
    with path.open(newline=&quot;&quot;) as f:
        r = csv.DictReader(f)
        for row in r:
            parsed = _parse_tag(row.get(&quot;label&quot;) or &quot;&quot;)
            if parsed is None:
                continue
            mode, lbl, itv = parsed
            step = _parse_step_idx_from_mfd(row.get(&quot;mfd&quot;) or &quot;&quot;)
            if step is None or not (0 &lt;= step &lt; n_steps):
                continue
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or &quot;&quot;)
            except Exception:
                continue
            evs.append(RxEvent(rx_ms=rx_ms, step_idx=step, truth_label=lbl, itv_ms=itv, mode=mode))
    return evs


def _dominant_mode(events: List[RxEvent]) -&gt; Optional[str]:
    c: Dict[str, int] = {&quot;P&quot;: 0, &quot;U&quot;: 0}
    for e in events:
        if e.mode in c:
            c[e.mode] += 1
    if c[&quot;P&quot;] == 0 and c[&quot;U&quot;] == 0:
        return None
    return &quot;P&quot; if c[&quot;P&quot;] &gt;= c[&quot;U&quot;] else &quot;U&quot;


def _estimate_offset_ms(events: List[RxEvent]) -&gt; Tuple[float, int]:
    first_ms: Dict[int, float] = {}
    for e in events:
        if e.step_idx not in first_ms:
            first_ms[e.step_idx] = e.rx_ms
    if not first_ms:
        return 0.0, 0
    offsets = [(idx * DT_MS) - ms for idx, ms in first_ms.items()]
    offsets.sort()
    return float(statistics.median(offsets)), len(offsets)


def _build_trial(path: Path, n_steps: int) -&gt; Optional[Trial]:
    events = _read_rx_events(path, n_steps=n_steps)
    if not events:
        return None
    mode = _dominant_mode(events)
    if mode is None:
        return None
    events = [e for e in events if e.mode == mode]
    if len(events) &lt; 80:
        return None

    offset_ms, _ = _estimate_offset_ms(events)
    aligned: List[Tuple[float, int, int, int]] = []
    itv_by_step: Dict[int, int] = {}
    lbl_by_step: Dict[int, int] = {}
    for e in events:
        aligned_ms = e.rx_ms + offset_ms
        aligned.append((aligned_ms, e.truth_label, e.step_idx, e.itv_ms))
        if e.step_idx not in itv_by_step:
            itv_by_step[e.step_idx] = e.itv_ms
        if e.step_idx not in lbl_by_step:
            lbl_by_step[e.step_idx] = e.truth_label
    aligned.sort(key=lambda x: x[0])
    return Trial(path=path, mode=mode, offset_ms=offset_ms, aligned_events=aligned, itv_by_step=itv_by_step, lbl_by_step=lbl_by_step)


def _compute_tl_list(
    truth_labels: List[int],
    aligned_events: List[Tuple[float, int, int, int]],
) -&gt; Tuple[List[float], List[Optional[int]]]:
    # transitions: at step i (i&gt;=1), new label = truth_labels[i]
    transitions: List[Tuple[float, int]] = []
    prev = truth_labels[0]
    for i in range(1, len(truth_labels)):
        cur = truth_labels[i]
        if cur != prev:
            transitions.append((i * DT_MS, cur))
        prev = cur

    events_by_label: Dict[int, List[Tuple[float, int]]] = {}
    for t_ms, lbl, step, _itv in aligned_events:
        events_by_label.setdefault(lbl, []).append((t_ms, step))
    for lbl in events_by_label:
        events_by_label[lbl].sort()

    tl_s: List[float] = []
    arrival_step: List[Optional[int]] = []
    for t_ms, new_lbl in transitions:
        arr = events_by_label.get(new_lbl) or []
        found: Optional[Tuple[float, int]] = None
        for ms, step in arr:
            if ms &gt;= t_ms:
                found = (ms, step)
                break
        if found is None:
            tl_s.append(float(&quot;inf&quot;))
            arrival_step.append(None)
        else:
            tl_s.append((found[0] - t_ms) / 1000.0)
            arrival_step.append(found[1])
    return tl_s, arrival_step


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _fmt(v: float, digits: int = 2) -&gt; str:
    if math.isnan(v) or math.isinf(v):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def _write_csv(path: Path, header: List[str], rows: List[List[object]]) -&gt; None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.writer(f)
        w.writerow(header)
        w.writerows(rows)


def _ffill_series(n_steps: int, by_step: Dict[int, int]) -&gt; List[int]:
    if not by_step:
        return [500] * n_steps
    first = min(by_step.keys())
    cur = by_step[first]
    out = [cur] * n_steps
    for t in range(n_steps):
        if t in by_step:
            cur = by_step[t]
        out[t] = cur
    return out


def _plot_story_svg(
    out_svg: Path,
    title: str,
    truth_step: int,
    truth_new_label: int,
    window_steps: int,
    u_trial: Trial,
    u_tl: float,
    u_arr_step: Optional[int],
    p_trial: Trial,
    p_tl: float,
    p_arr_step: Optional[int],
    n_steps: int,
) -&gt; None:
    width, height = 1000, 560
    ml, mr, mt, mb = 80, 30, 70, 60
    row_h = 200
    pw = width - ml - mr
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    bg = &quot;#ffffff&quot;
    c100 = &quot;#ef4444&quot;
    c500 = &quot;#3b82f6&quot;
    c_hit = &quot;#10b981&quot;
    c_miss = &quot;#111827&quot;

    # Expand window to include arrival step if outside.
    lo = max(0, truth_step - window_steps)
    hi = min(n_steps - 1, truth_step + window_steps)
    for arr in [u_arr_step, p_arr_step]:
        if arr is not None:
            lo = min(lo, max(0, arr - window_steps))
            hi = max(hi, min(n_steps - 1, arr + window_steps))
    span = max(1, hi - lo)

    def xpx(step: int) -&gt; float:
        return ml + (step - lo) * pw / span

    def rel_s(step: int) -&gt; float:
        return (step - truth_step) * DT_MS / 1000.0

    svg: List[str] = []
    svg.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg.append(&apos;&lt;defs&gt;&lt;marker id=&quot;arr&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;9&quot; refY=&quot;5&quot; markerWidth=&quot;7&quot; markerHeight=&quot;7&quot; orient=&quot;auto-start-reverse&quot;&gt;&lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; fill=&quot;#111827&quot;/&gt;&lt;/marker&gt;&lt;/defs&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;{bg}&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{row_h*2}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    # x ticks in seconds
    for i in range(7):
        step = lo + int(round(span * i / 6))
        px = xpx(step)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{mt+row_h*2}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{mt+row_h*2+28}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(rel_s(step),1)}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-22}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;time relative to selected transition [s]&lt;/text&gt;&apos;)

    # transition line
    px0 = xpx(truth_step)
    svg.append(f&apos;&lt;line x1=&quot;{px0:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px0:.2f}&quot; y2=&quot;{mt+row_h*2}&quot; stroke=&quot;#6b7280&quot; stroke-width=&quot;2&quot; stroke-dasharray=&quot;6 4&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{px0+6:.2f}&quot; y=&quot;{mt-10}&quot; font-size=&quot;12&quot; fill=&quot;#6b7280&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;truth transition (label={truth_new_label})&lt;/text&gt;&apos;)

    def draw_row(y0: int, name: str, tr: Trial, tl: float, arr_step: Optional[int]) -&gt; None:
        itv = _ffill_series(n_steps, tr.itv_by_step)
        y_band = y0 + 28
        h_band = 26
        y_rx = y0 + 84
        y_arrow = y0 + 140

        svg.append(f&apos;&lt;text x=&quot;{ml}&quot; y=&quot;{y0+18}&quot; font-size=&quot;13&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(name)} (TL={_fmt(tl,2)}s)&lt;/text&gt;&apos;)

        # interval blocks
        cur = itv[lo]
        seg_start = lo
        for t in range(lo + 1, hi + 2):
            v = itv[t] if t &lt;= hi else None
            if v != cur:
                x1 = xpx(seg_start)
                x2 = xpx(t - 1)
                w = max(1.0, x2 - x1)
                col = c100 if cur == 100 else c500
                svg.append(f&apos;&lt;rect x=&quot;{x1:.2f}&quot; y=&quot;{y_band:.2f}&quot; width=&quot;{w:.2f}&quot; height=&quot;{h_band}&quot; fill=&quot;{col}&quot; opacity=&quot;0.22&quot;/&gt;&apos;)
                seg_start = t
                cur = v
        svg.append(f&apos;&lt;text x=&quot;{ml+6}&quot; y=&quot;{y_band+18}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;interval&lt;/text&gt;&apos;)

        # RX marks; green if new label, black otherwise
        for step, lbl in tr.lbl_by_step.items():
            if step &lt; lo or step &gt; hi:
                continue
            px = xpx(step)
            col = c_hit if lbl == truth_new_label and step &gt;= truth_step else c_miss
            svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{y_rx:.2f}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{y_rx+18:.2f}&quot; stroke=&quot;{col}&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml+6}&quot; y=&quot;{y_rx+14}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX (green=new label)&lt;/text&gt;&apos;)

        # TL arrow to arrival
        if arr_step is not None:
            px1 = xpx(arr_step)
            svg.append(f&apos;&lt;line x1=&quot;{px0:.2f}&quot; y1=&quot;{y_arrow:.2f}&quot; x2=&quot;{px1:.2f}&quot; y2=&quot;{y_arrow:.2f}&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arr)&quot;/&gt;&apos;)
            svg.append(f&apos;&lt;text x=&quot;{(px0+px1)/2:.2f}&quot; y=&quot;{y_arrow-8:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;TL&lt;/text&gt;&apos;)

    draw_row(mt + 0 * row_h, &quot;U-only (CCS-off)&quot;, u_trial, u_tl, u_arr_step)
    draw_row(mt + 1 * row_h, &quot;Policy (U+CCS)&quot;, p_trial, p_tl, p_arr_step)

    # legend for hit/miss
    lx, ly = ml + pw - 260, mt + 10
    svg.append(f&apos;&lt;rect x=&quot;{lx}&quot; y=&quot;{ly}&quot; width=&quot;240&quot; height=&quot;66&quot; fill=&quot;#ffffff&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;line x1=&quot;{lx+14}&quot; y1=&quot;{ly+22}&quot; x2=&quot;{lx+14}&quot; y2=&quot;{ly+40}&quot; stroke=&quot;{c_hit}&quot; stroke-width=&quot;2&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{lx+26}&quot; y=&quot;{ly+36}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX new-label packet&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;line x1=&quot;{lx+14}&quot; y1=&quot;{ly+46}&quot; x2=&quot;{lx+14}&quot; y2=&quot;{ly+64}&quot; stroke=&quot;{c_miss}&quot; stroke-width=&quot;2&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{lx+26}&quot; y=&quot;{ly+60}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX other packet&lt;/text&gt;&apos;)

    svg.append(&quot;&lt;/svg&gt;\n&quot;)
    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(svg), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    ap.add_argument(&quot;--tau-s&quot;, type=float, default=1.0)
    ap.add_argument(&quot;--window-s&quot;, type=float, default=3.0)
    ap.add_argument(&quot;--top-k&quot;, type=int, default=5)
    args = ap.parse_args()

    tau = args.tau_s
    window_steps = int(round(args.window_s * 1000 / DT_MS))

    truth_labels = _read_truth_labels(args.truth, n_steps=args.n_steps)
    transitions = _extract_transitions(truth_labels)
    if not transitions:
        raise SystemExit(&quot;no transitions found in truth&quot;)

    trials: List[Trial] = []
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        t = _build_trial(p, n_steps=args.n_steps)
        if t is not None:
            trials.append(t)
    if not trials:
        raise SystemExit(&quot;no usable trials&quot;)

    # Per-transition extraction
    per_rows: List[List[object]] = []
    # Aggregate per transition across trials
    agg: Dict[Tuple[str, int], Dict[str, float]] = {}

    for tr in trials:
        tl_list, arr_steps = _compute_tl_list(truth_labels, tr.aligned_events)
        if len(tl_list) != len(transitions):
            raise SystemExit(&quot;internal mismatch in transitions length&quot;)
        for idx, step in enumerate(transitions):
            new_lbl = truth_labels[step]
            tl = tl_list[idx]
            arr_step = arr_steps[idx]
            outage = 1 if (tl == float(&quot;inf&quot;) or tl &gt; tau) else 0
            per_rows.append([tr.path.name, tr.mode, step, truth_labels[step - 1], new_lbl, tl, outage, &quot;&quot; if arr_step is None else arr_step, tr.offset_ms])

            key = (tr.mode, step)
            a = agg.setdefault(key, {&quot;n&quot;: 0.0, &quot;out&quot;: 0.0, &quot;tl_sum&quot;: 0.0})
            a[&quot;n&quot;] += 1.0
            a[&quot;out&quot;] += float(outage)
            if tl != float(&quot;inf&quot;):
                a[&quot;tl_sum&quot;] += float(tl)

    args.out_dir.mkdir(parents=True, exist_ok=True)
    _write_csv(
        args.out_dir / &quot;per_transition.csv&quot;,
        [&quot;rx_file&quot;, &quot;mode&quot;, &quot;transition_step&quot;, &quot;label_prev&quot;, &quot;label_cur&quot;, &quot;tl_s&quot;, &quot;outage_gt_tau&quot;, &quot;arrival_step&quot;, &quot;offset_ms&quot;],
        per_rows,
    )

    # Ranking by outage-rate difference (U - P)
    ranking: List[List[object]] = []
    for step in transitions:
        np_ = agg.get((&quot;P&quot;, step), {}).get(&quot;n&quot;, 0.0)
        nu_ = agg.get((&quot;U&quot;, step), {}).get(&quot;n&quot;, 0.0)
        p_out = agg.get((&quot;P&quot;, step), {}).get(&quot;out&quot;, 0.0)
        u_out = agg.get((&quot;U&quot;, step), {}).get(&quot;out&quot;, 0.0)
        p_rate = (p_out / np_) if np_ else float(&quot;nan&quot;)
        u_rate = (u_out / nu_) if nu_ else float(&quot;nan&quot;)
        ranking.append([step, truth_labels[step - 1], truth_labels[step], p_out, np_, p_rate, u_out, nu_, u_rate, (u_rate - p_rate) if (not math.isnan(u_rate) and not math.isnan(p_rate)) else float(&quot;nan&quot;)])
    ranking.sort(key=lambda r: (r[-1], r[6]), reverse=True)
    _write_csv(
        args.out_dir / &quot;outage_ranking.csv&quot;,
        [&quot;transition_step&quot;, &quot;label_prev&quot;, &quot;label_cur&quot;, &quot;policy_out_n&quot;, &quot;policy_n&quot;, &quot;policy_out_rate&quot;, &quot;u_only_out_n&quot;, &quot;u_only_n&quot;, &quot;u_only_out_rate&quot;, &quot;u_minus_p_out_rate&quot;],
        ranking,
    )

    # Choose a transition where U-only has more outages than policy, else fall back to largest TL in U-only.
    selected_step = None
    for r in ranking:
        if r[6] &gt; r[3]:
            selected_step = int(r[0])
            break
    if selected_step is None:
        selected_step = int(ranking[0][0])

    # Pick representative trials (U: max TL, P: min TL) at that transition
    def pick_trial(mode: str, want_max: bool) -&gt; Tuple[Trial, float, Optional[int]]:
        best = None
        # Recompute TL list for each candidate and take the specific transition index.
        for tr in trials:
            if tr.mode != mode:
                continue
            tl_list, arr_steps = _compute_tl_list(truth_labels, tr.aligned_events)
            idx = transitions.index(selected_step)
            tl = tl_list[idx]
            arr = arr_steps[idx]
            if tl == float(&quot;inf&quot;):
                continue
            cand = (tr, tl, arr)
            if best is None:
                best = cand
            else:
                if want_max and cand[1] &gt; best[1]:
                    best = cand
                if not want_max and cand[1] &lt; best[1]:
                    best = cand
        if best is None:
            raise SystemExit(f&quot;no candidate trials for mode={mode}&quot;)
        return best

    u_tr, u_tl, u_arr = pick_trial(&quot;U&quot;, want_max=True)
    p_tr, p_tl, p_arr = pick_trial(&quot;P&quot;, want_max=False)

    selected = {
        &quot;transition_step&quot;: selected_step,
        &quot;new_label&quot;: truth_labels[selected_step],
        &quot;tau_s&quot;: tau,
        &quot;window_s&quot;: args.window_s,
        &quot;u_only_rx_file&quot;: u_tr.path.name,
        &quot;u_only_tl_s&quot;: u_tl,
        &quot;policy_rx_file&quot;: p_tr.path.name,
        &quot;policy_tl_s&quot;: p_tl,
    }
    (args.out_dir / &quot;selected_event.json&quot;).write_text(json.dumps(selected, indent=2), encoding=&quot;utf-8&quot;)

    _plot_story_svg(
        args.out_dir / &quot;fig_outage_timeline.svg&quot;,
        title=f&quot;D4B outage story (S4, scan90): failure-centered view (TL&gt;{tau:.1f}s)&quot;,
        truth_step=selected_step,
        truth_new_label=truth_labels[selected_step],
        window_steps=window_steps,
        u_trial=u_tr,
        u_tl=u_tl,
        u_arr_step=u_arr,
        p_trial=p_tr,
        p_tl=p_tl,
        p_arr_step=p_arr,
        n_steps=args.n_steps,
    )


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/analysis/plot_alpha_vs_pout.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Plot normalized power allocation α vs QoS (pout_1s) with per-run normalization.

α = (P - P500) / (P100 - P500)
  - P100: fixed100 avg_power_mW_mean within the same run
  - P500: fixed500 avg_power_mW_mean within the same run

This removes day-to-day drift and makes the &quot;same energy allocation, better QoS&quot;
story for CCS (D4B: U-only vs U+CCS) visually crisp.

Inputs: one or more summary_by_condition.csv files (no external deps).
Output: dependency-free SVG.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple


@dataclass(frozen=True)
class Row:
    cond: str
    pout_mean: float
    pout_std: float
    p_mean: float
    p_std: float


def f_or(v: Optional[str], default: float = 0.0) -&gt; float:
    s = (v or &quot;&quot;).strip()
    if not s:
        return default
    try:
        x = float(s)
    except Exception:
        return default
    if math.isnan(x) or math.isinf(x):
        return default
    return x


def read_summary(path: Path) -&gt; Dict[str, Row]:
    out: Dict[str, Row] = {}
    with path.open(newline=&quot;&quot;) as f:
        r = csv.DictReader(f)
        for row in r:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            out[cond] = Row(
                cond=cond,
                pout_mean=f_or(row.get(&quot;pout_1s_mean&quot;), default=float(&quot;nan&quot;)),
                pout_std=f_or(row.get(&quot;pout_1s_std&quot;), default=0.0),
                p_mean=f_or(row.get(&quot;avg_power_mW_mean&quot;), default=float(&quot;nan&quot;)),
                p_std=f_or(row.get(&quot;avg_power_mW_std&quot;), default=0.0),
            )
    return out


def compute_alpha(
    p: float,
    p_std: float,
    p100: float,
    p100_std: float,
    p500: float,
    p500_std: float,
) -&gt; Tuple[float, float]:
    denom = (p100 - p500)
    if denom == 0 or math.isnan(denom) or math.isinf(denom):
        return float(&quot;nan&quot;), float(&quot;nan&quot;)
    alpha = (p - p500) / denom
    # Simple error propagation (assume independence).
    # alpha = (p - p500)/d, d=(p100-p500)
    # dalpha/dp = 1/d
    # dalpha/dp500 = (-1)/d + (p-p500)/d^2
    # dalpha/dp100 = -(p-p500)/d^2
    d = denom
    a = (p - p500)
    da_dp = 1.0 / d
    da_dp500 = (-1.0 / d) + (a / (d * d))
    da_dp100 = -(a / (d * d))
    var = (da_dp * p_std) ** 2 + (da_dp500 * p500_std) ** 2 + (da_dp100 * p100_std) ** 2
    return alpha, math.sqrt(max(0.0, var))


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _fmt(v: float, digits: int = 3) -&gt; str:
    if math.isnan(v) or math.isinf(v):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def _marker(shape: str, cx: float, cy: float, color: str) -&gt; str:
    if shape == &quot;diamond&quot;:
        return f&apos;&lt;polygon points=&quot;{cx:.2f},{cy-7:.2f} {cx-7:.2f},{cy:.2f} {cx:.2f},{cy+7:.2f} {cx+7:.2f},{cy:.2f}&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;
    if shape == &quot;square&quot;:
        return f&apos;&lt;rect x=&quot;{cx-6:.2f}&quot; y=&quot;{cy-6:.2f}&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;
    if shape == &quot;triangle&quot;:
        return f&apos;&lt;polygon points=&quot;{cx:.2f},{cy-7:.2f} {cx-6.5:.2f},{cy+6:.2f} {cx+6.5:.2f},{cy+6:.2f}&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;
    return f&apos;&lt;circle cx=&quot;{cx:.2f}&quot; cy=&quot;{cy:.2f}&quot; r=&quot;6&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;


@dataclass(frozen=True)
class Pt:
    key: str
    label: str
    alpha: float
    alpha_std: float
    pout: float
    pout_std: float
    color: str
    shape: str


def write_svg(out_svg: Path, title: str, pts: List[Pt]) -&gt; None:
    width, height = 980, 620
    ml, mr, mt, mb = 90, 30, 70, 80
    pw, ph = width - ml - mr, height - mt - mb
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    bg = &quot;#ffffff&quot;

    xs = [p.alpha for p in pts if not math.isnan(p.alpha)]
    ys = [p.pout for p in pts if not math.isnan(p.pout)]
    xerrs = [p.alpha_std for p in pts if not math.isnan(p.alpha)]
    yerrs = [p.pout_std for p in pts if not math.isnan(p.pout)]
    xmin = min(x - xe for x, xe in zip(xs, xerrs))
    xmax = max(x + xe for x, xe in zip(xs, xerrs))
    ymin = min(y - ye for y, ye in zip(ys, yerrs))
    ymax = max(y + ye for y, ye in zip(ys, yerrs))

    # α is conceptually [0,1], but allow a small margin.
    xmin = min(-0.05, xmin - 0.05)
    xmax = max(1.05, xmax + 0.05)
    ymin = max(0.0, ymin - 0.03)
    ymax += 0.03

    def xpx(x: float) -&gt; float:
        return ml + (x - xmin) * pw / (xmax - xmin) if xmax &gt; xmin else ml + pw / 2

    def ypx(y: float) -&gt; float:
        return mt + (ymax - y) * ph / (ymax - ymin) if ymax &gt; ymin else mt + ph / 2

    svg: List[str] = []
    svg.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;{bg}&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    for i in range(6):
        tx = xmin + (xmax - xmin) * i / 5.0
        px = xpx(tx)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{mt+ph}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{mt+ph+28}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(tx, 2)}&lt;/text&gt;&apos;)
    for i in range(6):
        ty = ymin + (ymax - ymin) * i / 5.0
        py = ypx(ty)
        svg.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml-10}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(ty, 3)}&lt;/text&gt;&apos;)

    svg.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-26}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;α=(P−P500)/(P100−P500)  (normalized power allocation)&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;22&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 {mt+ph/2:.1f})&quot;&gt;pout_1s (lower=better)&lt;/text&gt;&apos;)

    # δ=0.1 guideline (for D3 scan70 story)
    y_delta = 0.1
    if y_delta &gt;= ymin and y_delta &lt;= ymax:
        py = ypx(y_delta)
        svg.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;#9ca3af&quot; stroke-width=&quot;2&quot; stroke-dasharray=&quot;6 4&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml+pw-10}&quot; y=&quot;{py-8:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#6b7280&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;δ=0.1&lt;/text&gt;&apos;)

    # points + error bars
    for p in pts:
        px, py = xpx(p.alpha), ypx(p.pout)
        svg.append(f&apos;&lt;line x1=&quot;{xpx(p.alpha-p.alpha_std):.2f}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{xpx(p.alpha+p.alpha_std):.2f}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{p.color}&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{ypx(p.pout-p.pout_std):.2f}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{ypx(p.pout+p.pout_std):.2f}&quot; stroke=&quot;{p.color}&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg.append(_marker(p.shape, px, py, p.color))
        svg.append(f&apos;&lt;text x=&quot;{px+10:.2f}&quot; y=&quot;{py-10:.2f}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(p.label)}&lt;/text&gt;&apos;)

    # legend
    lx, ly = ml + 10, mt + 10
    svg.append(f&apos;&lt;rect x=&quot;{lx-6}&quot; y=&quot;{ly-6}&quot; width=&quot;360&quot; height=&quot;138&quot; fill=&quot;#ffffff&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
    legend = [
        (&quot;fixed100/fixed500 (each run)&quot;, &quot;#3b82f6&quot;, &quot;square&quot;),
        (&quot;policy (U+CCS)&quot;, &quot;#10b981&quot;, &quot;circle&quot;),
        (&quot;ablation (U-shuf / CCS-off)&quot;, &quot;#f59e0b&quot;, &quot;triangle&quot;),
        (&quot;scan70 points&quot;, &quot;#111827&quot;, &quot;diamond&quot;),
    ]
    for i, (name, color, shape) in enumerate(legend):
        cy = ly + 18 + i * 30
        svg.append(_marker(shape, lx + 12, cy, color))
        svg.append(f&apos;&lt;text x=&quot;{lx+28}&quot; y=&quot;{cy+5}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(name)}&lt;/text&gt;&apos;)

    svg.append(&quot;&lt;/svg&gt;\n&quot;)
    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(svg), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--d4b&quot;, type=Path, default=Path(&quot;uccs_d4b_scan90/metrics/01/summary_by_condition.csv&quot;))
    ap.add_argument(&quot;--d4&quot;, type=Path, default=Path(&quot;uccs_d4_scan90/metrics/01/summary_by_condition.csv&quot;))
    ap.add_argument(&quot;--d3&quot;, type=Path, default=Path(&quot;uccs_d3_scan70/metrics/01/summary_by_condition.csv&quot;))
    ap.add_argument(&quot;--out&quot;, type=Path, required=True)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;Normalized power allocation α vs QoS (S4)&quot;)
    args = ap.parse_args()

    d4b = read_summary(args.d4b)
    d4 = read_summary(args.d4)
    d3 = read_summary(args.d3)

    pts: List[Pt] = []

    # D4B scan90 normalization
    p100, p100s = d4b[&quot;S4_fixed100&quot;].p_mean, d4b[&quot;S4_fixed100&quot;].p_std
    p500, p500s = d4b[&quot;S4_fixed500&quot;].p_mean, d4b[&quot;S4_fixed500&quot;].p_std
    for cond, label, color, shape in [
        (&quot;S4_fixed100&quot;, &quot;scan90 fixed100&quot;, &quot;#3b82f6&quot;, &quot;square&quot;),
        (&quot;S4_fixed500&quot;, &quot;scan90 fixed500&quot;, &quot;#3b82f6&quot;, &quot;square&quot;),
        (&quot;S4_policy&quot;, &quot;scan90 policy (U+CCS)&quot;, &quot;#10b981&quot;, &quot;circle&quot;),
        (&quot;S4_ablation_ccs_off&quot;, &quot;scan90 CCS-off (U-only)&quot;, &quot;#f59e0b&quot;, &quot;triangle&quot;),
    ]:
        r = d4b[cond]
        a, astd = compute_alpha(r.p_mean, r.p_std, p100, p100s, p500, p500s)
        if cond == &quot;S4_fixed100&quot;:
            a, astd = 1.0, 0.0
        if cond == &quot;S4_fixed500&quot;:
            a, astd = 0.0, 0.0
        pts.append(Pt(f&quot;d4b_{cond}&quot;, label, a, astd, r.pout_mean, r.pout_std, color, shape))

    # D4 scan90 (U-shuffle) normalization (use D4 fixed points)
    p100_d4, p100s_d4 = d4[&quot;S4_fixed100&quot;].p_mean, d4[&quot;S4_fixed100&quot;].p_std
    p500_d4, p500s_d4 = d4[&quot;S4_fixed500&quot;].p_mean, d4[&quot;S4_fixed500&quot;].p_std
    for cond, label, color in [
        (&quot;S4_policy&quot;, &quot;scan90 policy (D4)&quot;, &quot;#10b981&quot;),
        (&quot;S4_ablation_u_shuf&quot;, &quot;scan90 U-shuf&quot;, &quot;#f59e0b&quot;),
    ]:
        r = d4[cond]
        a, astd = compute_alpha(r.p_mean, r.p_std, p100_d4, p100s_d4, p500_d4, p500s_d4)
        pts.append(Pt(f&quot;d4_{cond}&quot;, label, a, astd, r.pout_mean, r.pout_std, color, &quot;triangle&quot;))

    # D3 scan70 normalization (use D3 fixed points)
    p100_d3, p100s_d3 = d3[&quot;S4_fixed100&quot;].p_mean, d3[&quot;S4_fixed100&quot;].p_std
    p500_d3, p500s_d3 = d3[&quot;S4_fixed500&quot;].p_mean, d3[&quot;S4_fixed500&quot;].p_std
    for cond, label in [
        (&quot;S4_fixed100&quot;, &quot;scan70 fixed100&quot;,),
        (&quot;S4_fixed500&quot;, &quot;scan70 fixed500&quot;,),
        (&quot;S4_policy&quot;, &quot;scan70 policy&quot;,),
    ]:
        r = d3[cond]
        a, astd = compute_alpha(r.p_mean, r.p_std, p100_d3, p100s_d3, p500_d3, p500s_d3)
        if cond == &quot;S4_fixed100&quot;:
            a, astd = 1.0, 0.0
        if cond == &quot;S4_fixed500&quot;:
            a, astd = 0.0, 0.0
        pts.append(Pt(f&quot;d3_{cond}&quot;, label, a, astd, r.pout_mean, r.pout_std, &quot;#111827&quot;, &quot;diamond&quot;))

    write_svg(args.out, args.title, pts)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/analysis/plot_role_separation_overview.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Single-figure overview to fix the narrative in one plot:

  - Role of U: U-shuffle collapses toward 100ms behavior (power↑)
  - Role of CCS: CCS-off (U-only) degrades QoS at ~same power vs U+CCS
  - Robustness: scan70 degrades Fixed500 strongly, while Policy remains feasible

Inputs are per-experiment summary_by_condition.csv files (no external deps).
Output is dependency-free SVG.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple


@dataclass(frozen=True)
class Point:
    key: str
    label: str
    x: float
    y: float
    xerr: float
    yerr: float
    color: str
    shape: str  # &quot;circle&quot; | &quot;square&quot; | &quot;triangle&quot; | &quot;diamond&quot;


def f_or_none(v: str) -&gt; Optional[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary(path: Path) -&gt; Dict[str, Dict[str, float]]:
    out: Dict[str, Dict[str, float]] = {}
    with path.open(newline=&quot;&quot;) as f:
        r = csv.DictReader(f)
        for row in r:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            x = f_or_none(row.get(&quot;avg_power_mW_mean&quot;) or &quot;&quot;)
            y = f_or_none(row.get(&quot;pout_1s_mean&quot;) or &quot;&quot;)
            if x is None or y is None:
                continue
            out[cond] = {
                &quot;x&quot;: float(x),
                &quot;y&quot;: float(y),
                &quot;xerr&quot;: float(f_or_none(row.get(&quot;avg_power_mW_std&quot;) or &quot;&quot;) or 0.0),
                &quot;yerr&quot;: float(f_or_none(row.get(&quot;pout_1s_std&quot;) or &quot;&quot;) or 0.0),
            }
    return out


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _fmt(v: float, digits: int = 3) -&gt; str:
    if math.isnan(v) or math.isinf(v):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def _draw_marker(shape: str, cx: float, cy: float, color: str) -&gt; str:
    if shape == &quot;square&quot;:
        return f&apos;&lt;rect x=&quot;{cx-6:.2f}&quot; y=&quot;{cy-6:.2f}&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;
    if shape == &quot;triangle&quot;:
        return f&apos;&lt;polygon points=&quot;{cx:.2f},{cy-7:.2f} {cx-6.5:.2f},{cy+6:.2f} {cx+6.5:.2f},{cy+6:.2f}&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;
    if shape == &quot;diamond&quot;:
        return f&apos;&lt;polygon points=&quot;{cx:.2f},{cy-7:.2f} {cx-7:.2f},{cy:.2f} {cx:.2f},{cy+7:.2f} {cx+7:.2f},{cy:.2f}&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;
    return f&apos;&lt;circle cx=&quot;{cx:.2f}&quot; cy=&quot;{cy:.2f}&quot; r=&quot;6&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;


def write_svg(out_svg: Path, title: str, points: List[Point], arrows: List[Tuple[str, str, str]]) -&gt; None:
    width, height = 980, 640
    ml, mr, mt, mb = 90, 30, 70, 80
    pw, ph = width - ml - mr, height - mt - mb
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    bg = &quot;#ffffff&quot;

    xs = [p.x for p in points]
    ys = [p.y for p in points]
    xerrs = [p.xerr for p in points]
    yerrs = [p.yerr for p in points]
    xmin = min(x - xe for x, xe in zip(xs, xerrs))
    xmax = max(x + xe for x, xe in zip(xs, xerrs))
    ymin = min(y - ye for y, ye in zip(ys, yerrs))
    ymax = max(y + ye for y, ye in zip(ys, yerrs))
    xpad = max(0.8, (xmax - xmin) * 0.08)
    ypad = max(0.01, (ymax - ymin) * 0.18)
    xmin -= xpad
    xmax += xpad
    ymin = max(0.0, ymin - ypad)
    ymax += ypad

    def xpx(x: float) -&gt; float:
        return ml + (x - xmin) * pw / (xmax - xmin) if xmax &gt; xmin else ml + pw / 2

    def ypx(y: float) -&gt; float:
        return mt + (ymax - y) * ph / (ymax - ymin) if ymax &gt; ymin else mt + ph / 2

    svg: List[str] = []
    svg.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg.append(f&apos;&lt;defs&gt;&lt;marker id=&quot;arrow&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;9&quot; refY=&quot;5&quot; markerWidth=&quot;7&quot; markerHeight=&quot;7&quot; orient=&quot;auto-start-reverse&quot;&gt;&lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; fill=&quot;{axis}&quot;/&gt;&lt;/marker&gt;&lt;/defs&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;{bg}&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    for i in range(6):
        tx = xmin + (xmax - xmin) * i / 5.0
        px = xpx(tx)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{mt+ph}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{mt+ph+28}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(tx, 1)}&lt;/text&gt;&apos;)
    for i in range(6):
        ty = ymin + (ymax - ymin) * i / 5.0
        py = ypx(ty)
        svg.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml-10}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(ty, 3)}&lt;/text&gt;&apos;)

    svg.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-26}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;avg_power_mW (lower=better)&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;22&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 {mt+ph/2:.1f})&quot;&gt;pout_1s (lower=better)&lt;/text&gt;&apos;)

    # Index points by key for arrows.
    by_key: Dict[str, Point] = {p.key: p for p in points}

    # Arrows (behind points)
    for src, dst, text in arrows:
        ps = by_key.get(src)
        pd = by_key.get(dst)
        if ps is None or pd is None:
            continue
        x1, y1 = xpx(ps.x), ypx(ps.y)
        x2, y2 = xpx(pd.x), ypx(pd.y)
        svg.append(f&apos;&lt;line x1=&quot;{x1:.2f}&quot; y1=&quot;{y1:.2f}&quot; x2=&quot;{x2:.2f}&quot; y2=&quot;{y2:.2f}&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arrow)&quot; opacity=&quot;0.85&quot;/&gt;&apos;)
        mx, my = (x1 + x2) / 2, (y1 + y2) / 2
        svg.append(f&apos;&lt;text x=&quot;{mx+6:.2f}&quot; y=&quot;{my-6:.2f}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(text)}&lt;/text&gt;&apos;)

    # Points + error bars
    for p in points:
        px, py = xpx(p.x), ypx(p.y)
        # error bars
        svg.append(f&apos;&lt;line x1=&quot;{xpx(p.x-p.xerr):.2f}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{xpx(p.x+p.xerr):.2f}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{p.color}&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{ypx(p.y-p.yerr):.2f}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{ypx(p.y+p.yerr):.2f}&quot; stroke=&quot;{p.color}&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg.append(_draw_marker(p.shape, px, py, p.color))
        svg.append(f&apos;&lt;text x=&quot;{px+10:.2f}&quot; y=&quot;{py-10:.2f}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(p.label)}&lt;/text&gt;&apos;)

    # Legend
    lx, ly = ml + 10, mt + 10
    svg.append(f&apos;&lt;rect x=&quot;{lx-6}&quot; y=&quot;{ly-6}&quot; width=&quot;360&quot; height=&quot;128&quot; fill=&quot;#ffffff&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
    legend = [
        (&quot;scan90 fixed&quot;, &quot;#3b82f6&quot;, &quot;square&quot;),
        (&quot;scan90 policy&quot;, &quot;#10b981&quot;, &quot;circle&quot;),
        (&quot;scan90 ablation&quot;, &quot;#f59e0b&quot;, &quot;triangle&quot;),
        (&quot;scan70 (worse RX)&quot;, &quot;#111827&quot;, &quot;diamond&quot;),
    ]
    for i, (name, color, shape) in enumerate(legend):
        cy = ly + 18 + i * 28
        svg.append(_draw_marker(shape, lx + 12, cy, color))
        svg.append(f&apos;&lt;text x=&quot;{lx+28}&quot; y=&quot;{cy+5}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(name)}&lt;/text&gt;&apos;)

    svg.append(&quot;&lt;/svg&gt;\n&quot;)
    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(svg), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--d4-csv&quot;, type=Path, default=Path(&quot;uccs_d4_scan90/metrics/01/summary_by_condition.csv&quot;))
    ap.add_argument(&quot;--d4b-csv&quot;, type=Path, default=Path(&quot;uccs_d4b_scan90/metrics/01/summary_by_condition.csv&quot;))
    ap.add_argument(&quot;--d3-csv&quot;, type=Path, default=Path(&quot;uccs_d3_scan70/metrics/01/summary_by_condition.csv&quot;))
    ap.add_argument(&quot;--out&quot;, type=Path, required=True)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;Role separation overview (scan90/scan70, S4)&quot;)
    args = ap.parse_args()

    d4 = read_summary(args.d4_csv)
    d4b = read_summary(args.d4b_csv)
    d3 = read_summary(args.d3_csv)

    pts: List[Point] = []
    # scan90 fixed points (use D4B fixed values for consistency with CCS-off run)
    pts.append(Point(&quot;scan90_fixed100&quot;, &quot;fixed100 (scan90)&quot;, d4b[&quot;S4_fixed100&quot;][&quot;x&quot;], d4b[&quot;S4_fixed100&quot;][&quot;y&quot;], d4b[&quot;S4_fixed100&quot;][&quot;xerr&quot;], d4b[&quot;S4_fixed100&quot;][&quot;yerr&quot;], &quot;#3b82f6&quot;, &quot;square&quot;))
    pts.append(Point(&quot;scan90_fixed500&quot;, &quot;fixed500 (scan90)&quot;, d4b[&quot;S4_fixed500&quot;][&quot;x&quot;], d4b[&quot;S4_fixed500&quot;][&quot;y&quot;], d4b[&quot;S4_fixed500&quot;][&quot;xerr&quot;], d4b[&quot;S4_fixed500&quot;][&quot;yerr&quot;], &quot;#3b82f6&quot;, &quot;square&quot;))

    # scan90 policy (U+CCS): use D4B policy point (same definition)
    pts.append(Point(&quot;scan90_policy&quot;, &quot;policy U+CCS (scan90)&quot;, d4b[&quot;S4_policy&quot;][&quot;x&quot;], d4b[&quot;S4_policy&quot;][&quot;y&quot;], d4b[&quot;S4_policy&quot;][&quot;xerr&quot;], d4b[&quot;S4_policy&quot;][&quot;yerr&quot;], &quot;#10b981&quot;, &quot;circle&quot;))

    # scan90 ablations
    pts.append(Point(&quot;scan90_u_shuf&quot;, &quot;ablation U-shuf (scan90)&quot;, d4[&quot;S4_ablation_u_shuf&quot;][&quot;x&quot;], d4[&quot;S4_ablation_u_shuf&quot;][&quot;y&quot;], d4[&quot;S4_ablation_u_shuf&quot;][&quot;xerr&quot;], d4[&quot;S4_ablation_u_shuf&quot;][&quot;yerr&quot;], &quot;#f59e0b&quot;, &quot;triangle&quot;))
    pts.append(Point(&quot;scan90_ccs_off&quot;, &quot;ablation CCS-off (U-only)&quot;, d4b[&quot;S4_ablation_ccs_off&quot;][&quot;x&quot;], d4b[&quot;S4_ablation_ccs_off&quot;][&quot;y&quot;], d4b[&quot;S4_ablation_ccs_off&quot;][&quot;xerr&quot;], d4b[&quot;S4_ablation_ccs_off&quot;][&quot;yerr&quot;], &quot;#f59e0b&quot;, &quot;triangle&quot;))

    # scan70 robustness (D3): fixed100/fixed500/policy
    pts.append(Point(&quot;scan70_fixed100&quot;, &quot;fixed100 (scan70)&quot;, d3[&quot;S4_fixed100&quot;][&quot;x&quot;], d3[&quot;S4_fixed100&quot;][&quot;y&quot;], d3[&quot;S4_fixed100&quot;][&quot;xerr&quot;], d3[&quot;S4_fixed100&quot;][&quot;yerr&quot;], &quot;#111827&quot;, &quot;diamond&quot;))
    pts.append(Point(&quot;scan70_fixed500&quot;, &quot;fixed500 (scan70)&quot;, d3[&quot;S4_fixed500&quot;][&quot;x&quot;], d3[&quot;S4_fixed500&quot;][&quot;y&quot;], d3[&quot;S4_fixed500&quot;][&quot;xerr&quot;], d3[&quot;S4_fixed500&quot;][&quot;yerr&quot;], &quot;#111827&quot;, &quot;diamond&quot;))
    pts.append(Point(&quot;scan70_policy&quot;, &quot;policy U+CCS (scan70)&quot;, d3[&quot;S4_policy&quot;][&quot;x&quot;], d3[&quot;S4_policy&quot;][&quot;y&quot;], d3[&quot;S4_policy&quot;][&quot;xerr&quot;], d3[&quot;S4_policy&quot;][&quot;yerr&quot;], &quot;#111827&quot;, &quot;diamond&quot;))

    arrows = [
        (&quot;scan90_u_shuf&quot;, &quot;scan90_policy&quot;, &quot;U effect&quot;),
        (&quot;scan90_ccs_off&quot;, &quot;scan90_policy&quot;, &quot;CCS effect&quot;),
        (&quot;scan90_fixed500&quot;, &quot;scan70_fixed500&quot;, &quot;worse RX (scan70)&quot;),
        (&quot;scan90_policy&quot;, &quot;scan70_policy&quot;, &quot;robustness&quot;),
    ]

    write_svg(args.out, title=args.title, points=pts, arrows=arrows)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/analysis/pout_tail_decomposition.py">#!/usr/bin/env python3
&quot;&quot;&quot;
D4B (CCS ablation) additional analysis: tail-risk decomposition of Pout(1s).

Motivation:
  - pout_1s is often driven by a small number of transition events (TL &gt; 1s).
  - This script quantifies &quot;how concentrated&quot; the delta-pout is across transitions
    and generates a few letter-friendly, no-deps SVG plots.

Inputs:
  - per_transition.csv from outage_story_trace.py (trial × transition TL/outage)
  - outage_ranking.csv from outage_story_trace.py (transition-wise outage-rate diff)

Outputs (out_dir):
  - outage_counts_by_trial.csv
  - delta_pout_contrib.csv
  - fig_delta_pout_cum.svg
  - fig_outage_count_hist.svg
  - pout_tail_decomposition.md

No external dependencies.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
import statistics
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Tuple


@dataclass(frozen=True)
class TrialOutage:
    rx_file: str
    mode: str  # &quot;P&quot; or &quot;U&quot;
    n_transitions: int
    n_outages: int


def _read_csv(path: Path) -&gt; List[Dict[str, str]]:
    with path.open(newline=&quot;&quot;) as f:
        return list(csv.DictReader(f))


def _write_csv(path: Path, header: List[str], rows: List[List[object]]) -&gt; None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.writer(f)
        w.writerow(header)
        w.writerows(rows)


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _fmt(v: float, digits: int = 3) -&gt; str:
    if math.isnan(v) or math.isinf(v):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def _plot_cumulative_svg(
    out_svg: Path,
    title: str,
    xs: List[int],
    ys: List[float],
    y_label: str,
) -&gt; None:
    width, height = 920, 520
    ml, mr, mt, mb = 70, 30, 70, 60
    pw = width - ml - mr
    ph = height - mt - mb
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    line = &quot;#2563eb&quot;

    def xpx(x: float) -&gt; float:
        if not xs:
            return ml
        xmin, xmax = min(xs), max(xs)
        if xmax == xmin:
            return ml + pw / 2
        return ml + (x - xmin) * pw / (xmax - xmin)

    def ypx(y: float) -&gt; float:
        # y in [0,1]
        return mt + (1.0 - max(0.0, min(1.0, y))) * ph

    svg: List[str] = []
    svg.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;#ffffff&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    # grid + y ticks
    for i in range(6):
        y = i / 5
        py = ypx(y)
        svg.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml-8}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(y,2)}&lt;/text&gt;&apos;)

    # x ticks
    for i in range(6):
        if not xs:
            break
        x = min(xs) + (max(xs) - min(xs)) * i / 5
        px = xpx(x)
        svg.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{mt}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{mt+ph}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{mt+ph+26}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{int(round(x))}&lt;/text&gt;&apos;)

    # path
    if xs:
        d = [f&quot;M {xpx(xs[0]):.2f} {ypx(ys[0]):.2f}&quot;]
        for x, y in zip(xs[1:], ys[1:]):
            d.append(f&quot;L {xpx(x):.2f} {ypx(y):.2f}&quot;)
        svg.append(f&apos;&lt;path d=&quot;{&quot; &quot;.join(d)}&quot; fill=&quot;none&quot; stroke=&quot;{line}&quot; stroke-width=&quot;2.5&quot;/&gt;&apos;)

    svg.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-20}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;top-K transitions (sorted by ΔPout contribution)&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;18&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 18 {mt+ph/2:.1f})&quot;&gt;{_svg_escape(y_label)}&lt;/text&gt;&apos;)
    svg.append(&quot;&lt;/svg&gt;&quot;)

    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(svg), encoding=&quot;utf-8&quot;)


def _plot_hist_svg(
    out_svg: Path,
    title: str,
    bins: List[int],
    counts_p: List[int],
    counts_u: List[int],
) -&gt; None:
    width, height = 920, 520
    ml, mr, mt, mb = 70, 30, 70, 60
    pw = width - ml - mr
    ph = height - mt - mb
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    col_p = &quot;#2563eb&quot;
    col_u = &quot;#ef4444&quot;

    max_count = max(counts_p + counts_u + [1])

    svg: List[str] = []
    svg.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;#ffffff&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{ml}&quot; y=&quot;{mt}&quot; width=&quot;{pw}&quot; height=&quot;{ph}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    for i in range(6):
        y = i / 5 * max_count
        py = mt + (1 - i / 5) * ph
        svg.append(f&apos;&lt;line x1=&quot;{ml}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{ml+pw}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{ml-8}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{int(round(y))}&lt;/text&gt;&apos;)

    n = max(1, len(bins))
    group_w = pw / n
    bar_w = group_w * 0.35

    def ypx(count: int) -&gt; float:
        return mt + (1 - (count / max_count)) * ph

    for i, b in enumerate(bins):
        x0 = ml + i * group_w + group_w / 2
        # policy bar
        hp = ph - (ypx(counts_p[i]) - mt)
        svg.append(f&apos;&lt;rect x=&quot;{x0-bar_w-2:.2f}&quot; y=&quot;{ypx(counts_p[i]):.2f}&quot; width=&quot;{bar_w:.2f}&quot; height=&quot;{hp:.2f}&quot; fill=&quot;{col_p}&quot; opacity=&quot;0.75&quot;/&gt;&apos;)
        # u-only bar
        hu = ph - (ypx(counts_u[i]) - mt)
        svg.append(f&apos;&lt;rect x=&quot;{x0+2:.2f}&quot; y=&quot;{ypx(counts_u[i]):.2f}&quot; width=&quot;{bar_w:.2f}&quot; height=&quot;{hu:.2f}&quot; fill=&quot;{col_u}&quot; opacity=&quot;0.75&quot;/&gt;&apos;)
        svg.append(f&apos;&lt;text x=&quot;{x0:.2f}&quot; y=&quot;{mt+ph+26}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{b}&lt;/text&gt;&apos;)

    # legend
    lx, ly = ml + pw - 220, mt + 10
    svg.append(f&apos;&lt;rect x=&quot;{lx}&quot; y=&quot;{ly}&quot; width=&quot;210&quot; height=&quot;54&quot; fill=&quot;#ffffff&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{lx+12}&quot; y=&quot;{ly+14}&quot; width=&quot;14&quot; height=&quot;14&quot; fill=&quot;{col_p}&quot; opacity=&quot;0.75&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{lx+34}&quot; y=&quot;{ly+26}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;Policy (U+CCS)&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;rect x=&quot;{lx+12}&quot; y=&quot;{ly+34}&quot; width=&quot;14&quot; height=&quot;14&quot; fill=&quot;{col_u}&quot; opacity=&quot;0.75&quot;/&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;{lx+34}&quot; y=&quot;{ly+46}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;U-only (CCS-off)&lt;/text&gt;&apos;)

    svg.append(f&apos;&lt;text x=&quot;{ml+pw/2:.1f}&quot; y=&quot;{height-20}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;outage count per trial (TL&amp;gt;1s), binned&lt;/text&gt;&apos;)
    svg.append(f&apos;&lt;text x=&quot;18&quot; y=&quot;{mt+ph/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 18 {mt+ph/2:.1f})&quot;&gt;# trials&lt;/text&gt;&apos;)
    svg.append(&quot;&lt;/svg&gt;&quot;)

    out_svg.parent.mkdir(parents=True, exist_ok=True)
    out_svg.write_text(&quot;\n&quot;.join(svg), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--per-transition-csv&quot;, type=Path, required=True)
    ap.add_argument(&quot;--outage-ranking-csv&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--tau-s&quot;, type=float, default=1.0)
    ap.add_argument(&quot;--top-k-max&quot;, type=int, default=20)
    args = ap.parse_args()

    args.out_dir.mkdir(parents=True, exist_ok=True)

    # Per-trial outage counts
    per_rows = _read_csv(args.per_transition_csv)
    by_trial: Dict[Tuple[str, str], List[int]] = {}
    for r in per_rows:
        mode = r[&quot;mode&quot;]
        if mode not in (&quot;P&quot;, &quot;U&quot;):
            continue
        key = (r[&quot;rx_file&quot;], mode)
        by_trial.setdefault(key, []).append(int(r[&quot;outage_gt_tau&quot;]))

    trials: List[TrialOutage] = []
    for (rx_file, mode), outs in sorted(by_trial.items()):
        trials.append(TrialOutage(rx_file=rx_file, mode=mode, n_transitions=len(outs), n_outages=sum(outs)))

    _write_csv(
        args.out_dir / &quot;outage_counts_by_trial.csv&quot;,
        [&quot;rx_file&quot;, &quot;mode&quot;, &quot;n_transitions&quot;, &quot;n_outages&quot;, &quot;pout_est&quot;],
        [[t.rx_file, t.mode, t.n_transitions, t.n_outages, (t.n_outages / t.n_transitions if t.n_transitions else float(&quot;nan&quot;))] for t in trials],
    )

    # Histogram bins (0..max_outages observed)
    max_out = max((t.n_outages for t in trials), default=0)
    bins = list(range(0, max_out + 1))
    c_p = [0] * len(bins)
    c_u = [0] * len(bins)
    for t in trials:
        if t.n_outages not in bins:
            continue
        idx = bins.index(t.n_outages)
        if t.mode == &quot;P&quot;:
            c_p[idx] += 1
        else:
            c_u[idx] += 1

    _plot_hist_svg(
        args.out_dir / &quot;fig_outage_count_hist.svg&quot;,
        title=f&quot;D4B: outage-count distribution per trial (TL&gt;{args.tau_s:.1f}s)&quot;,
        bins=bins,
        counts_p=c_p,
        counts_u=c_u,
    )

    # Delta-Pout contribution across transitions (from outage_ranking.csv)
    rank_rows = _read_csv(args.outage_ranking_csv)
    # Keep only finite deltas
    deltas: List[Tuple[int, float]] = []
    for r in rank_rows:
        try:
            step = int(float(r[&quot;transition_step&quot;]))
            du = float(r[&quot;u_minus_p_out_rate&quot;])
        except Exception:
            continue
        if math.isnan(du) or math.isinf(du):
            continue
        deltas.append((step, du))

    # Contributions: overall Δpout = mean_j du_j (j over transitions)
    # We focus on positive du (U-only worse) because it explains the improvement.
    pos = [(step, du) for step, du in deltas if du &gt; 0]
    pos.sort(key=lambda x: x[1], reverse=True)
    total_pos = sum(du for _step, du in pos) or 1.0

    contrib_rows: List[List[object]] = []
    cum = 0.0
    xs: List[int] = []
    ys: List[float] = []
    for k in range(1, min(args.top_k_max, len(pos)) + 1):
        step, du = pos[k - 1]
        cum += du
        frac = cum / total_pos
        xs.append(k)
        ys.append(frac)
        contrib_rows.append([k, step, du, frac])

    _write_csv(
        args.out_dir / &quot;delta_pout_contrib.csv&quot;,
        [&quot;k&quot;, &quot;transition_step&quot;, &quot;delta_out_rate&quot;, &quot;cum_frac_of_positive_delta&quot;],
        contrib_rows,
    )
    if xs:
        _plot_cumulative_svg(
            args.out_dir / &quot;fig_delta_pout_cum.svg&quot;,
            title=&quot;D4B: cumulative share of positive ΔPout explained by top-K transitions&quot;,
            xs=xs,
            ys=ys,
            y_label=&quot;cumulative fraction of positive ΔPout&quot;,
        )

    # Write a short markdown summary (letter-friendly notes)
    p_pouts = [t.n_outages / t.n_transitions for t in trials if t.mode == &quot;P&quot; and t.n_transitions]
    u_pouts = [t.n_outages / t.n_transitions for t in trials if t.mode == &quot;U&quot; and t.n_transitions]
    md: List[str] = []
    md.append(&quot;# D4B Pout tail decomposition (TL&gt;%.1fs)&quot; % args.tau_s)
    md.append(&quot;&quot;)
    md.append(f&quot;- input: `{args.per_transition_csv}` / `{args.outage_ranking_csv}`&quot;)
    md.append(f&quot;- output dir: `{args.out_dir}`&quot;)
    md.append(&quot;&quot;)
    md.append(&quot;## Trial-level outage counts&quot;)
    md.append(&quot;&quot;)
    if p_pouts and u_pouts:
        md.append(f&quot;- Policy (U+CCS): mean pout_est={_fmt(statistics.mean(p_pouts),4)} (n_trials={len(p_pouts)})&quot;)
        md.append(f&quot;- U-only (CCS-off): mean pout_est={_fmt(statistics.mean(u_pouts),4)} (n_trials={len(u_pouts)})&quot;)
    md.append(&quot;&quot;)
    md.append(&quot;## Concentration across transitions&quot;)
    md.append(&quot;&quot;)
    if xs:
        md.append(f&quot;- #transitions with positive ΔPout (U-only worse): {len(pos)} / {len(deltas)} total transitions&quot;)
        md.append(f&quot;- top-1 explains {ys[0]*100:.1f}% of positive ΔPout; top-{xs[min(4,len(xs))-1]} explains {ys[min(4,len(xs))-1]*100:.1f}%&quot;)
        md.append(f&quot;- see `fig_delta_pout_cum.svg` + `delta_pout_contrib.csv`&quot;)
    md.append(&quot;&quot;)
    md.append(&quot;## Figures&quot;)
    md.append(&quot;&quot;)
    md.append(f&quot;- `fig_outage_count_hist.svg`: outage-count distribution per trial&quot;)
    md.append(f&quot;- `fig_delta_pout_cum.svg`: cumulative ΔPout concentration curve (top-K transitions)&quot;)
    md.append(&quot;&quot;)
    (args.out_dir / &quot;pout_tail_decomposition.md&quot;).write_text(&quot;\n&quot;.join(md) + &quot;\n&quot;, encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/metrics/01/effects_ci.csv">metric,cond_a,cond_b,label,n_a,n_b,mean_a,mean_b,delta_mean,ci_low,ci_high,p_two_sided,n_boot,alpha,seed,generated_local,source_csv
pout_1s,S4_policy,S4_ablation_ccs_off,Δpout (U+CCS − U-only),3,3,0.04878,0.06504066666666666,-0.016260666666666666,-0.024391000000000003,0.0,0.0758,20000,0.05,20251217,2025-12-17 10:56,uccs_d4b_scan90/metrics/01/per_trial.csv
avg_power_mW,S4_policy,S4_ablation_ccs_off,Δpower_mW (U+CCS − U-only),3,3,200.62558239671534,200.6491276940079,-0.023545297292542955,-0.23315122934343435,0.18857135899770583,0.8283,20000,0.05,20251217,2025-12-17 10:56,uccs_d4b_scan90/metrics/01/per_trial.csv
tl_mean_s,S4_policy,S4_ablation_ccs_off,Δtl_mean_s (U+CCS − U-only),3,3,1.3173253333333335,1.4065450000000002,-0.0892196666666667,-0.25917100000000004,0.014316999999999913,0.2274,20000,0.05,20251217,2025-12-17 10:56,uccs_d4b_scan90/metrics/01/per_trial.csv
pdr_unique,S4_policy,S4_ablation_ccs_off,Δpdr_unique (U+CCS − U-only),3,3,0.44773666666666667,0.43357799999999996,0.014158666666666708,-0.0013263333333333183,0.02963566666666667,0.0624,20000,0.05,20251217,2025-12-17 10:56,uccs_d4b_scan90/metrics/01/per_trial.csv</file><file path="uccs_d4b_scan90/metrics/01/effects_ci.md"># effects_ci: D4B scan90 S4 (run01)

- source: `uccs_d4b_scan90/metrics/01/per_trial.csv`
- generated: 2025-12-17 10:56 (local)
- bootstrap: percentile CI, n_boot=20000, alpha=0.05, seed=20251217

| label | delta(mean) | 95% CI | p(two-sided) |
|---|---:|---:|---:|
| Δpout (U+CCS − U-only) | -0.0163 | [-0.0244, 0.0000] | 0.0758 |
| Δpower_mW (U+CCS − U-only) | -0.0235 | [-0.2332, 0.1886] | 0.8283 |
| Δtl_mean_s (U+CCS − U-only) | -0.0892 | [-0.2592, 0.0143] | 0.2274 |
| Δpdr_unique (U+CCS − U-only) | 0.0142 | [-0.0013, 0.0296] | 0.0624 |</file><file path="uccs_d4b_scan90/metrics/01/extra_analysis.md"># D4B run01: 追加解析メモ（tail / conditional）

このrun01は「同電力（同α）なのにQoS（pout/TL）が改善」の主結果を持つが、poutは少数のアウトエイジイベント（TL&gt;1s）で決まりやすい。
そのため、平均化したタイミング指標よりも「尾（outage）」に焦点を当てた可視化を追加する。

## 1) outage story（失敗イベント中心のストーリー図）

- 出力: `uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline.svg`
- 遷移の選び方: `uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv` の上位（U-onlyのoutage率が大きい遷移）から機械的に選択
- 例（選択イベント）: transition_step=1128 は U-onlyでTL≈9.889s（outage）だが、Policy(U+CCS)はTL≈0.212s（非outage）

再現コマンド:

`python3 uccs_d4b_scan90/analysis/outage_story_trace.py --rx-dir uccs_d4b_scan90/data/01/RX --truth Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv --out-dir uccs_d4b_scan90/plots/outage_story_01 --n-steps 1800 --tau-s 1.0 --window-s 3.0`

## 2) Poutの寄与分解（尾の集中度）

- 出力: `uccs_d4b_scan90/plots/pout_tail_01/`
  - `fig_outage_count_hist.svg`（trialごとのoutage数分布）
  - `fig_delta_pout_cum.svg`（上位K遷移がΔPoutをどれだけ説明するか）

再現コマンド:

`python3 uccs_d4b_scan90/analysis/pout_tail_decomposition.py --per-transition-csv uccs_d4b_scan90/plots/outage_story_01/per_transition.csv --outage-ranking-csv uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv --out-dir uccs_d4b_scan90/plots/pout_tail_01 --tau-s 1.0 --top-k-max 20`

## 3) 条件付きタイミング（失敗しやすい遷移のみ）

- 出力: `uccs_d4b_scan90/plots/ccs_timing_conditional_01/fig_event_triggered_p100_conditional.svg`
- 条件: U-onlyが悪化している遷移（outage差上位topK）に限定して `P(interval=100ms)` を再集計（平均化で差が薄まるのを避ける）

再現コマンド:

`python3 uccs_d4b_scan90/analysis/ccs_timing_analysis_conditional.py --rx-dir uccs_d4b_scan90/data/01/RX --truth Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv --outage-ranking-csv uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv --out-dir uccs_d4b_scan90/plots/ccs_timing_conditional_01 --n-steps 1800 --window-s 2.0 --subset u_only_worse --top-k 5`</file><file path="uccs_d4b_scan90/metrics/01/per_trial.csv">rx_trial_id,condition,repeat_idx,mode,rx_count,rx_unique,adv_count,pdr_unique,rx_tag_share100_time_est,tl_mean_s,tl_p95_s,pout_1s,pout_2s,pout_3s,tl_time_offset_ms,tl_time_offset_n,txsd_ms_total,E_total_mJ,avg_power_mW,txsd_path,rx_path
2,S4_fixed100,1,FIXED_100,737,737,1796,0.410356,1.0,1.552585,14.5963,0.073171,0.073171,0.073171,-1228.0,737,181463.0,37744.841,208.00295928095537,uccs_d4b_scan90/data/01/TX/trial_003_c2_s4_fixed500.csv,uccs_d4b_scan90/data/01/RX/rx_trial_002.csv
3,S4_fixed500,1,FIXED_500,290,290,359,0.807799,0.000692,1.042333,9.59,0.146341,0.097561,0.097561,-697.0,290,179628.0,33736.67,187.81409357115817,uccs_d4b_scan90/data/01/TX/trial_001_c3_s4_policy.csv,uccs_d4b_scan90/data/01/RX/rx_trial_003.csv
4,S4_policy,1,POLICY,538,537,1215,0.441975,0.428716,1.333439,13.9455,0.04878,0.04878,0.04878,-897.0,537,180885.0,36316.025,200.7685822483899,uccs_d4b_scan90/data/01/TX/trial_001_c5_unk.csv,uccs_d4b_scan90/data/01/RX/rx_trial_004.csv
5,S4_ablation_ccs_off,1,U_ONLY,533,533,1227,0.434393,0.418255,1.312,13.9479,0.04878,0.04878,0.04878,-900.0,533,180898.0,36302.285,200.67819986953975,uccs_d4b_scan90/data/01/TX/trial_001_c4_s4_ablation_ccs_off.csv,uccs_d4b_scan90/data/01/RX/rx_trial_005.csv
6,S4_fixed100,2,FIXED_100,705,705,1796,0.392539,1.0,1.553244,14.6142,0.073171,0.073171,0.073171,-1205.0,705,181448.0,37894.507,208.8449969137163,uccs_d4b_scan90/data/01/TX/trial_004_c2_s4_fixed500.csv,uccs_d4b_scan90/data/01/RX/rx_trial_006.csv
7,S4_fixed500,2,FIXED_500,301,301,359,0.83844,0.000666,1.513049,14.9559,0.097561,0.097561,0.097561,-685.0,301,179612.0,33813.545,188.25883014497919,uccs_d4b_scan90/data/01/TX/trial_002_c3_s4_policy.csv,uccs_d4b_scan90/data/01/RX/rx_trial_007.csv
8,S4_policy,2,POLICY,549,549,1215,0.451852,0.432836,1.288439,13.9323,0.04878,0.04878,0.04878,-860.0,549,180875.0,36260.876,200.47478092605388,uccs_d4b_scan90/data/01/TX/trial_002_c5_unk.csv,uccs_d4b_scan90/data/01/RX/rx_trial_008.csv
9,S4_ablation_ccs_off,2,U_ONLY,512,512,1227,0.417278,0.430851,1.57761,15.2289,0.073171,0.073171,0.073171,-860.0,512,180889.0,36261.609,200.4633172829746,uccs_d4b_scan90/data/01/TX/trial_002_c4_s4_ablation_ccs_off.csv,uccs_d4b_scan90/data/01/RX/rx_trial_009.csv
10,S4_fixed100,3,FIXED_100,591,591,1796,0.329065,1.0,1.354073,13.8769,0.097561,0.04878,0.04878,-1095.0,591,181442.0,37737.473,207.98642541418192,uccs_d4b_scan90/data/01/TX/trial_005_c2_s4_fixed500.csv,uccs_d4b_scan90/data/01/RX/rx_trial_010.csv
11,S4_fixed500,3,FIXED_500,295,295,359,0.821727,0.0,1.073375,9.65505,0.146341,0.073171,0.073171,-633.0,295,179606.0,33833.253,188.3748482790107,uccs_d4b_scan90/data/01/TX/trial_003_c3_s4_policy.csv,uccs_d4b_scan90/data/01/RX/rx_trial_011.csv
12,S4_policy,3,POLICY,546,546,1215,0.449383,0.439394,1.330098,13.9118,0.04878,0.04878,0.04878,-846.0,546,180865.0,36287.557,200.63338401570232,uccs_d4b_scan90/data/01/TX/trial_003_c5_unk.csv,uccs_d4b_scan90/data/01/RX/rx_trial_012.csv
13,S4_ablation_ccs_off,3,U_ONLY,551,551,1227,0.449063,0.43669,1.330025,14.66235,0.073171,0.073171,0.073171,-839.0,551,180875.0,36320.761,200.8058659295093,uccs_d4b_scan90/data/01/TX/trial_003_c4_s4_ablation_ccs_off.csv,uccs_d4b_scan90/data/01/RX/rx_trial_013.csv</file><file path="uccs_d4b_scan90/metrics/01/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std,share100_power_mix_mean
S4_ablation_ccs_off,3,0.065041,0.014082,1.406545,0.148421,0.433578,0.015908,0.428599,0.009422,200.649,0.173,1227.0,0.0,0.620995
S4_fixed100,3,0.081301,0.014082,1.486634,0.114802,0.37732,0.042729,1.0,0.0,208.278,0.491,1796.0,0.0,
S4_fixed500,3,0.130081,0.028163,1.209586,0.263265,0.822655,0.015342,0.000453,0.000392,188.149,0.296,359.0,0.0,
S4_policy,3,0.04878,0.0,1.317325,0.025072,0.447737,0.00514,0.433649,0.005385,200.626,0.147,1215.0,0.0,0.619852</file><file path="uccs_d4b_scan90/metrics/01/summary.md"># uccs_d4b_scan90 metrics summary (v2)

- source RX: `uccs_d4b_scan90/data/01/RX`
- source TXSD: `uccs_d4b_scan90/data/01/TX`
- truth: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv` (n_steps=1800, dt=100ms)
- selected RX trials: 002..013 (n=12)
- selected TXSD trials: grouped by adv_count=[359, 1215, 1227, 1796] (3 trials each)
- generated: 2025-12-17 00:10 (local)
- command: `python3 uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py --rx-dir uccs_d4b_scan90/data/01/RX --txsd-dir uccs_d4b_scan90/data/01/TX --out-dir uccs_d4b_scan90/metrics/01`

## Summary (mean ± std)
| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) | share100_power_mix |
|---|---:|---:|---:|---:|---:|---:|---:|
| S4_ablation_ccs_off | 0.0650±0.0141 | 1.407±0.148 | 0.434±0.016 | 200.6±0.2 | 1227.0±0.0 | 0.429±0.009 | 0.621 |
| S4_fixed100 | 0.0813±0.0141 | 1.487±0.115 | 0.377±0.043 | 208.3±0.5 | 1796.0±0.0 | 1.000±0.000 |  |
| S4_fixed500 | 0.1301±0.0282 | 1.210±0.263 | 0.823±0.015 | 188.1±0.3 | 359.0±0.0 | 0.000±0.000 |  |
| S4_policy | 0.0488±0.0000 | 1.317±0.025 | 0.448±0.005 | 200.6±0.1 | 1215.0±0.0 | 0.434±0.005 | 0.620 |

## Notes
- RX window: latest 12 trials that form 4 conditions × 3 repeats (duration&gt;=160s).
- TXSD pairing: cond_idがズレる/mtimeが壊れる可能性があるため、adv_count（tick_count）でクラスタリングして割り当て。
  - filter: avg_power_mW &gt;= 150.0 かつ E_total_mJ&gt;0（古いログ混在/逆符号を除外）
- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).
- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique.
- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/alloc_efficiency_summary.csv">condition,n_trials,share100_time,mean_CCS_change_all,mean_CCS_change_when100,top10pct_CCS_change_covered_by100,top10pct_U_covered_by100
policy(U+CCS),3,0.6396296296296297,0.4340228661111111,0.5583031087720113,0.5537037037037037,0.5796296296296296
u_only(CCS-off),3,0.6257407407407408,0.4340228661111111,0.5624959978401584,0.5537037037037037,0.5685185185185185</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/event_triggered_p100.csv">tau_s,p100_policy,p100_u_only
-2.0,0.5166666666666667,0.5
-1.9,0.5,0.49166666666666664
-1.8,0.48333333333333334,0.475
-1.7,0.5083333333333333,0.48333333333333334
-1.6,0.5166666666666667,0.5166666666666667
-1.5,0.5083333333333333,0.5166666666666667
-1.4,0.5333333333333333,0.525
-1.3,0.5447154471544715,0.5284552845528455
-1.2,0.5365853658536586,0.5121951219512195
-1.1,0.5365853658536586,0.5121951219512195
-1.0,0.5365853658536586,0.5121951219512195
-0.9,0.5447154471544715,0.5365853658536586
-0.8,0.5528455284552846,0.5365853658536586
-0.7,0.5121951219512195,0.5121951219512195
-0.6,0.5365853658536586,0.5365853658536586
-0.5,0.5121951219512195,0.5284552845528455
-0.4,0.5121951219512195,0.5284552845528455
-0.3,0.5121951219512195,0.5365853658536586
-0.2,0.5284552845528455,0.5447154471544715
-0.1,0.5284552845528455,0.5447154471544715
0.0,0.5284552845528455,0.5284552845528455
0.1,0.5284552845528455,0.5284552845528455
0.2,0.5691056910569106,0.5691056910569106
0.3,0.5772357723577236,0.5853658536585366
0.4,0.6097560975609756,0.6097560975609756
0.5,0.6747967479674797,0.6422764227642277
0.6,0.7886178861788617,0.7398373983739838
0.7,0.8373983739837398,0.7967479674796748
0.8,0.8861788617886179,0.8699186991869918
0.9,0.9186991869918699,0.9024390243902439
1.0,0.926829268292683,0.9024390243902439
1.1,0.926829268292683,0.9024390243902439
1.2,0.926829268292683,0.9024390243902439
1.3,0.9512195121951219,0.926829268292683
1.4,1.0,1.0
1.5,1.0,1.0
1.6,1.0,1.0
1.7,1.0,1.0
1.8,1.0,1.0
1.9,1.0,1.0
2.0,1.0,1.0</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/fig_alloc_efficiency.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;520&quot; viewBox=&quot;0 0 920 520&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;520&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B timing (S4, scan90): allocation efficiency of 100ms (higher=better)&lt;/text&gt;
&lt;rect x=&quot;80&quot; y=&quot;60&quot; width=&quot;810&quot; height=&quot;390&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;80&quot; y1=&quot;450.00&quot; x2=&quot;890&quot; y2=&quot;450.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;454.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.00&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;372.00&quot; x2=&quot;890&quot; y2=&quot;372.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;376.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.20&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;294.00&quot; x2=&quot;890&quot; y2=&quot;294.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;298.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.40&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;216.00&quot; x2=&quot;890&quot; y2=&quot;216.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;220.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.60&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;138.00&quot; x2=&quot;890&quot; y2=&quot;138.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;142.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.80&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;60.00&quot; x2=&quot;890&quot; y2=&quot;60.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;64.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.00&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;255.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 255.0)&quot;&gt;ratio / score&lt;/text&gt;
&lt;rect x=&quot;117.97&quot; y=&quot;234.06&quot; width=&quot;126.56&quot; height=&quot;215.94&quot; fill=&quot;#10b981&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;181.25&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;top10 (1-CCS) P&lt;/text&gt;
&lt;text x=&quot;181.25&quot; y=&quot;228.06&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.554&lt;/text&gt;
&lt;rect x=&quot;320.47&quot; y=&quot;234.06&quot; width=&quot;126.56&quot; height=&quot;215.94&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;383.75&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;top10 (1-CCS) U&lt;/text&gt;
&lt;text x=&quot;383.75&quot; y=&quot;228.06&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.554&lt;/text&gt;
&lt;rect x=&quot;522.97&quot; y=&quot;232.26&quot; width=&quot;126.56&quot; height=&quot;217.74&quot; fill=&quot;#10b981&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;586.25&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;mean (1-CCS)|100 P&lt;/text&gt;
&lt;text x=&quot;586.25&quot; y=&quot;226.26&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.558&lt;/text&gt;
&lt;rect x=&quot;725.47&quot; y=&quot;230.63&quot; width=&quot;126.56&quot; height=&quot;219.37&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;788.75&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;mean (1-CCS)|100 U&lt;/text&gt;
&lt;text x=&quot;788.75&quot; y=&quot;224.63&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.562&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/fig_event_triggered_p100.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;560&quot; viewBox=&quot;0 0 920 560&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;560&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B timing (S4, scan90): P(100ms) around truth transitions (±2.0s)&lt;/text&gt;
&lt;rect x=&quot;80&quot; y=&quot;60&quot; width=&quot;810&quot; height=&quot;430&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;80.00&quot; y1=&quot;60&quot; x2=&quot;80.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-2.0&lt;/text&gt;
&lt;line x1=&quot;242.00&quot; y1=&quot;60&quot; x2=&quot;242.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;242.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-1.2&lt;/text&gt;
&lt;line x1=&quot;404.00&quot; y1=&quot;60&quot; x2=&quot;404.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;404.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-0.4&lt;/text&gt;
&lt;line x1=&quot;566.00&quot; y1=&quot;60&quot; x2=&quot;566.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;566.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.4&lt;/text&gt;
&lt;line x1=&quot;728.00&quot; y1=&quot;60&quot; x2=&quot;728.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;728.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.2&lt;/text&gt;
&lt;line x1=&quot;890.00&quot; y1=&quot;60&quot; x2=&quot;890.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;890.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2.0&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;490.00&quot; x2=&quot;890&quot; y2=&quot;490.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;494.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.00&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;404.00&quot; x2=&quot;890&quot; y2=&quot;404.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;408.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.20&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;318.00&quot; x2=&quot;890&quot; y2=&quot;318.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;322.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.40&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;232.00&quot; x2=&quot;890&quot; y2=&quot;232.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;236.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.60&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;146.00&quot; x2=&quot;890&quot; y2=&quot;146.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;150.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.80&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;60.00&quot; x2=&quot;890&quot; y2=&quot;60.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;64.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.00&lt;/text&gt;
&lt;text x=&quot;485.0&quot; y=&quot;536&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;relative time from transition [s]&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;275.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 275.0)&quot;&gt;P(interval=100ms)&lt;/text&gt;
&lt;polyline fill=&quot;none&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;3&quot; points=&quot;80.00,267.83 100.25,275.00 120.50,282.17 140.75,271.42 161.00,267.83 181.25,271.42 201.50,260.67 221.75,255.77 242.00,259.27 262.25,259.27 282.50,259.27 302.75,255.77 323.00,252.28 343.25,269.76 363.50,259.27 383.75,269.76 404.00,269.76 424.25,269.76 444.50,262.76 464.75,262.76 485.00,262.76 505.25,262.76 525.50,245.28 545.75,241.79 566.00,227.80 586.25,199.84 606.50,150.89 626.75,129.92 647.00,108.94 667.25,94.96 687.50,91.46 707.75,91.46 728.00,91.46 748.25,80.98 768.50,60.00 788.75,60.00 809.00,60.00 829.25,60.00 849.50,60.00 869.75,60.00 890.00,60.00&quot;/&gt;
&lt;circle cx=&quot;485.00&quot; cy=&quot;262.76&quot; r=&quot;4.5&quot; fill=&quot;#10b981&quot;/&gt;
&lt;polyline fill=&quot;none&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;3&quot; points=&quot;80.00,275.00 100.25,278.58 120.50,285.75 140.75,282.17 161.00,267.83 181.25,267.83 201.50,264.25 221.75,262.76 242.00,269.76 262.25,269.76 282.50,269.76 302.75,259.27 323.00,259.27 343.25,269.76 363.50,259.27 383.75,262.76 404.00,262.76 424.25,259.27 444.50,255.77 464.75,255.77 485.00,262.76 505.25,262.76 525.50,245.28 545.75,238.29 566.00,227.80 586.25,213.82 606.50,171.87 626.75,147.40 647.00,115.93 667.25,101.95 687.50,101.95 707.75,101.95 728.00,101.95 748.25,91.46 768.50,60.00 788.75,60.00 809.00,60.00 829.25,60.00 849.50,60.00 869.75,60.00 890.00,60.00&quot;/&gt;
&lt;circle cx=&quot;485.00&quot; cy=&quot;262.76&quot; r=&quot;4.5&quot; fill=&quot;#f59e0b&quot;/&gt;
&lt;rect x=&quot;84&quot; y=&quot;64&quot; width=&quot;260&quot; height=&quot;64&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;line x1=&quot;90&quot; y1=&quot;88&quot; x2=&quot;118&quot; y2=&quot;88&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;4&quot;/&gt;
&lt;text x=&quot;126&quot; y=&quot;93&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;policy (U+CCS)&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;114&quot; x2=&quot;118&quot; y2=&quot;114&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;4&quot;/&gt;
&lt;text x=&quot;126&quot; y=&quot;119&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;u-only (CCS-off)&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/fig_hit_cover.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;520&quot; viewBox=&quot;0 0 920 520&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;520&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B timing (S4, scan90): transition hit/prehit/cover (mean over transitions×trials)&lt;/text&gt;
&lt;rect x=&quot;80&quot; y=&quot;60&quot; width=&quot;810&quot; height=&quot;390&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;80&quot; y1=&quot;450.00&quot; x2=&quot;890&quot; y2=&quot;450.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;454.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.00&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;372.00&quot; x2=&quot;890&quot; y2=&quot;372.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;376.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.20&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;294.00&quot; x2=&quot;890&quot; y2=&quot;294.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;298.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.40&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;216.00&quot; x2=&quot;890&quot; y2=&quot;216.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;220.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.60&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;138.00&quot; x2=&quot;890&quot; y2=&quot;138.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;142.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.80&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;60.00&quot; x2=&quot;890&quot; y2=&quot;60.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;64.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.00&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;255.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 255.0)&quot;&gt;ratio&lt;/text&gt;
&lt;rect x=&quot;105.31&quot; y=&quot;88.54&quot; width=&quot;84.37&quot; height=&quot;361.46&quot; fill=&quot;#10b981&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;147.50&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;hit@1s P&lt;/text&gt;
&lt;text x=&quot;147.50&quot; y=&quot;82.54&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.927&lt;/text&gt;
&lt;rect x=&quot;240.31&quot; y=&quot;98.05&quot; width=&quot;84.37&quot; height=&quot;351.95&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;282.50&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;hit@1s U&lt;/text&gt;
&lt;text x=&quot;282.50&quot; y=&quot;92.05&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.902&lt;/text&gt;
&lt;rect x=&quot;375.31&quot; y=&quot;231.22&quot; width=&quot;84.37&quot; height=&quot;218.78&quot; fill=&quot;#10b981&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;417.50&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;pre@0.5s P&lt;/text&gt;
&lt;text x=&quot;417.50&quot; y=&quot;225.22&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.561&lt;/text&gt;
&lt;rect x=&quot;510.31&quot; y=&quot;224.88&quot; width=&quot;84.37&quot; height=&quot;225.12&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;552.50&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;pre@0.5s U&lt;/text&gt;
&lt;text x=&quot;552.50&quot; y=&quot;218.88&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.577&lt;/text&gt;
&lt;rect x=&quot;645.31&quot; y=&quot;206.31&quot; width=&quot;84.37&quot; height=&quot;243.69&quot; fill=&quot;#10b981&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;687.50&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;cover±1s P&lt;/text&gt;
&lt;text x=&quot;687.50&quot; y=&quot;200.31&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.625&lt;/text&gt;
&lt;rect x=&quot;780.31&quot; y=&quot;208.72&quot; width=&quot;84.37&quot; height=&quot;241.28&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;822.50&quot; y=&quot;474&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;cover±1s U&lt;/text&gt;
&lt;text x=&quot;822.50&quot; y=&quot;202.72&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.619&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/fig_lag_cdf.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;560&quot; viewBox=&quot;0 0 920 560&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;560&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B timing (S4, scan90): CDF of lag-to-100ms after transition&lt;/text&gt;
&lt;rect x=&quot;80&quot; y=&quot;60&quot; width=&quot;810&quot; height=&quot;430&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;80.00&quot; y1=&quot;60&quot; x2=&quot;80.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.0&lt;/text&gt;
&lt;line x1=&quot;242.00&quot; y1=&quot;60&quot; x2=&quot;242.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;242.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.4&lt;/text&gt;
&lt;line x1=&quot;404.00&quot; y1=&quot;60&quot; x2=&quot;404.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;404.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.8&lt;/text&gt;
&lt;line x1=&quot;566.00&quot; y1=&quot;60&quot; x2=&quot;566.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;566.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.2&lt;/text&gt;
&lt;line x1=&quot;728.00&quot; y1=&quot;60&quot; x2=&quot;728.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;728.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.6&lt;/text&gt;
&lt;line x1=&quot;890.00&quot; y1=&quot;60&quot; x2=&quot;890.00&quot; y2=&quot;490&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;890.00&quot; y=&quot;514&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2.0&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;490.00&quot; x2=&quot;890&quot; y2=&quot;490.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;494.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.00&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;404.00&quot; x2=&quot;890&quot; y2=&quot;404.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;408.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.20&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;318.00&quot; x2=&quot;890&quot; y2=&quot;318.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;322.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.40&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;232.00&quot; x2=&quot;890&quot; y2=&quot;232.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;236.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.60&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;146.00&quot; x2=&quot;890&quot; y2=&quot;146.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;150.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.80&lt;/text&gt;
&lt;line x1=&quot;80&quot; y1=&quot;60.00&quot; x2=&quot;890&quot; y2=&quot;60.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70&quot; y=&quot;64.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.00&lt;/text&gt;
&lt;text x=&quot;485.0&quot; y=&quot;536&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;time since transition [s]&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;275.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 275.0)&quot;&gt;CDF&lt;/text&gt;
&lt;polyline fill=&quot;none&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;3&quot; points=&quot;80.00,262.76 120.50,255.77 161.00,238.29 201.50,234.80 242.00,220.81 282.50,192.85 323.00,150.89 363.50,129.92 404.00,108.94 444.50,94.96 485.00,91.46 525.50,91.46 566.00,91.46 606.50,80.98 647.00,60.00 687.50,60.00 728.00,60.00 768.50,60.00 809.00,60.00 849.50,60.00 890.00,60.00&quot;/&gt;
&lt;circle cx=&quot;80.00&quot; cy=&quot;262.76&quot; r=&quot;4.5&quot; fill=&quot;#10b981&quot;/&gt;
&lt;polyline fill=&quot;none&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;3&quot; points=&quot;80.00,262.76 120.50,255.77 161.00,238.29 201.50,231.30 242.00,220.81 282.50,206.83 323.00,168.37 363.50,147.40 404.00,115.93 444.50,101.95 485.00,101.95 525.50,101.95 566.00,101.95 606.50,91.46 647.00,60.00 687.50,60.00 728.00,60.00 768.50,60.00 809.00,60.00 849.50,60.00 890.00,60.00&quot;/&gt;
&lt;circle cx=&quot;80.00&quot; cy=&quot;262.76&quot; r=&quot;4.5&quot; fill=&quot;#f59e0b&quot;/&gt;
&lt;rect x=&quot;84&quot; y=&quot;64&quot; width=&quot;260&quot; height=&quot;64&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;line x1=&quot;90&quot; y1=&quot;88&quot; x2=&quot;118&quot; y2=&quot;88&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;4&quot;/&gt;
&lt;text x=&quot;126&quot; y=&quot;93&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;policy (U+CCS)&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;114&quot; x2=&quot;118&quot; y2=&quot;114&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;4&quot;/&gt;
&lt;text x=&quot;126&quot; y=&quot;119&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;u-only (CCS-off)&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/hit_cover_lag_summary.csv">condition,n_trials,hit_rate,pre_hit_rate,cover_ratio,lag_median_s,lag_p90_s
policy(U+CCS),3,0.926829268292683,0.5609756097560976,0.6248548199767713,0.0,0.9
u_only(CCS-off),3,0.9024390243902439,0.5772357723577236,0.6186604723190089,0.0,0.9</file><file path="uccs_d4b_scan90/plots/ccs_timing_01/lag_cdf.csv">x_s,cdf_policy,cdf_u_only
0.0,0.5284552845528455,0.5284552845528455
0.1,0.5447154471544715,0.5447154471544715
0.2,0.5853658536585366,0.5853658536585366
0.30000000000000004,0.5934959349593496,0.6016260162601627
0.4,0.6260162601626016,0.6260162601626016
0.5,0.6910569105691057,0.6585365853658537
0.6000000000000001,0.7886178861788617,0.7479674796747967
0.7000000000000001,0.8373983739837398,0.7967479674796748
0.8,0.8861788617886179,0.8699186991869918
0.9,0.9186991869918699,0.9024390243902439
1.0,0.926829268292683,0.9024390243902439
1.1,0.926829268292683,0.9024390243902439
1.2000000000000002,0.926829268292683,0.9024390243902439
1.3,0.9512195121951219,0.926829268292683
1.4000000000000001,1.0,1.0
1.5,1.0,1.0
1.6,1.0,1.0
1.7000000000000002,1.0,1.0
1.8,1.0,1.0
1.9000000000000001,1.0,1.0
2.0,1.0,1.0</file><file path="uccs_d4b_scan90/plots/ccs_timing_conditional_01/fig_event_triggered_p100_conditional.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;520&quot; viewBox=&quot;0 0 920 520&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;520&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B conditional timing: P(100ms) around transitions (u_only_worse, topK=5)&lt;/text&gt;
&lt;rect x=&quot;70&quot; y=&quot;70&quot; width=&quot;820&quot; height=&quot;390&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;70&quot; y1=&quot;460.00&quot; x2=&quot;890&quot; y2=&quot;460.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;464.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.0&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;382.00&quot; x2=&quot;890&quot; y2=&quot;382.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;386.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.2&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;304.00&quot; x2=&quot;890&quot; y2=&quot;304.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;308.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.4&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;226.00&quot; x2=&quot;890&quot; y2=&quot;226.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;230.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.6&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;148.00&quot; x2=&quot;890&quot; y2=&quot;148.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;152.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.8&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;70.00&quot; x2=&quot;890&quot; y2=&quot;70.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;74.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.0&lt;/text&gt;
&lt;line x1=&quot;70.00&quot; y1=&quot;70&quot; x2=&quot;70.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-2.0&lt;/text&gt;
&lt;line x1=&quot;206.67&quot; y1=&quot;70&quot; x2=&quot;206.67&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;206.67&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-1.3&lt;/text&gt;
&lt;line x1=&quot;343.33&quot; y1=&quot;70&quot; x2=&quot;343.33&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;343.33&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-0.7&lt;/text&gt;
&lt;line x1=&quot;480.00&quot; y1=&quot;70&quot; x2=&quot;480.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;480.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.0&lt;/text&gt;
&lt;line x1=&quot;616.67&quot; y1=&quot;70&quot; x2=&quot;616.67&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;616.67&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.7&lt;/text&gt;
&lt;line x1=&quot;753.33&quot; y1=&quot;70&quot; x2=&quot;753.33&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;753.33&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.3&lt;/text&gt;
&lt;line x1=&quot;890.00&quot; y1=&quot;70&quot; x2=&quot;890.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;890.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2.0&lt;/text&gt;
&lt;line x1=&quot;480.00&quot; y1=&quot;70&quot; x2=&quot;480.00&quot; y2=&quot;460&quot; stroke=&quot;#6b7280&quot; stroke-width=&quot;2&quot; stroke-dasharray=&quot;6 4&quot;/&gt;
&lt;path d=&quot;M 70.00 265.00 L 90.50 265.00 L 111.00 265.00 L 131.50 265.00 L 152.00 265.00 L 172.50 265.00 L 193.00 265.00 L 213.50 265.00 L 234.00 265.00 L 254.50 265.00 L 275.00 265.00 L 295.50 265.00 L 316.00 265.00 L 336.50 265.00 L 357.00 265.00 L 377.50 265.00 L 398.00 265.00 L 418.50 265.00 L 439.00 265.00 L 459.50 265.00 L 480.00 265.00 L 500.50 265.00 L 521.00 265.00 L 541.50 265.00 L 562.00 265.00 L 582.50 265.00 L 603.00 265.00 L 623.50 135.00 L 644.00 70.00 L 664.50 70.00 L 685.00 70.00 L 705.50 70.00 L 726.00 70.00 L 746.50 70.00 L 767.00 70.00 L 787.50 70.00 L 808.00 70.00 L 828.50 70.00 L 849.00 70.00 L 869.50 70.00 L 890.00 70.00&quot; fill=&quot;none&quot; stroke=&quot;#2563eb&quot; stroke-width=&quot;2.5&quot;/&gt;
&lt;path d=&quot;M 70.00 265.00 L 90.50 265.00 L 111.00 265.00 L 131.50 265.00 L 152.00 265.00 L 172.50 265.00 L 193.00 265.00 L 213.50 265.00 L 234.00 265.00 L 254.50 265.00 L 275.00 265.00 L 295.50 265.00 L 316.00 265.00 L 336.50 265.00 L 357.00 265.00 L 377.50 265.00 L 398.00 265.00 L 418.50 265.00 L 439.00 265.00 L 459.50 265.00 L 480.00 265.00 L 500.50 265.00 L 521.00 265.00 L 541.50 265.00 L 562.00 265.00 L 582.50 265.00 L 603.00 265.00 L 623.50 135.00 L 644.00 70.00 L 664.50 70.00 L 685.00 70.00 L 705.50 70.00 L 726.00 70.00 L 746.50 70.00 L 767.00 70.00 L 787.50 70.00 L 808.00 70.00 L 828.50 70.00 L 849.00 70.00 L 869.50 70.00 L 890.00 70.00&quot; fill=&quot;none&quot; stroke=&quot;#ef4444&quot; stroke-width=&quot;2.5&quot;/&gt;
&lt;rect x=&quot;650&quot; y=&quot;80&quot; width=&quot;230&quot; height=&quot;54&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;line x1=&quot;664&quot; y1=&quot;100&quot; x2=&quot;684&quot; y2=&quot;100&quot; stroke=&quot;#2563eb&quot; stroke-width=&quot;3&quot;/&gt;
&lt;text x=&quot;692&quot; y=&quot;104&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;Policy (U+CCS)&lt;/text&gt;
&lt;line x1=&quot;664&quot; y1=&quot;120&quot; x2=&quot;684&quot; y2=&quot;120&quot; stroke=&quot;#ef4444&quot; stroke-width=&quot;3&quot;/&gt;
&lt;text x=&quot;692&quot; y=&quot;124&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;U-only (CCS-off)&lt;/text&gt;
&lt;text x=&quot;480.0&quot; y=&quot;500&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;relative time to truth transition [s]&lt;/text&gt;
&lt;text x=&quot;18&quot; y=&quot;265.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 18 265.0)&quot;&gt;P(interval=100ms)&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/ccs_timing_conditional_01/selected_transitions.csv">transition_step
1128
1404</file><file path="uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;1000&quot; height=&quot;560&quot; viewBox=&quot;0 0 1000 560&quot;&gt;
&lt;defs&gt;&lt;marker id=&quot;arr&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;9&quot; refY=&quot;5&quot; markerWidth=&quot;7&quot; markerHeight=&quot;7&quot; orient=&quot;auto-start-reverse&quot;&gt;&lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; fill=&quot;#111827&quot;/&gt;&lt;/marker&gt;&lt;/defs&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;1000&quot; height=&quot;560&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;500.0&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B outage story (S4, scan90): failure-centered view (TL&amp;gt;1.0s)&lt;/text&gt;
&lt;rect x=&quot;80&quot; y=&quot;70&quot; width=&quot;890&quot; height=&quot;400&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;80.00&quot; y1=&quot;70&quot; x2=&quot;80.00&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80.00&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-3.0&lt;/text&gt;
&lt;line x1=&quot;227.39&quot; y1=&quot;70&quot; x2=&quot;227.39&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;227.39&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-0.4&lt;/text&gt;
&lt;line x1=&quot;374.78&quot; y1=&quot;70&quot; x2=&quot;374.78&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;374.78&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2.2&lt;/text&gt;
&lt;line x1=&quot;522.17&quot; y1=&quot;70&quot; x2=&quot;522.17&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;522.17&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;4.8&lt;/text&gt;
&lt;line x1=&quot;675.22&quot; y1=&quot;70&quot; x2=&quot;675.22&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;675.22&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;7.5&lt;/text&gt;
&lt;line x1=&quot;822.61&quot; y1=&quot;70&quot; x2=&quot;822.61&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;822.61&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;10.1&lt;/text&gt;
&lt;line x1=&quot;970.00&quot; y1=&quot;70&quot; x2=&quot;970.00&quot; y2=&quot;470&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;970.00&quot; y=&quot;498&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;12.7&lt;/text&gt;
&lt;text x=&quot;525.0&quot; y=&quot;538&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;time relative to selected transition [s]&lt;/text&gt;
&lt;line x1=&quot;250.06&quot; y1=&quot;70&quot; x2=&quot;250.06&quot; y2=&quot;470&quot; stroke=&quot;#6b7280&quot; stroke-width=&quot;2&quot; stroke-dasharray=&quot;6 4&quot;/&gt;
&lt;text x=&quot;256.06&quot; y=&quot;60&quot; font-size=&quot;12&quot; fill=&quot;#6b7280&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;truth transition (label=9)&lt;/text&gt;
&lt;text x=&quot;80&quot; y=&quot;88&quot; font-size=&quot;13&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;U-only (CCS-off) (TL=9.89s)&lt;/text&gt;
&lt;rect x=&quot;80.00&quot; y=&quot;98.00&quot; width=&quot;459.17&quot; height=&quot;26&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.22&quot;/&gt;
&lt;rect x=&quot;544.84&quot; y=&quot;98.00&quot; width=&quot;277.77&quot; height=&quot;26&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.22&quot;/&gt;
&lt;rect x=&quot;828.28&quot; y=&quot;98.00&quot; width=&quot;141.72&quot; height=&quot;26&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.22&quot;/&gt;
&lt;text x=&quot;86&quot; y=&quot;116&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;interval&lt;/text&gt;
&lt;line x1=&quot;80.00&quot; y1=&quot;154.00&quot; x2=&quot;80.00&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;97.01&quot; y1=&quot;154.00&quot; x2=&quot;97.01&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;108.34&quot; y1=&quot;154.00&quot; x2=&quot;108.34&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;119.68&quot; y1=&quot;154.00&quot; x2=&quot;119.68&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;131.02&quot; y1=&quot;154.00&quot; x2=&quot;131.02&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;142.36&quot; y1=&quot;154.00&quot; x2=&quot;142.36&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;153.69&quot; y1=&quot;154.00&quot; x2=&quot;153.69&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;170.70&quot; y1=&quot;154.00&quot; x2=&quot;170.70&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;187.71&quot; y1=&quot;154.00&quot; x2=&quot;187.71&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;199.04&quot; y1=&quot;154.00&quot; x2=&quot;199.04&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;221.72&quot; y1=&quot;154.00&quot; x2=&quot;221.72&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;244.39&quot; y1=&quot;154.00&quot; x2=&quot;244.39&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;261.40&quot; y1=&quot;154.00&quot; x2=&quot;261.40&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;278.41&quot; y1=&quot;154.00&quot; x2=&quot;278.41&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;295.41&quot; y1=&quot;154.00&quot; x2=&quot;295.41&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;306.75&quot; y1=&quot;154.00&quot; x2=&quot;306.75&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;318.09&quot; y1=&quot;154.00&quot; x2=&quot;318.09&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;335.10&quot; y1=&quot;154.00&quot; x2=&quot;335.10&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;352.10&quot; y1=&quot;154.00&quot; x2=&quot;352.10&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;363.44&quot; y1=&quot;154.00&quot; x2=&quot;363.44&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;380.45&quot; y1=&quot;154.00&quot; x2=&quot;380.45&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;397.45&quot; y1=&quot;154.00&quot; x2=&quot;397.45&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;414.46&quot; y1=&quot;154.00&quot; x2=&quot;414.46&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;431.46&quot; y1=&quot;154.00&quot; x2=&quot;431.46&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;448.47&quot; y1=&quot;154.00&quot; x2=&quot;448.47&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;476.82&quot; y1=&quot;154.00&quot; x2=&quot;476.82&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;488.15&quot; y1=&quot;154.00&quot; x2=&quot;488.15&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;499.49&quot; y1=&quot;154.00&quot; x2=&quot;499.49&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;510.83&quot; y1=&quot;154.00&quot; x2=&quot;510.83&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;544.84&quot; y1=&quot;154.00&quot; x2=&quot;544.84&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;601.53&quot; y1=&quot;154.00&quot; x2=&quot;601.53&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;629.87&quot; y1=&quot;154.00&quot; x2=&quot;629.87&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;658.22&quot; y1=&quot;154.00&quot; x2=&quot;658.22&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;686.56&quot; y1=&quot;154.00&quot; x2=&quot;686.56&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;714.90&quot; y1=&quot;154.00&quot; x2=&quot;714.90&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;771.59&quot; y1=&quot;154.00&quot; x2=&quot;771.59&quot; y2=&quot;172.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;799.94&quot; y1=&quot;154.00&quot; x2=&quot;799.94&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;828.28&quot; y1=&quot;154.00&quot; x2=&quot;828.28&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;839.62&quot; y1=&quot;154.00&quot; x2=&quot;839.62&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;850.96&quot; y1=&quot;154.00&quot; x2=&quot;850.96&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;867.96&quot; y1=&quot;154.00&quot; x2=&quot;867.96&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;884.97&quot; y1=&quot;154.00&quot; x2=&quot;884.97&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;901.97&quot; y1=&quot;154.00&quot; x2=&quot;901.97&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;913.31&quot; y1=&quot;154.00&quot; x2=&quot;913.31&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;924.65&quot; y1=&quot;154.00&quot; x2=&quot;924.65&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;941.66&quot; y1=&quot;154.00&quot; x2=&quot;941.66&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;952.99&quot; y1=&quot;154.00&quot; x2=&quot;952.99&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;964.33&quot; y1=&quot;154.00&quot; x2=&quot;964.33&quot; y2=&quot;172.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;86&quot; y=&quot;168&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX (green=new label)&lt;/text&gt;
&lt;line x1=&quot;250.06&quot; y1=&quot;210.00&quot; x2=&quot;799.94&quot; y2=&quot;210.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arr)&quot;/&gt;
&lt;text x=&quot;525.00&quot; y=&quot;202.00&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;TL&lt;/text&gt;
&lt;text x=&quot;80&quot; y=&quot;288&quot; font-size=&quot;13&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;Policy (U+CCS) (TL=0.21s)&lt;/text&gt;
&lt;rect x=&quot;80.00&quot; y=&quot;298.00&quot; width=&quot;459.17&quot; height=&quot;26&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.22&quot;/&gt;
&lt;rect x=&quot;544.84&quot; y=&quot;298.00&quot; width=&quot;277.77&quot; height=&quot;26&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.22&quot;/&gt;
&lt;rect x=&quot;828.28&quot; y=&quot;298.00&quot; width=&quot;141.72&quot; height=&quot;26&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.22&quot;/&gt;
&lt;text x=&quot;86&quot; y=&quot;316&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;interval&lt;/text&gt;
&lt;line x1=&quot;80.00&quot; y1=&quot;354.00&quot; x2=&quot;80.00&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;91.34&quot; y1=&quot;354.00&quot; x2=&quot;91.34&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;108.34&quot; y1=&quot;354.00&quot; x2=&quot;108.34&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;125.35&quot; y1=&quot;354.00&quot; x2=&quot;125.35&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;142.36&quot; y1=&quot;354.00&quot; x2=&quot;142.36&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;153.69&quot; y1=&quot;354.00&quot; x2=&quot;153.69&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;170.70&quot; y1=&quot;354.00&quot; x2=&quot;170.70&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;193.38&quot; y1=&quot;354.00&quot; x2=&quot;193.38&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;204.71&quot; y1=&quot;354.00&quot; x2=&quot;204.71&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;216.05&quot; y1=&quot;354.00&quot; x2=&quot;216.05&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;227.39&quot; y1=&quot;354.00&quot; x2=&quot;227.39&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;255.73&quot; y1=&quot;354.00&quot; x2=&quot;255.73&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;267.07&quot; y1=&quot;354.00&quot; x2=&quot;267.07&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;284.08&quot; y1=&quot;354.00&quot; x2=&quot;284.08&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;295.41&quot; y1=&quot;354.00&quot; x2=&quot;295.41&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;306.75&quot; y1=&quot;354.00&quot; x2=&quot;306.75&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;318.09&quot; y1=&quot;354.00&quot; x2=&quot;318.09&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;329.43&quot; y1=&quot;354.00&quot; x2=&quot;329.43&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;340.76&quot; y1=&quot;354.00&quot; x2=&quot;340.76&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;352.10&quot; y1=&quot;354.00&quot; x2=&quot;352.10&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;369.11&quot; y1=&quot;354.00&quot; x2=&quot;369.11&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;386.11&quot; y1=&quot;354.00&quot; x2=&quot;386.11&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;408.79&quot; y1=&quot;354.00&quot; x2=&quot;408.79&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;425.80&quot; y1=&quot;354.00&quot; x2=&quot;425.80&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;442.80&quot; y1=&quot;354.00&quot; x2=&quot;442.80&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;459.81&quot; y1=&quot;354.00&quot; x2=&quot;459.81&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;471.15&quot; y1=&quot;354.00&quot; x2=&quot;471.15&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;482.48&quot; y1=&quot;354.00&quot; x2=&quot;482.48&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;493.82&quot; y1=&quot;354.00&quot; x2=&quot;493.82&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;505.16&quot; y1=&quot;354.00&quot; x2=&quot;505.16&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;544.84&quot; y1=&quot;354.00&quot; x2=&quot;544.84&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;601.53&quot; y1=&quot;354.00&quot; x2=&quot;601.53&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;629.87&quot; y1=&quot;354.00&quot; x2=&quot;629.87&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;658.22&quot; y1=&quot;354.00&quot; x2=&quot;658.22&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;686.56&quot; y1=&quot;354.00&quot; x2=&quot;686.56&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;714.90&quot; y1=&quot;354.00&quot; x2=&quot;714.90&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;743.25&quot; y1=&quot;354.00&quot; x2=&quot;743.25&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;771.59&quot; y1=&quot;354.00&quot; x2=&quot;771.59&quot; y2=&quot;372.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;799.94&quot; y1=&quot;354.00&quot; x2=&quot;799.94&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;828.28&quot; y1=&quot;354.00&quot; x2=&quot;828.28&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;839.62&quot; y1=&quot;354.00&quot; x2=&quot;839.62&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;850.96&quot; y1=&quot;354.00&quot; x2=&quot;850.96&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;862.29&quot; y1=&quot;354.00&quot; x2=&quot;862.29&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;873.63&quot; y1=&quot;354.00&quot; x2=&quot;873.63&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;884.97&quot; y1=&quot;354.00&quot; x2=&quot;884.97&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;896.31&quot; y1=&quot;354.00&quot; x2=&quot;896.31&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;907.64&quot; y1=&quot;354.00&quot; x2=&quot;907.64&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;918.98&quot; y1=&quot;354.00&quot; x2=&quot;918.98&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;935.99&quot; y1=&quot;354.00&quot; x2=&quot;935.99&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;958.66&quot; y1=&quot;354.00&quot; x2=&quot;958.66&quot; y2=&quot;372.00&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;1.4&quot; opacity=&quot;0.9&quot;/&gt;
&lt;text x=&quot;86&quot; y=&quot;368&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX (green=new label)&lt;/text&gt;
&lt;line x1=&quot;250.06&quot; y1=&quot;410.00&quot; x2=&quot;255.73&quot; y2=&quot;410.00&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arr)&quot;/&gt;
&lt;text x=&quot;252.90&quot; y=&quot;402.00&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;TL&lt;/text&gt;
&lt;rect x=&quot;710&quot; y=&quot;80&quot; width=&quot;240&quot; height=&quot;66&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;line x1=&quot;724&quot; y1=&quot;102&quot; x2=&quot;724&quot; y2=&quot;120&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot;/&gt;
&lt;text x=&quot;736&quot; y=&quot;116&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX new-label packet&lt;/text&gt;
&lt;line x1=&quot;724&quot; y1=&quot;126&quot; x2=&quot;724&quot; y2=&quot;144&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot;/&gt;
&lt;text x=&quot;736&quot; y=&quot;140&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;RX other packet&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv">transition_step,label_prev,label_cur,policy_out_n,policy_n,policy_out_rate,u_only_out_n,u_only_n,u_only_out_rate,u_minus_p_out_rate
1128,2,9,0.0,3.0,0.0,1.0,3.0,0.3333333333333333,0.3333333333333333
1404,9,7,0.0,3.0,0.0,1.0,3.0,0.3333333333333333,0.3333333333333333
88,0,6,3.0,3.0,1.0,3.0,3.0,1.0,0.0
91,6,7,3.0,3.0,1.0,3.0,3.0,1.0,0.0
13,1,0,0.0,3.0,0.0,0.0,3.0,0.0,0.0
97,7,11,0.0,3.0,0.0,0.0,3.0,0.0,0.0
120,11,10,0.0,3.0,0.0,0.0,3.0,0.0,0.0
245,10,6,0.0,3.0,0.0,0.0,3.0,0.0,0.0
338,6,7,0.0,3.0,0.0,0.0,3.0,0.0,0.0
362,7,11,0.0,3.0,0.0,0.0,3.0,0.0,0.0
376,11,4,0.0,3.0,0.0,0.0,3.0,0.0,0.0
429,4,10,0.0,3.0,0.0,0.0,3.0,0.0,0.0
605,10,3,0.0,3.0,0.0,0.0,3.0,0.0,0.0
615,3,7,0.0,3.0,0.0,0.0,3.0,0.0,0.0
642,7,3,0.0,3.0,0.0,0.0,3.0,0.0,0.0
680,3,9,0.0,3.0,0.0,0.0,3.0,0.0,0.0
714,9,8,0.0,3.0,0.0,0.0,3.0,0.0,0.0
724,8,7,0.0,3.0,0.0,0.0,3.0,0.0,0.0
775,7,0,0.0,3.0,0.0,0.0,3.0,0.0,0.0
796,0,7,0.0,3.0,0.0,0.0,3.0,0.0,0.0
858,7,4,0.0,3.0,0.0,0.0,3.0,0.0,0.0
963,4,6,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1035,6,5,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1055,5,9,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1087,9,2,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1130,9,4,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1224,4,9,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1282,9,0,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1299,0,9,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1410,7,2,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1414,2,8,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1458,8,6,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1523,6,11,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1581,11,5,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1603,5,1,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1614,1,2,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1627,2,8,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1678,8,1,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1697,1,2,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1701,2,1,0.0,3.0,0.0,0.0,3.0,0.0,0.0
1766,1,3,0.0,3.0,0.0,0.0,3.0,0.0,0.0</file><file path="uccs_d4b_scan90/plots/outage_story_01/per_transition.csv">rx_file,mode,transition_step,label_prev,label_cur,tl_s,outage_gt_tau,arrival_step,offset_ms
rx_trial_004.csv,P,13,1,0,0.007,0,19,-897.0
rx_trial_004.csv,P,88,0,6,15.39,1,246,-897.0
rx_trial_004.csv,P,91,6,7,25.106,1,346,-897.0
rx_trial_004.csv,P,97,7,11,0.077,0,103,-897.0
rx_trial_004.csv,P,120,11,10,0.193,0,127,-897.0
rx_trial_004.csv,P,245,10,6,0.129,0,251,-897.0
rx_trial_004.csv,P,338,6,7,0.406,0,346,-897.0
rx_trial_004.csv,P,362,7,11,0.153,0,367,-897.0
rx_trial_004.csv,P,376,11,4,0.219,0,382,-897.0
rx_trial_004.csv,P,429,4,10,0.358,0,436,-897.0
rx_trial_004.csv,P,605,10,3,0.23,0,609,-897.0
rx_trial_004.csv,P,615,3,7,0.11,0,619,-897.0
rx_trial_004.csv,P,642,7,3,0.141,0,646,-897.0
rx_trial_004.csv,P,680,3,9,0.146,0,683,-897.0
rx_trial_004.csv,P,714,9,8,0.011,0,716,-897.0
rx_trial_004.csv,P,724,8,7,0.242,0,728,-897.0
rx_trial_004.csv,P,775,7,0,0.47,0,781,-897.0
rx_trial_004.csv,P,796,0,7,0.138,0,798,-897.0
rx_trial_004.csv,P,858,7,4,0.35,0,862,-897.0
rx_trial_004.csv,P,963,4,6,0.486,0,968,-897.0
rx_trial_004.csv,P,1035,6,5,0.945,0,1044,-897.0
rx_trial_004.csv,P,1055,5,9,0.167,0,1056,-897.0
rx_trial_004.csv,P,1087,9,2,0.225,0,1088,-897.0
rx_trial_004.csv,P,1128,2,9,0.212,0,1129,-897.0
rx_trial_004.csv,P,1130,9,4,0.211,0,1131,-897.0
rx_trial_004.csv,P,1224,4,9,0.298,0,1225,-897.0
rx_trial_004.csv,P,1282,9,0,0.511,0,1285,-897.0
rx_trial_004.csv,P,1299,0,9,0.369,0,1300,-897.0
rx_trial_004.csv,P,1404,9,7,0.521,0,1406,-897.0
rx_trial_004.csv,P,1410,7,2,0.489,0,1412,-897.0
rx_trial_004.csv,P,1414,2,8,0.401,0,1415,-897.0
rx_trial_004.csv,P,1458,8,6,0.447,0,1459,-897.0
rx_trial_004.csv,P,1523,6,11,0.483,0,1524,-897.0
rx_trial_004.csv,P,1581,11,5,0.735,0,1584,-897.0
rx_trial_004.csv,P,1603,5,1,0.731,0,1605,-897.0
rx_trial_004.csv,P,1614,1,2,0.569,0,1615,-897.0
rx_trial_004.csv,P,1627,2,8,0.542,0,1627,-897.0
rx_trial_004.csv,P,1678,8,1,0.606,0,1679,-897.0
rx_trial_004.csv,P,1697,1,2,0.568,0,1697,-897.0
rx_trial_004.csv,P,1701,2,1,0.677,0,1702,-897.0
rx_trial_004.csv,P,1766,1,3,0.602,0,1766,-897.0
rx_trial_005.csv,U,13,1,0,0.0,0,19,-902.0
rx_trial_005.csv,U,88,0,6,15.39,1,246,-902.0
rx_trial_005.csv,U,91,6,7,24.589,1,341,-902.0
rx_trial_005.csv,U,97,7,11,0.056,0,103,-902.0
rx_trial_005.csv,U,120,11,10,0.19,0,127,-902.0
rx_trial_005.csv,U,245,10,6,0.106,0,251,-902.0
rx_trial_005.csv,U,338,6,7,0.405,0,346,-902.0
rx_trial_005.csv,U,362,7,11,0.045,0,366,-902.0
rx_trial_005.csv,U,376,11,4,0.005,0,380,-902.0
rx_trial_005.csv,U,429,4,10,0.33,0,436,-902.0
rx_trial_005.csv,U,605,10,3,0.203,0,609,-902.0
rx_trial_005.csv,U,615,3,7,0.098,0,619,-902.0
rx_trial_005.csv,U,642,7,3,0.131,0,646,-902.0
rx_trial_005.csv,U,680,3,9,0.112,0,683,-902.0
rx_trial_005.csv,U,714,9,8,0.086,0,716,-902.0
rx_trial_005.csv,U,724,8,7,0.229,0,728,-902.0
rx_trial_005.csv,U,775,7,0,0.351,0,780,-902.0
rx_trial_005.csv,U,796,0,7,0.262,0,800,-902.0
rx_trial_005.csv,U,858,7,4,0.34,0,862,-902.0
rx_trial_005.csv,U,963,4,6,0.949,0,972,-902.0
rx_trial_005.csv,U,1035,6,5,0.452,0,1039,-902.0
rx_trial_005.csv,U,1055,5,9,0.249,0,1057,-902.0
rx_trial_005.csv,U,1087,9,2,0.094,0,1087,-902.0
rx_trial_005.csv,U,1128,2,9,0.18,0,1129,-902.0
rx_trial_005.csv,U,1130,9,4,0.299,0,1132,-902.0
rx_trial_005.csv,U,1224,4,9,0.296,0,1225,-902.0
rx_trial_005.csv,U,1282,9,0,0.501,0,1285,-902.0
rx_trial_005.csv,U,1299,0,9,0.336,0,1300,-902.0
rx_trial_005.csv,U,1404,9,7,0.513,0,1406,-902.0
rx_trial_005.csv,U,1410,7,2,0.363,0,1411,-902.0
rx_trial_005.csv,U,1414,2,8,0.274,0,1414,-902.0
rx_trial_005.csv,U,1458,8,6,0.358,0,1458,-902.0
rx_trial_005.csv,U,1523,6,11,0.464,0,1524,-902.0
rx_trial_005.csv,U,1581,11,5,0.715,0,1584,-902.0
rx_trial_005.csv,U,1603,5,1,0.472,0,1603,-902.0
rx_trial_005.csv,U,1614,1,2,0.525,0,1615,-902.0
rx_trial_005.csv,U,1627,2,8,0.798,0,1630,-902.0
rx_trial_005.csv,U,1678,8,1,0.59,0,1679,-902.0
rx_trial_005.csv,U,1697,1,2,0.674,0,1698,-902.0
rx_trial_005.csv,U,1701,2,1,0.811,0,1704,-902.0
rx_trial_005.csv,U,1766,1,3,0.869,0,1769,-902.0
rx_trial_008.csv,P,13,1,0,0.196,0,21,-861.0
rx_trial_008.csv,P,88,0,6,15.392,1,246,-861.0
rx_trial_008.csv,P,91,6,7,24.605,1,341,-861.0
rx_trial_008.csv,P,97,7,11,0.085,0,103,-861.0
rx_trial_008.csv,P,120,11,10,0.077,0,126,-861.0
rx_trial_008.csv,P,245,10,6,0.232,0,252,-861.0
rx_trial_008.csv,P,338,6,7,0.413,0,346,-861.0
rx_trial_008.csv,P,362,7,11,0.051,0,366,-861.0
rx_trial_008.csv,P,376,11,4,0.024,0,380,-861.0
rx_trial_008.csv,P,429,4,10,0.667,0,439,-861.0
rx_trial_008.csv,P,605,10,3,0.222,0,609,-861.0
rx_trial_008.csv,P,615,3,7,0.115,0,619,-861.0
rx_trial_008.csv,P,642,7,3,0.015,0,644,-861.0
rx_trial_008.csv,P,680,3,9,0.085,0,683,-861.0
rx_trial_008.csv,P,714,9,8,0.245,0,718,-861.0
rx_trial_008.csv,P,724,8,7,0.09,0,726,-861.0
rx_trial_008.csv,P,775,7,0,0.365,0,780,-861.0
rx_trial_008.csv,P,796,0,7,0.202,0,798,-861.0
rx_trial_008.csv,P,858,7,4,0.352,0,862,-861.0
rx_trial_008.csv,P,963,4,6,0.046,0,963,-861.0
rx_trial_008.csv,P,1035,6,5,0.456,0,1039,-861.0
rx_trial_008.csv,P,1055,5,9,0.263,0,1057,-861.0
rx_trial_008.csv,P,1087,9,2,0.109,0,1087,-861.0
rx_trial_008.csv,P,1128,2,9,0.28,0,1129,-861.0
rx_trial_008.csv,P,1130,9,4,0.293,0,1131,-861.0
rx_trial_008.csv,P,1224,4,9,0.322,0,1225,-861.0
rx_trial_008.csv,P,1282,9,0,0.52,0,1285,-861.0
rx_trial_008.csv,P,1299,0,9,0.366,0,1300,-861.0
rx_trial_008.csv,P,1404,9,7,0.519,0,1406,-861.0
rx_trial_008.csv,P,1410,7,2,0.381,0,1411,-861.0
rx_trial_008.csv,P,1414,2,8,0.292,0,1414,-861.0
rx_trial_008.csv,P,1458,8,6,0.524,0,1460,-861.0
rx_trial_008.csv,P,1523,6,11,0.5,0,1524,-861.0
rx_trial_008.csv,P,1581,11,5,0.754,0,1584,-861.0
rx_trial_008.csv,P,1603,5,1,0.596,0,1604,-861.0
rx_trial_008.csv,P,1614,1,2,0.442,0,1614,-861.0
rx_trial_008.csv,P,1627,2,8,0.614,0,1628,-861.0
rx_trial_008.csv,P,1678,8,1,0.61,0,1679,-861.0
rx_trial_008.csv,P,1697,1,2,0.785,0,1699,-861.0
rx_trial_008.csv,P,1701,2,1,0.087,0,1696,-861.0
rx_trial_008.csv,P,1766,1,3,0.593,0,1766,-861.0
rx_trial_009.csv,U,13,1,0,0.106,0,20,-862.0
rx_trial_009.csv,U,88,0,6,15.82,1,251,-862.0
rx_trial_009.csv,U,91,6,7,24.614,1,341,-862.0
rx_trial_009.csv,U,97,7,11,0.171,0,104,-862.0
rx_trial_009.csv,U,120,11,10,0.076,0,126,-862.0
rx_trial_009.csv,U,245,10,6,0.12,0,251,-862.0
rx_trial_009.csv,U,338,6,7,0.428,0,346,-862.0
rx_trial_009.csv,U,362,7,11,0.153,0,367,-862.0
rx_trial_009.csv,U,376,11,4,0.132,0,381,-862.0
rx_trial_009.csv,U,429,4,10,0.336,0,436,-862.0
rx_trial_009.csv,U,605,10,3,0.735,0,614,-862.0
rx_trial_009.csv,U,615,3,7,0.105,0,619,-862.0
rx_trial_009.csv,U,642,7,3,0.139,0,646,-862.0
rx_trial_009.csv,U,680,3,9,0.211,0,684,-862.0
rx_trial_009.csv,U,714,9,8,0.072,0,716,-862.0
rx_trial_009.csv,U,724,8,7,0.112,0,727,-862.0
rx_trial_009.csv,U,775,7,0,0.362,0,780,-862.0
rx_trial_009.csv,U,796,0,7,0.266,0,799,-862.0
rx_trial_009.csv,U,858,7,4,0.338,0,862,-862.0
rx_trial_009.csv,U,963,4,6,0.92,0,972,-862.0
rx_trial_009.csv,U,1035,6,5,0.952,0,1044,-862.0
rx_trial_009.csv,U,1055,5,9,0.16,0,1056,-862.0
rx_trial_009.csv,U,1087,9,2,0.213,0,1088,-862.0
rx_trial_009.csv,U,1128,2,9,9.889,1,1225,-862.0
rx_trial_009.csv,U,1130,9,4,0.15,0,1130,-862.0
rx_trial_009.csv,U,1224,4,9,0.289,0,1225,-862.0
rx_trial_009.csv,U,1282,9,0,0.502,0,1285,-862.0
rx_trial_009.csv,U,1299,0,9,0.235,0,1299,-862.0
rx_trial_009.csv,U,1404,9,7,0.526,0,1406,-862.0
rx_trial_009.csv,U,1410,7,2,0.48,0,1412,-862.0
rx_trial_009.csv,U,1414,2,8,0.382,0,1415,-862.0
rx_trial_009.csv,U,1458,8,6,0.517,0,1460,-862.0
rx_trial_009.csv,U,1523,6,11,0.488,0,1524,-862.0
rx_trial_009.csv,U,1581,11,5,0.716,0,1584,-862.0
rx_trial_009.csv,U,1603,5,1,0.495,0,1603,-862.0
rx_trial_009.csv,U,1614,1,2,0.553,0,1615,-862.0
rx_trial_009.csv,U,1627,2,8,0.629,0,1628,-862.0
rx_trial_009.csv,U,1678,8,1,0.596,0,1679,-862.0
rx_trial_009.csv,U,1697,1,2,0.671,0,1698,-862.0
rx_trial_009.csv,U,1701,2,1,0.057,0,1696,-862.0
rx_trial_009.csv,U,1766,1,3,0.884,0,1769,-862.0
rx_trial_012.csv,P,13,1,0,0.093,0,20,-846.0
rx_trial_012.csv,P,88,0,6,15.378,1,246,-846.0
rx_trial_012.csv,P,91,6,7,24.603,1,341,-846.0
rx_trial_012.csv,P,97,7,11,0.172,0,104,-846.0
rx_trial_012.csv,P,120,11,10,0.284,0,128,-846.0
rx_trial_012.csv,P,245,10,6,0.103,0,251,-846.0
rx_trial_012.csv,P,338,6,7,0.406,0,346,-846.0
rx_trial_012.csv,P,362,7,11,0.058,0,366,-846.0
rx_trial_012.csv,P,376,11,4,0.103,0,381,-846.0
rx_trial_012.csv,P,429,4,10,0.354,0,436,-846.0
rx_trial_012.csv,P,605,10,3,0.707,0,614,-846.0
rx_trial_012.csv,P,615,3,7,0.095,0,619,-846.0
rx_trial_012.csv,P,642,7,3,0.233,0,647,-846.0
rx_trial_012.csv,P,680,3,9,0.2,0,684,-846.0
rx_trial_012.csv,P,714,9,8,0.23,0,718,-846.0
rx_trial_012.csv,P,724,8,7,0.271,0,728,-846.0
rx_trial_012.csv,P,775,7,0,0.352,0,780,-846.0
rx_trial_012.csv,P,796,0,7,0.055,0,798,-846.0
rx_trial_012.csv,P,858,7,4,0.34,0,862,-846.0
rx_trial_012.csv,P,963,4,6,0.473,0,968,-846.0
rx_trial_012.csv,P,1035,6,5,0.452,0,1039,-846.0
rx_trial_012.csv,P,1055,5,9,0.043,0,1055,-846.0
rx_trial_012.csv,P,1087,9,2,0.215,0,1088,-846.0
rx_trial_012.csv,P,1128,2,9,0.226,0,1129,-846.0
rx_trial_012.csv,P,1130,9,4,0.547,0,1134,-846.0
rx_trial_012.csv,P,1224,4,9,0.274,0,1225,-846.0
rx_trial_012.csv,P,1282,9,0,0.52,0,1285,-846.0
rx_trial_012.csv,P,1299,0,9,0.464,0,1301,-846.0
rx_trial_012.csv,P,1404,9,7,0.504,0,1406,-846.0
rx_trial_012.csv,P,1410,7,2,0.365,0,1411,-846.0
rx_trial_012.csv,P,1414,2,8,0.485,0,1416,-846.0
rx_trial_012.csv,P,1458,8,6,0.584,0,1460,-846.0
rx_trial_012.csv,P,1523,6,11,0.474,0,1524,-846.0
rx_trial_012.csv,P,1581,11,5,0.716,0,1584,-846.0
rx_trial_012.csv,P,1603,5,1,0.568,0,1604,-846.0
rx_trial_012.csv,P,1614,1,2,0.612,0,1615,-846.0
rx_trial_012.csv,P,1627,2,8,0.575,0,1628,-846.0
rx_trial_012.csv,P,1678,8,1,0.595,0,1679,-846.0
rx_trial_012.csv,P,1697,1,2,0.66,0,1698,-846.0
rx_trial_012.csv,P,1701,2,1,0.568,0,1701,-846.0
rx_trial_012.csv,P,1766,1,3,0.577,0,1766,-846.0
rx_trial_013.csv,U,13,1,0,0.1935,0,21,-839.5
rx_trial_013.csv,U,88,0,6,15.3835,1,246,-839.5
rx_trial_013.csv,U,91,6,7,24.5925,1,341,-839.5
rx_trial_013.csv,U,97,7,11,0.2755,0,105,-839.5
rx_trial_013.csv,U,120,11,10,0.1785,0,127,-839.5
rx_trial_013.csv,U,245,10,6,0.2055,0,252,-839.5
rx_trial_013.csv,U,338,6,7,0.8515,0,351,-839.5
rx_trial_013.csv,U,362,7,11,0.1445,0,367,-839.5
rx_trial_013.csv,U,376,11,4,0.0065,0,380,-839.5
rx_trial_013.csv,U,429,4,10,0.3245,0,436,-839.5
rx_trial_013.csv,U,605,10,3,0.1915,0,609,-839.5
rx_trial_013.csv,U,615,3,7,0.0925,0,619,-839.5
rx_trial_013.csv,U,642,7,3,0.0105,0,645,-839.5
rx_trial_013.csv,U,680,3,9,0.0915,0,683,-839.5
rx_trial_013.csv,U,714,9,8,0.0505,0,716,-839.5
rx_trial_013.csv,U,724,8,7,0.1245,0,727,-839.5
rx_trial_013.csv,U,775,7,0,0.3445,0,780,-839.5
rx_trial_013.csv,U,796,0,7,0.0075,0,797,-839.5
rx_trial_013.csv,U,858,7,4,0.3235,0,862,-839.5
rx_trial_013.csv,U,963,4,6,0.9235,0,972,-839.5
rx_trial_013.csv,U,1035,6,5,0.4245,0,1039,-839.5
rx_trial_013.csv,U,1055,5,9,0.0275,0,1055,-839.5
rx_trial_013.csv,U,1087,9,2,0.0965,0,1087,-839.5
rx_trial_013.csv,U,1128,2,9,0.2015,0,1129,-839.5
rx_trial_013.csv,U,1130,9,4,0.2115,0,1131,-839.5
rx_trial_013.csv,U,1224,4,9,0.2885,0,1225,-839.5
rx_trial_013.csv,U,1282,9,0,0.5035,0,1285,-839.5
rx_trial_013.csv,U,1299,0,9,0.4405,0,1301,-839.5
rx_trial_013.csv,U,1404,9,7,inf,1,,-839.5
rx_trial_013.csv,U,1410,7,2,0.3515,0,1411,-839.5
rx_trial_013.csv,U,1414,2,8,0.4845,0,1416,-839.5
rx_trial_013.csv,U,1458,8,6,0.3745,0,1458,-839.5
rx_trial_013.csv,U,1523,6,11,0.9505,0,1529,-839.5
rx_trial_013.csv,U,1581,11,5,0.7045,0,1584,-839.5
rx_trial_013.csv,U,1603,5,1,0.5935,0,1604,-839.5
rx_trial_013.csv,U,1614,1,2,0.4355,0,1614,-839.5
rx_trial_013.csv,U,1627,2,8,0.4925,0,1627,-839.5
rx_trial_013.csv,U,1678,8,1,0.5865,0,1679,-839.5
rx_trial_013.csv,U,1697,1,2,0.7755,0,1699,-839.5
rx_trial_013.csv,U,1701,2,1,0.0475,0,1696,-839.5
rx_trial_013.csv,U,1766,1,3,0.8745,0,1769,-839.5</file><file path="uccs_d4b_scan90/plots/outage_story_01/selected_event.json">{
  &quot;transition_step&quot;: 1128,
  &quot;new_label&quot;: 9,
  &quot;tau_s&quot;: 1.0,
  &quot;window_s&quot;: 3.0,
  &quot;u_only_rx_file&quot;: &quot;rx_trial_009.csv&quot;,
  &quot;u_only_tl_s&quot;: 9.889,
  &quot;policy_rx_file&quot;: &quot;rx_trial_004.csv&quot;,
  &quot;policy_tl_s&quot;: 0.212
}</file><file path="uccs_d4b_scan90/plots/pout_tail_01/delta_pout_contrib.csv">k,transition_step,delta_out_rate,cum_frac_of_positive_delta
1,1128,0.3333333333333333,0.5
2,1404,0.3333333333333333,1.0</file><file path="uccs_d4b_scan90/plots/pout_tail_01/fig_delta_pout_cum.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;520&quot; viewBox=&quot;0 0 920 520&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;520&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B: cumulative share of positive ΔPout explained by top-K transitions&lt;/text&gt;
&lt;rect x=&quot;70&quot; y=&quot;70&quot; width=&quot;820&quot; height=&quot;390&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;70&quot; y1=&quot;460.00&quot; x2=&quot;890&quot; y2=&quot;460.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;464.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.00&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;382.00&quot; x2=&quot;890&quot; y2=&quot;382.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;386.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.20&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;304.00&quot; x2=&quot;890&quot; y2=&quot;304.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;308.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.40&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;226.00&quot; x2=&quot;890&quot; y2=&quot;226.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;230.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.60&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;148.00&quot; x2=&quot;890&quot; y2=&quot;148.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;152.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.80&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;70.00&quot; x2=&quot;890&quot; y2=&quot;70.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;74.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.00&lt;/text&gt;
&lt;line x1=&quot;70.00&quot; y1=&quot;70&quot; x2=&quot;70.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;70.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1&lt;/text&gt;
&lt;line x1=&quot;234.00&quot; y1=&quot;70&quot; x2=&quot;234.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;234.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1&lt;/text&gt;
&lt;line x1=&quot;398.00&quot; y1=&quot;70&quot; x2=&quot;398.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;398.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1&lt;/text&gt;
&lt;line x1=&quot;562.00&quot; y1=&quot;70&quot; x2=&quot;562.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;562.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2&lt;/text&gt;
&lt;line x1=&quot;726.00&quot; y1=&quot;70&quot; x2=&quot;726.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;726.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2&lt;/text&gt;
&lt;line x1=&quot;890.00&quot; y1=&quot;70&quot; x2=&quot;890.00&quot; y2=&quot;460&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;890.00&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2&lt;/text&gt;
&lt;path d=&quot;M 70.00 265.00 L 890.00 70.00&quot; fill=&quot;none&quot; stroke=&quot;#2563eb&quot; stroke-width=&quot;2.5&quot;/&gt;
&lt;text x=&quot;480.0&quot; y=&quot;500&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;top-K transitions (sorted by ΔPout contribution)&lt;/text&gt;
&lt;text x=&quot;18&quot; y=&quot;265.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 18 265.0)&quot;&gt;cumulative fraction of positive ΔPout&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/pout_tail_01/fig_outage_count_hist.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;920&quot; height=&quot;520&quot; viewBox=&quot;0 0 920 520&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;920&quot; height=&quot;520&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;460.0&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B: outage-count distribution per trial (TL&amp;gt;1.0s)&lt;/text&gt;
&lt;rect x=&quot;70&quot; y=&quot;70&quot; width=&quot;820&quot; height=&quot;390&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;70&quot; y1=&quot;460.00&quot; x2=&quot;890&quot; y2=&quot;460.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;464.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;382.00&quot; x2=&quot;890&quot; y2=&quot;382.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;386.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;304.00&quot; x2=&quot;890&quot; y2=&quot;304.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;308.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;226.00&quot; x2=&quot;890&quot; y2=&quot;226.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;230.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;148.00&quot; x2=&quot;890&quot; y2=&quot;148.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;152.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2&lt;/text&gt;
&lt;line x1=&quot;70&quot; y1=&quot;70.00&quot; x2=&quot;890&quot; y2=&quot;70.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;62&quot; y=&quot;74.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;3&lt;/text&gt;
&lt;rect x=&quot;98.75&quot; y=&quot;460.00&quot; width=&quot;71.75&quot; height=&quot;0.00&quot; fill=&quot;#2563eb&quot; opacity=&quot;0.75&quot;/&gt;
&lt;rect x=&quot;174.50&quot; y=&quot;460.00&quot; width=&quot;71.75&quot; height=&quot;0.00&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.75&quot;/&gt;
&lt;text x=&quot;172.50&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0&lt;/text&gt;
&lt;rect x=&quot;303.75&quot; y=&quot;460.00&quot; width=&quot;71.75&quot; height=&quot;0.00&quot; fill=&quot;#2563eb&quot; opacity=&quot;0.75&quot;/&gt;
&lt;rect x=&quot;379.50&quot; y=&quot;460.00&quot; width=&quot;71.75&quot; height=&quot;0.00&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.75&quot;/&gt;
&lt;text x=&quot;377.50&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1&lt;/text&gt;
&lt;rect x=&quot;508.75&quot; y=&quot;70.00&quot; width=&quot;71.75&quot; height=&quot;390.00&quot; fill=&quot;#2563eb&quot; opacity=&quot;0.75&quot;/&gt;
&lt;rect x=&quot;584.50&quot; y=&quot;330.00&quot; width=&quot;71.75&quot; height=&quot;130.00&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.75&quot;/&gt;
&lt;text x=&quot;582.50&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;2&lt;/text&gt;
&lt;rect x=&quot;713.75&quot; y=&quot;460.00&quot; width=&quot;71.75&quot; height=&quot;0.00&quot; fill=&quot;#2563eb&quot; opacity=&quot;0.75&quot;/&gt;
&lt;rect x=&quot;789.50&quot; y=&quot;200.00&quot; width=&quot;71.75&quot; height=&quot;260.00&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.75&quot;/&gt;
&lt;text x=&quot;787.50&quot; y=&quot;486&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;3&lt;/text&gt;
&lt;rect x=&quot;670&quot; y=&quot;80&quot; width=&quot;210&quot; height=&quot;54&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;rect x=&quot;682&quot; y=&quot;94&quot; width=&quot;14&quot; height=&quot;14&quot; fill=&quot;#2563eb&quot; opacity=&quot;0.75&quot;/&gt;
&lt;text x=&quot;704&quot; y=&quot;106&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;Policy (U+CCS)&lt;/text&gt;
&lt;rect x=&quot;682&quot; y=&quot;114&quot; width=&quot;14&quot; height=&quot;14&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.75&quot;/&gt;
&lt;text x=&quot;704&quot; y=&quot;126&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;U-only (CCS-off)&lt;/text&gt;
&lt;text x=&quot;480.0&quot; y=&quot;500&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;outage count per trial (TL&amp;gt;1s), binned&lt;/text&gt;
&lt;text x=&quot;18&quot; y=&quot;265.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 18 265.0)&quot;&gt;# trials&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/pout_tail_01/outage_counts_by_trial.csv">rx_file,mode,n_transitions,n_outages,pout_est
rx_trial_004.csv,P,41,2,0.04878048780487805
rx_trial_005.csv,U,41,2,0.04878048780487805
rx_trial_008.csv,P,41,2,0.04878048780487805
rx_trial_009.csv,U,41,3,0.07317073170731707
rx_trial_012.csv,P,41,2,0.04878048780487805
rx_trial_013.csv,U,41,3,0.07317073170731707</file><file path="uccs_d4b_scan90/plots/pout_tail_01/pout_tail_decomposition.md"># D4B Pout tail decomposition (TL&gt;1.0s)

- input: `uccs_d4b_scan90/plots/outage_story_01/per_transition.csv` / `uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv`
- output dir: `uccs_d4b_scan90/plots/pout_tail_01`

## Trial-level outage counts

- Policy (U+CCS): mean pout_est=0.0488 (n_trials=3)
- U-only (CCS-off): mean pout_est=0.0650 (n_trials=3)

## Concentration across transitions

- #transitions with positive ΔPout (U-only worse): 2 / 41 total transitions
- top-1 explains 50.0% of positive ΔPout; top-2 explains 100.0%
- see `fig_delta_pout_cum.svg` + `delta_pout_contrib.csv`

## Figures

- `fig_outage_count_hist.svg`: outage-count distribution per trial
- `fig_delta_pout_cum.svg`: cumulative ΔPout concentration curve (top-K transitions)</file><file path="uccs_d4b_scan90/plots/alpha_vs_pout_overview.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;980&quot; height=&quot;620&quot; viewBox=&quot;0 0 980 620&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;980&quot; height=&quot;620&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;490.0&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;α-normalized power vs pout_1s (S4): CCS improves QoS at same α&lt;/text&gt;
&lt;rect x=&quot;90&quot; y=&quot;70&quot; width=&quot;860&quot; height=&quot;470&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;90.00&quot; y1=&quot;70&quot; x2=&quot;90.00&quot; y2=&quot;540&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;90.00&quot; y=&quot;568&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;-0.05&lt;/text&gt;
&lt;line x1=&quot;262.00&quot; y1=&quot;70&quot; x2=&quot;262.00&quot; y2=&quot;540&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;262.00&quot; y=&quot;568&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.18&lt;/text&gt;
&lt;line x1=&quot;434.00&quot; y1=&quot;70&quot; x2=&quot;434.00&quot; y2=&quot;540&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;434.00&quot; y=&quot;568&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.41&lt;/text&gt;
&lt;line x1=&quot;606.00&quot; y1=&quot;70&quot; x2=&quot;606.00&quot; y2=&quot;540&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;606.00&quot; y=&quot;568&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.65&lt;/text&gt;
&lt;line x1=&quot;778.00&quot; y1=&quot;70&quot; x2=&quot;778.00&quot; y2=&quot;540&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;778.00&quot; y=&quot;568&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.88&lt;/text&gt;
&lt;line x1=&quot;950.00&quot; y1=&quot;70&quot; x2=&quot;950.00&quot; y2=&quot;540&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;950.00&quot; y=&quot;568&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;1.11&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;540.00&quot; x2=&quot;950&quot; y2=&quot;540.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;544.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.007&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;446.00&quot; x2=&quot;950&quot; y2=&quot;446.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;450.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.081&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;352.00&quot; x2=&quot;950&quot; y2=&quot;352.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;356.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.154&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;258.00&quot; x2=&quot;950&quot; y2=&quot;258.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;262.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.228&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;164.00&quot; x2=&quot;950&quot; y2=&quot;164.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;168.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.302&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;70.00&quot; x2=&quot;950&quot; y2=&quot;70.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;74.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.376&lt;/text&gt;
&lt;text x=&quot;520.0&quot; y=&quot;594&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;α=(P−P500)/(P100−P500)  (normalized power allocation)&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;305.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 305.0)&quot;&gt;pout_1s (lower=better)&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;421.41&quot; x2=&quot;950&quot; y2=&quot;421.41&quot; stroke=&quot;#9ca3af&quot; stroke-width=&quot;2&quot; stroke-dasharray=&quot;6 4&quot;/&gt;
&lt;text x=&quot;940&quot; y=&quot;413.41&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#6b7280&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;δ=0.1&lt;/text&gt;
&lt;line x1=&quot;868.97&quot; y1=&quot;445.22&quot; x2=&quot;868.97&quot; y2=&quot;445.22&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;868.97&quot; y1=&quot;463.15&quot; x2=&quot;868.97&quot; y2=&quot;427.29&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;rect x=&quot;862.97&quot; y=&quot;439.22&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;878.97&quot; y=&quot;435.22&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 fixed100&lt;/text&gt;
&lt;line x1=&quot;127.09&quot; y1=&quot;383.10&quot; x2=&quot;127.09&quot; y2=&quot;383.10&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;127.09&quot; y1=&quot;418.96&quot; x2=&quot;127.09&quot; y2=&quot;347.23&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;rect x=&quot;121.09&quot; y=&quot;377.10&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;137.09&quot; y=&quot;373.10&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 fixed500&lt;/text&gt;
&lt;line x1=&quot;573.82&quot; y1=&quot;486.63&quot; x2=&quot;600.08&quot; y2=&quot;486.63&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;586.95&quot; y1=&quot;486.63&quot; x2=&quot;586.95&quot; y2=&quot;486.63&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;circle cx=&quot;586.95&quot; cy=&quot;486.63&quot; r=&quot;6&quot; fill=&quot;#10b981&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;596.95&quot; y=&quot;476.63&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 policy (U+CCS)&lt;/text&gt;
&lt;line x1=&quot;574.23&quot; y1=&quot;465.93&quot; x2=&quot;601.36&quot; y2=&quot;465.93&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;587.80&quot; y1=&quot;483.86&quot; x2=&quot;587.80&quot; y2=&quot;447.99&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;587.80,458.93 581.30,471.93 594.30,471.93&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;597.80&quot; y=&quot;455.93&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 CCS-off (U-only)&lt;/text&gt;
&lt;line x1=&quot;547.08&quot; y1=&quot;424.51&quot; x2=&quot;630.18&quot; y2=&quot;424.51&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;588.63&quot; y1=&quot;455.57&quot; x2=&quot;588.63&quot; y2=&quot;393.45&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;588.63,417.51 582.13,430.51 595.13,430.51&quot; fill=&quot;#10b981&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;598.63&quot; y=&quot;414.51&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 policy (D4)&lt;/text&gt;
&lt;line x1=&quot;819.40&quot; y1=&quot;486.63&quot; x2=&quot;912.91&quot; y2=&quot;486.63&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;866.15&quot; y1=&quot;486.63&quot; x2=&quot;866.15&quot; y2=&quot;486.63&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;866.15,479.63 859.65,492.63 872.65,492.63&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;876.15&quot; y=&quot;476.63&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 U-shuf&lt;/text&gt;
&lt;line x1=&quot;868.97&quot; y1=&quot;465.93&quot; x2=&quot;868.97&quot; y2=&quot;465.93&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;868.97&quot; y1=&quot;501.79&quot; x2=&quot;868.97&quot; y2=&quot;430.06&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;868.97,458.93 861.97,465.93 868.97,472.93 875.97,465.93&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;878.97&quot; y=&quot;455.93&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan70 fixed100&lt;/text&gt;
&lt;line x1=&quot;127.09&quot; y1=&quot;186.37&quot; x2=&quot;127.09&quot; y2=&quot;186.37&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;127.09&quot; y1=&quot;264.54&quot; x2=&quot;127.09&quot; y2=&quot;108.21&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;127.09,179.37 120.09,186.37 127.09,193.37 134.09,186.37&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;137.09&quot; y=&quot;176.37&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan70 fixed500&lt;/text&gt;
&lt;line x1=&quot;571.53&quot; y1=&quot;434.87&quot; x2=&quot;600.21&quot; y2=&quot;434.87&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;585.87&quot; y1=&quot;482.31&quot; x2=&quot;585.87&quot; y2=&quot;387.42&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;585.87,427.87 578.87,434.87 585.87,441.87 592.87,434.87&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;595.87&quot; y=&quot;424.87&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan70 policy&lt;/text&gt;
&lt;rect x=&quot;94&quot; y=&quot;74&quot; width=&quot;360&quot; height=&quot;138&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;rect x=&quot;106.00&quot; y=&quot;92.00&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;103&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed100/fixed500 (each run)&lt;/text&gt;
&lt;circle cx=&quot;112.00&quot; cy=&quot;128.00&quot; r=&quot;6&quot; fill=&quot;#10b981&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;133&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;policy (U+CCS)&lt;/text&gt;
&lt;polygon points=&quot;112.00,151.00 105.50,164.00 118.50,164.00&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;163&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;ablation (U-shuf / CCS-off)&lt;/text&gt;
&lt;polygon points=&quot;112.00,181.00 105.00,188.00 112.00,195.00 119.00,188.00&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;193&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan70 points&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/d4b_01_power_vs_pout.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;900&quot; height=&quot;600&quot; viewBox=&quot;0 0 900 600&quot;&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;900&quot; height=&quot;600&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;450.0&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;D4B scan90 (S4): CCS-off ablation&lt;/text&gt;
&lt;rect x=&quot;90&quot; y=&quot;60&quot; width=&quot;780&quot; height=&quot;470&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;90.00&quot; y1=&quot;60&quot; x2=&quot;90.00&quot; y2=&quot;530&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;90.00&quot; y=&quot;554&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;186.2&lt;/text&gt;
&lt;line x1=&quot;246.00&quot; y1=&quot;60&quot; x2=&quot;246.00&quot; y2=&quot;530&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;246.00&quot; y=&quot;554&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;191.0&lt;/text&gt;
&lt;line x1=&quot;402.00&quot; y1=&quot;60&quot; x2=&quot;402.00&quot; y2=&quot;530&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;402.00&quot; y=&quot;554&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;195.9&lt;/text&gt;
&lt;line x1=&quot;558.00&quot; y1=&quot;60&quot; x2=&quot;558.00&quot; y2=&quot;530&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;558.00&quot; y=&quot;554&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;200.7&lt;/text&gt;
&lt;line x1=&quot;714.00&quot; y1=&quot;60&quot; x2=&quot;714.00&quot; y2=&quot;530&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;714.00&quot; y=&quot;554&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;205.6&lt;/text&gt;
&lt;line x1=&quot;870.00&quot; y1=&quot;60&quot; x2=&quot;870.00&quot; y2=&quot;530&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;870.00&quot; y=&quot;554&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;210.4&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;530.00&quot; x2=&quot;870&quot; y2=&quot;530.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;534.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.036&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;436.00&quot; x2=&quot;870&quot; y2=&quot;436.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;440.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.063&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;342.00&quot; x2=&quot;870&quot; y2=&quot;342.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;346.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.090&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;248.00&quot; x2=&quot;870&quot; y2=&quot;248.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;252.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.117&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;154.00&quot; x2=&quot;870&quot; y2=&quot;154.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;158.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.144&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;60.00&quot; x2=&quot;870&quot; y2=&quot;60.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;64.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.171&lt;/text&gt;
&lt;text x=&quot;480.0&quot; y=&quot;576&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;avg_power_mW (mean±std)&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;295.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 295.0)&quot;&gt;pout_1s (mean±std)&lt;/text&gt;
&lt;line x1=&quot;784.64&quot; y1=&quot;371.91&quot; x2=&quot;816.21&quot; y2=&quot;371.91&quot; stroke=&quot;#ef4444&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;800.42&quot; y1=&quot;323.15&quot; x2=&quot;800.42&quot; y2=&quot;420.67&quot; stroke=&quot;#ef4444&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;circle cx=&quot;800.42&quot; cy=&quot;371.91&quot; r=&quot;6&quot; fill=&quot;#ef4444&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;810.42&quot; y=&quot;361.91&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed100 (adv=1796, share100_rx=1.000, share100_mix=NA)&lt;/text&gt;
&lt;line x1=&quot;143.79&quot; y1=&quot;203.00&quot; x2=&quot;162.82&quot; y2=&quot;203.00&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;153.31&quot; y1=&quot;105.48&quot; x2=&quot;153.31&quot; y2=&quot;300.52&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;circle cx=&quot;153.31&quot; cy=&quot;203.00&quot; r=&quot;6&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;163.31&quot; y=&quot;193.00&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed500 (adv=359, share100_rx=0.000, share100_mix=NA)&lt;/text&gt;
&lt;line x1=&quot;549.70&quot; y1=&quot;484.52&quot; x2=&quot;559.15&quot; y2=&quot;484.52&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;554.42&quot; y1=&quot;484.52&quot; x2=&quot;554.42&quot; y2=&quot;484.52&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;circle cx=&quot;554.42&quot; cy=&quot;484.52&quot; r=&quot;6&quot; fill=&quot;#10b981&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;564.42&quot; y=&quot;474.52&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;policy (adv=1215, share100_rx=0.434, share100_mix=0.620)&lt;/text&gt;
&lt;line x1=&quot;549.60&quot; y1=&quot;428.21&quot; x2=&quot;560.72&quot; y2=&quot;428.21&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;555.16&quot; y1=&quot;379.45&quot; x2=&quot;555.16&quot; y2=&quot;476.97&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;circle cx=&quot;555.16&quot; cy=&quot;428.21&quot; r=&quot;6&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;565.16&quot; y=&quot;418.21&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;ablation_ccs_off (adv=1227, share100_rx=0.429, share100_mix=0.621)&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/plots/role_separation_d3_d4_d4b.svg">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;980&quot; height=&quot;640&quot; viewBox=&quot;0 0 980 640&quot;&gt;
&lt;defs&gt;&lt;marker id=&quot;arrow&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;9&quot; refY=&quot;5&quot; markerWidth=&quot;7&quot; markerHeight=&quot;7&quot; orient=&quot;auto-start-reverse&quot;&gt;&lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; fill=&quot;#111827&quot;/&gt;&lt;/marker&gt;&lt;/defs&gt;
&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;980&quot; height=&quot;640&quot; fill=&quot;#ffffff&quot;/&gt;
&lt;text x=&quot;490.0&quot; y=&quot;38&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;Role separation: U vs CCS vs robustness (S4)&lt;/text&gt;
&lt;rect x=&quot;90&quot; y=&quot;70&quot; width=&quot;860&quot; height=&quot;490&quot; fill=&quot;none&quot; stroke=&quot;#111827&quot; stroke-width=&quot;1.2&quot;/&gt;
&lt;line x1=&quot;90.00&quot; y1=&quot;70&quot; x2=&quot;90.00&quot; y2=&quot;560&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;90.00&quot; y=&quot;588&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;186.0&lt;/text&gt;
&lt;line x1=&quot;262.00&quot; y1=&quot;70&quot; x2=&quot;262.00&quot; y2=&quot;560&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;262.00&quot; y=&quot;588&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;191.3&lt;/text&gt;
&lt;line x1=&quot;434.00&quot; y1=&quot;70&quot; x2=&quot;434.00&quot; y2=&quot;560&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;434.00&quot; y=&quot;588&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;196.5&lt;/text&gt;
&lt;line x1=&quot;606.00&quot; y1=&quot;70&quot; x2=&quot;606.00&quot; y2=&quot;560&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;606.00&quot; y=&quot;588&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;201.8&lt;/text&gt;
&lt;line x1=&quot;778.00&quot; y1=&quot;70&quot; x2=&quot;778.00&quot; y2=&quot;560&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;778.00&quot; y=&quot;588&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;207.0&lt;/text&gt;
&lt;line x1=&quot;950.00&quot; y1=&quot;70&quot; x2=&quot;950.00&quot; y2=&quot;560&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;950.00&quot; y=&quot;588&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;212.2&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;560.00&quot; x2=&quot;950&quot; y2=&quot;560.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;564.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.000&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;462.00&quot; x2=&quot;950&quot; y2=&quot;462.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;466.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.080&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;364.00&quot; x2=&quot;950&quot; y2=&quot;364.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;368.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.161&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;266.00&quot; x2=&quot;950&quot; y2=&quot;266.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;270.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.241&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;168.00&quot; x2=&quot;950&quot; y2=&quot;168.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;172.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.321&lt;/text&gt;
&lt;line x1=&quot;90&quot; y1=&quot;70.00&quot; x2=&quot;950&quot; y2=&quot;70.00&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;text x=&quot;80&quot; y=&quot;74.00&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;0.402&lt;/text&gt;
&lt;text x=&quot;520.0&quot; y=&quot;614&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;avg_power_mW (lower=better)&lt;/text&gt;
&lt;text x=&quot;22&quot; y=&quot;315.0&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 315.0)&quot;&gt;pout_1s (lower=better)&lt;/text&gt;
&lt;line x1=&quot;814.85&quot; y1=&quot;500.48&quot; x2=&quot;569.01&quot; y2=&quot;500.48&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arrow)&quot; opacity=&quot;0.85&quot;/&gt;
&lt;text x=&quot;697.93&quot; y=&quot;494.48&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;U effect&lt;/text&gt;
&lt;line x1=&quot;569.76&quot; y1=&quot;480.64&quot; x2=&quot;569.01&quot; y2=&quot;500.48&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arrow)&quot; opacity=&quot;0.85&quot;/&gt;
&lt;text x=&quot;575.39&quot; y=&quot;484.56&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;CCS effect&lt;/text&gt;
&lt;line x1=&quot;159.04&quot; y1=&quot;401.27&quot; x2=&quot;204.74&quot; y2=&quot;212.78&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arrow)&quot; opacity=&quot;0.85&quot;/&gt;
&lt;text x=&quot;187.89&quot; y=&quot;301.03&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;worse RX (scan70)&lt;/text&gt;
&lt;line x1=&quot;569.01&quot; y1=&quot;500.48&quot; x2=&quot;618.00&quot; y2=&quot;450.87&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#arrow)&quot; opacity=&quot;0.85&quot;/&gt;
&lt;text x=&quot;599.50&quot; y=&quot;469.68&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;robustness&lt;/text&gt;
&lt;line x1=&quot;804.31&quot; y1=&quot;460.79&quot; x2=&quot;836.57&quot; y2=&quot;460.79&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;820.44&quot; y1=&quot;477.98&quot; x2=&quot;820.44&quot; y2=&quot;443.61&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;rect x=&quot;814.44&quot; y=&quot;454.79&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;830.44&quot; y=&quot;450.79&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed100 (scan90)&lt;/text&gt;
&lt;line x1=&quot;149.31&quot; y1=&quot;401.27&quot; x2=&quot;168.76&quot; y2=&quot;401.27&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;159.04&quot; y1=&quot;435.64&quot; x2=&quot;159.04&quot; y2=&quot;366.91&quot; stroke=&quot;#3b82f6&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;rect x=&quot;153.04&quot; y=&quot;395.27&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;169.04&quot; y=&quot;391.27&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed500 (scan90)&lt;/text&gt;
&lt;line x1=&quot;564.18&quot; y1=&quot;500.48&quot; x2=&quot;573.84&quot; y2=&quot;500.48&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;569.01&quot; y1=&quot;500.48&quot; x2=&quot;569.01&quot; y2=&quot;500.48&quot; stroke=&quot;#10b981&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;circle cx=&quot;569.01&quot; cy=&quot;500.48&quot; r=&quot;6&quot; fill=&quot;#10b981&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;579.01&quot; y=&quot;490.48&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;policy U+CCS (scan90)&lt;/text&gt;
&lt;line x1=&quot;806.24&quot; y1=&quot;500.48&quot; x2=&quot;823.46&quot; y2=&quot;500.48&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;814.85&quot; y1=&quot;500.48&quot; x2=&quot;814.85&quot; y2=&quot;500.48&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;814.85,493.48 808.35,506.48 821.35,506.48&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;824.85&quot; y=&quot;490.48&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;ablation U-shuf (scan90)&lt;/text&gt;
&lt;line x1=&quot;564.08&quot; y1=&quot;480.64&quot; x2=&quot;575.45&quot; y2=&quot;480.64&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;569.76&quot; y1=&quot;497.82&quot; x2=&quot;569.76&quot; y2=&quot;463.45&quot; stroke=&quot;#f59e0b&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;569.76,473.64 563.26,486.64 576.26,486.64&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;579.76&quot; y=&quot;470.64&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;ablation CCS-off (U-only)&lt;/text&gt;
&lt;line x1=&quot;855.33&quot; y1=&quot;480.64&quot; x2=&quot;890.69&quot; y2=&quot;480.64&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;873.01&quot; y1=&quot;515.00&quot; x2=&quot;873.01&quot; y2=&quot;446.27&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;873.01,473.64 866.01,480.64 873.01,487.64 880.01,480.64&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;883.01&quot; y=&quot;470.64&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed100 (scan70)&lt;/text&gt;
&lt;line x1=&quot;189.20&quot; y1=&quot;212.78&quot; x2=&quot;220.28&quot; y2=&quot;212.78&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;204.74&quot; y1=&quot;287.68&quot; x2=&quot;204.74&quot; y2=&quot;137.88&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;204.74,205.78 197.74,212.78 204.74,219.78 211.74,212.78&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;214.74&quot; y=&quot;202.78&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;fixed500 (scan70)&lt;/text&gt;
&lt;line x1=&quot;614.52&quot; y1=&quot;450.87&quot; x2=&quot;621.48&quot; y2=&quot;450.87&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;line x1=&quot;618.00&quot; y1=&quot;496.34&quot; x2=&quot;618.00&quot; y2=&quot;405.41&quot; stroke=&quot;#111827&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;
&lt;polygon points=&quot;618.00,443.87 611.00,450.87 618.00,457.87 625.00,450.87&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;628.00&quot; y=&quot;440.87&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;policy U+CCS (scan70)&lt;/text&gt;
&lt;rect x=&quot;94&quot; y=&quot;74&quot; width=&quot;360&quot; height=&quot;128&quot; fill=&quot;#ffffff&quot; stroke=&quot;#e5e7eb&quot; stroke-width=&quot;1&quot;/&gt;
&lt;rect x=&quot;106.00&quot; y=&quot;92.00&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;#3b82f6&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;103&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 fixed&lt;/text&gt;
&lt;circle cx=&quot;112.00&quot; cy=&quot;126.00&quot; r=&quot;6&quot; fill=&quot;#10b981&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;131&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 policy&lt;/text&gt;
&lt;polygon points=&quot;112.00,147.00 105.50,160.00 118.50,160.00&quot; fill=&quot;#f59e0b&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;159&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan90 ablation&lt;/text&gt;
&lt;polygon points=&quot;112.00,175.00 105.00,182.00 112.00,189.00 119.00,182.00&quot; fill=&quot;#111827&quot; opacity=&quot;0.95&quot;/&gt;
&lt;text x=&quot;128&quot; y=&quot;187&quot; font-size=&quot;12&quot; fill=&quot;#111827&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;scan70 (worse RX)&lt;/text&gt;
&lt;/svg&gt;</file><file path="uccs_d4b_scan90/src/rx/RX_UCCS_D4B_SCAN90/RX_UCCS_D4B_SCAN90.ino">// RX_UCCS_D4B_SCAN90.ino (uccs_d4b_scan90)
// Receive TX_UCCS_D4B packets (MFD &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;) and log to SD.
// - SYNC gate: TX GPIO25 -&gt; RX GPIO26.
// - NimBLE passive scan with scan90% (interval=100ms, window=90ms).

#include &lt;Arduino.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NimBLEDevice.h&gt;
#include &lt;math.h&gt;

static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26; // TX GPIO25 -&gt; RX GPIO26

// scan90
static const float SCAN_INTERVAL_MS = 100.0f;
static const float SCAN_WINDOW_MS   = 90.0f;

static const uint32_t SESSION_TIMEOUT_MS = 1200000;
static const uint32_t SYNC_LOW_DEBOUNCE_MS = 100;
static const uint32_t START_LEVEL_HOLD_MS = 200;

static inline uint16_t ms_to_0p625(float ms){ return (uint16_t)lroundf(ms / 0.625f); }

static const uint16_t RX_BUF_SIZE = 512;
static const uint32_t FLUSH_INTERVAL_MS = 500;

struct RxEntry {
  uint32_t ms;
  int8_t   rssi;
  uint16_t seq;
  char     label[24];
  char     addr[18];
  char     mfd[48];
};

static RxEntry rxBuf[RX_BUF_SIZE];
static volatile uint16_t rxHead = 0;
static uint16_t rxTail = 0;
static uint32_t bufOverflow = 0;
static uint32_t lastFlushMs = 0;

static bool trial = false;
static uint32_t t0Ms = 0;
static uint32_t rxCount = 0;
static uint32_t syncLowSince = 0;
static uint32_t syncHighSince = 0;

static File f;
static const char FW_TAG[] = &quot;RX_UCCS_D4B_SCAN90&quot;;
static bool condSeen = false;
static bool condWritten = false;
static char condLabel[24] = {0};

static bool parseMFD(const std::string&amp; s, uint16_t&amp; seq, std::string&amp; label) {
  size_t usPos = s.find(&apos;_&apos;);
  if (usPos == std::string::npos || usPos &lt; 1) return false;
  std::string seqStr = s.substr(0, usPos);
  label = s.substr(usPos + 1);
  if (label.empty()) return false;
  char* endp = nullptr;
  unsigned long v = strtoul(seqStr.c_str(), &amp;endp, 10);
  if (endp == seqStr.c_str() || v &gt; 65535UL) return false;
  seq = static_cast&lt;uint16_t&gt;(v);
  return true;
}

static String nextPath() {
  SD.mkdir(&quot;/logs&quot;);
  char p[64];
  for (uint32_t id = 1;; ++id) {
    snprintf(p, sizeof(p), &quot;/logs/rx_trial_%03lu.csv&quot;, (unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

static void flushBuffer() {
  if (!f) return;
  if (!condWritten &amp;&amp; condSeen) {
    f.printf(&quot;# condition_label=%s\r\n&quot;, condLabel);
    condWritten = true;
  }
  uint16_t head = rxHead;
  bool wrote = false;
  while (rxTail != head) {
    RxEntry&amp; e = rxBuf[rxTail];
    f.printf(&quot;%lu,ADV,%d,%u,%s,%s,%s\r\n&quot;,
             (unsigned long)e.ms,
             (int)e.rssi,
             (unsigned)e.seq,
             e.label,
             e.addr,
             e.mfd);
    rxTail = (rxTail + 1) % RX_BUF_SIZE;
    wrote = true;
  }
  if (wrote) f.flush();
}

static void startSession() {
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (f) {
    f.println(&quot;ms,event,rssi,seq,label,addr,mfd&quot;);
    f.printf(&quot;# meta, firmware=%s, buf_size=%u\r\n&quot;, FW_TAG, (unsigned)RX_BUF_SIZE);
    f.printf(&quot;# meta, scan_interval_ms=%.1f, scan_window_ms=%.1f\r\n&quot;, SCAN_INTERVAL_MS, SCAN_WINDOW_MS);
    f.flush();
  }
  t0Ms = millis();
  rxCount = 0;
  rxHead = rxTail = 0;
  bufOverflow = 0;
  lastFlushMs = t0Ms;
  condSeen = false;
  condWritten = false;
  condLabel[0] = &apos;\0&apos;;
  Serial.printf(&quot;[RX] start %s\n&quot;, path.c_str());
  trial = true;
}

static void endSession() {
  if (!trial) return;
  flushBuffer();
  if (f) { f.flush(); f.close(); }
  uint32_t t_ms = millis() - t0Ms;
  double dur_s = t_ms / 1000.0;
  double rate_hz = dur_s &gt; 0 ? (double)rxCount / dur_s : 0.0;
  Serial.printf(&quot;[RX] end ms_total=%lu rx=%lu buf_overflow=%lu rate_hz=%.2f\n&quot;,
                (unsigned long)t_ms,
                (unsigned long)rxCount,
                (unsigned long)bufOverflow,
                rate_hz);
  trial = false;
}

class AdvCB : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    const std::string&amp; mfd = d-&gt;getManufacturerData();
    uint16_t seq;
    std::string label;
    if (!parseMFD(mfd, seq, label)) return;
    if (!condSeen) {
      strncpy(condLabel, label.c_str(), sizeof(condLabel) - 1);
      condLabel[sizeof(condLabel) - 1] = &apos;\0&apos;;
      condSeen = true;
    }
    const std::string addr = d-&gt;getAddress().toString();

    uint16_t nextH = (rxHead + 1) % RX_BUF_SIZE;
    if (nextH == rxTail) { bufOverflow++; return; }

    RxEntry&amp; e = rxBuf[rxHead];
    e.ms = millis() - t0Ms;
    e.rssi = (int8_t)d-&gt;getRSSI();
    e.seq = seq;
    strncpy(e.label, label.c_str(), sizeof(e.label) - 1);
    e.label[sizeof(e.label) - 1] = &apos;\0&apos;;
    strncpy(e.addr, addr.c_str(), sizeof(e.addr) - 1);
    e.addr[sizeof(e.addr) - 1] = &apos;\0&apos;;
    strncpy(e.mfd, mfd.c_str(), sizeof(e.mfd) - 1);
    e.mfd[sizeof(e.mfd) - 1] = &apos;\0&apos;;

    rxHead = nextH;
    rxCount++;
  }
};

static NimBLEScan* scan = nullptr;
static AdvCB cb;

void setup() {
  Serial.begin(115200);
  Serial.printf(&quot;[RX] FW=%s\n&quot;, FW_TAG);

  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) {
    Serial.println(&quot;[RX] SD init FAIL&quot;);
    while (1) delay(1000);
  }

  pinMode(SYNC_IN, INPUT_PULLDOWN);

  NimBLEDevice::init(&quot;&quot;);
  scan = NimBLEDevice::getScan();
  // NimBLE-Arduino API compatibility:
  // Prefer setScanCallbacks (available on older/newer). If your NimBLE build only has
  // setAdvertisedDeviceCallbacks, replace this line with:
  //   scan-&gt;setAdvertisedDeviceCallbacks(&amp;cb);
  scan-&gt;setScanCallbacks(&amp;cb, false);
  scan-&gt;setActiveScan(false);
  scan-&gt;setInterval(ms_to_0p625(SCAN_INTERVAL_MS));
  scan-&gt;setWindow(ms_to_0p625(SCAN_WINDOW_MS));
  scan-&gt;setMaxResults(0);
  scan-&gt;start(0, false, false);

  Serial.printf(&quot;[RX] ready (buf=%u, flush=%lums, wait SYNC pin=%d)\n&quot;,
                (unsigned)RX_BUF_SIZE, (unsigned long)FLUSH_INTERVAL_MS, SYNC_IN);
}

void loop() {
  uint32_t nowMs = millis();
  int syncIn = digitalRead(SYNC_IN);

  if (!trial) {
    if (syncIn == HIGH) {
      if (syncHighSince == 0) syncHighSince = nowMs;
      if ((nowMs - syncHighSince) &gt;= START_LEVEL_HOLD_MS) {
        startSession();
        syncHighSince = 0;
        syncLowSince = 0;
      }
    } else {
      syncHighSince = 0;
    }
    vTaskDelay(pdMS_TO_TICKS(10));
    return;
  }

  if ((nowMs - lastFlushMs) &gt;= FLUSH_INTERVAL_MS) {
    flushBuffer();
    lastFlushMs = nowMs;
  }

  if (syncIn == LOW) {
    if (syncLowSince == 0) syncLowSince = nowMs;
    if ((nowMs - syncLowSince) &gt;= SYNC_LOW_DEBOUNCE_MS) {
      endSession();
      syncLowSince = 0;
    }
  } else {
    syncLowSince = 0;
  }

  if ((nowMs - t0Ms) &gt;= SESSION_TIMEOUT_MS) {
    endSession();
  }

  vTaskDelay(pdMS_TO_TICKS(10));
}</file><file path="uccs_d4b_scan90/src/tx/TX_UCCS_D4B_SCAN90/TX_UCCS_D4B_SCAN90.ino">// TX_UCCS_D4B_SCAN90.ino (uccs_d4b_scan90)
//
// Step D4B（CCSが効いている切り分け / Ablation）
// - S4のみを再生し、4条件×REPEAT回を自動実行する。
//   1) Fixed100
//   2) Fixed500
//   3) Policy(U+CCS, 100↔500)
//   4) Ablation_CCS_off（= U-only, 100↔500）
//
// 動的でもTL/Poutが評価できるよう payload に step_idx（100msグリッド）を埋め込む。
// TXSDへは SYNC(25) + preamble TICK(27) で cond_id を通知し、trial中は更新ごとにTICKを1発出して adv_count近似とする。
//
// Payload (ManufacturerData):
//   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
//     tag: &quot;F4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;U4-&lt;label&gt;-&lt;itv&gt;&quot;
//
// Note:
// - `stress_causal_*` の CCS は「安定度（高いほどstable）」なので、changeとして扱うため `CCS_change = 1-CCS` に変換する。
// - U-only（CCS-off）は「上げる判定/戻す判定ともUだけ」を使う（CCSで戻りをブロックしない）。

#include &lt;Arduino.h&gt;
#include &lt;BLEDevice.h&gt;
#include &lt;math.h&gt;

#ifdef ARDUINO_ARCH_ESP32
#include &quot;esp_pm.h&quot;
#endif

#include &quot;../stress_causal_s1_s4_180s.h&quot;

// ==== schedule ====
static const uint32_t GAP_MS = 5000;
static const uint8_t REPEAT = 3;
static const uint16_t EFFECTIVE_LEN_STEPS = 1800; // 180s @ 100ms grid

// ==== pins ====
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN = 2;

// ==== options ====
static const bool USE_LED = false;
static const bool ENABLE_TICK_PREAMBLE = true;
static const bool ENABLE_TICK_PER_UPDATE = true;
static const bool RESTART_ADV_ON_INTERVAL_CHANGE = true;

static const uint32_t PREAMBLE_WINDOW_MS = 800; // TXSD window
static const uint32_t PREAMBLE_GUARD_MS = 100;  // after SYNC HIGH before preamble

// ==== actions（実機は100↔500に固定） ====
static const uint16_t ACTIONS[] = {100, 500};
static const uint8_t N_ACTIONS = sizeof(ACTIONS) / sizeof(ACTIONS[0]);

// ==== policy params（D2bと同一） ====
static const float U_MID = 0.20f;
static const float U_HIGH = 0.35f;
static const float C_MID = 0.20f;
static const float C_HIGH = 0.35f;
static const float HYST = 0.02f;
static const float EMA_ALPHA = 0.20f;

// ==== BLE ====
static BLEAdvertising* adv = nullptr;

#ifdef ARDUINO_ARCH_ESP32
static esp_pm_lock_handle_t noLightSleepLock = nullptr;
static bool sleepBlocked = false;
#endif

enum Mode : uint8_t {
  MODE_FIXED = 0,
  MODE_POLICY = 1,
  MODE_ABL_CCS_OFF = 2,
};

struct Condition {
  uint8_t cond_id;   // TXSD preamble pulses
  Mode mode;
  uint16_t fixed_ms; // MODE_FIXED only
};

// cond_id:
//  1: S4 fixed100
//  2: S4 fixed500
//  3: S4 policy
//  4: S4 ablation_ccs_off (U-only)
static const Condition CONDS[] = {
  {1, MODE_FIXED, 100},
  {2, MODE_FIXED, 500},
  {3, MODE_POLICY, 500},
  {4, MODE_ABL_CCS_OFF, 500},
};
static const uint8_t N_CONDS = sizeof(CONDS) / sizeof(CONDS[0]);

// state
static bool trialRunning = false;
static bool pendingStart = false;
static uint32_t syncRiseMs = 0;
static uint32_t trialStartMs = 0;
static uint32_t nextUpdateMs = 0;
static uint32_t gapStartMs = 0;
static uint8_t condIndex = 0;
static uint8_t repIndex = 0;

static uint16_t stepIdx = 0;               // 100ms grid index
static uint16_t currentIntervalMs = 500;   // 100 or 500
static float uEma = 0.0f;
static float cEma = 0.0f;                  // change-CCS EMA (policy only)

static inline uint16_t ms_to_0p625(float ms) {
  long v = lroundf(ms / 0.625f);
  if (v &lt; 0x20) v = 0x20;     // 20ms minimum
  if (v &gt; 0x4000) v = 0x4000; // 10.24s maximum
  return (uint16_t)v;
}

static uint16_t clamp_interval(uint16_t interval_ms) {
  uint16_t best = ACTIONS[0];
  uint32_t bestDist = (uint32_t)abs((int)interval_ms - (int)best);
  for (uint8_t i = 1; i &lt; N_ACTIONS; i++) {
    uint16_t a = ACTIONS[i];
    uint32_t d = (uint32_t)abs((int)interval_ms - (int)a);
    if (d &lt; bestDist || (d == bestDist &amp;&amp; a &lt; best)) {
      best = a;
      bestDist = d;
    }
  }
  return best;
}

static void syncStart() {
  if (USE_LED) digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
  syncRiseMs = millis();
}

static void syncEnd() {
  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_LED) digitalWrite(LED_PIN, LOW);
}

static void tickPulseOnce(uint16_t high_us = 200) {
  digitalWrite(TICK_OUT_PIN, HIGH);
  delayMicroseconds(high_us);
  digitalWrite(TICK_OUT_PIN, LOW);
}

static void tickPreamble(uint8_t nPulses) {
  if (!ENABLE_TICK_PREAMBLE) return;
  for (uint8_t i = 0; i &lt; nPulses; i++) {
    tickPulseOnce(200);
    delay(20);
  }
}

static void setAdvIntervalMs(uint16_t ms) {
  if (!adv) return;
  uint16_t units = ms_to_0p625((float)ms);
  adv-&gt;setMinInterval(units);
  adv-&gt;setMaxInterval(units);
}

static void setPayload(uint16_t step_idx, const char* tag) {
  if (!adv) return;
  BLEAdvertisementData ad;
  String mfd = String((unsigned)step_idx) + &quot;_&quot; + String(tag);
  ad.setManufacturerData(mfd);
  adv-&gt;setAdvertisementData(ad);
}

static void setSleepAllowed(bool allowLightSleep) {
#ifdef ARDUINO_ARCH_ESP32
  if (!noLightSleepLock) return;
  if (allowLightSleep) {
    if (sleepBlocked) {
      esp_pm_lock_release(noLightSleepLock);
      sleepBlocked = false;
    }
  } else {
    if (!sleepBlocked) {
      esp_pm_lock_acquire(noLightSleepLock);
      sleepBlocked = true;
    }
  }
#else
  (void)allowLightSleep;
#endif
}

static inline uint8_t getLabel(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0;
  return pgm_read_byte(&amp;S4_LABEL[idx]);
}

static inline float getU(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_U_Q[idx]);
  return q_to_f(q);
}

static inline float getCCSStable(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_CCS_Q[idx]);
  return q_to_f(q);
}

static void makeTag(char* out, size_t out_sz, const Condition&amp; c, uint8_t truthLabel, uint16_t intervalMs) {
  const char mp = (c.mode == MODE_FIXED) ? &apos;F&apos; : (c.mode == MODE_POLICY ? &apos;P&apos; : &apos;U&apos;);
  const unsigned lbl = (unsigned)truthLabel;
  const unsigned itv = (unsigned)intervalMs;
  snprintf(out, out_sz, &quot;%c4-%02u-%u&quot;, mp, lbl, itv);
}

static uint16_t policyStep_U_CCS(uint16_t prevInterval, float u, float c_change) {
  const float u_hi_up = U_HIGH;
  const float c_hi_up = C_HIGH;
  const float u_mid_down = U_MID - HYST;
  const float c_mid_down = C_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if ((u &gt;= u_hi_up) || (c_change &gt;= c_hi_up)) next = 100;
  } else { // prevInterval == 100
    if ((u &lt; u_mid_down) &amp;&amp; (c_change &lt; c_mid_down)) next = 500;
  }
  return clamp_interval(next);
}

static uint16_t policyStep_U_only(uint16_t prevInterval, float u) {
  const float u_hi_up = U_HIGH;
  const float u_mid_down = U_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if (u &gt;= u_hi_up) next = 100;
  } else { // prevInterval == 100
    if (u &lt; u_mid_down) next = 500;
  }
  return clamp_interval(next);
}

static void applyInterval(uint16_t nextMs) {
  if (nextMs == currentIntervalMs) return;
  currentIntervalMs = nextMs;
  if (!adv) return;
  if (RESTART_ADV_ON_INTERVAL_CHANGE) {
    adv-&gt;stop();
    setAdvIntervalMs(currentIntervalMs);
    adv-&gt;start();
  } else {
    setAdvIntervalMs(currentIntervalMs);
  }
}

static void beginCondition(const Condition&amp; c) {
  stepIdx = 0;
  uEma = 0.0f;
  cEma = 0.0f;
  currentIntervalMs = (c.mode == MODE_FIXED) ? c.fixed_ms : 500;
  currentIntervalMs = clamp_interval(currentIntervalMs);

  if (adv) adv-&gt;stop();
  setAdvIntervalMs(currentIntervalMs);

  setSleepAllowed(true);

  syncStart();
  delay(PREAMBLE_GUARD_MS);
  tickPreamble(c.cond_id);
  pendingStart = true;
}

static void startTrialNow(const Condition&amp; c) {
  trialStartMs = millis();
  trialRunning = true;

  const uint8_t lbl = getLabel(0);
  char tag[16];
  makeTag(tag, sizeof(tag), c, lbl, currentIntervalMs);
  setPayload(0, tag);

  if (adv) adv-&gt;start();
  if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

  const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
  stepIdx = (uint16_t)(stepIdx + deltaSteps);
  nextUpdateMs = millis() + currentIntervalMs;
}

static void endTrial() {
  trialRunning = false;
  pendingStart = false;
  if (adv) adv-&gt;stop();
  syncEnd();
  gapStartMs = millis();
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);
  digitalWrite(SYNC_OUT_PIN, LOW);
  pinMode(TICK_OUT_PIN, OUTPUT);
  digitalWrite(TICK_OUT_PIN, LOW);

  BLEDevice::init(&quot;TX_UCCS_D4B_SCAN90&quot;);
  BLEDevice::setPower(ESP_PWR_LVL_N0);
  adv = BLEDevice::getAdvertising();
  adv-&gt;setScanResponse(false);
  adv-&gt;setMinPreferred(0);

#ifdef ARDUINO_ARCH_ESP32
  (void)esp_pm_lock_create(ESP_PM_NO_LIGHT_SLEEP, 0, &quot;uccs_d4b&quot;, &amp;noLightSleepLock);
#endif

  condIndex = 0;
  repIndex = 0;
  gapStartMs = 0;
  trialRunning = false;
  pendingStart = false;

  beginCondition(CONDS[condIndex]);
}

void loop() {
  const uint32_t nowMs = millis();
  const Condition&amp; c = CONDS[condIndex];

  if (pendingStart) {
    if ((nowMs - syncRiseMs) &gt;= PREAMBLE_WINDOW_MS) {
      pendingStart = false;
      startTrialNow(c);
    } else {
      vTaskDelay(1);
      return;
    }
  }

  if (trialRunning) {
    if (stepIdx &gt;= EFFECTIVE_LEN_STEPS) {
      endTrial();
      vTaskDelay(pdMS_TO_TICKS(50));
      return;
    }

    if ((int32_t)(nowMs - nextUpdateMs) &gt;= 0) {
      const uint8_t truthLabel = getLabel(stepIdx);

      if (c.mode == MODE_POLICY) {
        const float uRaw = getU(stepIdx);
        const float cStable = getCCSStable(stepIdx);
        const float cChange = 1.0f - cStable; // invert stable-&gt;change
        uEma = EMA_ALPHA * uRaw + (1.0f - EMA_ALPHA) * uEma;
        cEma = EMA_ALPHA * cChange + (1.0f - EMA_ALPHA) * cEma;
        const uint16_t nextI = policyStep_U_CCS(currentIntervalMs, uEma, cEma);
        applyInterval(nextI);
      } else if (c.mode == MODE_ABL_CCS_OFF) {
        const float uRaw = getU(stepIdx);
        uEma = EMA_ALPHA * uRaw + (1.0f - EMA_ALPHA) * uEma;
        const uint16_t nextI = policyStep_U_only(currentIntervalMs, uEma);
        applyInterval(nextI);
      }

      char tag[16];
      makeTag(tag, sizeof(tag), c, truthLabel, currentIntervalMs);
      setPayload(stepIdx, tag);

      // Avoid interfering with TXSD preamble window.
      if (ENABLE_TICK_PER_UPDATE &amp;&amp; (nowMs - syncRiseMs) &gt; (PREAMBLE_WINDOW_MS + 50)) {
        tickPulseOnce(200);
      }

      const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
      stepIdx = (uint16_t)(stepIdx + deltaSteps);
      nextUpdateMs = millis() + currentIntervalMs;
    }
    vTaskDelay(1);
    return;
  }

  // gap
  if (gapStartMs == 0) gapStartMs = nowMs;
  if ((nowMs - gapStartMs) &lt; GAP_MS) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return;
  }

  gapStartMs = 0;
  condIndex++;
  if (condIndex &gt;= N_CONDS) {
    condIndex = 0;
    repIndex++;
  }
  if (repIndex &gt;= REPEAT) {
    setSleepAllowed(true);
    if (adv) adv-&gt;stop();
    syncEnd();
    vTaskDelay(pdMS_TO_TICKS(1000));
    return;
  }

  beginCondition(CONDS[condIndex]);
  vTaskDelay(pdMS_TO_TICKS(200));
}</file><file path="uccs_d4b_scan90/src/tx/stress_causal_s1_s4_180s.h">// stress_causal_s1_s4_180s.h (uccs_d4b_scan90)
// D2で凍結済みのtruthヘッダを参照するラッパ。

#pragma once

#include &quot;../../../uccs_d2_scan90/src/tx/stress_causal_s1_s4_180s.h&quot;</file><file path="uccs_d4b_scan90/src/txsd/TXSD_UCCS_D4B_SCAN90/TXSD_UCCS_D4B_SCAN90.ino">// TXSD_UCCS_D4B_SCAN90.ino (uccs_d4b_scan90)
// INA219 logger for Step D4B (CCS ablation).
// Start/stop via SYNC (TX GPIO25 -&gt; TXSD GPIO26).
// TX sends preamble pulses on TICK (TX GPIO27 -&gt; TXSD GPIO33) to encode cond_id.
// During trial, TX additionally emits 1 tick per payload update; TXSD uses tick_count as adv_count (approx).
//
// cond_id:
//   1: S4 fixed100
//   2: S4 fixed500
//   3: S4 policy (U+CCS)
//   4: S4 ablation_ccs_off (U-only)

#include &lt;Arduino.h&gt;
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;Adafruit_INA219.h&gt;

// Pins
static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26;
static const int SYNC_OFF_IN = -1; // unused
static const int TICK_IN = 33;
static const int I2C_SDA = 21;
static const int I2C_SCL = 22;

// Settings
static const uint32_t SAMPLE_US    = 10000;   // 10ms = 100Hz
static const uint32_t FALLBACK_MS  = 2400000; // safety fallback
static const uint32_t MIN_TRIAL_MS = 1000;
static const uint32_t TICK_PER_TRIAL = 0;     // 0=disabled (use SYNC to end)
static const char SUBJECT_ID[] = &quot;uccs_d4b_scan90&quot;;

// Preamble window (count TICK pulses after SYNC rising edge)
static const uint32_t PREAMBLE_WINDOW_MS = 800;
static const uint8_t PREAMBLE_MAX_ID = 16;

HardwareSerial Debug(0);
Adafruit_INA219 ina;
File f;

volatile uint32_t tickCountRaw=0; // cumulative
uint32_t tickStart=0;
uint32_t tickCount=0;
bool logging=false;
bool pendingStart=false;
uint32_t t0_ms=0, nextSampleUs=0;
uint32_t badLines=0;
uint32_t syncLowSince=0;
uint32_t pendingSinceMs=0;
uint32_t tickAtSync=0;
uint8_t condId=0;

// Stats
double sumP=0.0; double sumV=0.0; double sumI=0.0; uint32_t sampN=0;

static bool condInfo(uint8_t id, const char** tag){
  switch(id){
    case 1: *tag = &quot;s4_fixed100&quot;; return true;
    case 2: *tag = &quot;s4_fixed500&quot;; return true;
    case 3: *tag = &quot;s4_policy&quot;; return true;
    case 4: *tag = &quot;s4_ablation_ccs_off&quot;; return true;
    default: break;
  }
  *tag = &quot;unk&quot;;
  return false;
}

static inline String nextPath(uint8_t id){
  SD.mkdir(&quot;/logs&quot;);
  char p[96];
  const char* tag=&quot;unk&quot;;
  (void)condInfo(id, &amp;tag);
  for (uint32_t trial_idx=1;;++trial_idx){
    snprintf(p,sizeof(p),&quot;/logs/trial_%03lu_c%u_%s.csv&quot;,
             (unsigned long)trial_idx, (unsigned)id, tag);
    if(!SD.exists(p)) return String(p);
  }
}

void IRAM_ATTR onTickRaw(){ tickCountRaw++; }

static void startTrial(uint8_t id){
  condId = id;
  const char* tag=&quot;unk&quot;;
  (void)condInfo(condId, &amp;tag);
  String path = nextPath(id);
  f = SD.open(path, FILE_WRITE);
  if (!f){ Debug.println(&quot;[SD] open FAIL&quot;); return; }
  f.println(&quot;ms,mV,uA,p_mW&quot;);

  f.printf(&quot;# meta, firmware=TXSD_UCCS_D4B_SCAN90, cond_id=%u, tag=%s, subject=%s\r\n&quot;,
           (unsigned)condId, tag, SUBJECT_ID);
  if (condId == 3){
    f.printf(&quot;# meta, policy=U+CCS actions{100,500} u_mid=0.20 u_high=0.35 c_mid=0.20 c_high=0.35 hyst=0.02 ema_alpha=0.20 ccs_inverted=true\r\n&quot;);
  } else if (condId == 4){
    f.printf(&quot;# meta, ablation=ccs_off policy=U_only actions{100,500} u_mid=0.20 u_high=0.35 hyst=0.02 ema_alpha=0.20\r\n&quot;);
  }
  f.flush();

  logging = true;
  t0_ms = millis();
  nextSampleUs = micros() + SAMPLE_US;
  badLines = 0;
  tickCount = 0;
  tickStart = tickCountRaw; // exclude preamble pulses
  sumP=sumV=sumI=0.0;
  sampN=0;
  Debug.printf(&quot;[PWR] start %s subject=%s\n&quot;, path.c_str(), SUBJECT_ID);
}

static void endTrial(){
  if (!logging) return;
  logging = false;
  uint32_t ms_total = millis() - t0_ms;
  tickCount = tickCountRaw - tickStart;

  if (ms_total &lt; MIN_TRIAL_MS){
    Debug.printf(&quot;[PWR] ignore short trial ms_total=%lu\n&quot;, (unsigned long)ms_total);
    if (f){ f.flush(); f.close(); }
    return;
  }

  double meanP = (sampN&gt;0)? (sumP/sampN) : 0.0;
  double meanV = (sampN&gt;0)? (sumV/sampN) : 0.0;
  double meanI = (sampN&gt;0)? (sumI/sampN) : 0.0;
  double E_mJ  = meanP * (ms_total/1000.0);

  f.printf(&quot;# summary, ms_total=%lu, adv_count=%lu, E_total_mJ=%.3f, subject=%s\r\n&quot;,
           (unsigned long)ms_total, (unsigned long)tickCount, E_mJ, SUBJECT_ID);
  f.printf(&quot;# diag, samples=%lu, rate_hz=%.2f, mean_v=%.3f, mean_i=%.3f, mean_p_mW=%.1f, parse_drop=%lu\r\n&quot;,
           (unsigned long)sampN,
           (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
           meanV, meanI, meanP, (unsigned long)badLines);
  f.flush(); f.close();

  Debug.printf(&quot;[PWR] end ms=%lu adv_count=%lu E=%.3fmJ\n&quot;,
               (unsigned long)ms_total, (unsigned long)tickCount, E_mJ);
  Debug.printf(&quot;[PWR] diag samples=%lu rate=%.2f mean_v=%.3f mean_i=%.3f mean_p=%.1f parse_drop=%lu\n&quot;,
               (unsigned long)sampN,
               (ms_total&gt;0? (double)sampN/(ms_total/1000.0):0.0),
               meanV, meanI, meanP, (unsigned long)badLines);
}

void setup(){
  Debug.begin(115200);
  Debug.println(&quot;[PWR] FW=TXSD_UCCS_D4B_SCAN90&quot;);
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)){ Debug.println(&quot;[SD] init FAIL&quot;); while(1) delay(1000); }

  pinMode(SYNC_IN, INPUT_PULLDOWN);
  if (SYNC_OFF_IN &gt;= 0) pinMode(SYNC_OFF_IN, INPUT_PULLDOWN);
  pinMode(TICK_IN, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(TICK_IN), onTickRaw, RISING);

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  ina.begin();
  ina.setCalibration_16V_400mA();

  Debug.println(&quot;[PWR] ready&quot;);
}

void loop(){
  uint32_t nowMs = millis();
  int syncIn = digitalRead(SYNC_IN);
  int syncOff = (SYNC_OFF_IN &gt;= 0) ? digitalRead(SYNC_OFF_IN) : HIGH;

  if (!logging &amp;&amp; !pendingStart &amp;&amp; syncIn == HIGH){
    pendingStart = true;
    pendingSinceMs = nowMs;
    tickAtSync = tickCountRaw;
    syncLowSince = 0;
    Debug.printf(&quot;[PWR] SYNC high, wait preamble %lums (tick_raw=%lu)\n&quot;,
                 (unsigned long)PREAMBLE_WINDOW_MS, (unsigned long)tickCountRaw);
  }

  if (pendingStart){
    if (syncIn == LOW){
      pendingStart = false;
      Debug.println(&quot;[PWR] pending start canceled (SYNC LOW)&quot;);
    } else if ((nowMs - pendingSinceMs) &gt;= PREAMBLE_WINDOW_MS){
      uint32_t pulses = tickCountRaw - tickAtSync;
      uint8_t id = (pulses &gt;= 1 &amp;&amp; pulses &lt;= PREAMBLE_MAX_ID) ? (uint8_t)pulses : 0;
      startTrial(id);
      pendingStart = false;
      syncLowSince = 0;
      Debug.printf(&quot;[PWR] trigger start by preamble pulses=%lu -&gt; cond_id=%u\n&quot;,
                   (unsigned long)pulses, (unsigned)id);
      nowMs = millis();
    }
  }

  if (logging){
    bool syncLow = (syncIn == LOW) || (syncOff == LOW);
    if (syncLow){
      if (syncLowSince == 0) syncLowSince = nowMs;
      if ((nowMs - syncLowSince) &gt;= 100){
        Debug.printf(&quot;[PWR] end by SYNC/SYNC_OFF sync=%d sync_off=%d\n&quot;, syncIn, syncOff);
        endTrial();
        syncLowSince = 0;
      }
    } else {
      syncLowSince = 0;
      tickCount = tickCountRaw - tickStart;
      if (TICK_PER_TRIAL &gt; 0 &amp;&amp; tickCount &gt;= TICK_PER_TRIAL){
        Debug.printf(&quot;[PWR] force end by TICK (count=%lu)\n&quot;, (unsigned long)tickCount);
        endTrial();
      }
      if ((nowMs - t0_ms) &gt;= FALLBACK_MS){
        Debug.printf(&quot;[PWR] force end by timeout (ms=%lu)\n&quot;, (unsigned long)(nowMs - t0_ms));
        endTrial();
      }
    }

    uint32_t nowUs = micros();
    while ((int32_t)(nowUs - nextSampleUs) &gt;= 0){
      nextSampleUs += SAMPLE_US;
      float v = ina.getBusVoltage_V();
      float i = ina.getCurrent_mA();
      int32_t mv = (int32_t)lroundf(v*1000.0f);
      int32_t uA = (int32_t)lroundf(i*1000.0f);
      double p_mW = v*i;
      uint32_t relMs = millis() - t0_ms;

      sumP += p_mW;
      sumV += v;
      sumI += i;
      sampN++;

      char buf[64];
      int n = snprintf(buf, sizeof(buf), &quot;%lu,%ld,%ld,%.1f\r\n&quot;,
                       (unsigned long)relMs, (long)mv, (long)uA, p_mW);
      if (n &gt; 0) f.write((uint8_t*)buf, n); else badLines++;
      nowUs = micros();
    }
  } else {
    delay(10);
  }
}</file><file path="AGENTS.md"># Repository Guidelines

## Project structure &amp; module organization
- `docs/フェーズ1/` contains phase-one deliverables such as `要件定義.md` and `Runbook.md`. Add new phases as `docs/フェーズN/` and mirror folder names inside references.
- `docs/フェーズ0-1/` はフェーズ0-1のマスターフォルダ。原本として扱い、直接変更しない（参照のみ、派生は別フェーズ側で作成）。
- `data/` stores curated datasets; log source, version, and SHA256 in the consuming document. Do not commit raw exports without documentation.
- `configs/` tracks reusable parameter sets; align filenames with the related doc slug (e.g., `要件定義_simulation.yaml`).
- `results/` captures derived tables, charts, or summaries. Note generation date and script in the adjacent Markdown file.
- `scripts/` keeps ad-hoc automation; run from the repository root (`python scripts/generate_summary.py`) and document dependencies.
- External experiments or firmware belong in sibling repositories such as `labs/`; leave references here that link outward.

## Build, test, and development commands
- `markdownlint docs` lint headings, lists, and fenced blocks before committing.
- `glow docs/フェーズ1/要件定義.md` preview the rendered Markdown; use any equivalent viewer if Glow is unavailable.
- `git diff` confirm table layout and diagram embeds before pushing.
- Optional: `npx markdown-link-check docs/フェーズ1/要件定義.md` verify external URLs when refreshing references.

## Coding style &amp; naming conventions
- Write concise, declarative Japanese-first prose; introduce English terms in parentheses on first mention.
- Prefer Japanese filenames; when romanizing, use lowercase snake case (`yoken_teigi.md`). Keep new content ASCII unless quoting external text.
- Maintain parallel bullet structures, limit paragraphs to three sentences, and date entries as `YYYY-MM-DD`.
- Document dataset metrics with metric units and cite sources alongside quantitative claims.

## Testing guidelines
- No automated suite exists; manually confirm internal anchors, relative links, and cross-phase references.
- Preview diagrams and tables with a Markdown viewer; reconcile CCS thresholds with `docs/フェーズ1/Runbook.md`.
- When adjusting datasets, validate row counts against expectations and update recorded checksums.

## Commit &amp; pull request guidelines
- Write imperative commit subjects such as `Update 要件定義.md`; keep each commit scoped to a single topic.
- PR descriptions should list affected documents, summarize impact, reference issues, and attach render diffs or screenshots for visual changes.
- Request at least one peer review and wait for required checks before merging.

## Agent-specific instructions
- Add new material to the appropriate phase directory and store supporting assets beside the referencing document with slugged filenames (e.g., `要件定義_図1.png`).
- Avoid introducing new tooling or build systems unless coordinated with maintainers.
- ESP32スケッチとログ収集コードのファイル名は役割ごとに `RX_*`（受信ロガ）, `TX_*`（送信/DUT）, `TXSD_*`（送信側の電力ロガ）で始めること。既存名を変更する際は文書内の参照（README, Runbook など）も併せて更新する。

## Recent experiment snapshot (Phase 0-0)
- Phase: 0-0 baseline. Conditions: E2 (high interference), distance 1 m, adv_interval=100 ms, TxPower=0 dBm, 60 s × 6 runs.
- Data (ON): `data/実験データ/研究室/1m_ad/` (collected with non-separated ON/OFF code). Directory checksums consolidated in `data/実験データ/SHA256.txt`.
- Data (OFF): `data/実験データ/研究室/1m_off/` (collected with separated OFF code).
- Results summary: `results/フェーズ0-0_E2_1m_100ms_2025-11-09.md`
- RX retry summary: `results/フェーズ0-0_E2_1m_100ms_retry_2025-11-09.md` (RX-only; power logs not present)
- ON retry summary: `results/フェーズ0-0_E2_1m_100ms_retry_latest_2025-11-09.md` (ON power+RX, n=2)
- OFF re-run summary: `results/フェーズ0-0_E2_1m_100ms_off_02_2025-11-09.md` (OFF power, n=2)
  - OFF_03: `results/フェーズ0-0_E2_1m_100ms_off_03_2025-11-09.md` (OFF power, n=2, TX-only)
  - OFF_04: `results/フェーズ0-0_E2_1m_100ms_off_04_2025-11-09.md` (OFF power, n=2, pass-through logger)
- Experiment log: `docs/フェーズ0-0/実験ログ_E2_1m_2025-11-09.md`
- ESP32 sketches
  - RX logger: `esp32/RX_BLE_to_SD_SYNC_B.ino`（旧 `RxLogger_BLE_to_SD_SYNC_B.ino`）
  - TX+INA (advertising ON): `esp32/TX_BLE_Adv_Meter_ON_nonblocking.ino`（旧 `Combined_TX_Meter_UART_B_nonblocking.ino`）
  - TX+INA (advertising OFF, 10 ms baseline): `esp32/TX_BLE_Adv_Meter_OFF_10ms.ino`（旧 `Combined_TX_Meter_UART_B_nonblocking_OFF.ino`）
  - Power logger (ON, TICKあり): `esp32/TXSD_PowerLogger_SYNC_TICK_ON.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B_ON.ino`）
  - Power logger (OFF, adv_count=0): `esp32/TXSD_PowerLogger_SYNC_TICK_OFF.ino`（旧 `PowerLogger_UART_to_SD_SYNC_TICK_B_OFF.ino`）
  - Note: The `1m_ad` dataset was recorded with the earlier common variants `esp32/TX_BLE_Adv_Meter_blocking.ino` (旧 `Combined_TX_Meter_UART_B.ino`) and `esp32/TXSD_PowerLogger_PASS_THRU_ON_v2.ino` (旧 `PowerLogger_UART_to_SD_SYNC_TICK_B.ino`).
- Key metrics (this set)
  - E_total_mJ mean ≈ 1933.47 mJ (±10.06)
  - E_per_adv_uJ mean ≈ 3222.45 μJ (±16.75) with `adv_count≈600` (t/100 ms approximation)
  - PDR mean ≈ 0.858 (±0.009); RSSI median ≈ −35 dBm
- ΔE snapshot: ON−OFF ≈ −3.58 J/60s (OFF&gt;ON; unexpected) — see `results/フェーズ0-0_E2_1m_100ms_deltaE_2025-11-09.md` and verify wiring/range/power domains/stack state.
  - Latest retry: ON−OFF ≈ −3.85 J/60s — see `results/フェーズ0-0_E2_1m_100ms_retry_latest_2025-11-09.md`.
  - With OFF_02: ON−OFF ≈ −10.07 J/60s — see `results/summary_1m_E2_100ms_deltaE_retry_off02.md`.
  - With OFF_03: ON−OFF ≈ −10.16 J/60s — see `results/summary_1m_E2_100ms_deltaE_retry_off03.md`.
- Next steps for ΔE
  - Collect OFF (60 s) under identical conditions and compute ΔE = E_on − E_off
  - Optionally wire TICK (TX 27 → Logger 33) and set `USE_TICK_INPUT=true` for exact `adv_count`
  - Extend analysis to TL distribution and Pout(τ) per Runbook
  - Ensure ON power logs are captured (`trial_*.csv`) when retrying; see `data/実験データ/研究室/1m_ad_retry/README.md`

## Agent Logging Rules (2025-12-12)
- 重要な作業をしたら、作業直後に `logs/worklog_YYYY-MM-DD_*.txt` に必ず追記する。日時はJSTで記載。
- 複数回の追記がある日は同じworklogファイルを使う（例: `worklog_2025-12-10_causal.txt`）。
- 記載内容は、何をやったか・ファイルパス・主要な指標変化（例: PDR改善、解析結果ファイル）を簡潔に。
- 各作業ディレクトリには簡易 index (README.md 等) を置き、配下ファイルの用途・生成物を記載する。作業内容は index と worklog の両方に残す。</file><file path="docs/metrics_definition.md"># Metrics Definition (ストレス固定 / CCS 評価用)

本ドキュメントでは、実機ログ解析で用いる主要指標の定義を明文化する。PDR/遅延系の解釈がブレないように、分母・分子の取り方や下限値をここで固定する。

## PDR
- `adv_count`: TXSD summary (`# summary` の `adv_count`) を真値とし、RX由来で再計算しない。
- `pdr_raw = rx_count / adv_count`  
  - `rx_count`: RX行数（重複含む）。  
  - `adv_count`: TXSD基準でクランプ（min(rx_count, adv_count) を使う実装）。
- `pdr_unique = rx_unique_seq / adv_count`  
  - `rx_unique_seq`: `seq`（MFD 先頭の数値）でユニーク化した件数。  
  - カバレッジ指標に近い（「広告イベントの何割を一度でも拾えたか」）。  
  - QoS比較にはこちらを使用。  
- 注意: 重複受信が多いと `pdr_raw` は &gt;1 になりうるので、QoS用途には `pdr_unique` を参照する。

## TL / Pout
- 真値: `truth` CSV の `idx,label`（EFFECTIVE_LEN=6352 を基準。末尾遷移が TX 再生範囲外に出ないようクリップ）。  
- 遅延: 各遷移時刻 `t_event` から最初に正しいラベルを観測するまでの時間。  
  - `tl_mean`, `tl_p95`: 遷移ごとの遅延の平均 / 95%点。  
  - `Pout(τ)`: 遷移のうち、遅延 &gt; τ の割合。  

### 時間同期（重要）
TL/Pout は **RXログの `ms` と truth の時間軸が一致している**前提で計算する必要がある。実機では開始タイミングのズレ（例: RX開始が遅れる、TXが先に進む）が入りやすく、ズレを補正しないと **TL/Pout が不自然に小さく見える**（特に長間隔側）ことがある。

本リポジトリでは、固定間隔リプレイ（seqが単調増加）を前提に、次の「定数オフセット」で同期する（`scripts/analyze_stress_causal_real.py` の実装）。

- 各 `seq` の最初の観測時刻を `first_ms(seq)` とする（RXログ由来）。
- 期待される真値時刻は `seq * interval_ms` とみなす。
- `offset_ms = median_{seq&gt;0}( seq*interval_ms - first_ms(seq) )`
- TL/Pout 計算では `ms_aligned = ms + offset_ms` を用いる。

出力CSVでは以下で確認できる。
- `tl_time_offset_ms`: 推定したオフセット（ms）
- `tl_time_offset_n`: 推定に使ったseq数

### 下限（参考）
一般に、τ &lt; interval のとき、受信100%でも遅延の量子化により `Pout(τ)` は 0 にならない（例: interval=2000ms, τ=1s なら 0.5 が目安）。
ただし、実際の `Pout(τ)` の下限は「遷移時刻の分布」と「開始位相」に依存するため、**一律の下限値を前提にせず**、上記の時間同期を行った上で実測値で議論する。

## EFFECTIVE_LEN / 末端遷移
- TX は `EFFECTIVE_LEN=6352` ステップ（約10.6分）でクランプ。  
- truth も同じ長さにクリップして末端遷移のズレを防ぐ。  
- abort試行（短時間）は manifest から除外する。

## ファイル
- scan90（固定フルセット, v5）:
  - per-trial: `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_full_scan90_v5.csv`
  - per-trial抜粋: `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_modes_scan90_v5.csv`
  - 集約: `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_agg_scan90_v5.csv`
  - 集約+派生: `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_agg_enriched_scan90_v5.csv`
  - インデックス: `results/stress_fixed/scan90/index.md`

## 補足
- RX FW は一部 `RX_ModeC2prime_1202` ログが混在。解析時は manifest で trialごとに明示。  
- 2000ms は Pout/TL が大きく揺れるため、複数trialで平均・分散を見ること。  
- エネルギー: TXSD summary の `E_per_adv_uJ`, `E_total_mJ` を使用。平均電力は `E_total_mJ / duration`.</file><file path="uccs_d2_scan90/analysis/summarize_d2_run.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Summarize uccs_d2_scan90 run (RX + TXSD) and compute TL/Pout using step_idx-aligned payload.

Step D2 idea:
  - TX ManufacturerData is &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;, where step_idx is the 100ms truth grid index.
  - RX logs `ms` (since session start) and `seq` (=step_idx).
  - Align RX time to truth time via a constant offset:
      offset_ms = median(step_idx*100 - first_rx_ms(step_idx))
  - Then compute TL/Pout on truth-time axis (100ms grid).

Inputs:
  - RX:  uccs_d2_scan90/data/RX/rx_trial_*.csv
  - TXSD: uccs_d2_scan90/data/TX/trial_*.csv (copied SD:/logs)
  - truth: Mode_C_2_シミュレート_causal/ccs/stress_causal_S1.csv and S4.csv

Outputs (out_dir):
  - per_trial.csv
  - summary_by_condition.csv
  - summary.md
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import re
import statistics
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


TRUTH_DT_MS = 100
TAU_VALUES_S = (1.0, 2.0, 3.0)
VALID_MIN_DURATION_MS = 160_000  # ~180s trials

TAG_RE = re.compile(r&quot;^(?P&lt;mode&gt;[FP])(?P&lt;sess&gt;[14])-(?P&lt;label&gt;\d+)-(?P&lt;itv&gt;\d+)$&quot;)
RX_TRIAL_RE = re.compile(r&quot;rx_trial_(?P&lt;id&gt;\d+)\.csv$&quot;)
TXSD_NAME_RE = re.compile(r&quot;trial_(?P&lt;idx&gt;\d+)_c(?P&lt;cond&gt;\d+)_(?P&lt;tag&gt;.+)\.csv$&quot;)


@dataclass(frozen=True)
class RxEvent:
    rx_ms: float
    step_idx: int
    tag: str


@dataclass
class RxTrial:
    rx_id: int
    path: Path
    duration_ms: float
    session: int  # 1 or 4
    mode: str  # &quot;F&quot; or &quot;P&quot;
    fixed_itv: Optional[int]  # 100/500 if fixed, else None
    events: List[RxEvent]


@dataclass
class TxsdTrial:
    path: Path
    trial_idx: int
    cond_id: int
    tag: str
    ms_total: float
    adv_count: int
    e_total_mj: float
    avg_power_mw: float
    # inferred
    session: Optional[int] = None  # 1/4 if known
    kind: str = &quot;unk&quot;  # fixed100/fixed500/policy/unk


def read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def read_rx_trial(path: Path) -&gt; RxTrial:
    m = RX_TRIAL_RE.search(path.name)
    if not m:
        raise ValueError(f&quot;not rx_trial: {path}&quot;)
    rx_id = int(m.group(&quot;id&quot;))

    events: List[RxEvent] = []
    last_ms: float = 0.0

    mode_c: Dict[str, int] = {&quot;F&quot;: 0, &quot;P&quot;: 0}
    sess_c: Dict[int, int] = {1: 0, 4: 0}
    itv_c: Dict[int, int] = {}

    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or 0.0)
            except Exception:
                continue
            last_ms = max(last_ms, rx_ms)

            try:
                step_idx = int(row.get(&quot;seq&quot;) or 0)
            except Exception:
                continue

            tag = (row.get(&quot;label&quot;) or &quot;&quot;).strip()
            if tag:
                tm = TAG_RE.match(tag)
                if tm:
                    mode_c[tm.group(&quot;mode&quot;)] += 1
                    sess_c[int(tm.group(&quot;sess&quot;))] += 1
                    itv = int(tm.group(&quot;itv&quot;))
                    itv_c[itv] = itv_c.get(itv, 0) + 1

            events.append(RxEvent(rx_ms=rx_ms, step_idx=step_idx, tag=tag))

    if not events:
        raise ValueError(f&quot;empty RX: {path}&quot;)

    # robust majority
    mode = &quot;F&quot; if mode_c[&quot;F&quot;] &gt;= mode_c[&quot;P&quot;] else &quot;P&quot;
    session = 1 if sess_c[1] &gt;= sess_c[4] else 4

    fixed_itv: Optional[int] = None
    if mode == &quot;F&quot;:
        if not itv_c:
            raise ValueError(f&quot;cannot infer fixed interval from tags: {path}&quot;)
        fixed_itv = max(itv_c.items(), key=lambda kv: kv[1])[0]

    return RxTrial(
        rx_id=rx_id,
        path=path,
        duration_ms=last_ms,
        session=session,
        mode=mode,
        fixed_itv=fixed_itv,
        events=events,
    )


def _rx_bucket(t: RxTrial) -&gt; str:
    if t.mode == &quot;P&quot;:
        return f&quot;P{t.session}&quot;
    return f&quot;F{t.session}_{t.fixed_itv}&quot;


def select_balanced_window(trials: List[RxTrial]) -&gt; List[RxTrial]:
    &quot;&quot;&quot;
    Pick the latest contiguous window that forms 6 conditions × 3 repeats = 18 trials.
    Conditions are defined by (mode, session, fixed_itv bucket).
    &quot;&quot;&quot;
    candidates = [t for t in trials if t.duration_ms &gt;= VALID_MIN_DURATION_MS]
    candidates.sort(key=lambda t: t.rx_id)
    if len(candidates) &lt; 18:
        raise SystemExit(f&quot;not enough valid RX trials (&gt;= {VALID_MIN_DURATION_MS}ms): {len(candidates)}&quot;)

    best: Optional[List[RxTrial]] = None
    for start in range(0, len(candidates) - 18 + 1):
        window = candidates[start : start + 18]
        counts: Dict[str, int] = {}
        for t in window:
            k = _rx_bucket(t)
            counts[k] = counts.get(k, 0) + 1
        if len(counts) == 6 and all(v == 3 for v in counts.values()):
            best = window  # keep updating; latest wins
    if not best:
        raise SystemExit(&quot;could not find balanced 18-trial window (6 conditions × 3 repeats)&quot;)
    return best


def estimate_offset_ms(events: List[RxEvent]) -&gt; Tuple[float, int]:
    first_ms: Dict[int, float] = {}
    for e in sorted(events, key=lambda x: x.rx_ms):
        if e.step_idx not in first_ms:
            first_ms[e.step_idx] = e.rx_ms
    deltas: List[float] = []
    for step, ms in first_ms.items():
        if step &lt;= 0:
            continue
        deltas.append(step * TRUTH_DT_MS - ms)
    if not deltas:
        return 0.0, 0
    return statistics.median(deltas), len(deltas)


def compute_tl_and_pout(truth_labels: List[int], aligned_events: List[Tuple[float, int]]) -&gt; Tuple[float, float, Dict[float, float]]:
    &quot;&quot;&quot;
    aligned_events: list of (t_ms_aligned, label) where t_ms_aligned is on truth-time axis.
    &quot;&quot;&quot;
    transitions_ms: List[int] = []
    prev = truth_labels[0]
    for idx, lab in enumerate(truth_labels[1:], start=1):
        if lab != prev:
            transitions_ms.append(idx * TRUTH_DT_MS)
            prev = lab
    if not transitions_ms:
        return 0.0, 0.0, {tau: 0.0 for tau in TAU_VALUES_S}

    aligned_events_sorted = sorted(aligned_events, key=lambda x: x[0])
    tl_list_s: List[float] = []
    for t_ms in transitions_ms:
        idx = min(t_ms // TRUTH_DT_MS, len(truth_labels) - 1)
        true_label = truth_labels[idx]
        arrival: Optional[float] = None
        for ms, lbl in aligned_events_sorted:
            if ms &gt; t_ms and lbl == true_label:
                arrival = ms
                break
        if arrival is None:
            tl_list_s.append(max((len(truth_labels) * TRUTH_DT_MS - t_ms), 0) / 1000.0)
        else:
            tl_list_s.append((arrival - t_ms) / 1000.0)

    tl_mean = statistics.mean(tl_list_s) if tl_list_s else 0.0
    tl_p95 = statistics.quantiles(tl_list_s, n=100)[94] if len(tl_list_s) &gt;= 2 else (tl_list_s[0] if tl_list_s else 0.0)
    pout = {tau: (sum(1 for tl in tl_list_s if tl &gt; tau) / len(tl_list_s)) for tau in TAU_VALUES_S}
    return tl_mean, tl_p95, pout


def parse_txsd_summary(path: Path) -&gt; Optional[TxsdTrial]:
    m = TXSD_NAME_RE.match(path.name)
    if not m:
        return None
    trial_idx = int(m.group(&quot;idx&quot;))
    cond_id = int(m.group(&quot;cond&quot;))
    tag = m.group(&quot;tag&quot;)

    ms_total = None
    adv_count = None
    e_total_mj = None
    with path.open() as f:
        for line in f:
            if line.startswith(&quot;# summary&quot;):
                parts = [p.strip() for p in line.strip().split(&quot;,&quot;)]
                kv: Dict[str, str] = {}
                for p in parts:
                    if &quot;=&quot; in p:
                        k, v = p.split(&quot;=&quot;, 1)
                        kv[k.strip(&quot;# &quot;).strip()] = v.strip()
                ms_total = float(kv.get(&quot;ms_total&quot;)) if kv.get(&quot;ms_total&quot;) else None
                adv_count = int(kv.get(&quot;adv_count&quot;)) if kv.get(&quot;adv_count&quot;) else None
                e_total_mj = float(kv.get(&quot;E_total_mJ&quot;)) if kv.get(&quot;E_total_mJ&quot;) else None
                break
    if ms_total is None or adv_count is None or e_total_mj is None:
        return None
    if ms_total &lt;= 0:
        return None
    avg_power = e_total_mj / (ms_total / 1000.0)
    return TxsdTrial(
        path=path,
        trial_idx=trial_idx,
        cond_id=cond_id,
        tag=tag,
        ms_total=ms_total,
        adv_count=adv_count,
        e_total_mj=e_total_mj,
        avg_power_mw=avg_power,
    )


def infer_txsd_kind(t: TxsdTrial) -&gt; None:
    name = t.path.name.lower()
    tag = t.tag.lower()

    # Session hint (may be mis-labeled; policy trials can be corrected later by share-based matching).
    if &quot;_s1_&quot; in name or tag.startswith(&quot;s1_&quot;):
        t.session = 1
    elif &quot;_s4_&quot; in name or tag.startswith(&quot;s4_&quot;):
        t.session = 4

    # Kind inference from adv_count (tick_count ~= number of payload updates).
    if 300 &lt;= t.adv_count &lt;= 450:
        t.kind = &quot;fixed500&quot;
        return
    if 1750 &lt;= t.adv_count &lt;= 1850:
        # Could be fixed100 or a policy that collapsed to 100ms.
        t.kind = &quot;policy&quot; if (&quot;policy&quot; in name or &quot;policy&quot; in tag) else &quot;fixed100&quot;
        return
    # In-between counts are treated as policy (two-valued 100/500 switching).
    t.kind = &quot;policy&quot;


def estimate_rx_tag_share100_time_est(events: List[RxEvent]) -&gt; Optional[float]:
    # Same definition as per-trial table: time share estimated from RX tags (sanity only; RX has drops).
    rx_itv_by_step: Dict[int, int] = {}
    for e in events:
        step = e.step_idx
        if step &lt; 0:
            continue
        tm = TAG_RE.match(e.tag)
        if tm and step not in rx_itv_by_step:
            try:
                rx_itv_by_step[step] = int(tm.group(&quot;itv&quot;))
            except Exception:
                pass
    n100 = sum(1 for v in rx_itv_by_step.values() if v == 100)
    n500 = sum(1 for v in rx_itv_by_step.values() if v == 500)
    denom_ms = n100 * 100 + n500 * 500
    if denom_ms &lt;= 0:
        return None
    return (n100 * 100) / denom_ms


def maybe_fix_policy_session_by_share(
    txsd_trials: List[TxsdTrial],
    *,
    rx_share_s1: Optional[float],
    rx_share_s4: Optional[float],
    adv_count_fixed100: Optional[float],
    adv_count_fixed500: Optional[float],
    min_confident_delta: float = 0.15,
) -&gt; None:
    # For policy trials, the TXSD filename/session tag can be wrong (preamble decode issues).
    # We estimate share100_time from adv_count and map to the closest RX-estimated share per session.
    if (
        rx_share_s1 is None
        or rx_share_s4 is None
        or adv_count_fixed100 is None
        or adv_count_fixed500 is None
        or adv_count_fixed100 &lt;= adv_count_fixed500
    ):
        return

    denom = adv_count_fixed100 - adv_count_fixed500
    for t in txsd_trials:
        if t.kind != &quot;policy&quot;:
            continue
        share_tx = (t.adv_count - adv_count_fixed500) / denom
        d1 = abs(share_tx - rx_share_s1)
        d4 = abs(share_tx - rx_share_s4)
        best_sess = 1 if d1 &lt;= d4 else 4
        best_d = min(d1, d4)
        if best_d &gt; min_confident_delta:
            continue
        t.session = best_sess


def rx_condition_key(t: RxTrial) -&gt; str:
    if t.session == 1 and t.mode == &quot;F&quot; and t.fixed_itv == 100:
        return &quot;S1_fixed100&quot;
    if t.session == 1 and t.mode == &quot;F&quot; and t.fixed_itv == 500:
        return &quot;S1_fixed500&quot;
    if t.session == 1 and t.mode == &quot;P&quot;:
        return &quot;S1_policy&quot;
    if t.session == 4 and t.mode == &quot;F&quot; and t.fixed_itv == 100:
        return &quot;S4_fixed100&quot;
    if t.session == 4 and t.mode == &quot;F&quot; and t.fixed_itv == 500:
        return &quot;S4_fixed500&quot;
    if t.session == 4 and t.mode == &quot;P&quot;:
        return &quot;S4_policy&quot;
    return &quot;UNK&quot;


def txsd_condition_key(t: TxsdTrial) -&gt; str:
    if t.session == 1 and t.kind == &quot;fixed100&quot;:
        return &quot;S1_fixed100&quot;
    if t.session == 1 and t.kind == &quot;fixed500&quot;:
        return &quot;S1_fixed500&quot;
    if t.session == 1 and t.kind == &quot;policy&quot;:
        return &quot;S1_policy&quot;
    if t.session == 4 and t.kind == &quot;fixed100&quot;:
        return &quot;S4_fixed100&quot;
    if t.session == 4 and t.kind == &quot;fixed500&quot;:
        return &quot;S4_fixed500&quot;
    if t.session == 4 and t.kind == &quot;policy&quot;:
        return &quot;S4_policy&quot;
    return &quot;UNK&quot;


def mean_std(xs: List[float]) -&gt; Tuple[float, float]:
    if not xs:
        return 0.0, 0.0
    if len(xs) == 1:
        return xs[0], 0.0
    return statistics.mean(xs), statistics.stdev(xs)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--txsd-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth-s1&quot;, type=Path, default=Path(&quot;Mode_C_2_シミュレート_causal/ccs/stress_causal_S1.csv&quot;))
    ap.add_argument(&quot;--truth-s4&quot;, type=Path, default=Path(&quot;Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv&quot;))
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    args = ap.parse_args()

    truth_s1 = read_truth_labels(args.truth_s1, args.n_steps)
    truth_s4 = read_truth_labels(args.truth_s4, args.n_steps)

    rx_trials_all: List[RxTrial] = []
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        try:
            rx_trials_all.append(read_rx_trial(p))
        except ValueError:
            continue
    rx_trials = select_balanced_window(rx_trials_all)

    # RX-derived policy share targets (used to correct TXSD session labels for policy trials).
    s1_policy_shares: List[float] = []
    s4_policy_shares: List[float] = []
    for t in rx_trials:
        if t.mode != &quot;P&quot;:
            continue
        sh = estimate_rx_tag_share100_time_est(t.events)
        if sh is None:
            continue
        k = rx_condition_key(t)
        if k == &quot;S1_policy&quot;:
            s1_policy_shares.append(sh)
        elif k == &quot;S4_policy&quot;:
            s4_policy_shares.append(sh)
    rx_share_s1 = statistics.mean(s1_policy_shares) if s1_policy_shares else None
    rx_share_s4 = statistics.mean(s4_policy_shares) if s4_policy_shares else None

    # TXSD trials
    txsd_trials: List[TxsdTrial] = []
    for p in sorted(args.txsd_dir.glob(&quot;trial_*.csv&quot;)):
        tt = parse_txsd_summary(p)
        if not tt:
            continue
        infer_txsd_kind(tt)
        if tt.ms_total &gt;= VALID_MIN_DURATION_MS:
            txsd_trials.append(tt)

    # Use fixed trials to estimate the &quot;100ms&quot; and &quot;500ms&quot; adv_count reference points.
    fixed100_counts = [float(t.adv_count) for t in txsd_trials if t.kind == &quot;fixed100&quot;]
    fixed500_counts = [float(t.adv_count) for t in txsd_trials if t.kind == &quot;fixed500&quot;]
    adv_count_fixed100 = statistics.median(fixed100_counts) if fixed100_counts else None
    adv_count_fixed500 = statistics.median(fixed500_counts) if fixed500_counts else None
    maybe_fix_policy_session_by_share(
        txsd_trials,
        rx_share_s1=rx_share_s1,
        rx_share_s4=rx_share_s4,
        adv_count_fixed100=adv_count_fixed100,
        adv_count_fixed500=adv_count_fixed500,
    )

    # Group RX/TXSD by condition
    rx_by_cond: Dict[str, List[RxTrial]] = {}
    for t in rx_trials:
        rx_by_cond.setdefault(rx_condition_key(t), []).append(t)
    for v in rx_by_cond.values():
        v.sort(key=lambda t: t.rx_id)

    tx_by_cond: Dict[str, List[TxsdTrial]] = {}
    unknown_fixed100 = [t for t in txsd_trials if t.session is None and t.kind == &quot;fixed100&quot;]
    for t in txsd_trials:
        k = txsd_condition_key(t)
        if k != &quot;UNK&quot;:
            tx_by_cond.setdefault(k, []).append(t)
    # If S1_fixed100 is short, fill from unknown fixed100 (likely preamble decode failed).
    if len(tx_by_cond.get(&quot;S1_fixed100&quot;, [])) &lt; 3 and unknown_fixed100:
        need = 3 - len(tx_by_cond.get(&quot;S1_fixed100&quot;, []))
        unknown_fixed100.sort(key=lambda t: t.trial_idx)
        tx_by_cond.setdefault(&quot;S1_fixed100&quot;, []).extend(unknown_fixed100[-need:])
    for v in tx_by_cond.values():
        v.sort(key=lambda t: (t.trial_idx, t.cond_id, t.path.name))

    args.out_dir.mkdir(parents=True, exist_ok=True)

    # Per-trial table (paired within condition by order)
    per_rows: List[Dict[str, object]] = []
    for cond, rx_list in rx_by_cond.items():
        tx_list = tx_by_cond.get(cond, [])
        # Pair by order (repeat index) if TXSD exists, else RX-only.
        n_pair = len(rx_list) if not tx_list else min(len(rx_list), len(tx_list))
        for i in range(n_pair):
            rx = rx_list[i]
            tx = tx_list[i] if i &lt; len(tx_list) else None
            truth = truth_s1 if rx.session == 1 else truth_s4

            offset_ms, offset_n = estimate_offset_ms(rx.events)

            aligned_events: List[Tuple[float, int]] = []
            step_set = set()
            # RX tag-based interval estimate (sanity only; RX has drops)
            # Count unique step_idx by interval indicated in tag (100/500).
            rx_itv_by_step: Dict[int, int] = {}
            for e in rx.events:
                step = e.step_idx
                if 0 &lt;= step &lt; args.n_steps:
                    aligned_events.append((e.rx_ms + offset_ms, truth[step]))
                    step_set.add(step)
                    tm = TAG_RE.match(e.tag)
                    if tm and step not in rx_itv_by_step:
                        try:
                            rx_itv_by_step[step] = int(tm.group(&quot;itv&quot;))
                        except Exception:
                            pass

            rx_tag_n100 = sum(1 for v in rx_itv_by_step.values() if v == 100)
            rx_tag_n500 = sum(1 for v in rx_itv_by_step.values() if v == 500)
            rx_tag_share100_time_est = &quot;&quot;
            denom_ms = rx_tag_n100 * 100 + rx_tag_n500 * 500
            if denom_ms &gt; 0:
                rx_tag_share100_time_est = (rx_tag_n100 * 100) / denom_ms

            tl_mean, tl_p95, pout = compute_tl_and_pout(truth, aligned_events)

            rx_count = len(rx.events)
            rx_unique = len(step_set)
            adv_count = tx.adv_count if tx else &quot;&quot;
            pdr_unique = (
                (min(rx_unique, adv_count) / adv_count) if isinstance(adv_count, int) and adv_count &gt; 0 else &quot;&quot;
            )

            per_rows.append(
                {
                    &quot;rx_trial_id&quot;: rx.rx_id,
                    &quot;condition&quot;: cond,
                    &quot;repeat_idx&quot;: i + 1,
                    &quot;session&quot;: rx.session,
                    &quot;mode&quot;: (&quot;POLICY&quot; if rx.mode == &quot;P&quot; else f&quot;FIXED_{rx.fixed_itv}&quot;),
                    &quot;rx_count&quot;: rx_count,
                    &quot;rx_unique&quot;: rx_unique,
                    &quot;adv_count&quot;: adv_count,
                    &quot;pdr_unique&quot;: round(pdr_unique, 6) if pdr_unique != &quot;&quot; else &quot;&quot;,
                    &quot;rx_tag_n100&quot;: rx_tag_n100,
                    &quot;rx_tag_n500&quot;: rx_tag_n500,
                    &quot;rx_tag_share100_time_est&quot;: (
                        round(rx_tag_share100_time_est, 6) if rx_tag_share100_time_est != &quot;&quot; else &quot;&quot;
                    ),
                    &quot;tl_mean_s&quot;: round(tl_mean, 6),
                    &quot;tl_p95_s&quot;: round(tl_p95, 6),
                    &quot;pout_1s&quot;: round(pout[1.0], 6),
                    &quot;pout_2s&quot;: round(pout[2.0], 6),
                    &quot;pout_3s&quot;: round(pout[3.0], 6),
                    &quot;tl_time_offset_ms&quot;: round(offset_ms, 3),
                    &quot;tl_time_offset_n&quot;: offset_n,
                    &quot;txsd_ms_total&quot;: tx.ms_total if tx else &quot;&quot;,
                    &quot;E_total_mJ&quot;: tx.e_total_mj if tx else &quot;&quot;,
                    &quot;avg_power_mW&quot;: tx.avg_power_mw if tx else &quot;&quot;,
                    &quot;txsd_path&quot;: str(tx.path) if tx else &quot;&quot;,
                    &quot;rx_path&quot;: str(rx.path),
                }
            )

    per_rows.sort(key=lambda r: int(r[&quot;rx_trial_id&quot;]))
    per_path = args.out_dir / &quot;per_trial.csv&quot;
    with per_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(per_rows[0].keys()))
        w.writeheader()
        w.writerows(per_rows)

    # Summary by condition
    by_cond: Dict[str, List[Dict[str, object]]] = {}
    for r in per_rows:
        by_cond.setdefault(str(r[&quot;condition&quot;]), []).append(r)

    summary_rows: List[Dict[str, object]] = []
    for cond, rows in sorted(by_cond.items()):
        pout_1s_list = [float(r[&quot;pout_1s&quot;]) for r in rows if r[&quot;pout_1s&quot;] != &quot;&quot;]
        tl_list = [float(r[&quot;tl_mean_s&quot;]) for r in rows if r[&quot;tl_mean_s&quot;] != &quot;&quot;]
        pdr_list = [float(r[&quot;pdr_unique&quot;]) for r in rows if r[&quot;pdr_unique&quot;] != &quot;&quot;]
        pwr_list = [float(r[&quot;avg_power_mW&quot;]) for r in rows if r[&quot;avg_power_mW&quot;] != &quot;&quot;]
        adv_list = [float(r[&quot;adv_count&quot;]) for r in rows if isinstance(r[&quot;adv_count&quot;], int)]
        share100_list = [
            float(r[&quot;rx_tag_share100_time_est&quot;]) for r in rows if r[&quot;rx_tag_share100_time_est&quot;] != &quot;&quot;
        ]

        pout_m, pout_s = mean_std(pout_1s_list)
        tl_m, tl_s = mean_std(tl_list)
        pdr_m, pdr_s = mean_std(pdr_list)
        pwr_m, pwr_s = mean_std(pwr_list)
        adv_m, adv_s = mean_std(adv_list)
        sh_m, sh_s = mean_std(share100_list)

        summary_rows.append(
            {
                &quot;condition&quot;: cond,
                &quot;n_trials&quot;: len(rows),
                &quot;pout_1s_mean&quot;: round(pout_m, 6),
                &quot;pout_1s_std&quot;: round(pout_s, 6),
                &quot;tl_mean_s_mean&quot;: round(tl_m, 6),
                &quot;tl_mean_s_std&quot;: round(tl_s, 6),
                &quot;pdr_unique_mean&quot;: round(pdr_m, 6) if pdr_list else &quot;&quot;,
                &quot;pdr_unique_std&quot;: round(pdr_s, 6) if pdr_list else &quot;&quot;,
                &quot;rx_tag_share100_time_est_mean&quot;: round(sh_m, 6) if share100_list else &quot;&quot;,
                &quot;rx_tag_share100_time_est_std&quot;: round(sh_s, 6) if share100_list else &quot;&quot;,
                &quot;avg_power_mW_mean&quot;: round(pwr_m, 3) if pwr_list else &quot;&quot;,
                &quot;avg_power_mW_std&quot;: round(pwr_s, 3) if pwr_list else &quot;&quot;,
                &quot;adv_count_mean&quot;: round(adv_m, 3) if adv_list else &quot;&quot;,
                &quot;adv_count_std&quot;: round(adv_s, 3) if adv_list else &quot;&quot;,
            }
        )

    sum_path = args.out_dir / &quot;summary_by_condition.csv&quot;
    with sum_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(summary_rows[0].keys()))
        w.writeheader()
        w.writerows(summary_rows)

    # Markdown summary
    md_path = args.out_dir / &quot;summary.md&quot;
    lines: List[str] = []
    lines.append(&quot;# uccs_d2_scan90 metrics summary\n\n&quot;)
    lines.append(f&quot;- source RX: `{args.rx_dir}`\n&quot;)
    lines.append(f&quot;- source TXSD: `{args.txsd_dir}`\n&quot;)
    lines.append(f&quot;- truth: `{args.truth_s1}`, `{args.truth_s4}` (n_steps={args.n_steps}, dt={TRUTH_DT_MS}ms)\n&quot;)

    rx_ids = [t.rx_id for t in rx_trials]
    lines.append(f&quot;- selected RX trials: {min(rx_ids):03d}..{max(rx_ids):03d} (n={len(rx_ids)})\n&quot;)
    lines.append(f&quot;- generated: {datetime.now().strftime(&apos;%Y-%m-%d %H:%M&apos;)} (local)\n&quot;)
    lines.append(
        &quot;- command: &quot;
        f&quot;`python3 uccs_d2_scan90/analysis/summarize_d2_run.py --rx-dir {args.rx_dir} --txsd-dir {args.txsd_dir} --out-dir {args.out_dir}`\n&quot;
    )

    lines.append(&quot;\n## Summary (mean ± std, n=3 each)\n&quot;)
    lines.append(&quot;| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) |\n&quot;)
    lines.append(&quot;|---|---:|---:|---:|---:|---:|---:|\n&quot;)
    for r in summary_rows:
        cond = r[&quot;condition&quot;]
        pout = f&quot;{r[&apos;pout_1s_mean&apos;]:.4f}±{r[&apos;pout_1s_std&apos;]:.4f}&quot;
        tl = f&quot;{r[&apos;tl_mean_s_mean&apos;]:.3f}±{r[&apos;tl_mean_s_std&apos;]:.3f}&quot;
        pdr = (
            f&quot;{r[&apos;pdr_unique_mean&apos;]:.3f}±{r[&apos;pdr_unique_std&apos;]:.3f}&quot;
            if r[&quot;pdr_unique_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        pwr = (
            f&quot;{r[&apos;avg_power_mW_mean&apos;]:.1f}±{r[&apos;avg_power_mW_std&apos;]:.1f}&quot;
            if r[&quot;avg_power_mW_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        adv = (
            f&quot;{r[&apos;adv_count_mean&apos;]:.1f}±{r[&apos;adv_count_std&apos;]:.1f}&quot;
            if r[&quot;adv_count_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        sh = (
            f&quot;{r[&apos;rx_tag_share100_time_est_mean&apos;]:.3f}±{r[&apos;rx_tag_share100_time_est_std&apos;]:.3f}&quot;
            if r[&quot;rx_tag_share100_time_est_mean&quot;] != &quot;&quot;
            else &quot;&quot;
        )
        lines.append(f&quot;| {cond} | {pout} | {tl} | {pdr} | {pwr} | {adv} | {sh} |\n&quot;)

    lines.append(&quot;\n## Notes\n&quot;)
    lines.append(&quot;- RX trial selection: latest 18 trials that form 6 conditions × 3 repeats (duration&gt;=160s).\n&quot;)
    lines.append(&quot;- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).\n&quot;)
    lines.append(&quot;- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique when available.\n&quot;)
    lines.append(&quot;- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).\n&quot;)

    md_path.write_text(&quot;&quot;.join(lines), encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d3_scan70/analysis/plot_power_vs_pout.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Plot Step D3 tradeoff: avg_power_mW vs pout_1s with share100 annotation (S4 only).
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import os
from pathlib import Path
from typing import Dict, Optional, Tuple


def f_or_none(v: str) -&gt; Optional[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary_by_condition(path: Path) -&gt; Dict[str, Dict[str, Optional[float]]]:
    out: Dict[str, Dict[str, Optional[float]]] = {}
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            out[cond] = {
                &quot;pout_1s_mean&quot;: f_or_none(row.get(&quot;pout_1s_mean&quot;) or &quot;&quot;),
                &quot;pout_1s_std&quot;: f_or_none(row.get(&quot;pout_1s_std&quot;) or &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: f_or_none(row.get(&quot;avg_power_mW_mean&quot;) or &quot;&quot;),
                &quot;avg_power_mW_std&quot;: f_or_none(row.get(&quot;avg_power_mW_std&quot;) or &quot;&quot;),
                &quot;adv_count_mean&quot;: f_or_none(row.get(&quot;adv_count_mean&quot;) or &quot;&quot;),
                &quot;rx_share100_mean&quot;: f_or_none(row.get(&quot;rx_tag_share100_time_est_mean&quot;) or &quot;&quot;),
                &quot;share100_power_mix_mean&quot;: f_or_none(row.get(&quot;share100_power_mix_mean&quot;) or &quot;&quot;),
            }
    return out


def compute_share100_from_adv(
    adv_count_policy: Optional[float],
    adv_count_fixed100: Optional[float],
    adv_count_fixed500: Optional[float],
) -&gt; Optional[float]:
    if (
        adv_count_policy is None
        or adv_count_fixed100 is None
        or adv_count_fixed500 is None
        or adv_count_fixed100 &lt;= adv_count_fixed500
    ):
        return None
    return (adv_count_policy - adv_count_fixed500) / (adv_count_fixed100 - adv_count_fixed500)


def get_point(
    rows: Dict[str, Dict[str, Optional[float]]],
    key: str,
) -&gt; Tuple[float, float, float, float, Optional[float], Optional[float]]:
    r = rows.get(key, {})
    x = r.get(&quot;avg_power_mW_mean&quot;)
    y = r.get(&quot;pout_1s_mean&quot;)
    if x is None or y is None:
        raise SystemExit(f&quot;missing required metrics for {key} in summary csv&quot;)
    xerr = r.get(&quot;avg_power_mW_std&quot;) or 0.0
    yerr = r.get(&quot;pout_1s_std&quot;) or 0.0
    adv = r.get(&quot;adv_count_mean&quot;)
    rx_share = r.get(&quot;rx_share100_mean&quot;)
    return float(x), float(y), float(xerr), float(yerr), adv, rx_share


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--summary-csv&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out&quot;, type=Path, required=True)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;&quot;)
    args = ap.parse_args()

    repo_root = Path.cwd()
    xdg_cache = repo_root / &quot;.cache&quot;
    xdg_cache.mkdir(exist_ok=True)
    os.environ.setdefault(&quot;XDG_CACHE_HOME&quot;, str(xdg_cache))
    mpl_dir = repo_root / &quot;.mplconfig&quot;
    mpl_dir.mkdir(exist_ok=True)
    os.environ.setdefault(&quot;MPLCONFIGDIR&quot;, str(mpl_dir))

    import matplotlib

    matplotlib.use(&quot;Agg&quot;)
    import matplotlib.pyplot as plt  # type: ignore

    rows = read_summary_by_condition(args.summary_csv)

    k100 = &quot;S4_fixed100&quot;
    k500 = &quot;S4_fixed500&quot;
    kpol = &quot;S4_policy&quot;

    x100, y100, x100e, y100e, adv100, _ = get_point(rows, k100)
    x500, y500, x500e, y500e, adv500, _ = get_point(rows, k500)
    xpol, ypol, xpole, ypole, advpol, rx_share_pol = get_point(rows, kpol)
    share_mix = rows.get(kpol, {}).get(&quot;share100_power_mix_mean&quot;)

    fig, ax = plt.subplots(figsize=(7.0, 4.6))
    ax.errorbar([x100, x500], [y100, y500], xerr=[x100e, x500e], yerr=[y100e, y500e],
                fmt=&quot;s&quot;, ms=7, color=&quot;#1f77b4&quot;, capsize=3, linestyle=&quot;none&quot;, label=&quot;fixed&quot;)
    ax.errorbar([xpol], [ypol], xerr=[xpole], yerr=[ypole],
                fmt=&quot;o&quot;, ms=8, color=&quot;#ff7f0e&quot;, capsize=3, linestyle=&quot;none&quot;, label=&quot;policy (U+CCS)&quot;)

    share = share_mix if share_mix is not None else compute_share100_from_adv(advpol, adv100, adv500)
    if share is None:
        share = rx_share_pol
    if share is not None:
        ax.annotate(f&quot;share100≈{share:.2f}&quot;, (xpol, ypol), textcoords=&quot;offset points&quot;, xytext=(8, 8), ha=&quot;left&quot;, fontsize=10, color=&quot;#ff7f0e&quot;)

    ax.annotate(&quot;100&quot;, (x100, y100), textcoords=&quot;offset points&quot;, xytext=(6, -12), fontsize=9, color=&quot;#1f77b4&quot;)
    ax.annotate(&quot;500&quot;, (x500, y500), textcoords=&quot;offset points&quot;, xytext=(6, -12), fontsize=9, color=&quot;#1f77b4&quot;)

    ax.set_xlabel(&quot;avg_power_mW (TXSD)&quot;)
    ax.set_ylabel(&quot;pout_1s&quot;)
    ax.grid(True, alpha=0.3)
    ax.set_title(args.title.strip() or f&quot;{args.summary_csv.parent.name}: avg_power vs pout_1s (D3 scan70, S4)&quot;)
    ax.legend(loc=&quot;best&quot;, frameon=True, fontsize=9)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    if args.out.suffix.lower() == &quot;.png&quot;:
        fig.savefig(args.out.with_suffix(&quot;.pdf&quot;))


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d3_scan70/metrics/01/summary_by_condition.csv">condition,n_trials,pout_1s_mean,pout_1s_std,tl_mean_s_mean,tl_mean_s_std,pdr_unique_mean,pdr_unique_std,rx_tag_share100_time_est_mean,rx_tag_share100_time_est_std,avg_power_mW_mean,avg_power_mW_std,adv_count_mean,adv_count_std,share100_power_mix_mean
S4_fixed100,3,0.06504,0.028164,1.342335,0.024927,0.304009,0.017062,1.0,0.0,209.878,0.538,1796.0,0.0,
S4_fixed500,3,0.284553,0.061381,2.928056,1.065527,0.651811,0.00737,0.000569,0.000493,189.54,0.473,359.0,0.0,
S4_policy,3,0.089431,0.037257,1.399779,0.070647,0.342841,0.016985,0.419939,0.017927,202.117,0.106,1227.0,0.0,0.618399</file><file path="uccs_d3_scan70/metrics/01/summary.md"># uccs_d3_scan70 metrics summary (v2)

- source RX: `uccs_d3_scan70/data/01/RX`
- source TXSD: `uccs_d3_scan70/data/01/TX`
- truth: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv` (n_steps=1800, dt=100ms)
- selected RX trials: 010..018 (n=9)
- selected TXSD trials: grouped by adv_count=[359, 1227, 1796] (n=9)
- generated: 2025-12-16 20:57 (local)
- command: `python3 uccs_d3_scan70/analysis/summarize_d3_run_v2.py --rx-dir uccs_d3_scan70/data/01/RX --txsd-dir uccs_d3_scan70/data/01/TX --out-dir uccs_d3_scan70/metrics/01`

## Summary (mean ± std)
| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) | share100_power_mix |
|---|---:|---:|---:|---:|---:|---:|---:|
| S4_fixed100 | 0.0650±0.0282 | 1.342±0.025 | 0.304±0.017 | 209.9±0.5 | 1796.0±0.0 | 1.000±0.000 |  |
| S4_fixed500 | 0.2846±0.0614 | 2.928±1.066 | 0.652±0.007 | 189.5±0.5 | 359.0±0.0 | 0.001±0.000 |  |
| S4_policy | 0.0894±0.0373 | 1.400±0.071 | 0.343±0.017 | 202.1±0.1 | 1227.0±0.0 | 0.420±0.018 | 0.618 |

## Notes
- RX window: latest 9 trials that form 3 conditions × 3 repeats (duration&gt;=160s).
- TXSD pairing: mtimeが信頼できないため、adv_count（tick_count）でクラスタリングして各条件3本を割り当て。
  - filter: avg_power_mW &gt;= 150.0（古いログ混在を除外）
- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).
- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique.
- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).</file><file path="uccs_d3_scan70/src/rx/RX_UCCS_D3_SCAN70/RX_UCCS_D3_SCAN70.ino">// RX_UCCS_D3_SCAN70.ino (uccs_d3_scan70)
// Receive TX_UCCS_D3 packets (MFD &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;) and log to SD.
// - SYNC gate: TX GPIO25 -&gt; RX GPIO26.
// - NimBLE passive scan with scan70% (interval=100ms, window=70ms).

#include &lt;Arduino.h&gt;
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;NimBLEDevice.h&gt;
#include &lt;math.h&gt;

static const int SD_CS   = 5;
static const int SD_SCK  = 18;
static const int SD_MISO = 19;
static const int SD_MOSI = 23;
static const int SYNC_IN = 26; // TX GPIO25 -&gt; RX GPIO26

// scan70
static const float SCAN_INTERVAL_MS = 100.0f;
static const float SCAN_WINDOW_MS   = 70.0f;

static const uint32_t SESSION_TIMEOUT_MS = 1200000;
static const uint32_t SYNC_LOW_DEBOUNCE_MS = 100;
static const uint32_t START_LEVEL_HOLD_MS = 200;

static inline uint16_t ms_to_0p625(float ms){ return (uint16_t)lroundf(ms / 0.625f); }

static const uint16_t RX_BUF_SIZE = 512;
static const uint32_t FLUSH_INTERVAL_MS = 500;

struct RxEntry {
  uint32_t ms;
  int8_t   rssi;
  uint16_t seq;
  char     label[16];
  char     addr[18];
  char     mfd[40];
};

static RxEntry rxBuf[RX_BUF_SIZE];
static volatile uint16_t rxHead = 0;
static uint16_t rxTail = 0;
static uint32_t bufOverflow = 0;
static uint32_t lastFlushMs = 0;

static bool trial = false;
static uint32_t t0Ms = 0;
static uint32_t rxCount = 0;
static uint32_t syncLowSince = 0;
static uint32_t syncHighSince = 0;

static File f;
static const char FW_TAG[] = &quot;RX_UCCS_D3_SCAN70&quot;;
static bool condSeen = false;
static bool condWritten = false;
static char condLabel[16] = {0};

static bool parseMFD(const std::string&amp; s, uint16_t&amp; seq, std::string&amp; label) {
  size_t usPos = s.find(&apos;_&apos;);
  if (usPos == std::string::npos || usPos &lt; 1) return false;
  std::string seqStr = s.substr(0, usPos);
  label = s.substr(usPos + 1);
  if (label.empty()) return false;
  char* endp = nullptr;
  unsigned long v = strtoul(seqStr.c_str(), &amp;endp, 10);
  if (endp == seqStr.c_str() || v &gt; 65535UL) return false;
  seq = static_cast&lt;uint16_t&gt;(v);
  return true;
}

static String nextPath() {
  SD.mkdir(&quot;/logs&quot;);
  char p[64];
  for (uint32_t id = 1;; ++id) {
    snprintf(p, sizeof(p), &quot;/logs/rx_trial_%03lu.csv&quot;, (unsigned long)id);
    if (!SD.exists(p)) return String(p);
  }
}

static void flushBuffer() {
  if (!f) return;
  if (!condWritten &amp;&amp; condSeen) {
    f.printf(&quot;# condition_label=%s\r\n&quot;, condLabel);
    condWritten = true;
  }
  uint16_t head = rxHead;
  bool wrote = false;
  while (rxTail != head) {
    RxEntry&amp; e = rxBuf[rxTail];
    f.printf(&quot;%lu,ADV,%d,%u,%s,%s,%s\r\n&quot;,
             (unsigned long)e.ms,
             (int)e.rssi,
             (unsigned)e.seq,
             e.label,
             e.addr,
             e.mfd);
    rxTail = (rxTail + 1) % RX_BUF_SIZE;
    wrote = true;
  }
  if (wrote) f.flush();
}

static void startSession() {
  String path = nextPath();
  f = SD.open(path, FILE_WRITE);
  if (f) {
    f.println(&quot;ms,event,rssi,seq,label,addr,mfd&quot;);
    f.printf(&quot;# meta, firmware=%s, buf_size=%u\r\n&quot;, FW_TAG, (unsigned)RX_BUF_SIZE);
    f.printf(&quot;# meta, scan_interval_ms=%.1f, scan_window_ms=%.1f\r\n&quot;, SCAN_INTERVAL_MS, SCAN_WINDOW_MS);
    f.flush();
  }
  t0Ms = millis();
  rxCount = 0;
  rxHead = rxTail = 0;
  bufOverflow = 0;
  lastFlushMs = t0Ms;
  condSeen = false;
  condWritten = false;
  condLabel[0] = &apos;\0&apos;;
  Serial.printf(&quot;[RX] start %s\n&quot;, path.c_str());
  trial = true;
}

static void endSession() {
  if (!trial) return;
  flushBuffer();
  if (f) { f.flush(); f.close(); }
  uint32_t t_ms = millis() - t0Ms;
  double dur_s = t_ms / 1000.0;
  double rate_hz = dur_s &gt; 0 ? (double)rxCount / dur_s : 0.0;
  Serial.printf(&quot;[RX] end ms_total=%lu rx=%lu buf_overflow=%lu rate_hz=%.2f\n&quot;,
                (unsigned long)t_ms,
                (unsigned long)rxCount,
                (unsigned long)bufOverflow,
                rate_hz);
  trial = false;
}

class AdvCB : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* d) override {
    if (!trial) return;
    const std::string&amp; mfd = d-&gt;getManufacturerData();
    uint16_t seq;
    std::string label;
    if (!parseMFD(mfd, seq, label)) return;
    if (!condSeen) {
      strncpy(condLabel, label.c_str(), sizeof(condLabel) - 1);
      condLabel[sizeof(condLabel) - 1] = &apos;\0&apos;;
      condSeen = true;
    }
    const std::string addr = d-&gt;getAddress().toString();

    uint16_t nextH = (rxHead + 1) % RX_BUF_SIZE;
    if (nextH == rxTail) { bufOverflow++; return; }

    RxEntry&amp; e = rxBuf[rxHead];
    e.ms = millis() - t0Ms;
    e.rssi = (int8_t)d-&gt;getRSSI();
    e.seq = seq;
    strncpy(e.label, label.c_str(), sizeof(e.label) - 1);
    e.label[sizeof(e.label) - 1] = &apos;\0&apos;;
    strncpy(e.addr, addr.c_str(), sizeof(e.addr) - 1);
    e.addr[sizeof(e.addr) - 1] = &apos;\0&apos;;
    strncpy(e.mfd, mfd.c_str(), sizeof(e.mfd) - 1);
    e.mfd[sizeof(e.mfd) - 1] = &apos;\0&apos;;

    rxHead = nextH;
    rxCount++;
  }
};

static NimBLEScan* scan = nullptr;
static AdvCB cb;

void setup() {
  Serial.begin(115200);
  Serial.printf(&quot;[RX] FW=%s\n&quot;, FW_TAG);

  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) {
    Serial.println(&quot;[RX] SD init FAIL&quot;);
    while (1) delay(1000);
  }

  pinMode(SYNC_IN, INPUT_PULLDOWN);

  NimBLEDevice::init(&quot;&quot;);
  scan = NimBLEDevice::getScan();
  // NimBLE-Arduino API compatibility:
  // Prefer setScanCallbacks (available on older/newer). If your NimBLE build only has
  // setAdvertisedDeviceCallbacks, replace this line with:
  //   scan-&gt;setAdvertisedDeviceCallbacks(&amp;cb);
  scan-&gt;setScanCallbacks(&amp;cb, false);
  scan-&gt;setActiveScan(false);
  scan-&gt;setInterval(ms_to_0p625(SCAN_INTERVAL_MS));
  scan-&gt;setWindow(ms_to_0p625(SCAN_WINDOW_MS));
  scan-&gt;setMaxResults(0);
  // start(duration_s, isContinue, restart)
  scan-&gt;start(0, false, false);

  Serial.printf(&quot;[RX] ready (buf=%u, flush=%lums, wait SYNC pin=%d)\n&quot;,
                (unsigned)RX_BUF_SIZE, (unsigned long)FLUSH_INTERVAL_MS, SYNC_IN);
}

void loop() {
  uint32_t nowMs = millis();
  int syncIn = digitalRead(SYNC_IN);

  if (!trial) {
    if (syncIn == HIGH) {
      if (syncHighSince == 0) syncHighSince = nowMs;
      if ((nowMs - syncHighSince) &gt;= START_LEVEL_HOLD_MS) {
        startSession();
        syncHighSince = 0;
        syncLowSince = 0;
      }
    } else {
      syncHighSince = 0;
    }
    vTaskDelay(pdMS_TO_TICKS(10));
    return;
  }

  if ((nowMs - lastFlushMs) &gt;= FLUSH_INTERVAL_MS) {
    flushBuffer();
    lastFlushMs = nowMs;
  }

  if (syncIn == LOW) {
    if (syncLowSince == 0) syncLowSince = nowMs;
    if ((nowMs - syncLowSince) &gt;= SYNC_LOW_DEBOUNCE_MS) {
      endSession();
      syncLowSince = 0;
    }
  } else {
    syncLowSince = 0;
  }

  if ((nowMs - t0Ms) &gt;= SESSION_TIMEOUT_MS) {
    endSession();
  }

  vTaskDelay(pdMS_TO_TICKS(10));
}</file><file path="uccs_d3_scan70/README.md"># uccs_d3_scan70（D3: scan duty を 90%→70% に落として適応性確認）

- 目的: `scan90`（良条件）で強い `Fixed500` が崩れる条件を作り、`Policy(100↔500)` が **必要時だけ100msに寄って耐える**ことを示す。
- スコープ: **S4のみ**（差が出やすい）
- 条件: `Fixed100 / Fixed500 / Policy(U+CCS, 100↔500)` × `n=3`
- RX設定: scan70%（interval=100ms, window=70ms）

## 結論（レター用の置き方）

scan70 / S4 では **Fixed500 がQoSで崩れる**一方、`Policy` は **Fixed500よりQoSを改善しつつ、Fixed100より低電力**という「中間解」を維持できた。

- Fixed500 がQoSで崩れる: `pout_1s = 0.2846 ± 0.0614`
- Policy は Fixed500 より改善: `pout_1s = 0.0894 ± 0.0373`
- Policy は Fixed100 より省電力（ただし Fixed500 より高電力）
  - power: Fixed100 `209.9±0.5` → Policy `202.1±0.1`（`-7.8 mW`, 約 `-3.7%`）
  - Fixed500 `189.5±0.5` → Policy（Fixed500比 `+12.6 mW`）

制約として `δ=0.1`（例: `Pout(1s) ≤ 0.1`）を置くと、scan70では

- Fixed500 は **不適**（`pout_1s &gt; 0.1`）
- Fixed100 は **適**だが高電力
- Policy は **適**かつ Fixed100 より低電力

→ D3の価値は「悪条件で Fixed500 が使えない状況を作って、policy が“100ms張り付きではない中間解”として意味を持つ」ことを実機で示せた点。

## ディレクトリ構成

- `uccs_d3_scan70/src/`
  - `tx/` : `TX_UCCS_D3_SCAN70`（Arduino）
  - `rx/` : `RX_UCCS_D3_SCAN70`（Arduino）
  - `txsd/`: `TXSD_UCCS_D3_SCAN70`（Arduino）
- `uccs_d3_scan70/data/01/`
  - `RX/` と `TX/`（TXSDのSD `/logs/` を `TX/` にコピー）

## 配線（D2/D4と同じ）

- TX GPIO25 → RX GPIO26（SYNC）
- TX GPIO25 → TXSD GPIO26（SYNC）
- TX GPIO27 → TXSD GPIO33（TICK）

## 実行手順（ME）

1. Arduino IDEで書き込み（フォルダ名=スケッチ名）
   - TX: `uccs_d3_scan70/src/tx/TX_UCCS_D3_SCAN70/TX_UCCS_D3_SCAN70.ino`
   - RX: `uccs_d3_scan70/src/rx/RX_UCCS_D3_SCAN70/RX_UCCS_D3_SCAN70.ino`
   - TXSD: `uccs_d3_scan70/src/txsd/TXSD_UCCS_D3_SCAN70/TXSD_UCCS_D3_SCAN70.ino`
2. 自動で `S4 × (Fixed100 → Fixed500 → Policy) × 3回` が流れる。
3. SDカードの `/logs/` を回収し、以下へコピー
   - RX側: `uccs_d3_scan70/data/01/RX/`
   - TXSD側: `uccs_d3_scan70/data/01/TX/`

## 期待される結果（成功条件）

- `Fixed500` の `pout_1s` / `tl_mean_s` が scan90 より悪化
- `Policy` が `Fixed500` よりQoSを改善しつつ、`Fixed100` より平均電力が下がる（または同程度）

## 出力（run01）

- 集計: `uccs_d3_scan70/metrics/01/summary.md`
- 図: `uccs_d3_scan70/plots/d3_01_power_vs_pout.png`

### share100 推定の注意（scan70では重要）

scan70では 100ms 側の取りこぼしが増えるため、`share100_time_est (RX tags)` は **系統的に過小評価**になりやすい。

そのため本実験では、`TXSD avg_power_mW` から **power-mix** で `share100_power_mix` を推定して併記している。

- 推定式（S4_policy）: `share100_power_mix ≈ (P_policy - P_500) / (P_100 - P_500)`
- run01の結果: `share100_power_mix≈0.618`（RX tags推定 `≈0.420` より大きい）</file><file path="uccs_d4_scan90/src/tx/TX_UCCS_D4_SCAN90/TX_UCCS_D4_SCAN90.ino">// TX_UCCS_D4_SCAN90.ino (uccs_d4_scan90)
//
// Step D4（Uが効いている切り分け / Ablation）
// - S4のみを再生し、4条件×REPEAT回を自動実行する。
//   1) Fixed100
//   2) Fixed500
//   3) Policy(U+CCS, 100↔500)
//   4) Ablation(U-shuffle: Uの分布は同じ、時間相関だけ破壊)
//
// D2/D2bと同様に、動的でもTL/Poutが評価できるよう payload に step_idx（100msグリッド）を埋め込む。
// TXSDへは SYNC(25) + preamble TICK(27) で cond_id を通知し、trial中は更新ごとにTICKを1発出して adv_count近似とする。
//
// Payload (ManufacturerData):
//   &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
//     tag: &quot;F4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;A4-&lt;label&gt;-&lt;itv&gt;&quot;
//
// Note:
// - `stress_causal_*` の CCS は「安定度（高いほどstable）」なので、changeとして扱うため `CCS_change = 1-CCS` に変換する。
// - U-shuffle は quantized U（uint8）列を Fisher-Yates でシャッフルしたものを使用（固定seed）。

#include &lt;Arduino.h&gt;
#include &lt;BLEDevice.h&gt;
#include &lt;math.h&gt;

#ifdef ARDUINO_ARCH_ESP32
#include &quot;esp_pm.h&quot;
#endif

#include &quot;../stress_causal_s1_s4_180s.h&quot;

// ==== スケジュール ====
static const uint32_t GAP_MS = 5000;
static const uint8_t REPEAT = 3;
static const uint16_t EFFECTIVE_LEN_STEPS = 1800; // 100ms grid (&lt;=STRESS_CAUSAL_LEN)

// ==== ピン ====
static const int SYNC_OUT_PIN = 25;
static const int TICK_OUT_PIN = 27;
static const int LED_PIN = 2;

// ==== オプション ====
static const bool USE_LED = false;
static const bool ENABLE_TICK_PREAMBLE = true;
static const bool ENABLE_TICK_PER_UPDATE = true;
static const bool RESTART_ADV_ON_INTERVAL_CHANGE = true;

static const uint32_t PREAMBLE_WINDOW_MS = 800; // TXSD window
static const uint32_t PREAMBLE_GUARD_MS = 100;  // wait after SYNC HIGH before preamble

// ==== actions（実機は100↔500に固定） ====
static const uint16_t ACTIONS[] = {100, 500};
static const uint8_t N_ACTIONS = sizeof(ACTIONS) / sizeof(ACTIONS[0]);

// ==== 代表ポリシー（D2bと同一） ====
static const float U_MID = 0.20f;
static const float U_HIGH = 0.35f;
static const float C_MID = 0.20f;
static const float C_HIGH = 0.35f;
static const float HYST = 0.02f;
static const float EMA_ALPHA = 0.20f;

// ==== BLE ====
static BLEAdvertising* adv = nullptr;

#ifdef ARDUINO_ARCH_ESP32
static esp_pm_lock_handle_t noLightSleepLock = nullptr;
static bool sleepBlocked = false;
#endif

enum Mode : uint8_t {
  MODE_FIXED = 0,
  MODE_POLICY = 1,
  MODE_ABL_U_SHUF = 2,
};

struct Condition {
  uint8_t cond_id;   // TXSD preamble pulses
  Mode mode;
  uint16_t fixed_ms; // MODE_FIXED only
};

// cond_id:
//  1: S4 fixed100
//  2: S4 fixed500
//  3: S4 policy (U+CCS)
//  4: S4 ablation (U-shuffle)
static const Condition CONDS[] = {
  {1, MODE_FIXED, 100},
  {2, MODE_FIXED, 500},
  {3, MODE_POLICY, 500},
  {4, MODE_ABL_U_SHUF, 500},
};
static const uint8_t N_CONDS = sizeof(CONDS) / sizeof(CONDS[0]);

// state
static bool trialRunning = false;
static bool pendingStart = false;
static uint32_t syncRiseMs = 0;
static uint32_t trialStartMs = 0;
static uint32_t nextUpdateMs = 0;
static uint32_t gapStartMs = 0;
static uint8_t condIndex = 0;
static uint8_t repIndex = 0;

static uint16_t stepIdx = 0;
static uint16_t currentIntervalMs = 500;
static float uEma = 0.0f;
static float cEma = 0.0f;

// U-shuffle（quantized U列をシャッフル）
static uint8_t S4_U_SHUF_Q[STRESS_CAUSAL_LEN];
static bool uShufReady = false;
static uint32_t rngState = 0xD4B40201u;

static inline uint32_t xorshift32() {
  uint32_t x = rngState;
  x ^= x &lt;&lt; 13;
  x ^= x &gt;&gt; 17;
  x ^= x &lt;&lt; 5;
  rngState = x;
  return x;
}

static void initUShuffle() {
  // copy
  for (uint16_t i = 0; i &lt; STRESS_CAUSAL_LEN; i++) {
    S4_U_SHUF_Q[i] = pgm_read_byte(&amp;S4_U_Q[i]);
  }
  // Fisher-Yates
  for (int i = (int)STRESS_CAUSAL_LEN - 1; i &gt; 0; i--) {
    uint32_t j = xorshift32() % (uint32_t)(i + 1);
    uint8_t tmp = S4_U_SHUF_Q[i];
    S4_U_SHUF_Q[i] = S4_U_SHUF_Q[j];
    S4_U_SHUF_Q[j] = tmp;
  }
  uShufReady = true;
}

static inline uint16_t ms_to_0p625(float ms) {
  long v = lroundf(ms / 0.625f);
  if (v &lt; 0x20) v = 0x20;     // 20ms minimum
  if (v &gt; 0x4000) v = 0x4000; // 10.24s maximum
  return (uint16_t)v;
}

static uint16_t clamp_interval(uint16_t interval_ms) {
  uint16_t best = ACTIONS[0];
  uint32_t bestDist = (uint32_t)abs((int)interval_ms - (int)best);
  for (uint8_t i = 1; i &lt; N_ACTIONS; i++) {
    uint16_t a = ACTIONS[i];
    uint32_t d = (uint32_t)abs((int)interval_ms - (int)a);
    if (d &lt; bestDist || (d == bestDist &amp;&amp; a &lt; best)) {
      best = a;
      bestDist = d;
    }
  }
  return best;
}

static void syncStart() {
  if (USE_LED) digitalWrite(LED_PIN, HIGH);
  digitalWrite(SYNC_OUT_PIN, HIGH);
}

static void syncEnd() {
  digitalWrite(SYNC_OUT_PIN, LOW);
  if (USE_LED) digitalWrite(LED_PIN, LOW);
}

static void tickPulseOnce(uint16_t high_us = 200) {
  digitalWrite(TICK_OUT_PIN, HIGH);
  delayMicroseconds(high_us);
  digitalWrite(TICK_OUT_PIN, LOW);
}

static void tickPreamble(uint8_t nPulses) {
  if (!ENABLE_TICK_PREAMBLE) return;
  for (uint8_t i = 0; i &lt; nPulses; i++) {
    tickPulseOnce(200);
    delay(20);
  }
}

static void setAdvIntervalMs(uint16_t ms) {
  if (!adv) return;
  uint16_t units = ms_to_0p625((float)ms);
  adv-&gt;setMinInterval(units);
  adv-&gt;setMaxInterval(units);
}

static void setPayload(uint16_t step_idx, const char* tag) {
  if (!adv) return;
  BLEAdvertisementData ad;
  String mfd = String((unsigned)step_idx) + &quot;_&quot; + String(tag);
  ad.setManufacturerData(mfd);
  adv-&gt;setAdvertisementData(ad);
}

static void setSleepAllowed(bool allowLightSleep) {
#ifdef ARDUINO_ARCH_ESP32
  if (!noLightSleepLock) return;
  if (allowLightSleep) {
    if (sleepBlocked) {
      esp_pm_lock_release(noLightSleepLock);
      sleepBlocked = false;
    }
  } else {
    if (!sleepBlocked) {
      esp_pm_lock_acquire(noLightSleepLock);
      sleepBlocked = true;
    }
  }
#else
  (void)allowLightSleep;
#endif
}

static inline uint8_t getLabel(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0;
  return pgm_read_byte(&amp;S4_LABEL[idx]);
}

static inline float getU(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_U_Q[idx]);
  return q_to_f(q);
}

static inline float getUShuf(uint16_t idx) {
  if (!uShufReady || idx &gt;= STRESS_CAUSAL_LEN) return getU(idx);
  return q_to_f(S4_U_SHUF_Q[idx]);
}

static inline float getCCSStable(uint16_t idx) {
  if (idx &gt;= STRESS_CAUSAL_LEN) return 0.0f;
  uint8_t q = pgm_read_byte(&amp;S4_CCS_Q[idx]);
  return q_to_f(q);
}

static uint16_t policyStep(uint16_t prevInterval, float u, float c_change) {
  const float u_hi_up = U_HIGH;
  const float c_hi_up = C_HIGH;
  const float u_mid_down = U_MID - HYST;
  const float c_mid_down = C_MID - HYST;

  uint16_t next = prevInterval;
  if (prevInterval == 500) {
    if ((u &gt;= u_hi_up) || (c_change &gt;= c_hi_up)) next = 100;
  } else { // prevInterval == 100
    if ((u &lt; u_mid_down) &amp;&amp; (c_change &lt; c_mid_down)) next = 500;
  }
  return clamp_interval(next);
}

static void applyInterval(uint16_t nextMs) {
  if (nextMs == currentIntervalMs) return;
  currentIntervalMs = nextMs;
  if (!adv) return;
  if (RESTART_ADV_ON_INTERVAL_CHANGE) {
    adv-&gt;stop();
    setAdvIntervalMs(currentIntervalMs);
    adv-&gt;start();
  } else {
    setAdvIntervalMs(currentIntervalMs);
  }
}

static void makeTag(char* out, size_t out_sz, const Condition&amp; c, uint8_t truthLabel, uint16_t intervalMs) {
  const char mp = (c.mode == MODE_FIXED) ? &apos;F&apos; : ((c.mode == MODE_POLICY) ? &apos;P&apos; : &apos;A&apos;);
  const unsigned lbl = (unsigned)truthLabel;
  const unsigned itv = (unsigned)intervalMs;
  snprintf(out, out_sz, &quot;%c4-%02u-%u&quot;, mp, lbl, itv);
}

static void beginCondition(const Condition&amp; c) {
  stepIdx = 0;
  uEma = 0.0f;
  cEma = 0.0f;
  currentIntervalMs = (c.mode == MODE_FIXED) ? c.fixed_ms : 500;
  currentIntervalMs = clamp_interval(currentIntervalMs);

  if (adv) adv-&gt;stop();
  setAdvIntervalMs(currentIntervalMs);

  setSleepAllowed(true);

  syncStart();
  syncRiseMs = millis();
  delay(PREAMBLE_GUARD_MS);
  tickPreamble(c.cond_id);
  pendingStart = true;
}

static void startTrialNow(const Condition&amp; c) {
  trialStartMs = millis();
  trialRunning = true;

  const uint8_t lbl = getLabel(0);
  char tag[20];
  makeTag(tag, sizeof(tag), c, lbl, currentIntervalMs);
  setPayload(0, tag);

  if (adv) adv-&gt;start();
  if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);
  // Allow the 800ms preamble window on TXSD to elapse before we start counting per-update ticks.
  // Without this, the first update tick may be counted as an extra preamble pulse (cond_id becomes +1).
  if (ENABLE_TICK_PREAMBLE) delay(PREAMBLE_WINDOW_MS);

  const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
  stepIdx = (uint16_t)(stepIdx + deltaSteps);
  nextUpdateMs = millis() + currentIntervalMs;
}

static void endTrial() {
  trialRunning = false;
  pendingStart = false;
  if (adv) adv-&gt;stop();
  syncEnd();
  gapStartMs = millis();
}

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  pinMode(SYNC_OUT_PIN, OUTPUT);
  digitalWrite(SYNC_OUT_PIN, LOW);
  pinMode(TICK_OUT_PIN, OUTPUT);
  digitalWrite(TICK_OUT_PIN, LOW);

  initUShuffle();

  BLEDevice::init(&quot;TX_UCCS_D4_SCAN90&quot;);
  BLEDevice::setPower(ESP_PWR_LVL_N0);
  adv = BLEDevice::getAdvertising();
  adv-&gt;setScanResponse(false);
  adv-&gt;setMinPreferred(0);

#ifdef ARDUINO_ARCH_ESP32
  (void)esp_pm_lock_create(ESP_PM_NO_LIGHT_SLEEP, 0, &quot;uccs_d4&quot;, &amp;noLightSleepLock);
#endif

  condIndex = 0;
  repIndex = 0;
  gapStartMs = 0;
  trialRunning = false;
  pendingStart = false;

  beginCondition(CONDS[condIndex]);
}

void loop() {
  const uint32_t nowMs = millis();
  const Condition&amp; c = CONDS[condIndex];

  if (pendingStart) {
    if ((nowMs - syncRiseMs) &gt;= PREAMBLE_WINDOW_MS) {
      pendingStart = false;
      startTrialNow(c);
    } else {
      vTaskDelay(1);
      return;
    }
  }

  if (trialRunning) {
    if (stepIdx &gt;= EFFECTIVE_LEN_STEPS) {
      endTrial();
      vTaskDelay(pdMS_TO_TICKS(50));
      return;
    }

    if ((int32_t)(nowMs - nextUpdateMs) &gt;= 0) {
      const uint8_t truthLabel = getLabel(stepIdx);

      if (c.mode == MODE_POLICY || c.mode == MODE_ABL_U_SHUF) {
        const float uRaw = (c.mode == MODE_ABL_U_SHUF) ? getUShuf(stepIdx) : getU(stepIdx);
        const float cStable = getCCSStable(stepIdx);
        const float cChange = 1.0f - cStable;
        uEma = EMA_ALPHA * uRaw + (1.0f - EMA_ALPHA) * uEma;
        cEma = EMA_ALPHA * cChange + (1.0f - EMA_ALPHA) * cEma;

        const uint16_t nextI = policyStep(currentIntervalMs, uEma, cEma);
        applyInterval(nextI);
      }

      char tag[20];
      makeTag(tag, sizeof(tag), c, truthLabel, currentIntervalMs);
      setPayload(stepIdx, tag);
      if (ENABLE_TICK_PER_UPDATE) tickPulseOnce(200);

      const uint16_t deltaSteps = (uint16_t)(currentIntervalMs / 100);
      stepIdx = (uint16_t)(stepIdx + deltaSteps);
      nextUpdateMs = millis() + currentIntervalMs;
    }

    vTaskDelay(1);
    return;
  }

  if (gapStartMs == 0) gapStartMs = nowMs;
  if ((nowMs - gapStartMs) &lt; GAP_MS) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return;
  }

  gapStartMs = 0;
  condIndex++;
  if (condIndex &gt;= N_CONDS) {
    condIndex = 0;
    repIndex++;
  }
  if (repIndex &gt;= REPEAT) {
    setSleepAllowed(true);
    if (adv) adv-&gt;stop();
    syncEnd();
    vTaskDelay(pdMS_TO_TICKS(1000));
    return;
  }

  beginCondition(CONDS[condIndex]);
  vTaskDelay(pdMS_TO_TICKS(200));
}</file><file path="uccs_d4_scan90/README.md"># uccs_d4_scan90（Step D4: Uが効いている切り分け / Ablation）

## 目的

実機D2bで得られた「Fixed100より省電力、Fixed500よりQoS良」の“程よい点”が **U（不確実度）**に依存しているかを、Ablationで切り分ける。

* 対象セッション: **S4のみ**（差が出やすい）
* 条件: 4条件 × n=3（最小セット）
  1. Fixed100
  2. Fixed500
  3. Policy（U+CCS）
  4. Ablation（**U-shuffle**: Uの分布は同じ、時間相関だけ破壊）

## 真値（truth）

* `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv`（100msグリッド, n_steps=1800=180s）
* TXは上記CSV由来の `label/U/CCS` をフラッシュに埋め込み、同一セッションを再生する。

## スケッチ（Arduino IDE 用）

* TX: `uccs_d4_scan90/src/tx/TX_UCCS_D4_SCAN90/TX_UCCS_D4_SCAN90.ino`
* RX: `uccs_d4_scan90/src/rx/RX_UCCS_D4_SCAN90/RX_UCCS_D4_SCAN90.ino`
* TXSD: `uccs_d4_scan90/src/txsd/TXSD_UCCS_D4_SCAN90/TXSD_UCCS_D4_SCAN90.ino`

## 配線

* TX `GPIO25 (SYNC_OUT)` → RX `GPIO26 (SYNC_IN)` / TXSD `GPIO26 (SYNC_IN)`
* TX `GPIO27 (TICK_OUT)` → TXSD `GPIO33 (TICK_IN)`

## 実行

* 1回の起動で S4 × 4条件を自動実行（`REPEAT=3`）。
* trial長: 180s（`EFFECTIVE_LEN_STEPS=1800`）。

## TX payload仕様（ManufacturerData）

形式: `&lt;step_idx&gt;_&lt;tag&gt;`

* `step_idx`: 100msグリッドの整数（0..）
* `tag`: `F4-&lt;label&gt;-&lt;itv&gt;` / `P4-&lt;label&gt;-&lt;itv&gt;` / `A4-&lt;label&gt;-&lt;itv&gt;`
  * `F`: fixed, `P`: policy, `A`: ablation（U-shuffle）
  * `&lt;label&gt;`: truth label（2桁）
  * `&lt;itv&gt;`: current interval（100 or 500）

## TXSD cond_id（preamble TICKパルス数）

* 1: S4 fixed100
* 2: S4 fixed500
* 3: S4 policy
* 4: S4 ablation_u_shuf

trial中は「広告更新」ごとにTICKを1発出し、TXSD側で `adv_count=tick_count` を記録する（近似）。

## データ配置

* SDから吸い上げた `/logs/` を `uccs_d4_scan90/data/&lt;run&gt;/{RX,TX}/` にコピーする（TX=TXSDログ）。
* `uccs_d4_scan90/data/&lt;run&gt;/README.md` に測定条件をメモ。

## 解析

* 集計スクリプト: `uccs_d4_scan90/analysis/summarize_d4_run_v2.py`（推奨: TXSDのtrial番号がcond毎にリセットされるのでmtime順でペアリングする）
  * 入力: `--rx-dir .../RX --txsd-dir .../TX`
  * 出力: `per_trial.csv`, `summary_by_condition.csv`, `summary.md`

* 図（任意）: `uccs_d4_scan90/analysis/plot_power_vs_pout.py`
  * 入力: `--summary-csv uccs_d4_scan90/metrics/&lt;run&gt;/summary_by_condition.csv`
  * 出力: `uccs_d4_scan90/plots/d4_&lt;run&gt;_power_vs_pout.png`（PDFも同時生成）
  * 実行例（matplotlibは `.venv_mhealth310` 推奨）:
    - `.venv_mhealth310/bin/python uccs_d4_scan90/analysis/plot_power_vs_pout.py --summary-csv uccs_d4_scan90/metrics/01/summary_by_condition.csv --out uccs_d4_scan90/plots/d4_01_power_vs_pout.png`

## D4で得られた知見（固定）

出典: `uccs_d4_scan90/metrics/01/summary.md`（S4のみ、scan90、4条件×n=3）

- 主要結果（mean±std, n=3）
  - Fixed100: `avg_power=208.2±1.3 mW`, `pout_1s=0.0488±0.0000`, `adv_count=1796`, `share100≈1.000`
  - Fixed500: `avg_power=187.9±0.8 mW`, `pout_1s=0.1301±0.0141`, `adv_count=359`, `share100≈0.000`
  - Policy(U+CCS): `avg_power=200.5±0.8 mW`, `pout_1s=0.0976±0.0244`, `adv_count=1227`, `share100≈0.593`
  - Ablation(U-shuffle): `avg_power=208.1±0.3 mW`, `pout_1s=0.0488±0.0000`, `adv_count=1715`, `share100≈0.943`

- 解釈（レター用の1行）
  - **Uを時間シャッフルして“いつ不確実か”の整合を壊すと、100ms張り付き寄りに崩れて省電力が消える**（`share100`と`adv_count`が増え、`avg_power`がFixed100級に戻る）。</file><file path="uccs_d4b_scan90/analysis/plot_power_vs_pout.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Plot Step D4B tradeoff: avg_power_mW vs pout_1s with share100 annotation (S4 only).

This script prefers matplotlib, but falls back to a dependency-free SVG output when
matplotlib is not available in the current Python environment.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import math
import os
from pathlib import Path
from typing import Dict, Optional, Tuple


def f_or_none(v: str) -&gt; Optional[float]:
    v = (v or &quot;&quot;).strip()
    if not v:
        return None
    try:
        return float(v)
    except Exception:
        return None


def read_summary_by_condition(path: Path) -&gt; Dict[str, Dict[str, Optional[float]]]:
    out: Dict[str, Dict[str, Optional[float]]] = {}
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            cond = (row.get(&quot;condition&quot;) or &quot;&quot;).strip()
            if not cond:
                continue
            out[cond] = {
                &quot;pout_1s_mean&quot;: f_or_none(row.get(&quot;pout_1s_mean&quot;) or &quot;&quot;),
                &quot;pout_1s_std&quot;: f_or_none(row.get(&quot;pout_1s_std&quot;) or &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: f_or_none(row.get(&quot;avg_power_mW_mean&quot;) or &quot;&quot;),
                &quot;avg_power_mW_std&quot;: f_or_none(row.get(&quot;avg_power_mW_std&quot;) or &quot;&quot;),
                &quot;adv_count_mean&quot;: f_or_none(row.get(&quot;adv_count_mean&quot;) or &quot;&quot;),
                &quot;rx_share100_mean&quot;: f_or_none(row.get(&quot;rx_tag_share100_time_est_mean&quot;) or &quot;&quot;),
                &quot;share100_power_mix_mean&quot;: f_or_none(row.get(&quot;share100_power_mix_mean&quot;) or &quot;&quot;),
            }
    return out


def get_point(
    rows: Dict[str, Dict[str, Optional[float]]],
    key: str,
) -&gt; Tuple[float, float, float, float, Optional[float], Optional[float], Optional[float]]:
    r = rows.get(key, {})
    x = r.get(&quot;avg_power_mW_mean&quot;)
    y = r.get(&quot;pout_1s_mean&quot;)
    if x is None or y is None:
        raise SystemExit(f&quot;missing required metrics for {key} in summary csv&quot;)
    xerr = r.get(&quot;avg_power_mW_std&quot;) or 0.0
    yerr = r.get(&quot;pout_1s_std&quot;) or 0.0
    adv = r.get(&quot;adv_count_mean&quot;)
    rx_share = r.get(&quot;rx_share100_mean&quot;)
    mix_share = r.get(&quot;share100_power_mix_mean&quot;)
    return float(x), float(y), float(xerr), float(yerr), adv, rx_share, mix_share


def _svg_escape(s: str) -&gt; str:
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace(&apos;&quot;&apos;, &quot;&amp;quot;&quot;)
        .replace(&quot;&apos;&quot;, &quot;&amp;#39;&quot;)
    )


def _fmt(v: Optional[float], digits: int = 3) -&gt; str:
    if v is None:
        return &quot;NA&quot;
    if isinstance(v, float) and (math.isnan(v) or math.isinf(v)):
        return &quot;NA&quot;
    return f&quot;{v:.{digits}f}&quot;


def _write_svg(
    out_path: Path,
    title: str,
    points: Dict[str, Dict[str, float]],
    x_label: str,
    y_label: str,
) -&gt; None:
    width = 900
    height = 600
    margin_l = 90
    margin_r = 30
    margin_t = 60
    margin_b = 70
    plot_w = width - margin_l - margin_r
    plot_h = height - margin_t - margin_b

    xs = [v[&quot;x&quot;] for v in points.values()]
    ys = [v[&quot;y&quot;] for v in points.values()]
    xerrs = [v[&quot;xerr&quot;] for v in points.values()]
    yerrs = [v[&quot;yerr&quot;] for v in points.values()]

    xmin = min(x - xe for x, xe in zip(xs, xerrs))
    xmax = max(x + xe for x, xe in zip(xs, xerrs))
    ymin = min(y - ye for y, ye in zip(ys, yerrs))
    ymax = max(y + ye for y, ye in zip(ys, yerrs))

    xpad = max(0.5, (xmax - xmin) * 0.08)
    ypad = max(0.002, (ymax - ymin) * 0.12)
    xmin -= xpad
    xmax += xpad
    ymin = max(0.0, ymin - ypad)
    ymax += ypad

    def x_to_px(x: float) -&gt; float:
        if xmax &lt;= xmin:
            return float(margin_l + plot_w / 2)
        return margin_l + (x - xmin) * plot_w / (xmax - xmin)

    def y_to_px(y: float) -&gt; float:
        if ymax &lt;= ymin:
            return float(margin_t + plot_h / 2)
        return margin_t + (ymax - y) * plot_h / (ymax - ymin)

    bg = &quot;#ffffff&quot;
    axis = &quot;#111827&quot;
    grid = &quot;#e5e7eb&quot;
    colors = {
        &quot;S4_fixed100&quot;: &quot;#ef4444&quot;,
        &quot;S4_fixed500&quot;: &quot;#3b82f6&quot;,
        &quot;S4_policy&quot;: &quot;#10b981&quot;,
        &quot;S4_ablation_ccs_off&quot;: &quot;#f59e0b&quot;,
    }

    svg_lines = []
    svg_lines.append(f&apos;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; viewBox=&quot;0 0 {width} {height}&quot;&gt;&apos;)
    svg_lines.append(f&apos;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;{width}&quot; height=&quot;{height}&quot; fill=&quot;{bg}&quot;/&gt;&apos;)
    svg_lines.append(f&apos;&lt;text x=&quot;{width/2:.1f}&quot; y=&quot;34&quot; font-size=&quot;20&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(title)}&lt;/text&gt;&apos;)
    svg_lines.append(f&apos;&lt;rect x=&quot;{margin_l}&quot; y=&quot;{margin_t}&quot; width=&quot;{plot_w}&quot; height=&quot;{plot_h}&quot; fill=&quot;none&quot; stroke=&quot;{axis}&quot; stroke-width=&quot;1.2&quot;/&gt;&apos;)

    for i in range(6):
        tx = xmin + (xmax - xmin) * i / 5.0
        px = x_to_px(tx)
        svg_lines.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{margin_t}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{margin_t+plot_h}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg_lines.append(f&apos;&lt;text x=&quot;{px:.2f}&quot; y=&quot;{margin_t+plot_h+24}&quot; font-size=&quot;12&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(tx, 1)}&lt;/text&gt;&apos;)
    for i in range(6):
        ty = ymin + (ymax - ymin) * i / 5.0
        py = y_to_px(ty)
        svg_lines.append(f&apos;&lt;line x1=&quot;{margin_l}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{margin_l+plot_w}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{grid}&quot; stroke-width=&quot;1&quot;/&gt;&apos;)
        svg_lines.append(f&apos;&lt;text x=&quot;{margin_l-10}&quot; y=&quot;{py+4:.2f}&quot; font-size=&quot;12&quot; text-anchor=&quot;end&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_fmt(ty, 3)}&lt;/text&gt;&apos;)

    svg_lines.append(f&apos;&lt;text x=&quot;{margin_l+plot_w/2:.1f}&quot; y=&quot;{height-24}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(x_label)}&lt;/text&gt;&apos;)
    svg_lines.append(f&apos;&lt;text x=&quot;22&quot; y=&quot;{margin_t+plot_h/2:.1f}&quot; font-size=&quot;14&quot; text-anchor=&quot;middle&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot; transform=&quot;rotate(-90 22 {margin_t+plot_h/2:.1f})&quot;&gt;{_svg_escape(y_label)}&lt;/text&gt;&apos;)

    for key, v in points.items():
        x = v[&quot;x&quot;]
        y = v[&quot;y&quot;]
        xerr = v[&quot;xerr&quot;]
        yerr = v[&quot;yerr&quot;]
        px = x_to_px(x)
        py = y_to_px(y)
        color = colors.get(key, &quot;#111827&quot;)
        px_l = x_to_px(x - xerr)
        px_r = x_to_px(x + xerr)
        py_u = y_to_px(y + yerr)
        py_d = y_to_px(y - yerr)
        svg_lines.append(f&apos;&lt;line x1=&quot;{px_l:.2f}&quot; y1=&quot;{py:.2f}&quot; x2=&quot;{px_r:.2f}&quot; y2=&quot;{py:.2f}&quot; stroke=&quot;{color}&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg_lines.append(f&apos;&lt;line x1=&quot;{px:.2f}&quot; y1=&quot;{py_u:.2f}&quot; x2=&quot;{px:.2f}&quot; y2=&quot;{py_d:.2f}&quot; stroke=&quot;{color}&quot; stroke-width=&quot;2&quot; opacity=&quot;0.9&quot;/&gt;&apos;)
        svg_lines.append(f&apos;&lt;circle cx=&quot;{px:.2f}&quot; cy=&quot;{py:.2f}&quot; r=&quot;6&quot; fill=&quot;{color}&quot; opacity=&quot;0.95&quot;/&gt;&apos;)
        label = key.replace(&quot;S4_&quot;, &quot;&quot;)
        note = f&quot;{label} (adv={int(v[&apos;adv&apos;]) if v.get(&apos;adv&apos;) is not None else &apos;NA&apos;}, share100_rx={_fmt(v.get(&apos;rx_share&apos;), 3)}, share100_mix={_fmt(v.get(&apos;mix_share&apos;), 3)})&quot;
        svg_lines.append(f&apos;&lt;text x=&quot;{px+10:.2f}&quot; y=&quot;{py-10:.2f}&quot; font-size=&quot;12&quot; fill=&quot;{axis}&quot; font-family=&quot;ui-sans-serif, system-ui, -apple-system&quot;&gt;{_svg_escape(note)}&lt;/text&gt;&apos;)

    svg_lines.append(&quot;&lt;/svg&gt;\n&quot;)
    out_path.write_text(&quot;\n&quot;.join(svg_lines), encoding=&quot;utf-8&quot;)


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--summary-csv&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out&quot;, type=Path, required=True)
    ap.add_argument(&quot;--title&quot;, type=str, default=&quot;&quot;)
    args = ap.parse_args()

    rows = read_summary_by_condition(args.summary_csv)

    k100 = &quot;S4_fixed100&quot;
    k500 = &quot;S4_fixed500&quot;
    kpol = &quot;S4_policy&quot;
    kubona = &quot;S4_ablation_ccs_off&quot;

    x100, y100, x100e, y100e, adv100, rx100, mix100 = get_point(rows, k100)
    x500, y500, x500e, y500e, adv500, rx500, mix500 = get_point(rows, k500)
    xpol, ypol, xpole, ypole, advpol, rxpol, mixpol = get_point(rows, kpol)
    xub, yub, xube, yube, advub, rxub, mixub = get_point(rows, kubona)

    # Try matplotlib first.
    repo_root = Path.cwd()
    try:
        xdg_cache = repo_root / &quot;.cache&quot;
        xdg_cache.mkdir(exist_ok=True)
        os.environ.setdefault(&quot;XDG_CACHE_HOME&quot;, str(xdg_cache))
        mpl_dir = repo_root / &quot;.mplconfig&quot;
        mpl_dir.mkdir(exist_ok=True)
        os.environ.setdefault(&quot;MPLCONFIGDIR&quot;, str(mpl_dir))

        import matplotlib  # type: ignore

        matplotlib.use(&quot;Agg&quot;)
        import matplotlib.pyplot as plt  # type: ignore
    except Exception:
        # Dependency-free fallback.
        args.out.parent.mkdir(parents=True, exist_ok=True)
        _write_svg(
            args.out.with_suffix(&quot;.svg&quot;),
            title=args.title or &quot;D4B scan90 (S4): CCS-off ablation&quot;,
            points={
                &quot;S4_fixed100&quot;: {&quot;x&quot;: x100, &quot;y&quot;: y100, &quot;xerr&quot;: x100e, &quot;yerr&quot;: y100e, &quot;adv&quot;: adv100 or 0.0, &quot;rx_share&quot;: rx100 or float(&quot;nan&quot;), &quot;mix_share&quot;: mix100 or float(&quot;nan&quot;)},
                &quot;S4_fixed500&quot;: {&quot;x&quot;: x500, &quot;y&quot;: y500, &quot;xerr&quot;: x500e, &quot;yerr&quot;: y500e, &quot;adv&quot;: adv500 or 0.0, &quot;rx_share&quot;: rx500 or float(&quot;nan&quot;), &quot;mix_share&quot;: mix500 or float(&quot;nan&quot;)},
                &quot;S4_policy&quot;: {&quot;x&quot;: xpol, &quot;y&quot;: ypol, &quot;xerr&quot;: xpole, &quot;yerr&quot;: ypole, &quot;adv&quot;: advpol or 0.0, &quot;rx_share&quot;: rxpol or float(&quot;nan&quot;), &quot;mix_share&quot;: mixpol or float(&quot;nan&quot;)},
                &quot;S4_ablation_ccs_off&quot;: {&quot;x&quot;: xub, &quot;y&quot;: yub, &quot;xerr&quot;: xube, &quot;yerr&quot;: yube, &quot;adv&quot;: advub or 0.0, &quot;rx_share&quot;: rxub or float(&quot;nan&quot;), &quot;mix_share&quot;: mixub or float(&quot;nan&quot;)},
            },
            x_label=&quot;avg_power_mW (mean±std)&quot;,
            y_label=&quot;pout_1s (mean±std)&quot;,
        )
        return

    fig, ax = plt.subplots(figsize=(7.6, 5.0), dpi=160)
    ax.errorbar([x100], [y100], xerr=[x100e], yerr=[y100e], fmt=&quot;s&quot;, ms=7, color=&quot;#ef4444&quot;, capsize=3, linestyle=&quot;none&quot;, label=&quot;fixed100&quot;)
    ax.errorbar([x500], [y500], xerr=[x500e], yerr=[y500e], fmt=&quot;s&quot;, ms=7, color=&quot;#3b82f6&quot;, capsize=3, linestyle=&quot;none&quot;, label=&quot;fixed500&quot;)
    ax.errorbar([xpol], [ypol], xerr=[xpole], yerr=[ypole], fmt=&quot;o&quot;, ms=8, color=&quot;#10b981&quot;, capsize=3, linestyle=&quot;none&quot;, label=&quot;policy (U+CCS)&quot;)
    ax.errorbar([xub], [yub], xerr=[xube], yerr=[yube], fmt=&quot;^&quot;, ms=8, color=&quot;#f59e0b&quot;, capsize=3, linestyle=&quot;none&quot;, label=&quot;ablation (U-only / CCS-off)&quot;)

    def annotate(x: float, y: float, name: str, adv: Optional[float], rx_share: Optional[float], mix_share: Optional[float]) -&gt; None:
        adv_s = f&quot;adv={int(adv)}&quot; if adv is not None else &quot;adv=NA&quot;
        rx_s = f&quot;share100_rx={rx_share:.2f}&quot; if rx_share is not None else &quot;share100_rx=NA&quot;
        mix_s = f&quot;share100_mix={mix_share:.2f}&quot; if mix_share is not None else &quot;share100_mix=NA&quot;
        ax.annotate(f&quot;{name}\n{adv_s}, {rx_s}, {mix_s}&quot;, (x, y), textcoords=&quot;offset points&quot;, xytext=(8, 8), ha=&quot;left&quot;, fontsize=8)

    annotate(x100, y100, &quot;fixed100&quot;, adv100, rx100, mix100)
    annotate(x500, y500, &quot;fixed500&quot;, adv500, rx500, mix500)
    annotate(xpol, ypol, &quot;policy&quot;, advpol, rxpol, mixpol)
    annotate(xub, yub, &quot;ccs_off&quot;, advub, rxub, mixub)

    ax.set_xlabel(&quot;avg_power_mW (TXSD)&quot;)
    ax.set_ylabel(&quot;pout_1s&quot;)
    ax.grid(True, alpha=0.25)
    if args.title:
        ax.set_title(args.title)
    ax.legend(loc=&quot;best&quot;, fontsize=9, frameon=True)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    if args.out.suffix.lower() == &quot;.png&quot;:
        fig.savefig(args.out.with_suffix(&quot;.pdf&quot;))


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Summarize uccs_d4b_scan90 run (RX + TXSD) and compute TL/Pout using step_idx-aligned payload.

Step D4B (CCS ablation):
  - S4 only
  - 4 conditions × 3 repeats = 12 trials
    - S4_fixed100 (F4-..-100)
    - S4_fixed500 (F4-..-500)
    - S4_policy (P4-..-itv)          # U+CCS
    - S4_ablation_ccs_off (U4-..-itv) # U-only (CCS-off)

RX ManufacturerData: &quot;&lt;step_idx&gt;_&lt;tag&gt;&quot;
  tag: &quot;F4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;P4-&lt;label&gt;-&lt;itv&gt;&quot; / &quot;U4-&lt;label&gt;-&lt;itv&gt;&quot;

Notes:
  - TXSD側は preamble（TICK）誤検出やSDコピーでmtimeが壊れるケースがあるため、
    cond_id/mtime に依存せず、adv_count（tick_count）を用いてクラスタリングして割り当てる。
  - TL/Poutは(100ms真値)遷移に対して、受信時刻をper-trial定数オフセットで整列して算出する（D2/D4と同じ）。
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import re
import statistics
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

TRUTH_DT_MS = 100
TAU_VALUES_S = (1.0, 2.0, 3.0)
VALID_MIN_DURATION_MS = 160_000  # ~180s trials

TAG_RE = re.compile(r&quot;^(?P&lt;mode&gt;[FPU])(?P&lt;sess&gt;[14])-(?P&lt;label&gt;\d+)-(?P&lt;itv&gt;\d+)$&quot;)
RX_TRIAL_RE = re.compile(r&quot;rx_trial_(?P&lt;id&gt;\d+)\.csv$&quot;)
TXSD_NAME_RE = re.compile(r&quot;trial_(?P&lt;idx&gt;\d+)_c(?P&lt;cond&gt;\d+)_(?P&lt;tag&gt;.+)\.csv$&quot;)

# Drop stale/mixed low-power files (typically old logs) and wrong-signed logs.
TXSD_MIN_AVG_POWER_MW = 150.0


@dataclass(frozen=True)
class RxEvent:
    rx_ms: float
    step_idx: int
    truth_label: int
    itv_ms: int
    tag: str


@dataclass
class RxTrial:
    rx_id: int
    path: Path
    duration_ms: float
    session: int  # 4
    mode: str  # F/P/U
    fixed_itv: Optional[int]  # 100/500 if fixed
    events: List[RxEvent]


@dataclass
class TxsdTrial:
    path: Path
    trial_idx: int
    cond_id: int
    tag: str
    ms_total: float
    adv_count: int
    e_total_mj: float
    avg_power_mw: float


def estimate_rx_tag_share100_time_est(events: List[RxEvent]) -&gt; Optional[float]:
    itv_by_step: Dict[int, int] = {}
    for e in events:
        if e.step_idx not in itv_by_step:
            itv_by_step[e.step_idx] = e.itv_ms
    n100 = sum(1 for v in itv_by_step.values() if v == 100)
    n500 = sum(1 for v in itv_by_step.values() if v == 500)
    denom_ms = n100 * 100 + n500 * 500
    if denom_ms &lt;= 0:
        return None
    return (n100 * 100) / denom_ms


def read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def parse_mfd(s: str) -&gt; Optional[Tuple[int, str]]:
    s = (s or &quot;&quot;).strip()
    if not s:
        return None
    us = s.find(&quot;_&quot;)
    if us &lt;= 0:
        return None
    try:
        step_idx = int(s[:us])
    except Exception:
        return None
    tag = s[us + 1 :].strip()
    if not tag:
        return None
    return step_idx, tag


def read_rx_trial(path: Path) -&gt; RxTrial:
    m = RX_TRIAL_RE.search(path.name)
    if not m:
        raise ValueError(f&quot;not rx_trial: {path}&quot;)
    rx_id = int(m.group(&quot;id&quot;))

    events: List[RxEvent] = []
    last_ms: float = 0.0
    mode_c: Dict[str, int] = {&quot;F&quot;: 0, &quot;P&quot;: 0, &quot;U&quot;: 0}
    fixed_itv_c: Dict[int, int] = {}

    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or 0.0)
            except Exception:
                continue
            last_ms = max(last_ms, rx_ms)

            mfd = (row.get(&quot;mfd&quot;) or &quot;&quot;).strip()
            pm = parse_mfd(mfd)
            if not pm:
                continue
            step_idx, tag = pm

            tm = TAG_RE.match(tag)
            if not tm:
                continue
            mode = tm.group(&quot;mode&quot;)
            sess = int(tm.group(&quot;sess&quot;))
            if sess != 4:
                continue
            truth_label = int(tm.group(&quot;label&quot;))
            itv_ms = int(tm.group(&quot;itv&quot;))

            mode_c[mode] = mode_c.get(mode, 0) + 1
            if mode == &quot;F&quot;:
                fixed_itv_c[itv_ms] = fixed_itv_c.get(itv_ms, 0) + 1

            events.append(RxEvent(rx_ms=rx_ms, step_idx=step_idx, truth_label=truth_label, itv_ms=itv_ms, tag=tag))

    if not events:
        raise ValueError(f&quot;empty/invalid RX: {path}&quot;)

    mode = max(mode_c.items(), key=lambda kv: kv[1])[0]
    fixed_itv = None
    if mode == &quot;F&quot;:
        fixed_itv = max(fixed_itv_c.items(), key=lambda kv: kv[1])[0] if fixed_itv_c else None
        if fixed_itv not in (100, 500):
            raise ValueError(f&quot;unexpected fixed interval {fixed_itv} in {path}&quot;)

    return RxTrial(rx_id=rx_id, path=path, duration_ms=last_ms, session=4, mode=mode, fixed_itv=fixed_itv, events=events)


def rx_bucket(t: RxTrial) -&gt; str:
    if t.mode == &quot;P&quot;:
        return &quot;P4&quot;
    if t.mode == &quot;U&quot;:
        return &quot;U4&quot;
    return f&quot;F4_{t.fixed_itv}&quot;


def select_balanced_window(trials: List[RxTrial]) -&gt; List[RxTrial]:
    candidates = [t for t in trials if t.duration_ms &gt;= VALID_MIN_DURATION_MS]
    candidates.sort(key=lambda t: t.rx_id)
    if len(candidates) &lt; 12:
        raise SystemExit(f&quot;not enough valid RX trials (&gt;= {VALID_MIN_DURATION_MS}ms): {len(candidates)}&quot;)

    want = {&quot;F4_100&quot;, &quot;F4_500&quot;, &quot;P4&quot;, &quot;U4&quot;}
    best: Optional[List[RxTrial]] = None
    for start in range(0, len(candidates) - 12 + 1):
        window = candidates[start : start + 12]
        counts: Dict[str, int] = {}
        for t in window:
            counts[rx_bucket(t)] = counts.get(rx_bucket(t), 0) + 1
        if set(counts.keys()) == want and all(counts.get(k, 0) == 3 for k in want):
            best = window
    if not best:
        raise SystemExit(&quot;could not find balanced 12-trial RX window (F4_100/F4_500/P4/U4 × 3 repeats)&quot;)
    return best


def estimate_offset_ms(events: List[RxEvent]) -&gt; Tuple[float, int]:
    first_ms: Dict[int, float] = {}
    for e in events:
        if e.step_idx not in first_ms:
            first_ms[e.step_idx] = e.rx_ms
    if not first_ms:
        return 0.0, 0
    offsets = [(idx * TRUTH_DT_MS) - ms for idx, ms in first_ms.items()]
    offsets.sort()
    return float(statistics.median(offsets)), len(offsets)


def compute_tl_and_pout(truth_labels: List[int], aligned_events: List[Tuple[float, int]]) -&gt; Tuple[float, float, Dict[float, float]]:
    # truth transitions by 100ms grid
    transitions: List[Tuple[float, int]] = []
    prev = truth_labels[0]
    for i in range(1, len(truth_labels)):
        cur = truth_labels[i]
        if cur != prev:
            transitions.append((i * TRUTH_DT_MS, cur))
        prev = cur

    # index events by truth label
    events_by_label: Dict[int, List[float]] = {}
    for t_ms, lbl in aligned_events:
        events_by_label.setdefault(lbl, []).append(t_ms)
    for lbl in events_by_label:
        events_by_label[lbl].sort()

    tl_list_s: List[float] = []
    for t_ms, true_label in transitions:
        arr = events_by_label.get(true_label) or []
        arrival = None
        for ms in arr:
            if ms &gt;= t_ms:
                arrival = ms
                break
        if arrival is None:
            tl_list_s.append(float(&quot;inf&quot;))
        else:
            tl_list_s.append((arrival - t_ms) / 1000.0)

    finite = [x for x in tl_list_s if x != float(&quot;inf&quot;)]
    tl_mean = statistics.mean(finite) if finite else float(&quot;inf&quot;)
    tl_p95 = statistics.quantiles(finite, n=20)[18] if len(finite) &gt;= 20 else (max(finite) if finite else float(&quot;inf&quot;))
    pout: Dict[float, float] = {}
    for tau in TAU_VALUES_S:
        miss = sum(1 for x in tl_list_s if x == float(&quot;inf&quot;) or x &gt; tau)
        pout[tau] = miss / len(tl_list_s) if tl_list_s else 0.0
    return tl_mean, tl_p95, pout


def parse_txsd_summary(path: Path) -&gt; Optional[TxsdTrial]:
    m = TXSD_NAME_RE.match(path.name)
    if not m:
        return None
    trial_idx = int(m.group(&quot;idx&quot;))
    cond_id = int(m.group(&quot;cond&quot;))
    tag = m.group(&quot;tag&quot;)

    ms_total = None
    adv_count = None
    e_total_mj = None
    with path.open() as f:
        for line in f:
            if line.startswith(&quot;# summary&quot;):
                parts = [p.strip() for p in line.strip().split(&quot;,&quot;)]
                kv: Dict[str, str] = {}
                for p in parts:
                    if &quot;=&quot; in p:
                        k, v = p.split(&quot;=&quot;, 1)
                        kv[k.strip(&quot;# &quot;).strip()] = v.strip()
                ms_total = float(kv.get(&quot;ms_total&quot;)) if kv.get(&quot;ms_total&quot;) else None
                adv_count = int(kv.get(&quot;adv_count&quot;)) if kv.get(&quot;adv_count&quot;) else None
                e_total_mj = float(kv.get(&quot;E_total_mJ&quot;)) if kv.get(&quot;E_total_mJ&quot;) else None
                break
    if ms_total is None or adv_count is None or e_total_mj is None:
        return None
    if ms_total &lt;= 0:
        return None
    avg_power = e_total_mj / (ms_total / 1000.0)
    return TxsdTrial(
        path=path,
        trial_idx=trial_idx,
        cond_id=cond_id,
        tag=tag,
        ms_total=ms_total,
        adv_count=adv_count,
        e_total_mj=e_total_mj,
        avg_power_mw=avg_power,
    )


def mean_std(xs: List[float]) -&gt; Tuple[float, float]:
    if not xs:
        return 0.0, 0.0
    if len(xs) == 1:
        return xs[0], 0.0
    return statistics.mean(xs), statistics.stdev(xs)


def condition_name(rx: RxTrial) -&gt; str:
    if rx.mode == &quot;P&quot;:
        return &quot;S4_policy&quot;
    if rx.mode == &quot;U&quot;:
        return &quot;S4_ablation_ccs_off&quot;
    return &quot;S4_fixed100&quot; if rx.fixed_itv == 100 else &quot;S4_fixed500&quot;


def pick_n_typical_by_power(group: List[TxsdTrial], n: int) -&gt; List[TxsdTrial]:
    if len(group) &lt; n:
        raise SystemExit(f&quot;not enough TXSD trials in group: need {n}, got {len(group)}&quot;)
    powers = [t.avg_power_mw for t in group]
    med = statistics.median(powers)
    group_sorted = sorted(group, key=lambda t: abs(t.avg_power_mw - med))
    return group_sorted[:n]


def compute_share100_power_mix(p_dyn: float, p_100: float, p_500: float) -&gt; Optional[float]:
    denom = (p_100 - p_500)
    if denom == 0:
        return None
    s = (p_dyn - p_500) / denom
    if s &lt; 0:
        s = 0.0
    if s &gt; 1:
        s = 1.0
    return float(s)


def classify_txsd_by_adv_count(
    txsd_trials: List[TxsdTrial],
    rx_share_policy: Optional[float],
    rx_share_uonly: Optional[float],
) -&gt; Dict[str, List[TxsdTrial]]:
    &quot;&quot;&quot;
    Classify TXSD trials into 4 conditions using adv_count clustering.
      - max adv_count -&gt; fixed100
      - min adv_count -&gt; fixed500
      - remaining 2 adv_count values -&gt; policy vs u-only (matched by RX tag share100 if available)
    &quot;&quot;&quot;
    by_adv: Dict[int, List[TxsdTrial]] = {}
    for t in txsd_trials:
        by_adv.setdefault(t.adv_count, []).append(t)
    adv_values = sorted(by_adv.keys())
    if len(adv_values) &lt; 4:
        raise SystemExit(f&quot;TXSD adv_count has &lt;4 unique values: {adv_values}&quot;)

    adv_min = adv_values[0]
    adv_max = adv_values[-1]
    dyn = [v for v in adv_values if v not in (adv_min, adv_max)]
    if len(dyn) != 2:
        dyn = sorted(dyn, key=lambda v: len(by_adv[v]), reverse=True)[:2]
        dyn = sorted(dyn)
    if len(dyn) != 2:
        raise SystemExit(f&quot;could not identify 2 dynamic adv_count values: {adv_values}&quot;)

    adv_dyn1, adv_dyn2 = dyn[0], dyn[1]

    def adv_to_share(a: int) -&gt; float:
        denom = (adv_max - adv_min)
        if denom &lt;= 0:
            return 0.0
        s = (a - adv_min) / denom
        if s &lt; 0:
            s = 0.0
        if s &gt; 1:
            s = 1.0
        return float(s)

    s1 = adv_to_share(adv_dyn1)
    s2 = adv_to_share(adv_dyn2)

    if rx_share_policy is not None and rx_share_uonly is not None:
        d11 = abs(s1 - rx_share_policy) + abs(s2 - rx_share_uonly)
        d12 = abs(s1 - rx_share_uonly) + abs(s2 - rx_share_policy)
        if d12 &lt; d11:
            adv_dyn1, adv_dyn2 = adv_dyn2, adv_dyn1
            s1, s2 = s2, s1

    groups = {
        &quot;S4_fixed500&quot;: by_adv[adv_min],
        &quot;S4_fixed100&quot;: by_adv[adv_max],
        &quot;S4_policy&quot;: by_adv[adv_dyn1],
        &quot;S4_ablation_ccs_off&quot;: by_adv[adv_dyn2],
    }
    for k in groups:
        groups[k] = sorted(groups[k], key=lambda t: t.path.name)
    return groups


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--txsd-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth-s4&quot;, type=Path, default=Path(&quot;Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv&quot;))
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    args = ap.parse_args()

    truth = read_truth_labels(args.truth_s4, args.n_steps)

    rx_all: List[RxTrial] = []
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        try:
            rx_all.append(read_rx_trial(p))
        except Exception:
            continue
    rx_trials = select_balanced_window(rx_all)
    rx_trials.sort(key=lambda t: t.rx_id)

    txsd_all: List[TxsdTrial] = []
    for p in sorted(args.txsd_dir.glob(&quot;trial_*.csv&quot;)):
        tt = parse_txsd_summary(p)
        if not tt:
            continue
        if tt.ms_total &gt;= VALID_MIN_DURATION_MS and tt.avg_power_mw &gt;= TXSD_MIN_AVG_POWER_MW and tt.e_total_mj &gt; 0:
            txsd_all.append(tt)
    if not txsd_all:
        raise SystemExit(&quot;no valid TXSD trials found after filtering&quot;)

    # RX share100 estimates for matching policy vs u-only TXSD clusters (optional).
    pol_shares = [estimate_rx_tag_share100_time_est(t.events) for t in rx_trials if t.mode == &quot;P&quot;]
    u_shares = [estimate_rx_tag_share100_time_est(t.events) for t in rx_trials if t.mode == &quot;U&quot;]
    pol_shares = [x for x in pol_shares if x is not None]
    u_shares = [x for x in u_shares if x is not None]
    rx_share_pol = statistics.mean(pol_shares) if pol_shares else None
    rx_share_u = statistics.mean(u_shares) if u_shares else None

    groups = classify_txsd_by_adv_count(txsd_all, rx_share_pol, rx_share_u)
    picked: Dict[str, List[TxsdTrial]] = {k: pick_n_typical_by_power(v, 3) for k, v in groups.items()}
    for k in picked:
        picked[k].sort(key=lambda t: t.path.name)

    pairs: List[Tuple[RxTrial, TxsdTrial]] = []
    for rx in rx_trials:
        cond = condition_name(rx)
        if cond not in picked or not picked[cond]:
            raise SystemExit(f&quot;TXSD group missing for {cond}&quot;)
        pairs.append((rx, picked[cond].pop(0)))

    rep_counter: Dict[str, int] = {}
    per_rows: List[Dict[str, object]] = []
    for rx, tx in pairs:
        cond = condition_name(rx)
        rep_counter[cond] = rep_counter.get(cond, 0) + 1
        rep_idx = rep_counter[cond]

        offset_ms, offset_n = estimate_offset_ms(rx.events)
        aligned_events: List[Tuple[float, int]] = []
        step_set: set[int] = set()
        for e in rx.events:
            t_ms = e.rx_ms + offset_ms
            if 0.0 &lt;= t_ms &lt; (args.n_steps * TRUTH_DT_MS):
                aligned_events.append((t_ms, e.truth_label))
            step_set.add(e.step_idx)

        tl_mean, tl_p95, pout = compute_tl_and_pout(truth, aligned_events)
        rx_unique = len(step_set)
        pdr_unique = min(rx_unique, tx.adv_count) / tx.adv_count if tx.adv_count &gt; 0 else 0.0
        share100 = estimate_rx_tag_share100_time_est(rx.events)

        per_rows.append(
            {
                &quot;rx_trial_id&quot;: rx.rx_id,
                &quot;condition&quot;: cond,
                &quot;repeat_idx&quot;: rep_idx,
                &quot;mode&quot;: (&quot;POLICY&quot; if rx.mode == &quot;P&quot; else (&quot;U_ONLY&quot; if rx.mode == &quot;U&quot; else f&quot;FIXED_{rx.fixed_itv}&quot;)),
                &quot;rx_count&quot;: len(rx.events),
                &quot;rx_unique&quot;: rx_unique,
                &quot;adv_count&quot;: tx.adv_count,
                &quot;pdr_unique&quot;: round(pdr_unique, 6),
                &quot;rx_tag_share100_time_est&quot;: (round(share100, 6) if share100 is not None else &quot;&quot;),
                &quot;tl_mean_s&quot;: round(tl_mean, 6),
                &quot;tl_p95_s&quot;: round(tl_p95, 6),
                &quot;pout_1s&quot;: round(pout[1.0], 6),
                &quot;pout_2s&quot;: round(pout[2.0], 6),
                &quot;pout_3s&quot;: round(pout[3.0], 6),
                &quot;tl_time_offset_ms&quot;: round(offset_ms, 3),
                &quot;tl_time_offset_n&quot;: offset_n,
                &quot;txsd_ms_total&quot;: tx.ms_total,
                &quot;E_total_mJ&quot;: tx.e_total_mj,
                &quot;avg_power_mW&quot;: tx.avg_power_mw,
                &quot;txsd_path&quot;: str(tx.path),
                &quot;rx_path&quot;: str(rx.path),
            }
        )

    per_rows.sort(key=lambda r: int(r[&quot;rx_trial_id&quot;]))
    args.out_dir.mkdir(parents=True, exist_ok=True)
    per_path = args.out_dir / &quot;per_trial.csv&quot;
    with per_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(per_rows[0].keys()))
        w.writeheader()
        w.writerows(per_rows)

    by_cond_rows: Dict[str, List[Dict[str, object]]] = {}
    for r in per_rows:
        by_cond_rows.setdefault(str(r[&quot;condition&quot;]), []).append(r)

    summary_rows: List[Dict[str, object]] = []
    for cond, rows in sorted(by_cond_rows.items()):
        pout_1s_list = [float(r[&quot;pout_1s&quot;]) for r in rows]
        tl_list = [float(r[&quot;tl_mean_s&quot;]) for r in rows]
        pdr_list = [float(r[&quot;pdr_unique&quot;]) for r in rows]
        pwr_list = [float(r[&quot;avg_power_mW&quot;]) for r in rows]
        adv_list = [float(r[&quot;adv_count&quot;]) for r in rows]
        share_list = [float(r[&quot;rx_tag_share100_time_est&quot;]) for r in rows if r[&quot;rx_tag_share100_time_est&quot;] != &quot;&quot;]

        pout_m, pout_s = mean_std(pout_1s_list)
        tl_m, tl_s = mean_std(tl_list)
        pdr_m, pdr_s = mean_std(pdr_list)
        pwr_m, pwr_s = mean_std(pwr_list)
        adv_m, adv_s = mean_std(adv_list)
        sh_m, sh_s = mean_std(share_list) if share_list else (0.0, 0.0)

        summary_rows.append(
            {
                &quot;condition&quot;: cond,
                &quot;n_trials&quot;: len(rows),
                &quot;pout_1s_mean&quot;: round(pout_m, 6),
                &quot;pout_1s_std&quot;: round(pout_s, 6),
                &quot;tl_mean_s_mean&quot;: round(tl_m, 6),
                &quot;tl_mean_s_std&quot;: round(tl_s, 6),
                &quot;pdr_unique_mean&quot;: round(pdr_m, 6),
                &quot;pdr_unique_std&quot;: round(pdr_s, 6),
                &quot;rx_tag_share100_time_est_mean&quot;: (round(sh_m, 6) if share_list else &quot;&quot;),
                &quot;rx_tag_share100_time_est_std&quot;: (round(sh_s, 6) if share_list else &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: round(pwr_m, 3),
                &quot;avg_power_mW_std&quot;: round(pwr_s, 3),
                &quot;adv_count_mean&quot;: round(adv_m, 3),
                &quot;adv_count_std&quot;: round(adv_s, 3),
            }
        )

    # Add share100_power_mix_mean for dynamic conditions (mean powers only).
    p100 = next((float(r[&quot;avg_power_mW_mean&quot;]) for r in summary_rows if r[&quot;condition&quot;] == &quot;S4_fixed100&quot;), None)
    p500 = next((float(r[&quot;avg_power_mW_mean&quot;]) for r in summary_rows if r[&quot;condition&quot;] == &quot;S4_fixed500&quot;), None)
    for r in summary_rows:
        r[&quot;share100_power_mix_mean&quot;] = &quot;&quot;
        if p100 is None or p500 is None:
            continue
        if r[&quot;condition&quot;] in (&quot;S4_policy&quot;, &quot;S4_ablation_ccs_off&quot;):
            s = compute_share100_power_mix(float(r[&quot;avg_power_mW_mean&quot;]), p100, p500)
            if s is not None:
                r[&quot;share100_power_mix_mean&quot;] = round(s, 6)

    sum_path = args.out_dir / &quot;summary_by_condition.csv&quot;
    with sum_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(summary_rows[0].keys()))
        w.writeheader()
        w.writerows(summary_rows)

    lines: List[str] = []
    lines.append(&quot;# uccs_d4b_scan90 metrics summary (v2)\n\n&quot;)
    lines.append(f&quot;- source RX: `{args.rx_dir}`\n&quot;)
    lines.append(f&quot;- source TXSD: `{args.txsd_dir}`\n&quot;)
    lines.append(f&quot;- truth: `{args.truth_s4}` (n_steps={args.n_steps}, dt=100ms)\n&quot;)
    lines.append(f&quot;- selected RX trials: {rx_trials[0].rx_id:03d}..{rx_trials[-1].rx_id:03d} (n={len(rx_trials)})\n&quot;)
    uniq_adv = sorted({tx.adv_count for _, tx in pairs})
    lines.append(f&quot;- selected TXSD trials: grouped by adv_count={uniq_adv} (3 trials each)\n&quot;)
    lines.append(f&quot;- generated: {datetime.now().strftime(&apos;%Y-%m-%d %H:%M&apos;)} (local)\n&quot;)
    lines.append(f&quot;- command: `python3 uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py --rx-dir {args.rx_dir} --txsd-dir {args.txsd_dir} --out-dir {args.out_dir}`\n&quot;)

    lines.append(&quot;\n## Summary (mean ± std)\n&quot;)
    lines.append(&quot;| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) | share100_power_mix |\n&quot;)
    lines.append(&quot;|---|---:|---:|---:|---:|---:|---:|---:|\n&quot;)

    def fmt_pm(m: object, s: object, decimals: int) -&gt; str:
        if m == &quot;&quot; or s == &quot;&quot;:
            return &quot;&quot;
        return f&quot;{float(m):.{decimals}f}±{float(s):.{decimals}f}&quot;

    for r in summary_rows:
        share_mix = r.get(&quot;share100_power_mix_mean&quot;, &quot;&quot;)
        lines.append(
            f&quot;| {r[&apos;condition&apos;]} | {fmt_pm(r[&apos;pout_1s_mean&apos;], r[&apos;pout_1s_std&apos;], 4)} | &quot;
            f&quot;{fmt_pm(r[&apos;tl_mean_s_mean&apos;], r[&apos;tl_mean_s_std&apos;], 3)} | &quot;
            f&quot;{fmt_pm(r[&apos;pdr_unique_mean&apos;], r[&apos;pdr_unique_std&apos;], 3)} | &quot;
            f&quot;{fmt_pm(r[&apos;avg_power_mW_mean&apos;], r[&apos;avg_power_mW_std&apos;], 1)} | &quot;
            f&quot;{fmt_pm(r[&apos;adv_count_mean&apos;], r[&apos;adv_count_std&apos;], 1)} | &quot;
            f&quot;{fmt_pm(r[&apos;rx_tag_share100_time_est_mean&apos;], r[&apos;rx_tag_share100_time_est_std&apos;], 3) if r.get(&apos;rx_tag_share100_time_est_mean&apos;,&apos;&apos;)!=&apos;&apos; else &apos;&apos;} | &quot;
            f&quot;{(f&apos;{float(share_mix):.3f}&apos; if share_mix != &apos;&apos; else &apos;&apos;)} |&quot;
            &quot;\n&quot;
        )

    lines.append(&quot;\n## Notes\n&quot;)
    lines.append(&quot;- RX window: latest 12 trials that form 4 conditions × 3 repeats (duration&gt;=160s).\n&quot;)
    lines.append(&quot;- TXSD pairing: cond_idがズレる/mtimeが壊れる可能性があるため、adv_count（tick_count）でクラスタリングして割り当て。\n&quot;)
    lines.append(f&quot;  - filter: avg_power_mW &gt;= {TXSD_MIN_AVG_POWER_MW:.1f} かつ E_total_mJ&gt;0（古いログ混在/逆符号を除外）\n&quot;)
    lines.append(&quot;- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).\n&quot;)
    lines.append(&quot;- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique.\n&quot;)
    lines.append(&quot;- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).\n&quot;)

    md_path = args.out_dir / &quot;summary.md&quot;
    md_path.write_text(&quot;&quot;.join(lines), encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="uccs_d4b_scan90/README.md"># uccs_d4b_scan90（Step D4B: CCSが効いている切り分け / Ablation）

## 目的

Step D4で「Uを壊す（U-shuffle）と100ms張り付き寄りに崩れる」を示した。次にレターで突っ込まれやすい
「CCSは要るのか？ Uだけで十分では？」へ答えるため、**CCSを無効化したU-only**を追加して切り分ける。

* 対象セッション: **S4のみ**（差が出やすい）
* 条件: 4条件 × n=3（最小セット）
  1. Fixed100
  2. Fixed500
  3. Policy（U+CCS, 100↔500）
  4. Ablation（CCS-off = **U-only**, 100↔500）

## 真値（truth）

* `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv`（100msグリッド, n_steps=1800=180s）
* TXは上記CSV由来の `label/U/CCS` をフラッシュに埋め込み、同一セッションを再生する。

## スケッチ（Arduino IDE 用）

* TX: `uccs_d4b_scan90/src/tx/TX_UCCS_D4B_SCAN90/TX_UCCS_D4B_SCAN90.ino`
* RX: `uccs_d4b_scan90/src/rx/RX_UCCS_D4B_SCAN90/RX_UCCS_D4B_SCAN90.ino`
* TXSD: `uccs_d4b_scan90/src/txsd/TXSD_UCCS_D4B_SCAN90/TXSD_UCCS_D4B_SCAN90.ino`

## 配線

* TX `GPIO25 (SYNC_OUT)` → RX `GPIO26 (SYNC_IN)` / TXSD `GPIO26 (SYNC_IN)`
* TX `GPIO27 (TICK_OUT)` → TXSD `GPIO33 (TICK_IN)`

## 実行

* 1回の起動で S4 × 4条件を自動実行（`REPEAT=3`）。
* trial長: 180s（`EFFECTIVE_LEN_STEPS=1800`）。

## TX payload仕様（ManufacturerData）

形式: `&lt;step_idx&gt;_&lt;tag&gt;`

* `step_idx`: 100msグリッドの整数（0..）
* `tag`: `F4-&lt;label&gt;-&lt;itv&gt;` / `P4-&lt;label&gt;-&lt;itv&gt;` / `U4-&lt;label&gt;-&lt;itv&gt;`
  * `F`: fixed, `P`: policy(U+CCS), `U`: U-only（CCS-off）
  * `&lt;label&gt;`: truth label（2桁）
  * `&lt;itv&gt;`: current interval（100 or 500）

## TXSD cond_id（preamble TICKパルス数）

* 1: S4 fixed100
* 2: S4 fixed500
* 3: S4 policy
* 4: S4 ablation_ccs_off（U-only）

trial中は「広告更新」ごとにTICKを1発出し、TXSD側で `adv_count=tick_count` を記録する（近似）。

## データ配置

* SDから吸い上げた `/logs/` を `uccs_d4b_scan90/data/&lt;run&gt;/{RX,TX}/` にコピーする（TX=TXSDログ）。
* `uccs_d4b_scan90/data/&lt;run&gt;/README.md` に測定条件をメモ。

## 解析

* 集計スクリプト: `uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py`
  * 入力: `--rx-dir .../RX --txsd-dir .../TX`
  * 出力: `per_trial.csv`, `summary_by_condition.csv`, `summary.md`
  * 注意: SDコピーでmtimeが壊れる/cond_idがズレることがあるため、TXSDは **adv_count（tick_count）でクラスタリング**して割り当てる（古いログ混在/逆符号はフィルタで除外）。

* 図（任意）: `uccs_d4b_scan90/analysis/plot_power_vs_pout.py`
  * 入力: `--summary-csv uccs_d4b_scan90/metrics/&lt;run&gt;/summary_by_condition.csv`
  * 出力: `uccs_d4b_scan90/plots/d4b_&lt;run&gt;_power_vs_pout.svg`（matplotlibが無い環境ではSVGを生成）

## 結果（run01）

- 集計: `uccs_d4b_scan90/metrics/01/summary.md`
- 図: `uccs_d4b_scan90/plots/d4b_01_power_vs_pout.svg`
  - 統合図（D3/D4/D4B）: `uccs_d4b_scan90/plots/role_separation_d3_d4_d4b.svg`
  - α正規化図（runごとのfixed100/500で正規化）: `uccs_d4b_scan90/plots/alpha_vs_pout_overview.svg`
  - 失敗イベント中心のストーリー図（TL&gt;1sを生んだ少数イベントの追跡）: `uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline.svg`
  - Poutの寄与分解（上位少数遷移が支配することの可視化）: `uccs_d4b_scan90/plots/pout_tail_01/`
  - 条件付きタイミング（失敗しやすい遷移だけに条件付け）: `uccs_d4b_scan90/plots/ccs_timing_conditional_01/fig_event_triggered_p100_conditional.svg`
  - 追加解析（CCSタイミング可視化）: `uccs_d4b_scan90/plots/ccs_timing_01/`
    - `fig_event_triggered_p100.svg`（truth遷移中心のP(100ms)）
    - `fig_lag_cdf.svg`（遷移→100msへのlag CDF）
    - `fig_hit_cover.svg`（Hit/PreHit/Coverの棒グラフ）
    - `alloc_efficiency_summary.csv`（100ms割当の“効率”指標）

### 主要な結論（S4のみ, mean±std, n=3）

同じ2値（100↔500）で **電力/100ms滞在（share100）がほぼ同等**のまま、CCSを有効にした `Policy(U+CCS)` の方が `U-only(CCS-off)` よりQoSが改善した。

- `S4_policy(U+CCS)`:
  - `avg_power_mW = 200.6±0.1`, `pout_1s = 0.0488±0.0000`, `share100_power_mix≈0.620`
- `S4_ablation_ccs_off(U-only)`:
  - `avg_power_mW = 200.6±0.2`, `pout_1s = 0.0650±0.0141`, `share100_power_mix≈0.621`

→ **Uは100ms滞在（電力）を決め、CCSは同じ電力の範囲でQoS（pout/TL）を改善する**、という「U/CCSの2本立て設計」の正当化に使える。

### レター用の言い切り（D4B単体）

`Policy(U+CCS)` と `U-only(CCS-off)` は **平均電力がほぼ同一**なのに、`Policy(U+CCS)` が **QoSを改善**している。

- 平均電力: `200.626 mW` vs `200.649 mW`（差 `-0.023 mW`）
- `adv_count`: `1215` vs `1227`（100/500のmixもほぼ同等）
- QoS改善（同電力での改善）:
  - `pout_1s`: `0.0650 → 0.0488`（絶対 `-0.0163`, 相対 `-25%`）
  - `tl_mean_s`: `1.407 → 1.317`（約 `-0.089 s`, 相対 `-6.3%`）
  - `pdr_unique`: `0.434 → 0.448`（小さいが改善）

→ **CCSは「100msを増やす」ことでなく、“同じ100ms予算の使い方（タイミング）”でQoSを下げる**と解釈できる。

#### 備考（追加解析の読み）

`uccs_d4b_scan90/plots/ccs_timing_01/` では、truth遷移を基準にした 100ms 割当（event-triggered average 等）を出力している。
ただし現状のD4B run01では、**truth遷移中心の100ms配置差は大きく出ない指標もある**ため、
本文ではまず「同電力でpout/TLが改善した」という事実（D4Bの主結果）を主軸に置くのが安全。
（必要に応じて、遷移定義や“outage近傍”での再可視化に拡張する）

`uccs_d4b_scan90/plots/outage_story_01/` は、上記の「同電力なのにpoutが改善」の内訳が、
**少数のアウトエイジ（TL&gt;1s）イベントの差**として現れていることを示すための、失敗イベント中心の可視化。
（例: transition_step=1128 は U-only でTL≈9.89sだが、Policy(U+CCS)ではTL≈0.21s）

また、チェリーピック回避のため、
`outage_story_01` は `outage_ranking.csv`（U-onlyとPolicyのoutage率差）で遷移をランキングし、
その上位から「U-onlyが悪化している遷移」を機械的に選択してストーリー図を生成する（選び方を固定）。

### Fixedとの位置づけ（S4, scan90）

`Policy(U+CCS)` は

- vs `Fixed500`
  - power: `188.1 → 200.6 mW`（`+12.5 mW`）
  - `pout_1s`: `0.130 → 0.0488`（`-62.5%`）
  - → **電力を少し足してQoSを大きく改善**する点として置ける
- vs `Fixed100`
  - power: `208.3 → 200.6 mW`（`-7.65 mW`, 約 `-3.7%`）
  - `pout_1s`: `0.0813 → 0.0488`（改善）
  - → 本runでは `Fixed100` を支配して見えるが、**環境依存はある**ので本文では言い方を調整する（例: “in this setup”）。</file><file path="README.md"># research_advertising-energy_saving

## エネルギー評価の前提
- 指標: ΔE/adv = (E_on − P_off × T_on) / N_adv。P_off は OFF 試行の平均電力（E_off / T_off）から算出し、T_on に時間スケールを合わせて差し引く。
- ON: 1 trial で ADV を 300 回送出する設計（adv_count は TXSD ログの #summary を真値として使用）。
- OFF: 60 s 固定窓（必要に応じて 120 s まで延長可）で P_off を推定。P_off_trial の median±3MAD を外れ値判定とし、manifest の include=false/high_baseline_outlier で管理する。

## 主なスクリプト
- エネルギー差分（時間スケール吸収・manifest尊重）: `scripts/compute_delta_energy_off.py`
- OFF 健全性チェック（P_off と MAD 外れ値表示）: `scripts/check_units_off.py`
- PDR 結合（TXSD+RX を join、正式指標=PDR_ms=rx_unique/(ms_rx/interval)）: `scripts/compute_pdr_join.py`（`--dedup-seq` で mfd seq 去重）

## 実験ログの配置
- ON: `data/実験データ/研究室/row_1120/TX`（TXSD）, `.../row_1120/RX`
- OFF: `data/実験データ/研究室/row_1123_off/TX`

## 最新データセット (2025-12-12)
- ストレスラベル固定（S1/S4 × {100,500,1000,2000}ms）: `data/1211_modeC2prime_stress_fixed/full`
  - manifest: `data/1211_modeC2prime_stress_fixed/full/manifest.csv`
  - 解析: `results/stress_causal_real_summary_1211_stress_full_scan50.csv`（scan50版をアーカイブ; scan90版は取得後 `_scan90` を出力予定）
  - 集約: `results/stress_causal_real_summary_1211_stress_modes_scan50.csv`（同上）、`..._agg_scan50.csv`
  - サマリ: `data/1211_modeC2prime_stress_fixed/README.md`（PDRは pdr_unique を参照）
  - 指標定義: `docs/metrics_definition.md`（pdr_raw/unique, TL/Pout, 2000msでPout1s≥0.5等）</file><file path="uccs_d2_scan90/README.md"># uccs_d2_scan90（Step D2 実機：動的QoS（TL/Pout）を“動的ログ”起点で確定）

## 目的（Gate-D2）

* D1で「100↔500 の動的切替が成立（電力も線形混合で説明可能）」まで確認できた。
* D2では **動的でもTL/Poutを評価できるログ仕様**にして、実機の `TL/Pout(τ)` を確定する。

## 方針（最小で壊れない形）

* 真値は **stress causal（100msグリッド）** を使用:
  * `Mode_C_2_シミュレート_causal/ccs/stress_causal_S1.csv`
  * `Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv`
* TXは上記CSV由来の **label/U/CCS** をフラッシュに埋め込み、同一セッションを再生する。
* 動的でも同期が壊れないよう、広告payloadに **`step_idx`（100msグリッドの整数）**を入れる。

## スケッチ（Arduino IDE 用）

* TX: `src/tx/TX_UCCS_D2_SCAN90/TX_UCCS_D2_SCAN90.ino`
* RX: `src/rx/RX_UCCS_D2_SCAN90/RX_UCCS_D2_SCAN90.ino`
* TXSD: `src/txsd/TXSD_UCCS_D2_SCAN90/TXSD_UCCS_D2_SCAN90.ino`

### D2b（policy修正版）

policy が 100ms 張り付きになった場合の再取得用。

* TX: `uccs_d2_scan90/src/tx/TX_UCCS_D2B_SCAN90/TX_UCCS_D2B_SCAN90.ino`
* RX: `uccs_d2_scan90/src/rx/RX_UCCS_D2B_SCAN90/RX_UCCS_D2B_SCAN90.ino`
* TXSD: `uccs_d2_scan90/src/txsd/TXSD_UCCS_D2B_SCAN90/TXSD_UCCS_D2B_SCAN90.ino`

修正点:
* `stress_causal_*` の `CCS` を `CCS_change = 1-CCS` に変換して判定（CCS定義の整合）。
* SYNC HIGH の直後に `preamble_guard_ms=100` を入れて cond_id の取りこぼしを低減。

## 配線（1210系と同じ）

* TX `GPIO25 (SYNC_OUT)` → RX `GPIO26 (SYNC_IN)` / TXSD `GPIO26 (SYNC_IN)`
* TX `GPIO27 (TICK_OUT)` → TXSD `GPIO33 (TICK_IN)`

## 実行（1回の起動で自動ループ）

* セッション: S1 と S4（両方）
* 条件（各セッションで3つ）:
  1. Fixed100
  2. Fixed500
  3. Policy(100↔500, u_mid=0.20,u_high=0.35,c_mid=0.20,c_high=0.35,hyst=0.02)
* 繰り返し: `REPEAT=3`（= 各条件×3）

※ trialの長さは `EFFECTIVE_LEN_STEPS`（100msグリッドの長さ）で決まる。デフォルトは 1800 (=180s)。

## TX payload仕様（ManufacturerData）

* 形式: `&lt;step_idx&gt;_&lt;tag&gt;`
  * `step_idx`: 100msグリッドの整数（0..）
  * `tag`: `F1-&lt;label&gt;-&lt;itv&gt;` / `P1-&lt;label&gt;-&lt;itv&gt;` / `F4-...` / `P4-...`
    * 先頭: `F`=fixed, `P`=policy
    * `1/4`: session id
    * `&lt;label&gt;`: 真値ラベル（数値）
    * `&lt;itv&gt;`: current interval（100 or 500）

この設計により、**動的でも `step_idx*100ms` が真値時刻として扱える**。

## TXSD cond_id（preamble TICKパルス数）

* 1: S1 fixed100
* 2: S1 fixed500
* 3: S1 policy
* 4: S4 fixed100
* 5: S4 fixed500
* 6: S4 policy

trial中は **各広告更新ごとにTICKを1発**出し、TXSD側で `adv_count=tick_count` が取れる。

## データ配置

* SDから吸い上げた `/logs/` を `uccs_d2_scan90/data/&lt;run&gt;/{RX,TX}/` にコピーする（TXはTXSDのログ）。
* `data/&lt;run&gt;/README.md` に測定条件（距離/環境/電源/scan duty）をメモ。

## 解析（D2）

* 実測ログ（RX/TXSD）から、`step_idx` 起点で TL/Pout を算出する。
  * スクリプト: `uccs_d2_scan90/analysis/summarize_d2_run.py`
  * 出力:
    * D2（policyが100ms張り付きになった取得分）: `uccs_d2_scan90/metrics/01/summary.md`
    * D2b（CCS反転でpolicyが100↔500で動作した取得分）: `uccs_d2_scan90/metrics/B/summary.md`
      * データ: `uccs_d2_scan90/data/B/README.md`
  * 図（D2b run B）: `uccs_d2_scan90/plots/d2b_B_power_vs_pout.png`（power vs pout + share100注釈）</file><file path="uccs_d3_scan70/analysis/summarize_d3_run_v2.py">#!/usr/bin/env python3
&quot;&quot;&quot;
Summarize uccs_d3_scan70 run (RX + TXSD) and compute TL/Pout using step_idx-aligned payload.

This pairs RX↔TXSD by file modification time order because TXSD trial index is allocated per tag/cond
and is not globally monotonic.

Step D3 (scan duty down):
  - S4 only
  - 3 conditions × 3 repeats = 9 trials
    - S4_fixed100
    - S4_fixed500
    - S4_policy
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import csv
import re
import statistics
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


TRUTH_DT_MS = 100
TAU_VALUES_S = (1.0, 2.0, 3.0)
VALID_MIN_DURATION_MS = 160_000  # ~180s trials

TAG_RE = re.compile(r&quot;^(?P&lt;mode&gt;[FP])(?P&lt;sess&gt;[14])-(?P&lt;label&gt;\d+)-(?P&lt;itv&gt;\d+)$&quot;)
RX_TRIAL_RE = re.compile(r&quot;rx_trial_(?P&lt;id&gt;\d+)\.csv$&quot;)
TXSD_NAME_RE = re.compile(r&quot;trial_(?P&lt;idx&gt;\d+)_c(?P&lt;cond&gt;\d+)_(?P&lt;tag&gt;.+)\.csv$&quot;)

# SDカードからのコピーでmtimeが信頼できないケース（FATが1980固定など）があるため、
# D3ではTXSDをmtimeで並べてzipするのを避け、adv_count(tick_count)の値でクラスタリングして割り当てる。
# また、明らかに別条件（古いログ混在）と思われる低電力ログを除外する。
TXSD_MIN_AVG_POWER_MW = 150.0


@dataclass(frozen=True)
class RxEvent:
    rx_ms: float
    step_idx: int
    truth_label: int
    itv_ms: int
    tag: str


@dataclass
class RxTrial:
    rx_id: int
    path: Path
    duration_ms: float
    mode: str  # F/P
    fixed_itv: Optional[int]
    events: List[RxEvent]


@dataclass
class TxsdTrial:
    path: Path
    mtime_s: float
    trial_idx: int
    cond_id: int
    tag: str
    ms_total: float
    adv_count: int
    e_total_mj: float
    avg_power_mw: float


def read_truth_labels(path: Path, n_steps: int) -&gt; List[int]:
    labels: List[int] = []
    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            labels.append(int(row[&quot;label&quot;]))
            if len(labels) &gt;= n_steps:
                break
    if len(labels) &lt; n_steps:
        raise SystemExit(f&quot;truth too short: {path} rows={len(labels)} &lt; {n_steps}&quot;)
    return labels


def read_rx_trial(path: Path) -&gt; RxTrial:
    m = RX_TRIAL_RE.search(path.name)
    if not m:
        raise ValueError(f&quot;not rx_trial: {path}&quot;)
    rx_id = int(m.group(&quot;id&quot;))

    events: List[RxEvent] = []
    last_ms: float = 0.0

    mode_c: Dict[str, int] = {&quot;F&quot;: 0, &quot;P&quot;: 0}
    itv_c: Dict[int, int] = {}

    with path.open(newline=&quot;&quot;) as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                rx_ms = float(row.get(&quot;ms&quot;) or 0.0)
            except Exception:
                continue
            last_ms = max(last_ms, rx_ms)

            try:
                step_idx = int(row.get(&quot;seq&quot;) or 0)
            except Exception:
                continue

            tag = (row.get(&quot;label&quot;) or &quot;&quot;).strip()
            tm = TAG_RE.match(tag)
            if not tm:
                continue
            mode = tm.group(&quot;mode&quot;)
            sess = int(tm.group(&quot;sess&quot;))
            if sess != 4:
                continue
            truth_label = int(tm.group(&quot;label&quot;))
            itv_ms = int(tm.group(&quot;itv&quot;))

            mode_c[mode] = mode_c.get(mode, 0) + 1
            itv_c[itv_ms] = itv_c.get(itv_ms, 0) + 1

            events.append(
                RxEvent(
                    rx_ms=rx_ms,
                    step_idx=step_idx,
                    truth_label=truth_label,
                    itv_ms=itv_ms,
                    tag=tag,
                )
            )

    if not events:
        raise ValueError(f&quot;empty/invalid RX: {path}&quot;)

    mode = max(mode_c.items(), key=lambda kv: kv[1])[0]
    fixed_itv: Optional[int] = None
    if mode == &quot;F&quot;:
        fixed_itv = max(itv_c.items(), key=lambda kv: kv[1])[0] if itv_c else None
        if fixed_itv not in (100, 500):
            raise ValueError(f&quot;unexpected fixed interval {fixed_itv} in {path}&quot;)

    return RxTrial(rx_id=rx_id, path=path, duration_ms=last_ms, mode=mode, fixed_itv=fixed_itv, events=events)


def rx_bucket(t: RxTrial) -&gt; str:
    if t.mode == &quot;P&quot;:
        return &quot;P4&quot;
    return f&quot;F4_{t.fixed_itv}&quot;


def select_balanced_window(trials: List[RxTrial]) -&gt; List[RxTrial]:
    candidates = [t for t in trials if t.duration_ms &gt;= VALID_MIN_DURATION_MS]
    candidates.sort(key=lambda t: t.rx_id)
    if len(candidates) &lt; 9:
        raise SystemExit(f&quot;not enough valid RX trials (&gt;= {VALID_MIN_DURATION_MS}ms): {len(candidates)}&quot;)

    want = {&quot;F4_100&quot;, &quot;F4_500&quot;, &quot;P4&quot;}
    best: Optional[List[RxTrial]] = None
    for start in range(0, len(candidates) - 9 + 1):
        window = candidates[start : start + 9]
        counts: Dict[str, int] = {}
        for t in window:
            counts[rx_bucket(t)] = counts.get(rx_bucket(t), 0) + 1
        if set(counts.keys()) == want and counts.get(&quot;F4_100&quot;, 0) == 3 and counts.get(&quot;F4_500&quot;, 0) == 3 and counts.get(&quot;P4&quot;, 0) == 3:
            best = window
    if not best:
        raise SystemExit(&quot;could not find balanced 9-trial RX window (F4_100/F4_500/P4 × 3 repeats)&quot;)
    return best


def estimate_offset_ms(events: List[RxEvent]) -&gt; Tuple[float, int]:
    first_ms: Dict[int, float] = {}
    for e in sorted(events, key=lambda x: x.rx_ms):
        if e.step_idx not in first_ms:
            first_ms[e.step_idx] = e.rx_ms
    deltas: List[float] = []
    for step, ms in first_ms.items():
        if step &lt;= 0:
            continue
        deltas.append(step * TRUTH_DT_MS - ms)
    if not deltas:
        return 0.0, 0
    return statistics.median(deltas), len(deltas)


def compute_tl_and_pout(truth_labels: List[int], aligned_events: List[Tuple[float, int]]) -&gt; Tuple[float, float, Dict[float, float]]:
    transitions_ms: List[int] = []
    prev = truth_labels[0]
    for idx, lab in enumerate(truth_labels[1:], start=1):
        if lab != prev:
            transitions_ms.append(idx * TRUTH_DT_MS)
            prev = lab
    if not transitions_ms:
        return 0.0, 0.0, {tau: 0.0 for tau in TAU_VALUES_S}

    aligned_events_sorted = sorted(aligned_events, key=lambda x: x[0])
    tl_list_s: List[float] = []
    for t_ms in transitions_ms:
        idx = min(t_ms // TRUTH_DT_MS, len(truth_labels) - 1)
        true_label = truth_labels[idx]
        arrival: Optional[float] = None
        for ms, lbl in aligned_events_sorted:
            if ms &gt; t_ms and lbl == true_label:
                arrival = ms
                break
        if arrival is None:
            tl_list_s.append(float(&quot;inf&quot;))
        else:
            tl_list_s.append((arrival - t_ms) / 1000.0)

    finite = [x for x in tl_list_s if x != float(&quot;inf&quot;)]
    tl_mean = statistics.mean(finite) if finite else float(&quot;inf&quot;)
    tl_p95 = statistics.quantiles(finite, n=20)[18] if len(finite) &gt;= 20 else (max(finite) if finite else float(&quot;inf&quot;))
    pout: Dict[float, float] = {}
    for tau in TAU_VALUES_S:
        miss = sum(1 for x in tl_list_s if x == float(&quot;inf&quot;) or x &gt; tau)
        pout[tau] = miss / len(tl_list_s)
    return tl_mean, tl_p95, pout


def parse_txsd_summary(path: Path) -&gt; Optional[TxsdTrial]:
    m = TXSD_NAME_RE.match(path.name)
    if not m:
        return None
    trial_idx = int(m.group(&quot;idx&quot;))
    cond_id = int(m.group(&quot;cond&quot;))
    tag = m.group(&quot;tag&quot;)

    ms_total = None
    adv_count = None
    e_total_mj = None
    with path.open() as f:
        for line in f:
            if line.startswith(&quot;# summary&quot;):
                parts = [p.strip() for p in line.strip().split(&quot;,&quot;)]
                kv: Dict[str, str] = {}
                for p in parts:
                    if &quot;=&quot; in p:
                        k, v = p.split(&quot;=&quot;, 1)
                        kv[k.strip(&quot;# &quot;).strip()] = v.strip()
                ms_total = float(kv.get(&quot;ms_total&quot;)) if kv.get(&quot;ms_total&quot;) else None
                adv_count = int(kv.get(&quot;adv_count&quot;)) if kv.get(&quot;adv_count&quot;) else None
                e_total_mj = float(kv.get(&quot;E_total_mJ&quot;)) if kv.get(&quot;E_total_mJ&quot;) else None
                break
    if ms_total is None or adv_count is None or e_total_mj is None:
        return None
    if ms_total &lt;= 0:
        return None
    avg_power = e_total_mj / (ms_total / 1000.0)
    return TxsdTrial(
        path=path,
        mtime_s=path.stat().st_mtime,
        trial_idx=trial_idx,
        cond_id=cond_id,
        tag=tag,
        ms_total=ms_total,
        adv_count=adv_count,
        e_total_mj=e_total_mj,
        avg_power_mw=avg_power,
    )


def estimate_rx_tag_share100_time_est(events: List[RxEvent]) -&gt; Optional[float]:
    itv_by_step: Dict[int, int] = {}
    for e in events:
        if e.step_idx not in itv_by_step:
            itv_by_step[e.step_idx] = e.itv_ms
    n100 = sum(1 for v in itv_by_step.values() if v == 100)
    n500 = sum(1 for v in itv_by_step.values() if v == 500)
    denom_ms = n100 * 100 + n500 * 500
    if denom_ms &lt;= 0:
        return None
    return (n100 * 100) / denom_ms


def classify_txsd_groups_by_adv_count(txsd_trials: List[TxsdTrial]) -&gt; Dict[str, List[TxsdTrial]]:
    &quot;&quot;&quot;
    Group TXSD trials by adv_count (tick_count).

    For D3 we expect three dominant adv_count values:
      - min  -&gt; fixed500
      - mid  -&gt; policy
      - max  -&gt; fixed100
    &quot;&quot;&quot;
    by_adv: Dict[int, List[TxsdTrial]] = {}
    for t in txsd_trials:
        by_adv.setdefault(t.adv_count, []).append(t)

    adv_values = sorted(by_adv.keys())
    if len(adv_values) &lt; 3:
        raise SystemExit(f&quot;TXSD adv_count has &lt;3 unique values: {adv_values}&quot;)

    adv_min = adv_values[0]
    adv_max = adv_values[-1]
    if len(adv_values) == 3:
        adv_mid = adv_values[1]
    else:
        # choose the value closest to the midpoint of min/max
        target = (adv_min + adv_max) / 2.0
        inner = adv_values[1:-1]
        adv_mid = min(inner, key=lambda v: abs(v - target))

    return {
        &quot;S4_fixed500&quot;: sorted(by_adv[adv_min], key=lambda t: t.path.name),
        &quot;S4_policy&quot;: sorted(by_adv[adv_mid], key=lambda t: t.path.name),
        &quot;S4_fixed100&quot;: sorted(by_adv[adv_max], key=lambda t: t.path.name),
    }


def pick_n_typical_by_power(group: List[TxsdTrial], n: int) -&gt; List[TxsdTrial]:
    &quot;&quot;&quot;
    Pick n trials whose avg_power is closest to the group&apos;s median (drop outliers).
    &quot;&quot;&quot;
    if len(group) &lt; n:
        raise SystemExit(f&quot;not enough TXSD trials in group: need {n}, got {len(group)}&quot;)
    powers = [t.avg_power_mw for t in group]
    med = statistics.median(powers)
    group_sorted = sorted(group, key=lambda t: abs(t.avg_power_mw - med))
    return group_sorted[:n]


def mean_std(xs: List[float]) -&gt; Tuple[float, float]:
    if not xs:
        return 0.0, 0.0
    if len(xs) == 1:
        return xs[0], 0.0
    return statistics.mean(xs), statistics.stdev(xs)


def compute_share100_power_mix(p_pol: float, p_100: float, p_500: float) -&gt; Optional[float]:
    &quot;&quot;&quot;
    Estimate time share of 100ms from average power assuming linear mixture:
      P = s*P100 + (1-s)*P500  -&gt;  s = (P - P500)/(P100 - P500)
    &quot;&quot;&quot;
    denom = (p_100 - p_500)
    if denom == 0:
        return None
    s = (p_pol - p_500) / denom
    # clamp to [0,1] to avoid small numerical drift
    if s &lt; 0:
        s = 0.0
    if s &gt; 1:
        s = 1.0
    return s


def condition_name(rx: RxTrial) -&gt; str:
    if rx.mode == &quot;F&quot;:
        return &quot;S4_fixed100&quot; if rx.fixed_itv == 100 else &quot;S4_fixed500&quot;
    return &quot;S4_policy&quot;


def main() -&gt; None:
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;--rx-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--txsd-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--out-dir&quot;, type=Path, required=True)
    ap.add_argument(&quot;--truth-s4&quot;, type=Path, default=Path(&quot;Mode_C_2_シミュレート_causal/ccs/stress_causal_S4.csv&quot;))
    ap.add_argument(&quot;--n-steps&quot;, type=int, default=1800)
    args = ap.parse_args()

    truth = read_truth_labels(args.truth_s4, args.n_steps)

    rx_all: List[RxTrial] = []
    for p in sorted(args.rx_dir.glob(&quot;rx_trial_*.csv&quot;)):
        try:
            rx_all.append(read_rx_trial(p))
        except Exception:
            continue
    rx_trials = select_balanced_window(rx_all)
    rx_trials.sort(key=lambda t: t.rx_id)

    txsd_all: List[TxsdTrial] = []
    for p in sorted(args.txsd_dir.glob(&quot;trial_*.csv&quot;)):
        tt = parse_txsd_summary(p)
        if not tt:
            continue
        if tt.ms_total &gt;= VALID_MIN_DURATION_MS:
            if tt.avg_power_mw &gt;= TXSD_MIN_AVG_POWER_MW:
                txsd_all.append(tt)

    if not txsd_all:
        raise SystemExit(&quot;no valid TXSD trials found after filtering&quot;)

    groups = classify_txsd_groups_by_adv_count(txsd_all)
    # pick exactly 3 trials per condition (closest to median power)
    picked: Dict[str, List[TxsdTrial]] = {k: pick_n_typical_by_power(v, 3) for k, v in groups.items()}
    for k in picked:
        picked[k].sort(key=lambda t: t.path.name)

    pairs: List[Tuple[RxTrial, TxsdTrial]] = []
    for rx in rx_trials:
        cond = condition_name(rx)
        if cond not in picked or not picked[cond]:
            raise SystemExit(f&quot;TXSD group missing for {cond}&quot;)
        pairs.append((rx, picked[cond].pop(0)))

    rep_counter: Dict[str, int] = {}
    per_rows: List[Dict[str, object]] = []
    for rx, tx in pairs:
        cond = condition_name(rx)
        rep_counter[cond] = rep_counter.get(cond, 0) + 1
        rep_idx = rep_counter[cond]

        offset_ms, offset_n = estimate_offset_ms(rx.events)
        aligned_events: List[Tuple[float, int]] = []
        step_set: set[int] = set()
        for e in rx.events:
            t_ms = e.rx_ms + offset_ms
            if 0.0 &lt;= t_ms &lt; (args.n_steps * TRUTH_DT_MS):
                aligned_events.append((t_ms, e.truth_label))
            if e.step_idx &gt;= 0:
                step_set.add(e.step_idx)

        tl_mean, tl_p95, pout = compute_tl_and_pout(truth, aligned_events)
        rx_unique = len(step_set)
        pdr_unique = min(rx_unique, tx.adv_count) / tx.adv_count if tx.adv_count &gt; 0 else 0.0
        share100 = estimate_rx_tag_share100_time_est(rx.events)

        per_rows.append(
            {
                &quot;rx_trial_id&quot;: rx.rx_id,
                &quot;condition&quot;: cond,
                &quot;repeat_idx&quot;: rep_idx,
                &quot;mode&quot;: (&quot;POLICY&quot; if rx.mode == &quot;P&quot; else f&quot;FIXED_{rx.fixed_itv}&quot;),
                &quot;rx_count&quot;: len(rx.events),
                &quot;rx_unique&quot;: rx_unique,
                &quot;adv_count&quot;: tx.adv_count,
                &quot;pdr_unique&quot;: round(pdr_unique, 6),
                &quot;rx_tag_share100_time_est&quot;: (round(share100, 6) if share100 is not None else &quot;&quot;),
                &quot;tl_mean_s&quot;: round(tl_mean, 6),
                &quot;tl_p95_s&quot;: round(tl_p95, 6),
                &quot;pout_1s&quot;: round(pout[1.0], 6),
                &quot;pout_2s&quot;: round(pout[2.0], 6),
                &quot;pout_3s&quot;: round(pout[3.0], 6),
                &quot;tl_time_offset_ms&quot;: round(offset_ms, 3),
                &quot;tl_time_offset_n&quot;: offset_n,
                &quot;txsd_ms_total&quot;: tx.ms_total,
                &quot;E_total_mJ&quot;: tx.e_total_mj,
                &quot;avg_power_mW&quot;: tx.avg_power_mw,
                &quot;txsd_mtime_s&quot;: round(tx.mtime_s, 3),
                &quot;txsd_path&quot;: str(tx.path),
                &quot;rx_path&quot;: str(rx.path),
            }
        )

    per_rows.sort(key=lambda r: int(r[&quot;rx_trial_id&quot;]))
    args.out_dir.mkdir(parents=True, exist_ok=True)
    per_path = args.out_dir / &quot;per_trial.csv&quot;
    with per_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(per_rows[0].keys()))
        w.writeheader()
        w.writerows(per_rows)

    by_cond: Dict[str, List[Dict[str, object]]] = {}
    for r in per_rows:
        by_cond.setdefault(str(r[&quot;condition&quot;]), []).append(r)

    summary_rows: List[Dict[str, object]] = []
    for cond, rows in sorted(by_cond.items()):
        pout_1s_list = [float(r[&quot;pout_1s&quot;]) for r in rows]
        tl_list = [float(r[&quot;tl_mean_s&quot;]) for r in rows]
        pdr_list = [float(r[&quot;pdr_unique&quot;]) for r in rows]
        pwr_list = [float(r[&quot;avg_power_mW&quot;]) for r in rows]
        adv_list = [float(r[&quot;adv_count&quot;]) for r in rows]
        share_list = [float(r[&quot;rx_tag_share100_time_est&quot;]) for r in rows if r[&quot;rx_tag_share100_time_est&quot;] != &quot;&quot;]

        pout_m, pout_s = mean_std(pout_1s_list)
        tl_m, tl_s = mean_std(tl_list)
        pdr_m, pdr_s = mean_std(pdr_list)
        pwr_m, pwr_s = mean_std(pwr_list)
        adv_m, adv_s = mean_std(adv_list)
        sh_m, sh_s = mean_std(share_list) if share_list else (0.0, 0.0)

        summary_rows.append(
            {
                &quot;condition&quot;: cond,
                &quot;n_trials&quot;: len(rows),
                &quot;pout_1s_mean&quot;: round(pout_m, 6),
                &quot;pout_1s_std&quot;: round(pout_s, 6),
                &quot;tl_mean_s_mean&quot;: round(tl_m, 6),
                &quot;tl_mean_s_std&quot;: round(tl_s, 6),
                &quot;pdr_unique_mean&quot;: round(pdr_m, 6),
                &quot;pdr_unique_std&quot;: round(pdr_s, 6),
                &quot;rx_tag_share100_time_est_mean&quot;: (round(sh_m, 6) if share_list else &quot;&quot;),
                &quot;rx_tag_share100_time_est_std&quot;: (round(sh_s, 6) if share_list else &quot;&quot;),
                &quot;avg_power_mW_mean&quot;: round(pwr_m, 3),
                &quot;avg_power_mW_std&quot;: round(pwr_s, 3),
                &quot;adv_count_mean&quot;: round(adv_m, 3),
                &quot;adv_count_std&quot;: round(adv_s, 3),
            }
        )

    # Add power-mix share100 estimate (use mean powers only).
    p100 = next((float(r[&quot;avg_power_mW_mean&quot;]) for r in summary_rows if r[&quot;condition&quot;] == &quot;S4_fixed100&quot;), None)
    p500 = next((float(r[&quot;avg_power_mW_mean&quot;]) for r in summary_rows if r[&quot;condition&quot;] == &quot;S4_fixed500&quot;), None)
    ppol = next((float(r[&quot;avg_power_mW_mean&quot;]) for r in summary_rows if r[&quot;condition&quot;] == &quot;S4_policy&quot;), None)
    share_mix = None
    if p100 is not None and p500 is not None and ppol is not None:
        share_mix = compute_share100_power_mix(ppol, p100, p500)
    for r in summary_rows:
        if r[&quot;condition&quot;] == &quot;S4_policy&quot; and share_mix is not None:
            r[&quot;share100_power_mix_mean&quot;] = round(share_mix, 6)
        else:
            r[&quot;share100_power_mix_mean&quot;] = &quot;&quot;

    sum_path = args.out_dir / &quot;summary_by_condition.csv&quot;
    with sum_path.open(&quot;w&quot;, newline=&quot;&quot;) as f:
        w = csv.DictWriter(f, fieldnames=list(summary_rows[0].keys()))
        w.writeheader()
        w.writerows(summary_rows)

    lines: List[str] = []
    lines.append(&quot;# uccs_d3_scan70 metrics summary (v2)\n\n&quot;)
    lines.append(f&quot;- source RX: `{args.rx_dir}`\n&quot;)
    lines.append(f&quot;- source TXSD: `{args.txsd_dir}`\n&quot;)
    lines.append(f&quot;- truth: `{args.truth_s4}` (n_steps={args.n_steps}, dt=100ms)\n&quot;)
    lines.append(f&quot;- selected RX trials: {rx_trials[0].rx_id:03d}..{rx_trials[-1].rx_id:03d} (n={len(rx_trials)})\n&quot;)
    uniq_adv = sorted({tx.adv_count for _, tx in pairs})
    lines.append(f&quot;- selected TXSD trials: grouped by adv_count={uniq_adv} (n={len(pairs)})\n&quot;)
    lines.append(f&quot;- generated: {datetime.now().strftime(&apos;%Y-%m-%d %H:%M&apos;)} (local)\n&quot;)
    lines.append(f&quot;- command: `python3 uccs_d3_scan70/analysis/summarize_d3_run_v2.py --rx-dir {args.rx_dir} --txsd-dir {args.txsd_dir} --out-dir {args.out_dir}`\n&quot;)

    lines.append(&quot;\n## Summary (mean ± std)\n&quot;)
    lines.append(&quot;| condition | pout_1s | tl_mean_s | pdr_unique | avg_power_mW | adv_count | share100_time_est (RX tags) | share100_power_mix |\n&quot;)
    lines.append(&quot;|---|---:|---:|---:|---:|---:|---:|---:|\n&quot;)

    def fmt_pm(m: object, s: object, decimals: int) -&gt; str:
        if m == &quot;&quot; or s == &quot;&quot;:
            return &quot;&quot;
        return f&quot;{float(m):.{decimals}f}±{float(s):.{decimals}f}&quot;

    for r in summary_rows:
        share_mix = r.get(&quot;share100_power_mix_mean&quot;, &quot;&quot;)
        lines.append(
            f&quot;| {r[&apos;condition&apos;]} | {fmt_pm(r[&apos;pout_1s_mean&apos;], r[&apos;pout_1s_std&apos;], 4)} | &quot;
            f&quot;{fmt_pm(r[&apos;tl_mean_s_mean&apos;], r[&apos;tl_mean_s_std&apos;], 3)} | &quot;
            f&quot;{fmt_pm(r[&apos;pdr_unique_mean&apos;], r[&apos;pdr_unique_std&apos;], 3)} | &quot;
            f&quot;{fmt_pm(r[&apos;avg_power_mW_mean&apos;], r[&apos;avg_power_mW_std&apos;], 1)} | &quot;
            f&quot;{fmt_pm(r[&apos;adv_count_mean&apos;], r[&apos;adv_count_std&apos;], 1)} | &quot;
            f&quot;{fmt_pm(r[&apos;rx_tag_share100_time_est_mean&apos;], r[&apos;rx_tag_share100_time_est_std&apos;], 3) if r.get(&apos;rx_tag_share100_time_est_mean&apos;,&apos;&apos;)!=&apos;&apos; else &apos;&apos;} | &quot;
            f&quot;{(f&apos;{float(share_mix):.3f}&apos; if share_mix != &apos;&apos; else &apos;&apos;)} |&quot;
            &quot;\n&quot;
        )

    lines.append(&quot;\n## Notes\n&quot;)
    lines.append(&quot;- RX window: latest 9 trials that form 3 conditions × 3 repeats (duration&gt;=160s).\n&quot;)
    lines.append(&quot;- TXSD pairing: mtimeが信頼できないため、adv_count（tick_count）でクラスタリングして各条件3本を割り当て。\n&quot;)
    lines.append(f&quot;  - filter: avg_power_mW &gt;= {TXSD_MIN_AVG_POWER_MW:.1f}（古いログ混在を除外）\n&quot;)
    lines.append(&quot;- TL/Pout alignment: per-trial constant offset estimated from (step_idx*100ms - first_rx_ms(step_idx)).\n&quot;)
    lines.append(&quot;- TXSD adv_count is tick_count (1 tick per payload update); used as denominator for pdr_unique.\n&quot;)
    lines.append(&quot;- share100_time_est: estimated from RX tags (unique step_idx by interval); sanity only (RX has drops).\n&quot;)

    md_path = args.out_dir / &quot;summary.md&quot;
    md_path.write_text(&quot;&quot;.join(lines), encoding=&quot;utf-8&quot;)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="docs/decision_log_2025-12-13_letter_route.md"># decision_log_2025-12-13_letter_route

- 日付: 2025-12-13
- 目的: レター投稿を最速で成立させるため、「新規性」と「実装/実験リスク」を比較してルートを確定する。

## 前提（いま揃っているもの）
- 実機固定（Mode C2′, scan90%）: `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_agg_enriched_scan90_v4.csv`
- オフライン（mHealth合成 + U/CCS）: `results/mhealth_policy_eval/`（policy table / Pareto sweep / context mixing）
- 電力テーブル（固定interval）: `results/mhealth_policy_eval/power_table_sleep_eval_2025-12-13.csv`
  - 生成元: `sleep_eval_scan90/metrics/on_off_test_100~2000/txsd_power_summary.csv`（TXSD mean_p_mW, n=2）

## 候補ルート（TODOとの比較）

### ルートA（docs/TODO.mdの主線）
- P0: TL/Pout定義の固定 → scan90固定フルセット図表化（実測vsシミュ説明）
- P1: CCS_causal を実機で取得（S1/S4）→ 固定と比較
- P2: self-UCB（不確実性駆動）をシミュで設計

**長所**
- 既存のMode C2′資産（S1/S4、scan90、解析パイプライン）に直結していてブレが少ない。

**短所（新規性）**
- CCS_causal が「HAR不確実度（U）そのもの」から少し遠く、レターの主張を「不確実性駆動」に寄せにくい。

### ルートB（今回の流れ: U/CCS→interval のオフライン最適化を主線にする）
- mHealth合成から得た U/CCS ログに対して、閾値ルール（ヒステリシス）を評価。
- scan90固定（S1/S4）メトリクスで QoS を、sleep_eval の power table で電力を合成し、Paretoを提示。
- Safe-MABは「Future Work」または「オフライン1図」までに留める。

**長所（新規性×最速）**
- 「HARの不確実度に基づく通信制御」をPhase1（ルールベース）で主張できる。
- power table を入れることで「share100を減らすと電力が下がる」を定量で示せる。

**短所（リスク）**
- 実機の“動的切替そのもの”の実証が薄いと突っ込まれる可能性がある。
  - 対策: 実機は最小セット（固定 + 2値制御）で「切替が成立する」だけ確認し、主結果はオフライン合成で示す。

## 評価（新規性の観点）
レター（Phase 1）の主張は `docs/全体像.md` のとおり「決め打ちルールで固定より良い」を示すこと。
ここでの差は「CCS（擬似安定度）」中心か、「U（不確実度）」中心か。

- 新規性を立てやすいのはルートB（U/CCSを明示できる）。
- ただし、論文化の安全性（再現性・測定系の説明容易性）はルートAの資産を活かす方が高い。

## 決定（Best / Fast）
**ルートBを主線**にして、TODOのP0（指標定義・図表化）は並行で必ず踏む。

具体的には：
1) **P0（必須）**: TL/Poutの真値定義を固定し、scan90固定の図表を整える（ここはTODO準拠）。
2) **Phase1主結果**: U/CCS→interval（ルールベース）を、scan90 QoS + power table でオフライン評価し、Pareto（pout_1s vs avg_power）を提示。
3) **実機は最小**: 動的切替の動作確認は「100↔500（2値）」で最小本数のみ（固定100/500/2000と合わせて比較、nは小さくてよい）。
4) **Safe-MAB**: レターでは Future Work（またはオフライン1図）に留める。

## 直近の根拠データ（境界条件の確定）
- power table（sleep_eval, n=2）:
  - 100ms: 201.45 mW
  - 500ms: 182.95 mW
  - 1000ms: 180.50 mW
  - 2000ms: 179.75 mW
  - 重要: 電力低下の主効果は「100→500」で、500→2000は小さい。
- Pareto v5（power_table反映 + context mixing）:
  - `results/mhealth_policy_eval/pareto_front_v5_power_table/pareto_summary.md`
  - δ=0.12 は feasible=0、δ=0.13 は feasible&gt;0（境界が 0.12〜0.13 にある）。

## 次アクション（この順で進める）
- A1: `scripts/analyze_stress_causal_real.py` のTL/Pout真値定義を再確認し、`docs/metrics_definition.md` と整合させる（TODO P0）。
- B1: `results/mhealth_policy_eval/pareto_front_v5_power_table/` を主結果候補として固定（図・表の整理）。
- B2: レター用に action を {100,500}（2値）へ縮退した評価を追加（説明簡単・電力の主効果に一致）。
- C1: 実機（動的切替）を最小セットで確認（Fixed 100/500/2000 + 2値制御、各n=1〜3）。

## 生成済み（主張図の固定）
- δ帯の主張図（固定点＋採用候補3点）:
  - `results/mhealth_policy_eval/letter_v1/fig_delta_band.png`
  - 選定点: `results/mhealth_policy_eval/letter_v1/selected_policies.csv`

## 追記（2025-12-13, v5反映後）
- scan90固定メトリクスを v4 → v5 に更新（TL/Poutの時間同期を追加）:
  - v5: `results/stress_fixed/scan90/stress_causal_real_summary_1211_stress_agg_enriched_scan90_v5.csv`
  - v4 は開始位相ズレの影響で TL/Pout が歪む可能性があるため、以後は v5 を基準にする（`docs/metrics_definition.md` の「時間同期」参照）。
- v5を用いて、mHealth Pareto sweep を再実行（power table + context mixing）:
  - v6: `results/mhealth_policy_eval/pareto_front_v6_power_table_scan90_v5/pareto_summary.md`
  - 更新点: δ=0.10 が feasible（例: 90/243）となり、従来の「δ=0.12不可/0.13から可」は v4前提の結論として扱う。
- 影響:
  - `results/mhealth_policy_eval/letter_v1/` と `pareto_front_v5_power_table/` は v4前提の図表なので、レター本文に使う場合は v6（scan90 v5反映）で再生成が必要。

## 追記（2025-12-16, 実機D2の主結果はD2b(B)を採用）

- 採用方針:
  - 実機D2は `uccs_d2_scan90/metrics/B/summary.md`（D2b run B）を主結果として採用する。
  - `uccs_d2_scan90/metrics/01/summary.md`（D2 run 01）は **policyの100ms張り付き（CCS定義不整合）**の例としてログに残し、主張には使わない。
- 根拠（D2b run B, mean±std, n=3）:
  - S1:
    - Fixed100: 202.9±0.5 mW / pout_1s=0.0833±0.0289 / TL_mean=4.210±1.540 s
    - Fixed500: 183.3±0.2 mW / pout_1s=0.1500±0.0500 / TL_mean=5.296±0.019 s
    - Policy: 189.8±0.4 mW / pout_1s=0.1167±0.0289 / TL_mean=5.247±0.053 s / share100≈0.332
  - S4:
    - Fixed100: 202.5±0.4 mW / pout_1s=0.0569±0.0141 / TL_mean=1.247±0.010 s
    - Fixed500: 183.2±0.3 mW / pout_1s=0.1545±0.0373 / TL_mean=2.166±0.870 s
    - Policy: 195.2±0.4 mW / pout_1s=0.0813±0.0373 / TL_mean=1.588±0.582 s / share100≈0.592
- 言えること（論文主張の形）:
  - **Fixed100より省電力**かつ **Fixed500よりQoS良**（pout/TL）という「程よい点」が実機で成立した（S1/S4とも）。
  - 遷移が多い側（S4）ほど share100 が増えるため、**“必要時だけ100msに寄せる”**がデータ上で確認できる。
  - 電力は fixed100/fixed500 の線形混合で説明できる（支配要因が interval 滞在比率であることの裏付け）。
- 補足（D2→D2bの修正理由）:
  - D2の `stress_causal_*` は CCS が「変化量」ではなく「安定度（高いほどstable）」のため、そのまま使うと判定が逆になり100ms張り付きになり得る。
  - D2bで `CCS_change = 1-CCS` として定義整合を取った。

## 追記（2025-12-16, D2b主結果を統合n=6へ更新）

- run B（n=3）+ 追加取得 B/02（n=3）を統合し，`uccs_d2_scan90/metrics/B_n6/`（各条件n=6）を論文・図表の主結果として採用する。
- 根拠（D2b, mean±std, n=6）:
  - S1_policy: 191.5±1.9 mW / pout_1s=0.1250±0.0274 / TL_mean=5.239±0.049 s / share100≈0.331
  - S4_policy: 196.6±1.6 mW / pout_1s=0.0691±0.0285 / TL_mean=1.575±0.500 s / share100≈0.595
- 出力:
  - 集計: `uccs_d2_scan90/metrics/B_n6/summary.md`（CSV: `uccs_d2_scan90/metrics/B_n6/summary_by_condition.csv`）
  - 図: `uccs_d2_scan90/plots/d2b_B_n6_power_vs_pout.pdf`
- 備考: n増加後も「Fixed100より省電力・Fixed500よりQoS良（pout/TL）」が成立しているため，主張の形は維持できる。

## 追記（2025-12-16, D4→D3の追加実験を採用）

- 目的: 実機D2bの「程よい点」が **U（不確実度）**に依存しているか（新規性）と、環境変化に対して崩れにくいか（実用性）を最小本数で補強する。
- 決定: **D4（U ablation）→D3（scan dutyを1段下げる）**の順で実施する。
  - D4は「Uが効く/効かない」を短時間・低リスクで言い切れるため先行する。
  - D3は環境要因が絡むため後段（D4で主張の芯を固めてから）に回す。
- D4（S4のみ、scan90）:
  - 条件: Fixed100 / Fixed500 / Policy(U+CCS) / Ablation(U-shuffle) の4条件×n=3
  - Ablationは **U-shuffle**（Uの分布は同じ・時間相関のみ破壊）を採用する。
  - 実装/取得ディレクトリ: `uccs_d4_scan90/`（TX/RX/TXSD + 集計スクリプト）
- D3（S4のみ）:
  - scan duty を 90% → 70% or 60% に落とし、Fixed500が崩れる帯で Policy が耐えるかを確認する。
  - 条件: Fixed100 / Fixed500 / Policy の3条件×n=3（最小）。

## 追記（2025-12-16, D4の主要結果と解釈を固定）

- 対象: D4（S4のみ、scan90、4条件×n=3）
- 出力（集計/図）:
  - 集計: `uccs_d4_scan90/metrics/01/summary.md`
  - 図: `uccs_d4_scan90/plots/d4_01_power_vs_pout.png`
- 主要結果（mean±std, n=3）:
  - Fixed100: `avg_power=208.2±1.3 mW`, `pout_1s=0.0488±0.0000`, `adv_count=1796`, `share100≈1.000`
  - Fixed500: `avg_power=187.9±0.8 mW`, `pout_1s=0.1301±0.0141`, `adv_count=359`, `share100≈0.000`
  - Policy(U+CCS): `avg_power=200.5±0.8 mW`, `pout_1s=0.0976±0.0244`, `adv_count=1227`, `share100≈0.593`
  - Ablation(U-shuffle): `avg_power=208.1±0.3 mW`, `pout_1s=0.0488±0.0000`, `adv_count=1715`, `share100≈0.943`
- 解釈（主張に変換）:
  - **Uの時間相関を壊す（U-shuffle）と、制御が100ms張り付き寄りに崩れる**（`share100: 0.593→0.943`, `adv_count: 1227→1715`, `avg_power: 200.5→208.1mW`）。
  - つまり「QoSを守りつつ100ms滞在を減らす」には、**Uの“いつ不確実か”という時間的整合が効いている**（閾値構造を固定したまま入力だけ壊すアブレーション）。</file><file path="docs/TODO.md"># エッジHAR TODO（Mode C2′ / ストレス固定 / 因果CCS・self-UCB 実機検証）

- 最終更新: 2025-12-16
- 対象スコープ:
  - **Mode C2′（ラベル再生）**を用いた「広告間隔制御」の評価（固定 vs 因果CCS vs self-UCB）。
  - まずは **ストレスラベル S1/S4** を主ケースとして、実測とシミュを整合させて論文化に耐える形にする。

- このファイルの役割:
  - **次に何をするか**（優先度付きTODO）を管理する。
  - **凍結した仕様/パラメータ**と、再検討トリガを残す。
  - 実験ログは `logs/worklog_*.txt`、決定理由は `docs/decision_log_*.md` に残す。

---

## 0. TL;DR（いま何が言えるか）

### 0.1 2次情報（他AIに渡してもよい粒度）

- **因果CCS（stress causal）シミュレーション**は完了。
  - 生成: `scripts/generate_modec2_stress_causal.py`
  - ラベル/真値: `Mode_C_2_シミュレート_causal/ccs/stress_causal_S1..S6.csv` と `manifest_stress_causal.json`
  - シミュ集計: `Mode_C_2_シミュレート_causal/sim_timeline_metrics_causal_agg.csv`
    - FIXED_100: acc=1.0
    - FIXED_500: acc≈0.972, TL_mean≈2.9s
    - FIXED_1000: acc≈0.935, TL_mean≈5.3s
    - FIXED_2000: acc≈0.870, TL_mean≈9.4s
    - CCS_causal: acc≈0.916, TL_mean≈6.8s
  - PDRスイープ: `Mode_C_2_シミュレート_causal/sim_timeline_metrics_causal_pdr_sweep.csv`（順位が崩れないことを確認）

- **固定間隔の電力基準（ΔE/adv）**は Mode_C の実測を参照する方針で固定。
  - 参照: `data/1202配線変更後/Mode_C_2_03/pdr_energy_summary.csv`
  - 例（E_per_adv_uJ_mean）: 100ms ≈ 19,872µJ / 500ms ≈ 96,739µJ / 1000ms ≈ 197,036µJ / 2000ms ≈ 394,850µJ

- **実機：ストレス固定（scan90%）フルセット（S1/S4×100/500/1000/2000）**が揃っており、解析も完了。
  - データ: `data/1211_modeC2prime_stress_fixed/full_scan90/`
  - per-trial: `results/stress_causal_real_summary_1211_stress_full_scan90.csv`
  - 集約: `..._modes_scan90.csv`, `..._agg_scan90.csv`, `..._agg_enriched_scan90.csv`
  - 現状の読みどころ:
    - 100ms の `pdr_unique` が **0.80前後まで改善**（scan duty 90% が効いた）
    - 500/1000/2000 は `pdr_unique` がほぼ 1.0（TXSD adv_count 基準でクランプしている前提）
    - ただし **TL/Pout が想定より大きい**（ストレス列の遷移の扱い／真値定義／サブサンプルの有無の確認が必要）

### 0.2 2025-12-14 追記（レター主線: v7 / robust power table）

- レター最速ルートは「**U/CCS→interval（ルールベース）を主結果**」に寄せる（Safe-MABはFuture Work）。
  - 決定ログ: `docs/decision_log_2025-12-13_letter_route.md`
- 固定intervalの電力テーブルを robust 版（sleep_on, n=9–10）で凍結し、オフライン評価の power 軸を置換（v7を主線）。
  - power table（主線）: `results/mhealth_policy_eval/power_table_sleep_eval_2025-12-14_interval_sweep_sleep_on_n9_10.csv`
  - Pareto（power table反映 + context mixing, scan90 v5）: `results/mhealth_policy_eval/pareto_front_v7_power_table_scan90_v5_sleep_on_n9_10/pareto_summary.md`
  - レター用δ帯（tight, 0.02/0.03/0.04）: `results/mhealth_policy_eval/letter_v3_scan90_v5_delta_tight_sleep_on_n9_10/fig_delta_band.png`
  - 候補（δ=0.03 power-min）: params=(0.10,0.35,0.15,0.35,0.08) → avg_power≈195.09mW / pout_1s≈0.0297（Fixed100比 −3.47mW）
  - 補助（sleep ON/OFF差分）: `sleep_eval_scan90/metrics/on_off_test_01/txsd_power_diff.md`（DoD=-0.25mW, n=2）
  - 重要: 電力低下の主効果は 100→500ms（≈−17.76mW）。500→2000msは小さい（≈−3.33mW）。

### 0.3 いま残っている一番重要な論点

- **TL/Pout の「定義」と「実装」が論文で説明できる形に固定されているか**
  - 例: 2000ms で `Pout(1s)` に理論下限が出るかどうかは、
    - 「遷移を 100ms 真値で取る（連続時間に近い評価）」なのか
    - 「TXが実際に送ったサブサンプル列で遷移を取る（可観測遷移のみ評価）」なのか
    で結論が変わる。
  - ここを曖昧にすると、**scan90 の改善や CCS/self-UCB の優位性を主張できない**。

### 0.4 次のゲート（ここを超えると後半が楽）

- Gate-0（図表の土台）: 
  - scan90 固定フルセットを **「定義が固定された指標」**で集約し、
  - 実測 vs シミュの差（桁差）が **説明可能な仮説**（burst loss / 可観測性 / 真値の粒度）で書ける。

---

## 1. 凍結仕様（再現性のために明文化）

### 1.1 解析指標（PDR/TL/Pout）

- `adv_count` は **TXSD の summary** を真値とする（RX側で再推定しない）。
- `pdr_raw` / `pdr_unique` を併記する。
  - `pdr_raw = min(rx_count, adv_count) / adv_count`（重複込みの受信量。&gt;1 を避けるためクランプ）
  - `pdr_unique = min(rx_unique_seq, adv_count) / adv_count`（seqユニークのカバレッジ指標）
- TL/Pout は「どの真値の遷移」を対象にしているかが本質。
  - **現行実装の定義を `docs/metrics_definition.md` に固定**し、
  - もし実装が「サブサンプル真値」になっているなら、その意図を明記する。

&gt; TODO（重要）: `scripts/analyze_stress_causal_real.py` が遷移抽出に使う truth が
&gt; - 100msの完全列なのか
&gt; - interval stepCount で間引いた列なのか
&gt; を 1回確認して、ドキュメント定義と一致させる。

### 1.2 truth 長さ（末端遷移）

- TX は `EFFECTIVE_LEN=6352`（100msステップ）で再生範囲をクランプ。
- truth も同じ長さにクリップする（末端遷移が TX 範囲外に出て TL が暴れるのを防ぐ）。

### 1.3 因果CCS（A-3 凍結）

- CCS 形: `CCS = 0.7*(1−U) + 0.3*S`
- `S_causal = clip(time_since_last_transition / 5.0, 0, 1)`
- `U_causal = clip(1 − S_causal + N(0, 0.05^2), 0, 1)`
- `T_adv` 写像（stress凍結）:
  - CCS &lt; 0.30 → 100ms
  - 0.30 ≤ CCS &lt; 0.70 → 500ms
  - CCS ≥ 0.70 → 2000ms
- stressケースでは **ヒステリシス無し**（まずは評価を簡単にするため）

### 1.4 RX スキャン設定（scan90 を主）

- `RX_ModeC2prime_1210`:
  - `SCAN_INTERVAL_MS=100, SCAN_WINDOW_MS=90`（duty 90%）
  - `ActiveScan=false`, duplicate filter OFF
- scan50 のデータは「改善前の参考」として残し、主張は scan90 で行う。

### 1.5 再検討トリガ（値を変えるべき時）

- CCSパラメータ（閾値/重み）
  - **固定フルセット（scan90）と同じ定義の TL/Pout** で CCS_causal が FIXED_500/1000 に勝てない場合
  - 2000ms 偏重で missed-state が増えすぎる場合
- RX設定
  - scan90 でも 100ms の `pdr_unique &lt; 0.7` が再発する場合（環境起因 vs 設定起因を切り分け）
- 指標定義
  - `Pout(1s)` の下限議論が食い違う場合 → まず定義/実装を揃える（パラメータ調整ではなく）

---

## 2. 成果物インデックス（場所が分かることが最優先）

### 2.1 実機データ

- scan90 固定フルセット: `data/1211_modeC2prime_stress_fixed/full_scan90/`
  - RX: `RX/rx_trial_042..049.csv`
  - TXSD: `TX/trial_048_on..055_on.csv`
  - manifest: `manifest.csv`（S1/S4 × 100/500/1000/2000 の対応）

### 2.2 実機解析出力

- per-trial: `results/stress_causal_real_summary_1211_stress_full_scan90.csv`
- 集約（modes/agg/enriched）:
  - `results/stress_causal_real_summary_1211_stress_modes_scan90.csv`
  - `results/stress_causal_real_summary_1211_stress_agg_scan90.csv`
  - `results/stress_causal_real_summary_1211_stress_agg_enriched_scan90.csv`
- gap 統計: `results/gap_stats_scan90.csv`
- missed-state（定義を固定した版）: `results/missed_state_scan90_v2.csv`

### 2.3 シミュレーション

- `Mode_C_2_シミュレート_causal/`
  - `ccs/stress_causal_S*.csv`
  - `sim_timeline_metrics_causal_agg.csv`
  - `sim_timeline_metrics_causal_pdr_sweep.csv`

### 2.4 スクリプト

- `scripts/generate_modec2_stress_causal.py`（因果CCS生成）
- `scripts/analyze_stress_causal_real.py`（RX/TXSD→PDR/TL/Pout/E/Power）
- `scripts/plot_stress_causal_real_vs_sim.py`（実測vsシミュ図表、matplotlib）
- `scripts/export_labels_all_to_csv.py`（labels_all.h→truth CSV; EFFECTIVE_LEN でclip）

---

## 3. 優先度付き TODO（最短で論文化できる順）

&gt; 記法: (ME)=実機/配線/取得が必要、(AI)=ローカル処理・解析のみ、(ME+AI)=両方

### P0-Letter: U/CCS→interval（mHealth合成, scan90 v5）

- [x] (AI) v7（robust power table: sleep_on n=9–10）で Pareto/δ tight を再生成して凍結
  - Pareto v7: `results/mhealth_policy_eval/pareto_front_v7_power_table_scan90_v5_sleep_on_n9_10/pareto_summary.md`
  - δ tight v3: `results/mhealth_policy_eval/letter_v3_scan90_v5_delta_tight_sleep_on_n9_10/summary.md`

- [x] (AI) D0: 行動空間を **{100,500}** に限定して δ=0.03 の代表ポリシーを再選定（実機比較の整合性）
  - Pareto v8（actions={100,500}）: `results/mhealth_policy_eval/pareto_front_v8_power_table_scan90_v5_sleep_on_n9_10_actions_100_500/pareto_summary.md`
  - δ tight v4（actions={100,500}）: `results/mhealth_policy_eval/letter_v4_scan90_v5_delta_tight_sleep_on_n9_10_actions_100_500/summary.md`

- [x] (ME+AI) D1: 実機（100↔500）最小セットで成立確認（Fixed100 / Fixed500 / Policy, 各n=3）
  - データ: `uccs_d1_scan90/data/01/`
  - 集計: `uccs_d1_scan90/metrics/01/summary.md`
  - 動的payload: `&lt;tx_elapsed_ms&gt;_&lt;label&gt;`（fixed=F100/F500, policy=P100/P500）

- [x] (AI) D2準備（最優先）: 動的QoS（TL/Pout）を評価できる D2 専用ディレクトリ＋スケッチを追加
  - index: `uccs_d2_scan90/README.md`
  - truth（flash埋め込み）: `uccs_d2_scan90/src/tx/stress_causal_s1_s4_180s.h`（S1/S4, 100msグリッド）
  - TX/RX/TXSD（Arduino）:
    - `uccs_d2_scan90/src/tx/TX_UCCS_D2_SCAN90/TX_UCCS_D2_SCAN90.ino`
    - `uccs_d2_scan90/src/rx/RX_UCCS_D2_SCAN90/RX_UCCS_D2_SCAN90.ino`
    - `uccs_d2_scan90/src/txsd/TXSD_UCCS_D2_SCAN90/TXSD_UCCS_D2_SCAN90.ino`
  - D2 payload: `&lt;step_idx&gt;_&lt;tag&gt;`（動的でも time axis が復元できる形）

- [x] (ME+AI) D2: 実機で動的QoS（TL/Pout）を `step_idx` 起点で確定（S1/S4 × Fixed100/Fixed500/Policy）
  - データ（今回の取得分）:
    - RX: `uccs_d2_scan90/data/RX/`（選定: rx_trial_009..026, n=18）
    - TXSD: `uccs_d2_scan90/data/TX/`（SD `/logs/` をコピー。混在あり）
  - 解析:
    - スクリプト: `uccs_d2_scan90/analysis/summarize_d2_run.py`
    - 出力: `uccs_d2_scan90/metrics/01/summary.md` / `uccs_d2_scan90/metrics/01/per_trial.csv`
  - 観測（要注意）:
    - policy が `share100_time_est≈0.99`（RXタグ由来sanity）かつ `adv_count≈1787` で、実質 **100ms張り付き**（省電力が出ない）。
    - 原因候補: D2で使っている `stress_causal_*` の `CCS` は「変化」ではなく「安定度（高いほどstable）」なので、実機実装側で **CCSを反転（CCS&apos;=1-CCS）** する等、定義整合が必要。

- [ ] (AI) 実測点を `pout_1s vs avg_power_mW` 図に重ね、予測↔実測の差分を `summary.md` に追記

- [x] (ME+AI) D2b: CCS反転でpolicy張り付き解消（S1/S4 × Fixed100/Fixed500/Policy, 各n=3）
  - データ: `uccs_d2_scan90/data/B/`
  - 集計: `uccs_d2_scan90/metrics/B/summary.md`
  - 図: `uccs_d2_scan90/plots/d2b_B_power_vs_pout.png`（power vs pout + share100注釈）
  - 備考: policyの `avg_power_mW/adv_count/pdr_unique` が空欄になる問題は `uccs_d2_scan90/analysis/summarize_d2_run.py` 側でペアリング復元を修正して解消。

- [x] (ME+AI) D2b 追加取得を統合して n=6 に拡張（run B + B/02）
  - 集計: `uccs_d2_scan90/metrics/B_n6/summary.md`
  - 図: `uccs_d2_scan90/plots/d2b_B_n6_power_vs_pout.png`

- [x] (AI) D4準備: U ablation（S4, scan90）の専用ディレクトリ＋スケッチ＋集計スクリプトを追加
  - index: `uccs_d4_scan90/README.md`
  - TX/RX/TXSD（Arduino）:
    - `uccs_d4_scan90/src/tx/TX_UCCS_D4_SCAN90/TX_UCCS_D4_SCAN90.ino`
    - `uccs_d4_scan90/src/rx/RX_UCCS_D4_SCAN90/RX_UCCS_D4_SCAN90.ino`
    - `uccs_d4_scan90/src/txsd/TXSD_UCCS_D4_SCAN90/TXSD_UCCS_D4_SCAN90.ino`
  - 集計: `uccs_d4_scan90/analysis/summarize_d4_run_v2.py`
  - Ablation: U-shuffle（seed=0xD4B40201、CCSは `1-CCS` で変化度化）

- [x] (ME+AI) D4: U ablation（S4, scan90, 4条件×n=3）を取得して集計
  - データ: `uccs_d4_scan90/data/01/`
  - 出力: `uccs_d4_scan90/metrics/01/summary.md`

- [x] (ME+AI) D4: Uあり/なし（U-shuffle）の差を1枚図にする（power vs pout + share100）
  - 図: `uccs_d4_scan90/plots/d4_01_power_vs_pout.png`

- [x] (AI) D4B準備: CCS ablation（S4, scan90）の専用ディレクトリ＋スケッチ＋集計スクリプトを追加
  - index: `uccs_d4b_scan90/README.md`
  - TX/RX/TXSD（Arduino）:
    - `uccs_d4b_scan90/src/tx/TX_UCCS_D4B_SCAN90/TX_UCCS_D4B_SCAN90.ino`
    - `uccs_d4b_scan90/src/rx/RX_UCCS_D4B_SCAN90/RX_UCCS_D4B_SCAN90.ino`
    - `uccs_d4b_scan90/src/txsd/TXSD_UCCS_D4B_SCAN90/TXSD_UCCS_D4B_SCAN90.ino`
  - 集計: `uccs_d4b_scan90/analysis/summarize_d4b_run_v2.py`
  - Ablation: CCS-off（U-only, 100↔500）

- [x] (ME+AI) D4B: CCS-off（U-only）で「CCSが効く」を切り分け（S4, scan90, 4条件×n=3）
  - データ: `uccs_d4b_scan90/data/01/`
  - 出力: `uccs_d4b_scan90/metrics/01/summary.md`
  - 図: `uccs_d4b_scan90/plots/d4b_01_power_vs_pout.svg`
  - 追加解析: `uccs_d4b_scan90/plots/ccs_timing_01/`（遷移近傍への100ms割当て可視化）
  - 差分CI: `uccs_d4b_scan90/metrics/01/effects_ci.md`（bootstrap, per-trial）

- [x] (AI) 役割分離の統合図（D3/D4/D4Bを1枚に統合）
  - 図: `uccs_d4b_scan90/plots/role_separation_d3_d4_d4b.svg`

- [x] (AI) 効果量の差分+不確かさ（bootstrap CI）を算出（D3/D4/D4B）
  - script: `scripts/bootstrap_effects.py`
  - D4B: `uccs_d4b_scan90/metrics/01/effects_ci.md`
  - D4: `uccs_d4_scan90/metrics/01/effects_ci.md`
  - D3: `uccs_d3_scan70/metrics/01/effects_ci.md`

- [x] (AI) α正規化（fixed100/500で正規化した電力配分）×QoS の図を作成（CCS寄与を刺す）
  - 図: `uccs_d4b_scan90/plots/alpha_vs_pout_overview.svg`

- [x] (AI) D4B: Poutを生んだ少数イベント（TL&gt;1s）を特定し、失敗イベント中心のストーリー図を作成
  - script: `uccs_d4b_scan90/analysis/outage_story_trace.py`
  - 出力: `uccs_d4b_scan90/plots/outage_story_01/fig_outage_timeline.svg`
  - 付随: `uccs_d4b_scan90/plots/outage_story_01/outage_ranking.csv`, `uccs_d4b_scan90/plots/outage_story_01/per_transition.csv`

- [x] (AI) D4B: Poutの寄与分解（尾の集中度）と条件付きタイミング（失敗遷移に条件付け）を追加
  - script: `uccs_d4b_scan90/analysis/pout_tail_decomposition.py`
  - 出力: `uccs_d4b_scan90/plots/pout_tail_01/`
  - script: `uccs_d4b_scan90/analysis/ccs_timing_analysis_conditional.py`
  - 出力: `uccs_d4b_scan90/plots/ccs_timing_conditional_01/fig_event_triggered_p100_conditional.svg`

- [x] (AI) D3準備: scan70%（interval=100ms, window=70ms）の専用ディレクトリ＋スケッチを追加
  - index: `uccs_d3_scan70/README.md`
  - TX/RX/TXSD（Arduino）:
    - `uccs_d3_scan70/src/tx/TX_UCCS_D3_SCAN70/TX_UCCS_D3_SCAN70.ino`
    - `uccs_d3_scan70/src/rx/RX_UCCS_D3_SCAN70/RX_UCCS_D3_SCAN70.ino`
    - `uccs_d3_scan70/src/txsd/TXSD_UCCS_D3_SCAN70/TXSD_UCCS_D3_SCAN70.ino`

- [x] (ME) D3: scan duty を 90→70% に落として適応性を確認（S4, fixed100/fixed500/policy, 各n=3）
  - データ: `uccs_d3_scan70/data/01/`

- [x] (AI) D3: 集計（pout/TL/power/share）と図（power vs pout）を生成
  - 集計: `uccs_d3_scan70/metrics/01/summary.md`
  - 図: `uccs_d3_scan70/plots/d3_01_power_vs_pout.png`
  - 備考: scan70では `share100_time_est (RX tags)` が過小評価しやすいため、`share100_power_mix`（power-mix推定）を主に参照する。

### P0: 定義固定 + 図表化（最優先）

- [x] (AI) **TL/Pout の真値定義を確定（v5）**
  - truth 遷移は **100ms真値**（`truth[idx,label]`）から抽出。
  - RXログの `ms` は開始位相ズレが入り得るため、`seq×interval_ms` から **定数オフセット**を推定して時間同期してから TL/Pout を計算（`tl_time_offset_ms`）。
  - 出力: `results/stress_fixed/scan90/*_scan90_v5.csv`（v4は時間同期なしのため原則参照しない）。

- [ ] (AI) scan90 固定フルセットの図表（論文用）を確定
  - 図1: intervalごとの `pdr_unique`, `Pout(1s)`, `TL_mean`, `E_per_adv`, `avg_power`
  - 図2: 実測 vs シミュ（pdr_sweep から最接近でマッチ）比較（`results/compare_*` を再生成）
  - 図3: scan50→scan90 の改善（特に 100ms の pdr_unique）

- [ ] (AI) 「実測がシミュより悪い」説明の文章骨子を作る
  - 候補: burst loss（時間相関ロス）、可観測遷移の欠落（間引き）、干渉・スキャン窓
  - どれが効いているかは gap_stats / missed-state / 実測の重尾（p95/max）で裏付ける

### P1: CCS_causal 実機（ストレス S1/S4）

- [ ] (ME+AI) TX に CCS_causal モードを追加（固定100/500/2000と同じI/Oでログが取れる形）
  - 実装方式: まずは **T_adv 列再生（オフライン決定）**が安全
  - 解析側は manifest に mode=`CCS_causal` を足すだけで回るようにする

- [ ] (ME) CCS_causal を S1/S4 で実行（E1）
  - 推奨: 1 trialずつ（10.6分×2本）→ まずは動作確認
  - その後、外れが大きい条件（2000偏重など）は追加1本

- [ ] (AI) 固定（scan90）と CCS_causal の比較表/図（同指標・同定義）
  - 主張の形: 「同電力でQoS↑」or「同QoSで電力↓」のどちらかに寄せる

### P2: self-UCB（不確実性駆動）

- [ ] (AI) self-UCB の設計（状態・報酬・制約）を 1ページで固定
  - 状態候補: (S,U,CCS,直近遷移からの時間, gap統計)
  - 報酬候補: −λ·E + QoS（遅延/アウトエイジ）
  - まずはシミュで λ をスイープして Pareto を出す

- [ ] (ME+AI) self-UCB の TX 実装（まずはオフラインpolicy再生でも可）

### P3: チャネル劣化（E2/E3）

- [ ] (ME) PDR を意図的に落とす環境を 1種類だけ固定（距離/遮蔽/干渉）
- [ ] (ME) 固定100 と CCS_causal と self-UCB を最小本数で比較（各1本）

### P4: 論文・スライド

- [ ] (AI) 章立てに合わせて図表を配置（少なくとも「固定 vs CCS_causal」を主結果に）
- [ ] (AI) 実装詳細（指標定義/凍結パラメータ/配線）を Appendix に逃がす

---

## 4. Done（主要な完了項目）

- [x] 因果CCSのストレス生成（A-1）
- [x] 因果CCSシミュ（PDR=1）＋集約（A-1/A-2）
- [x] A-3（CCS形/しきい値/重み）凍結
- [x] A-4（PDRスイープ）で順位安定性チェック
- [x] 実機解析スクリプト `analyze_stress_causal_real.py` の整備（pdr_raw/pdr_unique対応、manifest対応）
- [x] ストレス固定フルセット（scan90）取得・解析（S1/S4×100/500/1000/2000）

---

## 5. 付記（運用ルール）

- **データ命名**: 解析が走る最小情報を `manifest.csv` に持たせる（trial_id/セッション/interval/真値/モード）。
- **短いabort試行**は `manifest` から除外（残す場合は `mode=ABORT` 等で明示）。
- **1本増やす前に**: 指標定義と解析の一致を優先（同じバグを増幅させない）。</file></files></repomix>